/*
	Copyright (c) 2004-2010, The Dojo Foundation All Rights Reserved.
	Available via Academic Free License >= 2.1 OR the modified BSD license.
	see: http://dojotoolkit.org/license for details
*/

/*
	This is an optimized version of Dojo, built for deployment and not for
	development. To get sources and documentation, please visit:

		http://dojotoolkit.org
*/

dojo.provide("bssLayer.bssLayer");
if(!dojo._hasResource["dojo.date.stamp"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.date.stamp"] = true;
dojo.provide("dojo.date.stamp");

// Methods to convert dates to or from a wire (string) format using well-known conventions

dojo.date.stamp.fromISOString = function(/*String*/formattedString, /*Number?*/defaultTime){
	//	summary:
	//		Returns a Date object given a string formatted according to a subset of the ISO-8601 standard.
	//
	//	description:
	//		Accepts a string formatted according to a profile of ISO8601 as defined by
	//		[RFC3339](http://www.ietf.org/rfc/rfc3339.txt), except that partial input is allowed.
	//		Can also process dates as specified [by the W3C](http://www.w3.org/TR/NOTE-datetime)
	//		The following combinations are valid:
	//
	//			* dates only
	//			|	* yyyy
	//			|	* yyyy-MM
	//			|	* yyyy-MM-dd
	// 			* times only, with an optional time zone appended
	//			|	* THH:mm
	//			|	* THH:mm:ss
	//			|	* THH:mm:ss.SSS
	// 			* and "datetimes" which could be any combination of the above
	//
	//		timezones may be specified as Z (for UTC) or +/- followed by a time expression HH:mm
	//		Assumes the local time zone if not specified.  Does not validate.  Improperly formatted
	//		input may return null.  Arguments which are out of bounds will be handled
	// 		by the Date constructor (e.g. January 32nd typically gets resolved to February 1st)
	//		Only years between 100 and 9999 are supported.
	//
  	//	formattedString:
	//		A string such as 2005-06-30T08:05:00-07:00 or 2005-06-30 or T08:05:00
	//
	//	defaultTime:
	//		Used for defaults for fields omitted in the formattedString.
	//		Uses 1970-01-01T00:00:00.0Z by default.

	if(!dojo.date.stamp._isoRegExp){
		dojo.date.stamp._isoRegExp =
//TODO: could be more restrictive and check for 00-59, etc.
			/^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(.\d+)?)?((?:[+-](\d{2}):(\d{2}))|Z)?)?$/;
	}

	var match = dojo.date.stamp._isoRegExp.exec(formattedString),
		result = null;

	if(match){
		match.shift();
		if(match[1]){match[1]--;} // Javascript Date months are 0-based
		if(match[6]){match[6] *= 1000;} // Javascript Date expects fractional seconds as milliseconds

		if(defaultTime){
			// mix in defaultTime.  Relatively expensive, so use || operators for the fast path of defaultTime === 0
			defaultTime = new Date(defaultTime);
			dojo.map(["FullYear", "Month", "Date", "Hours", "Minutes", "Seconds", "Milliseconds"], function(prop){
				return defaultTime["get" + prop]();
			}).forEach(function(value, index){
				if(match[index] === undefined){
					match[index] = value;
				}
			});
		}
		result = new Date(match[0]||1970, match[1]||0, match[2]||1, match[3]||0, match[4]||0, match[5]||0, match[6]||0); //TODO: UTC defaults
		if(match[0] < 100){
			result.setFullYear(match[0] || 1970);
		}

		var offset = 0,
			zoneSign = match[7] && match[7].charAt(0);
		if(zoneSign != 'Z'){
			offset = ((match[8] || 0) * 60) + (Number(match[9]) || 0);
			if(zoneSign != '-'){ offset *= -1; }
		}
		if(zoneSign){
			offset -= result.getTimezoneOffset();
		}
		if(offset){
			result.setTime(result.getTime() + offset * 60000);
		}
	}

	return result; // Date or null
}

/*=====
	dojo.date.stamp.__Options = function(){
		//	selector: String
		//		"date" or "time" for partial formatting of the Date object.
		//		Both date and time will be formatted by default.
		//	zulu: Boolean
		//		if true, UTC/GMT is used for a timezone
		//	milliseconds: Boolean
		//		if true, output milliseconds
		this.selector = selector;
		this.zulu = zulu;
		this.milliseconds = milliseconds;
	}
=====*/

dojo.date.stamp.toISOString = function(/*Date*/dateObject, /*dojo.date.stamp.__Options?*/options){
	//	summary:
	//		Format a Date object as a string according a subset of the ISO-8601 standard
	//
	//	description:
	//		When options.selector is omitted, output follows [RFC3339](http://www.ietf.org/rfc/rfc3339.txt)
	//		The local time zone is included as an offset from GMT, except when selector=='time' (time without a date)
	//		Does not check bounds.  Only years between 100 and 9999 are supported.
	//
	//	dateObject:
	//		A Date object

	var _ = function(n){ return (n < 10) ? "0" + n : n; };
	options = options || {};
	var formattedDate = [],
		getter = options.zulu ? "getUTC" : "get",
		date = "";
	if(options.selector != "time"){
		var year = dateObject[getter+"FullYear"]();
		date = ["0000".substr((year+"").length)+year, _(dateObject[getter+"Month"]()+1), _(dateObject[getter+"Date"]())].join('-');
	}
	formattedDate.push(date);
	if(options.selector != "date"){
		var time = [_(dateObject[getter+"Hours"]()), _(dateObject[getter+"Minutes"]()), _(dateObject[getter+"Seconds"]())].join(':');
		var millis = dateObject[getter+"Milliseconds"]();
		if(options.milliseconds){
			time += "."+ (millis < 100 ? "0" : "") + _(millis);
		}
		if(options.zulu){
			time += "Z";
		}else if(options.selector != "time"){
			var timezoneOffset = dateObject.getTimezoneOffset();
			var absOffset = Math.abs(timezoneOffset);
			time += (timezoneOffset > 0 ? "-" : "+") + 
				_(Math.floor(absOffset/60)) + ":" + _(absOffset%60);
		}
		formattedDate.push(time);
	}
	return formattedDate.join('T'); // String
}

}

if(!dojo._hasResource["dojo.parser"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.parser"] = true;
dojo.provide("dojo.parser");


dojo.parser = new function(){
	// summary: The Dom/Widget parsing package

	var d = dojo;
	this._attrName = d._scopeName + "Type";
	this._query = "[" + this._attrName + "]";

	function val2type(/*Object*/ value){
		// summary:
		//		Returns name of type of given value.

		if(d.isString(value)){ return "string"; }
		if(typeof value == "number"){ return "number"; }
		if(typeof value == "boolean"){ return "boolean"; }
		if(d.isFunction(value)){ return "function"; }
		if(d.isArray(value)){ return "array"; } // typeof [] == "object"
		if(value instanceof Date) { return "date"; } // assume timestamp
		if(value instanceof d._Url){ return "url"; }
		return "object";
	}

	function str2obj(/*String*/ value, /*String*/ type){
		// summary:
		//		Convert given string value to given type
		switch(type){
			case "string":
				return value;
			case "number":
				return value.length ? Number(value) : NaN;
			case "boolean":
				// for checked/disabled value might be "" or "checked".  interpret as true.
				return typeof value == "boolean" ? value : !(value.toLowerCase()=="false");
			case "function":
				if(d.isFunction(value)){
					// IE gives us a function, even when we say something like onClick="foo"
					// (in which case it gives us an invalid function "function(){ foo }"). 
					//  Therefore, convert to string
					value=value.toString();
					value=d.trim(value.substring(value.indexOf('{')+1, value.length-1));
				}
				try{
					if(value.search(/[^\w\.]+/i) != -1){
						// The user has specified some text for a function like "return x+5"
						return new Function(value);
					}else{
						// The user has specified the name of a function like "myOnClick"
						return d.getObject(value, false);
					}
				}catch(e){ return new Function(); }
			case "array":
				return value ? value.split(/\s*,\s*/) : [];
			case "date":
				switch(value){
					case "": return new Date("");	// the NaN of dates
					case "now": return new Date();	// current date
					default: return d.date.stamp.fromISOString(value);
				}
			case "url":
				return d.baseUrl + value;
			default:
				return d.fromJson(value);
		}
	}

	var instanceClasses = {
		// map from fully qualified name (like "dijit.Button") to structure like
		// { cls: dijit.Button, params: {label: "string", disabled: "boolean"} }
	};

	// Widgets like BorderContainer add properties to _Widget via dojo.extend().
	// If BorderContainer is loaded after _Widget's parameter list has been cached,
	// we need to refresh that parameter list (for _Widget and all widgets that extend _Widget).
	dojo.connect(dojo, "extend", function(){
		instanceClasses = {};
	});

	function getClassInfo(/*String*/ className){
		// className:
		//		fully qualified name (like "dijit.form.Button")
		// returns:
		//		structure like
		//			{ 
		//				cls: dijit.Button, 
		//				params: { label: "string", disabled: "boolean"}
		//			}

		if(!instanceClasses[className]){
			// get pointer to widget class
			var cls = d.getObject(className);
			if(!d.isFunction(cls)){
				throw new Error("Could not load class '" + className +
					"'. Did you spell the name correctly and use a full path, like 'dijit.form.Button'?");
			}
			var proto = cls.prototype;
	
			// get table of parameter names & types
			var params = {}, dummyClass = {};
			for(var name in proto){
				if(name.charAt(0)=="_"){ continue; } 	// skip internal properties
				if(name in dummyClass){ continue; }		// skip "constructor" and "toString"
				var defVal = proto[name];
				params[name]=val2type(defVal);
			}

			instanceClasses[className] = { cls: cls, params: params };
		}
		return instanceClasses[className];
	}

	this._functionFromScript = function(script){
		var preamble = "";
		var suffix = "";
		var argsStr = script.getAttribute("args");
		if(argsStr){
			d.forEach(argsStr.split(/\s*,\s*/), function(part, idx){
				preamble += "var "+part+" = arguments["+idx+"]; ";
			});
		}
		var withStr = script.getAttribute("with");
		if(withStr && withStr.length){
			d.forEach(withStr.split(/\s*,\s*/), function(part){
				preamble += "with("+part+"){";
				suffix += "}";
			});
		}
		return new Function(preamble+script.innerHTML+suffix);
	}

	this.instantiate = function(/* Array */nodes, /* Object? */mixin, /* Object? */args){
		// summary:
		//		Takes array of nodes, and turns them into class instances and
		//		potentially calls a layout method to allow them to connect with
		//		any children		
		// mixin: Object?
		//		An object that will be mixed in with each node in the array.
		//		Values in the mixin will override values in the node, if they
		//		exist.
		// args: Object?
		//		An object used to hold kwArgs for instantiation.
		//		Only supports 'noStart' currently.
		var thelist = [], dp = dojo.parser;
		mixin = mixin||{};
		args = args||{};
		
		d.forEach(nodes, function(node){
			if(!node){ return; }
			var type = dp._attrName in mixin?mixin[dp._attrName]:node.getAttribute(dp._attrName);
			if(!type || !type.length){ return; }
			var clsInfo = getClassInfo(type),
				clazz = clsInfo.cls,
				ps = clazz._noScript || clazz.prototype._noScript;

			// read parameters (ie, attributes).
			// clsInfo.params lists expected params like {"checked": "boolean", "n": "number"}
			var params = {},
				attributes = node.attributes;
			for(var name in clsInfo.params){
				var item = name in mixin?{value:mixin[name],specified:true}:attributes.getNamedItem(name);
				if(!item || (!item.specified && (!dojo.isIE || name.toLowerCase()!="value"))){ continue; }
				var value = item.value;
				// Deal with IE quirks for 'class' and 'style'
				switch(name){
				case "class":
					value = "className" in mixin?mixin.className:node.className;
					break;
				case "style":
					value = "style" in mixin?mixin.style:(node.style && node.style.cssText); // FIXME: Opera?
				}
				var _type = clsInfo.params[name];
				if(typeof value == "string"){
					params[name] = str2obj(value, _type);
				}else{
					params[name] = value;
				}
			}

			// Process <script type="dojo/*"> script tags
			// <script type="dojo/method" event="foo"> tags are added to params, and passed to
			// the widget on instantiation.
			// <script type="dojo/method"> tags (with no event) are executed after instantiation
			// <script type="dojo/connect" event="foo"> tags are dojo.connected after instantiation
			// note: dojo/* script tags cannot exist in self closing widgets, like <input />
			if(!ps){
				var connects = [],	// functions to connect after instantiation
					calls = [];		// functions to call after instantiation

				d.query("> script[type^='dojo/']", node).orphan().forEach(function(script){
					var event = script.getAttribute("event"),
						type = script.getAttribute("type"),
						nf = d.parser._functionFromScript(script);
					if(event){
						if(type == "dojo/connect"){
							connects.push({event: event, func: nf});
						}else{
							params[event] = nf;
						}
					}else{
						calls.push(nf);
					}
				});
			}

			var markupFactory = clazz.markupFactory || clazz.prototype && clazz.prototype.markupFactory;
			// create the instance
			var instance = markupFactory ? markupFactory(params, node, clazz) : new clazz(params, node);
			thelist.push(instance);

			// map it to the JS namespace if that makes sense
			var jsname = node.getAttribute("jsId");
			if(jsname){
				d.setObject(jsname, instance);
			}

			// process connections and startup functions
			if(!ps){
				d.forEach(connects, function(connect){
					d.connect(instance, connect.event, null, connect.func);
				});
				d.forEach(calls, function(func){
					func.call(instance);
				});
			}
		});

		// Call startup on each top level instance if it makes sense (as for
		// widgets).  Parent widgets will recursively call startup on their
		// (non-top level) children
		if(!mixin._started){
			d.forEach(thelist, function(instance){
				if(	!args.noStart && instance  && 
					instance.startup &&
					!instance._started && 
					(!instance.getParent || !instance.getParent())
				){
					instance.startup();
				}
			});
		}
		return thelist;
	};

	this.parse = function(/*DomNode?*/ rootNode, /* Object? */ args){
		// summary:
		//		Scan the DOM for class instances, and instantiate them.
		//
		// description:
		//		Search specified node (or root node) recursively for class instances,
		//		and instantiate them Searches for
		//		dojoType="qualified.class.name"
		//
		// rootNode: DomNode?
		//		A default starting root node from which to start the parsing. Can be
		//		omitted, defaulting to the entire document. If omitted, the `args`
		//		object can be passed in this place. If the `args` object has a 
		//		`rootNode` member, that is used.
		//
		// args:
		//		a kwArgs object passed along to instantiate()
		//		
		//			* noStart: Boolean?
		//				when set will prevent the parser from calling .startup()
		//				when locating the nodes. 
		//			* rootNode: DomNode?
		//				identical to the function's `rootNode` argument, though
		//				allowed to be passed in via this `args object. 
		//
		// example:
		//		Parse all widgets on a page:
		//	|		dojo.parser.parse();
		//
		// example:
		//		Parse all classes within the node with id="foo"
		//	|		dojo.parser.parse(dojo.byId(foo));
		//
		// example:
		//		Parse all classes in a page, but do not call .startup() on any 
		//		child
		//	|		dojo.parser.parse({ noStart: true })
		//
		// example:
		//		Parse all classes in a node, but do not call .startup()
		//	|		dojo.parser.parse(someNode, { noStart:true });
		//	|		// or
		// 	|		dojo.parser.parse({ noStart:true, rootNode: someNode });

		// determine the root node based on the passed arguments.
		var root;
		if(!args && rootNode && rootNode.rootNode){
			args = rootNode;
			root = args.rootNode;
		}else{
			root = rootNode;
		}

		var	list = d.query(this._query, root);
			// go build the object instances
		return this.instantiate(list, null, args); // Array

	};
}();

//Register the parser callback. It should be the first callback
//after the a11y test.

(function(){
	var parseRunner = function(){ 
		if(dojo.config.parseOnLoad){
			dojo.parser.parse(); 
		}
	};

	// FIXME: need to clobber cross-dependency!!
	if(dojo.exists("dijit.wai.onload") && (dijit.wai.onload === dojo._loaders[0])){
		dojo._loaders.splice(1, 0, parseRunner);
	}else{
		dojo._loaders.unshift(parseRunner);
	}
})();

}

if(!dojo._hasResource["dojo.string"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.string"] = true;
dojo.provide("dojo.string");

/*=====
dojo.string = { 
	// summary: String utilities for Dojo
};
=====*/

dojo.string.rep = function(/*String*/str, /*Integer*/num){
	//	summary:
	//		Efficiently replicate a string `n` times.
	//	str:
	//		the string to replicate
	//	num:
	//		number of times to replicate the string
	
	if(num <= 0 || !str){ return ""; }
	
	var buf = [];
	for(;;){
		if(num & 1){
			buf.push(str);
		}
		if(!(num >>= 1)){ break; }
		str += str;
	}
	return buf.join("");	// String
};

dojo.string.pad = function(/*String*/text, /*Integer*/size, /*String?*/ch, /*Boolean?*/end){
	//	summary:
	//		Pad a string to guarantee that it is at least `size` length by
	//		filling with the character `ch` at either the start or end of the
	//		string. Pads at the start, by default.
	//	text:
	//		the string to pad
	//	size:
	//		length to provide padding
	//	ch:
	//		character to pad, defaults to '0'
	//	end:
	//		adds padding at the end if true, otherwise pads at start
	//	example:
	//	|	// Fill the string to length 10 with "+" characters on the right.  Yields "Dojo++++++".
	//	|	dojo.string.pad("Dojo", 10, "+", true);

	if(!ch){
		ch = '0';
	}
	var out = String(text),
		pad = dojo.string.rep(ch, Math.ceil((size - out.length) / ch.length));
	return end ? out + pad : pad + out;	// String
};

dojo.string.substitute = function(	/*String*/		template, 
									/*Object|Array*/map, 
									/*Function?*/	transform, 
									/*Object?*/		thisObject){
	//	summary:
	//		Performs parameterized substitutions on a string. Throws an
	//		exception if any parameter is unmatched.
	//	template: 
	//		a string with expressions in the form `${key}` to be replaced or
	//		`${key:format}` which specifies a format function. keys are case-sensitive. 
	//	map:
	//		hash to search for substitutions
	//	transform: 
	//		a function to process all parameters before substitution takes
	//		place, e.g. mylib.encodeXML
	//	thisObject: 
	//		where to look for optional format function; default to the global
	//		namespace
	//	example:
	//		Substitutes two expressions in a string from an Array or Object
	//	|	// returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// by providing substitution data in an Array
	//	|	dojo.string.substitute(
	//	|		"File '${0}' is not found in directory '${1}'.",
	//	|		["foo.html","/temp"]
	//	|	);
	//	|
	//	|	// also returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// but provides substitution data in an Object structure.  Dotted
	//	|	// notation may be used to traverse the structure.
	//	|	dojo.string.substitute(
	//	|		"File '${name}' is not found in directory '${info.dir}'.",
	//	|		{ name: "foo.html", info: { dir: "/temp" } }
	//	|	);
	//	example:
	//		Use a transform function to modify the values:
	//	|	// returns "file 'foo.html' is not found in directory '/temp'."
	//	|	dojo.string.substitute(
	//	|		"${0} is not found in ${1}.",
	//	|		["foo.html","/temp"],
	//	|		function(str){
	//	|			// try to figure out the type
	//	|			var prefix = (str.charAt(0) == "/") ? "directory": "file";
	//	|			return prefix + " '" + str + "'";
	//	|		}
	//	|	);
	//	example:
	//		Use a formatter
	//	|	// returns "thinger -- howdy"
	//	|	dojo.string.substitute(
	//	|		"${0:postfix}", ["thinger"], null, {
	//	|			postfix: function(value, key){
	//	|				return value + " -- howdy";
	//	|			}
	//	|		}
	//	|	);

	thisObject = thisObject || dojo.global;
	transform = transform ? 
		dojo.hitch(thisObject, transform) : function(v){ return v; };

	return template.replace(/\$\{([^\s\:\}]+)(?:\:([^\s\:\}]+))?\}/g,
		function(match, key, format){
			var value = dojo.getObject(key, false, map);
			if(format){
				value = dojo.getObject(format, false, thisObject).call(thisObject, value, key);
			}
			return transform(value, key).toString();
		}); // String
};

/*=====
dojo.string.trim = function(str){
	//	summary:
	//		Trims whitespace from both sides of the string
	//	str: String
	//		String to be trimmed
	//	returns: String
	//		Returns the trimmed string
	//	description:
	//		This version of trim() was taken from [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript).
	//		The short yet performant version of this function is dojo.trim(),
	//		which is part of Dojo base.  Uses String.prototype.trim instead, if available.
	return "";	// String
}
=====*/

dojo.string.trim = String.prototype.trim ?
	dojo.trim : // aliasing to the native function
	function(str){
		str = str.replace(/^\s+/, '');
		for(var i = str.length - 1; i >= 0; i--){
			if(/\S/.test(str.charAt(i))){
				str = str.substring(0, i + 1);
				break;
			}
		}
		return str;
	};

}

if(!dojo._hasResource["dojo.data.util.filter"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.util.filter"] = true;
dojo.provide("dojo.data.util.filter");

dojo.data.util.filter.patternToRegExp = function(/*String*/pattern, /*boolean?*/ ignoreCase){
	//	summary:  
	//		Helper function to convert a simple pattern to a regular expression for matching.
	//	description:
	//		Returns a regular expression object that conforms to the defined conversion rules.
	//		For example:  
	//			ca*   -> /^ca.*$/
	//			*ca*  -> /^.*ca.*$/
	//			*c\*a*  -> /^.*c\*a.*$/
	//			*c\*a?*  -> /^.*c\*a..*$/
	//			and so on.
	//
	//	pattern: string
	//		A simple matching pattern to convert that follows basic rules:
	//			* Means match anything, so ca* means match anything starting with ca
	//			? Means match single character.  So, b?b will match to bob and bab, and so on.
	//      	\ is an escape character.  So for example, \* means do not treat * as a match, but literal character *.
	//				To use a \ as a character in the string, it must be escaped.  So in the pattern it should be 
	//				represented by \\ to be treated as an ordinary \ character instead of an escape.
	//
	//	ignoreCase:
	//		An optional flag to indicate if the pattern matching should be treated as case-sensitive or not when comparing
	//		By default, it is assumed case sensitive.

	var rxp = "^";
	var c = null;
	for(var i = 0; i < pattern.length; i++){
		c = pattern.charAt(i);
		switch(c){
			case '\\':
				rxp += c;
				i++;
				rxp += pattern.charAt(i);
				break;
			case '*':
				rxp += ".*"; break;
			case '?':
				rxp += "."; break;
			case '$':
			case '^':
			case '/':
			case '+':
			case '.':
			case '|':
			case '(':
			case ')':
			case '{':
			case '}':
			case '[':
			case ']':
				rxp += "\\"; //fallthrough
			default:
				rxp += c;
		}
	}
	rxp += "$";
	if(ignoreCase){
		return new RegExp(rxp,"mi"); //RegExp
	}else{
		return new RegExp(rxp,"m"); //RegExp
	}
	
};

}

if(!dojo._hasResource["dojo.data.util.sorter"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.util.sorter"] = true;
dojo.provide("dojo.data.util.sorter");

dojo.data.util.sorter.basicComparator = function(	/*anything*/ a, 
													/*anything*/ b){
	//	summary:  
	//		Basic comparision function that compares if an item is greater or less than another item
	//	description:  
	//		returns 1 if a > b, -1 if a < b, 0 if equal.
	//		'null' values (null, undefined) are treated as larger values so that they're pushed to the end of the list.
	//		And compared to each other, null is equivalent to undefined.
	
	//null is a problematic compare, so if null, we set to undefined.
	//Makes the check logic simple, compact, and consistent
	//And (null == undefined) === true, so the check later against null
	//works for undefined and is less bytes.
	var r = -1;
	if(a === null){
		a = undefined;
	}
	if(b === null){
		b = undefined;
	}
	if(a == b){
		r = 0; 
	}else if(a > b || a == null){
		r = 1; 
	}
	return r; //int {-1,0,1}
};

dojo.data.util.sorter.createSortFunction = function(	/* attributes array */sortSpec,
														/*dojo.data.core.Read*/ store){
	//	summary:  
	//		Helper function to generate the sorting function based off the list of sort attributes.
	//	description:  
	//		The sort function creation will look for a property on the store called 'comparatorMap'.  If it exists
	//		it will look in the mapping for comparisons function for the attributes.  If one is found, it will
	//		use it instead of the basic comparator, which is typically used for strings, ints, booleans, and dates.
	//		Returns the sorting function for this particular list of attributes and sorting directions.
	//
	//	sortSpec: array
	//		A JS object that array that defines out what attribute names to sort on and whether it should be descenting or asending.
	//		The objects should be formatted as follows:
	//		{
	//			attribute: "attributeName-string" || attribute,
	//			descending: true|false;   // Default is false.
	//		}
	//	store: object
	//		The datastore object to look up item values from.
	//
	var sortFunctions=[];

	function createSortFunction(attr, dir, comp, s){
		//Passing in comp and s (comparator and store), makes this
		//function much faster.
		return function(itemA, itemB){
			var a = s.getValue(itemA, attr);
			var b = s.getValue(itemB, attr);
			return dir * comp(a,b); //int
		};
	}
	var sortAttribute;
	var map = store.comparatorMap;
	var bc = dojo.data.util.sorter.basicComparator;
	for(var i = 0; i < sortSpec.length; i++){
		sortAttribute = sortSpec[i];
		var attr = sortAttribute.attribute;
		if(attr){
			var dir = (sortAttribute.descending) ? -1 : 1;
			var comp = bc;
			if(map){
				if(typeof attr !== "string" && ("toString" in attr)){
					 attr = attr.toString();
				}
				comp = map[attr] || bc;
			}
			sortFunctions.push(createSortFunction(attr, 
				dir, comp, store));
		}
	}
	return function(rowA, rowB){
		var i=0;
		while(i < sortFunctions.length){
			var ret = sortFunctions[i++](rowA, rowB);
			if(ret !== 0){
				return ret;//int
			}
		}
		return 0; //int  
	}; // Function
};

}

if(!dojo._hasResource["dojo.data.util.simpleFetch"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.util.simpleFetch"] = true;
dojo.provide("dojo.data.util.simpleFetch");


dojo.data.util.simpleFetch.fetch = function(/* Object? */ request){
	//	summary:
	//		The simpleFetch mixin is designed to serve as a set of function(s) that can
	//		be mixed into other datastore implementations to accelerate their development.  
	//		The simpleFetch mixin should work well for any datastore that can respond to a _fetchItems() 
	//		call by returning an array of all the found items that matched the query.  The simpleFetch mixin
	//		is not designed to work for datastores that respond to a fetch() call by incrementally
	//		loading items, or sequentially loading partial batches of the result
	//		set.  For datastores that mixin simpleFetch, simpleFetch 
	//		implements a fetch method that automatically handles eight of the fetch()
	//		arguments -- onBegin, onItem, onComplete, onError, start, count, sort and scope
	//		The class mixing in simpleFetch should not implement fetch(),
	//		but should instead implement a _fetchItems() method.  The _fetchItems() 
	//		method takes three arguments, the keywordArgs object that was passed 
	//		to fetch(), a callback function to be called when the result array is
	//		available, and an error callback to be called if something goes wrong.
	//		The _fetchItems() method should ignore any keywordArgs parameters for
	//		start, count, onBegin, onItem, onComplete, onError, sort, and scope.  
	//		The _fetchItems() method needs to correctly handle any other keywordArgs
	//		parameters, including the query parameter and any optional parameters 
	//		(such as includeChildren).  The _fetchItems() method should create an array of 
	//		result items and pass it to the fetchHandler along with the original request object 
	//		-- or, the _fetchItems() method may, if it wants to, create an new request object 
	//		with other specifics about the request that are specific to the datastore and pass 
	//		that as the request object to the handler.
	//
	//		For more information on this specific function, see dojo.data.api.Read.fetch()
	request = request || {};
	if(!request.store){
		request.store = this;
	}
	var self = this;

	var _errorHandler = function(errorData, requestObject){
		if(requestObject.onError){
			var scope = requestObject.scope || dojo.global;
			requestObject.onError.call(scope, errorData, requestObject);
		}
	};

	var _fetchHandler = function(items, requestObject){
		var oldAbortFunction = requestObject.abort || null;
		var aborted = false;

		var startIndex = requestObject.start?requestObject.start:0;
		var endIndex = (requestObject.count && (requestObject.count !== Infinity))?(startIndex + requestObject.count):items.length;

		requestObject.abort = function(){
			aborted = true;
			if(oldAbortFunction){
				oldAbortFunction.call(requestObject);
			}
		};

		var scope = requestObject.scope || dojo.global;
		if(!requestObject.store){
			requestObject.store = self;
		}
		if(requestObject.onBegin){
			requestObject.onBegin.call(scope, items.length, requestObject);
		}
		if(requestObject.sort){
			items.sort(dojo.data.util.sorter.createSortFunction(requestObject.sort, self));
		}
		if(requestObject.onItem){
			for(var i = startIndex; (i < items.length) && (i < endIndex); ++i){
				var item = items[i];
				if(!aborted){
					requestObject.onItem.call(scope, item, requestObject);
				}
			}
		}
		if(requestObject.onComplete && !aborted){
			var subset = null;
			if(!requestObject.onItem){
				subset = items.slice(startIndex, endIndex);
			}
			requestObject.onComplete.call(scope, subset, requestObject);
		}
	};
	this._fetchItems(request, _fetchHandler, _errorHandler);
	return request;	// Object
};

}

if(!dojo._hasResource["dojo.data.ItemFileReadStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.ItemFileReadStore"] = true;
dojo.provide("dojo.data.ItemFileReadStore");





dojo.declare("dojo.data.ItemFileReadStore", null,{
	//	summary:
	//		The ItemFileReadStore implements the dojo.data.api.Read API and reads
	//		data from JSON files that have contents in this format --
	//		{ items: [
	//			{ name:'Kermit', color:'green', age:12, friends:['Gonzo', {_reference:{name:'Fozzie Bear'}}]},
	//			{ name:'Fozzie Bear', wears:['hat', 'tie']},
	//			{ name:'Miss Piggy', pets:'Foo-Foo'}
	//		]}
	//		Note that it can also contain an 'identifer' property that specified which attribute on the items 
	//		in the array of items that acts as the unique identifier for that item.
	//
	constructor: function(/* Object */ keywordParameters){
		//	summary: constructor
		//	keywordParameters: {url: String}
		//	keywordParameters: {data: jsonObject}
		//	keywordParameters: {typeMap: object)
		//		The structure of the typeMap object is as follows:
		//		{
		//			type0: function || object,
		//			type1: function || object,
		//			...
		//			typeN: function || object
		//		}
		//		Where if it is a function, it is assumed to be an object constructor that takes the 
		//		value of _value as the initialization parameters.  If it is an object, then it is assumed
		//		to be an object of general form:
		//		{
		//			type: function, //constructor.
		//			deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
		//		}
	
		this._arrayOfAllItems = [];
		this._arrayOfTopLevelItems = [];
		this._loadFinished = false;
		this._jsonFileUrl = keywordParameters.url;
		this._ccUrl = keywordParameters.url;
		this.url = keywordParameters.url;
		this._jsonData = keywordParameters.data;
		this.data = null;
		this._datatypeMap = keywordParameters.typeMap || {};
		if(!this._datatypeMap['Date']){
			//If no default mapping for dates, then set this as default.
			//We use the dojo.date.stamp here because the ISO format is the 'dojo way'
			//of generically representing dates.
			this._datatypeMap['Date'] = {
											type: Date,
											deserialize: function(value){
												return dojo.date.stamp.fromISOString(value);
											}
										};
		}
		this._features = {'dojo.data.api.Read':true, 'dojo.data.api.Identity':true};
		this._itemsByIdentity = null;
		this._storeRefPropName = "_S"; // Default name for the store reference to attach to every item.
		this._itemNumPropName = "_0"; // Default Item Id for isItem to attach to every item.
		this._rootItemPropName = "_RI"; // Default Item Id for isItem to attach to every item.
		this._reverseRefMap = "_RRM"; // Default attribute for constructing a reverse reference map for use with reference integrity
		this._loadInProgress = false; //Got to track the initial load to prevent duelling loads of the dataset.
		this._queuedFetches = [];
		if(keywordParameters.urlPreventCache !== undefined){
			this.urlPreventCache = keywordParameters.urlPreventCache?true:false;
		}
		if(keywordParameters.hierarchical !== undefined){
			this.hierarchical = keywordParameters.hierarchical?true:false;
		}
		if(keywordParameters.clearOnClose){
			this.clearOnClose = true;
		}
		if("failOk" in keywordParameters){
			this.failOk = keywordParameters.failOk?true:false;
		}
	},
	
	url: "",	// use "" rather than undefined for the benefit of the parser (#3539)

	//Internal var, crossCheckUrl.  Used so that setting either url or _jsonFileUrl, can still trigger a reload
	//when clearOnClose and close is used.
	_ccUrl: "",

	data: null,	// define this so that the parser can populate it

	typeMap: null, //Define so parser can populate.
	
	//Parameter to allow users to specify if a close call should force a reload or not.
	//By default, it retains the old behavior of not clearing if close is called.  But
	//if set true, the store will be reset to default state.  Note that by doing this,
	//all item handles will become invalid and a new fetch must be issued.
	clearOnClose: false,

	//Parameter to allow specifying if preventCache should be passed to the xhrGet call or not when loading data from a url.  
	//Note this does not mean the store calls the server on each fetch, only that the data load has preventCache set as an option.
	//Added for tracker: #6072
	urlPreventCache: false,
	
	//Parameter for specifying that it is OK for the xhrGet call to fail silently.
	failOk: false,

	//Parameter to indicate to process data from the url as hierarchical 
	//(data items can contain other data items in js form).  Default is true 
	//for backwards compatibility.  False means only root items are processed 
	//as items, all child objects outside of type-mapped objects and those in 
	//specific reference format, are left straight JS data objects.
	hierarchical: true,

	_assertIsItem: function(/* item */ item){
		//	summary:
		//		This function tests whether the item passed in is indeed an item in the store.
		//	item: 
		//		The item to test for being contained by the store.
		if(!this.isItem(item)){ 
			throw new Error("dojo.data.ItemFileReadStore: Invalid item argument.");
		}
	},

	_assertIsAttribute: function(/* attribute-name-string */ attribute){
		//	summary:
		//		This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.
		//	attribute: 
		//		The attribute to test for being contained by the store.
		if(typeof attribute !== "string"){ 
			throw new Error("dojo.data.ItemFileReadStore: Invalid attribute argument.");
		}
	},

	getValue: function(	/* item */ item, 
						/* attribute-name-string */ attribute, 
						/* value? */ defaultValue){
		//	summary: 
		//		See dojo.data.api.Read.getValue()
		var values = this.getValues(item, attribute);
		return (values.length > 0)?values[0]:defaultValue; // mixed
	},

	getValues: function(/* item */ item, 
						/* attribute-name-string */ attribute){
		//	summary: 
		//		See dojo.data.api.Read.getValues()

		this._assertIsItem(item);
		this._assertIsAttribute(attribute);
		return item[attribute] || []; // Array
	},

	getAttributes: function(/* item */ item){
		//	summary: 
		//		See dojo.data.api.Read.getAttributes()
		this._assertIsItem(item);
		var attributes = [];
		for(var key in item){
			// Save off only the real item attributes, not the special id marks for O(1) isItem.
			if((key !== this._storeRefPropName) && (key !== this._itemNumPropName) && (key !== this._rootItemPropName) && (key !== this._reverseRefMap)){
				attributes.push(key);
			}
		}
		return attributes; // Array
	},

	hasAttribute: function(	/* item */ item,
							/* attribute-name-string */ attribute){
		//	summary: 
		//		See dojo.data.api.Read.hasAttribute()
		this._assertIsItem(item);
		this._assertIsAttribute(attribute);
		return (attribute in item);
	},

	containsValue: function(/* item */ item, 
							/* attribute-name-string */ attribute, 
							/* anything */ value){
		//	summary: 
		//		See dojo.data.api.Read.containsValue()
		var regexp = undefined;
		if(typeof value === "string"){
			regexp = dojo.data.util.filter.patternToRegExp(value, false);
		}
		return this._containsValue(item, attribute, value, regexp); //boolean.
	},

	_containsValue: function(	/* item */ item, 
								/* attribute-name-string */ attribute, 
								/* anything */ value,
								/* RegExp?*/ regexp){
		//	summary: 
		//		Internal function for looking at the values contained by the item.
		//	description: 
		//		Internal function for looking at the values contained by the item.  This 
		//		function allows for denoting if the comparison should be case sensitive for
		//		strings or not (for handling filtering cases where string case should not matter)
		//	
		//	item:
		//		The data item to examine for attribute values.
		//	attribute:
		//		The attribute to inspect.
		//	value:	
		//		The value to match.
		//	regexp:
		//		Optional regular expression generated off value if value was of string type to handle wildcarding.
		//		If present and attribute values are string, then it can be used for comparison instead of 'value'
		return dojo.some(this.getValues(item, attribute), function(possibleValue){
			if(possibleValue !== null && !dojo.isObject(possibleValue) && regexp){
				if(possibleValue.toString().match(regexp)){
					return true; // Boolean
				}
			}else if(value === possibleValue){
				return true; // Boolean
			}
		});
	},

	isItem: function(/* anything */ something){
		//	summary: 
		//		See dojo.data.api.Read.isItem()
		if(something && something[this._storeRefPropName] === this){
			if(this._arrayOfAllItems[something[this._itemNumPropName]] === something){
				return true;
			}
		}
		return false; // Boolean
	},

	isItemLoaded: function(/* anything */ something){
		//	summary: 
		//		See dojo.data.api.Read.isItemLoaded()
		return this.isItem(something); //boolean
	},

	loadItem: function(/* object */ keywordArgs){
		//	summary: 
		//		See dojo.data.api.Read.loadItem()
		this._assertIsItem(keywordArgs.item);
	},

	getFeatures: function(){
		//	summary: 
		//		See dojo.data.api.Read.getFeatures()
		return this._features; //Object
	},

	getLabel: function(/* item */ item){
		//	summary: 
		//		See dojo.data.api.Read.getLabel()
		if(this._labelAttr && this.isItem(item)){
			return this.getValue(item,this._labelAttr); //String
		}
		return undefined; //undefined
	},

	getLabelAttributes: function(/* item */ item){
		//	summary: 
		//		See dojo.data.api.Read.getLabelAttributes()
		if(this._labelAttr){
			return [this._labelAttr]; //array
		}
		return null; //null
	},

	_fetchItems: function(	/* Object */ keywordArgs, 
							/* Function */ findCallback, 
							/* Function */ errorCallback){
		//	summary: 
		//		See dojo.data.util.simpleFetch.fetch()
		var self = this;
		var filter = function(requestArgs, arrayOfItems){
			var items = [];
			var i, key;
			if(requestArgs.query){
				var value;
				var ignoreCase = requestArgs.queryOptions ? requestArgs.queryOptions.ignoreCase : false; 

				//See if there are any string values that can be regexp parsed first to avoid multiple regexp gens on the
				//same value for each item examined.  Much more efficient.
				var regexpList = {};
				for(key in requestArgs.query){
					value = requestArgs.query[key];
					if(typeof value === "string"){
						regexpList[key] = dojo.data.util.filter.patternToRegExp(value, ignoreCase);
					}else if(value instanceof RegExp){
						regexpList[key] = value;
					}
				}
				for(i = 0; i < arrayOfItems.length; ++i){
					var match = true;
					var candidateItem = arrayOfItems[i];
					if(candidateItem === null){
						match = false;
					}else{
						for(key in requestArgs.query){
							value = requestArgs.query[key];
							if(!self._containsValue(candidateItem, key, value, regexpList[key])){
								match = false;
							}
						}
					}
					if(match){
						items.push(candidateItem);
					}
				}
				findCallback(items, requestArgs);
			}else{
				// We want a copy to pass back in case the parent wishes to sort the array. 
				// We shouldn't allow resort of the internal list, so that multiple callers 
				// can get lists and sort without affecting each other.  We also need to
				// filter out any null values that have been left as a result of deleteItem()
				// calls in ItemFileWriteStore.
				for(i = 0; i < arrayOfItems.length; ++i){
					var item = arrayOfItems[i];
					if(item !== null){
						items.push(item);
					}
				}
				findCallback(items, requestArgs);
			}
		};

		if(this._loadFinished){
			filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions));
		}else{
			//Do a check on the JsonFileUrl and crosscheck it.
			//If it doesn't match the cross-check, it needs to be updated
			//This allows for either url or _jsonFileUrl to he changed to
			//reset the store load location.  Done this way for backwards 
			//compatibility.  People use _jsonFileUrl (even though officially
			//private.
			if(this._jsonFileUrl !== this._ccUrl){
				dojo.deprecated("dojo.data.ItemFileReadStore: ", 
					"To change the url, set the url property of the store," +
					" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
				this._ccUrl = this._jsonFileUrl;
				this.url = this._jsonFileUrl;
			}else if(this.url !== this._ccUrl){
				this._jsonFileUrl = this.url;
				this._ccUrl = this.url;
			}

			//See if there was any forced reset of data.
			if(this.data != null && this._jsonData == null){
				this._jsonData = this.data;
				this.data = null;
			}

			if(this._jsonFileUrl){
				//If fetches come in before the loading has finished, but while
				//a load is in progress, we have to defer the fetching to be 
				//invoked in the callback.
				if(this._loadInProgress){
					this._queuedFetches.push({args: keywordArgs, filter: filter});
				}else{
					this._loadInProgress = true;
					var getArgs = {
							url: self._jsonFileUrl, 
							handleAs: "json-comment-optional",
							preventCache: this.urlPreventCache,
							failOk: this.failOk
						};
					var getHandler = dojo.xhrGet(getArgs);
					getHandler.addCallback(function(data){
						try{
							self._getItemsFromLoadedData(data);
							self._loadFinished = true;
							self._loadInProgress = false;
							
							filter(keywordArgs, self._getItemsArray(keywordArgs.queryOptions));
							self._handleQueuedFetches();
						}catch(e){
							self._loadFinished = true;
							self._loadInProgress = false;
							errorCallback(e, keywordArgs);
						}
					});
					getHandler.addErrback(function(error){
						self._loadInProgress = false;
						errorCallback(error, keywordArgs);
					});

					//Wire up the cancel to abort of the request
					//This call cancel on the deferred if it hasn't been called
					//yet and then will chain to the simple abort of the
					//simpleFetch keywordArgs
					var oldAbort = null;
					if(keywordArgs.abort){
						oldAbort = keywordArgs.abort;
					}
					keywordArgs.abort = function(){
						var df = getHandler;
						if(df && df.fired === -1){
							df.cancel();
							df = null;
						}
						if(oldAbort){
							oldAbort.call(keywordArgs);
						}
					};
				}
			}else if(this._jsonData){
				try{
					this._loadFinished = true;
					this._getItemsFromLoadedData(this._jsonData);
					this._jsonData = null;
					filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions));
				}catch(e){
					errorCallback(e, keywordArgs);
				}
			}else{
				errorCallback(new Error("dojo.data.ItemFileReadStore: No JSON source data was provided as either URL or a nested Javascript object."), keywordArgs);
			}
		}
	},

	_handleQueuedFetches: function(){
		//	summary: 
		//		Internal function to execute delayed request in the store.
		//Execute any deferred fetches now.
		if(this._queuedFetches.length > 0){
			for(var i = 0; i < this._queuedFetches.length; i++){
				var fData = this._queuedFetches[i];
				var delayedQuery = fData.args;
				var delayedFilter = fData.filter;
				if(delayedFilter){
					delayedFilter(delayedQuery, this._getItemsArray(delayedQuery.queryOptions)); 
				}else{
					this.fetchItemByIdentity(delayedQuery);
				}
			}
			this._queuedFetches = [];
		}
	},

	_getItemsArray: function(/*object?*/queryOptions){
		//	summary: 
		//		Internal function to determine which list of items to search over.
		//	queryOptions: The query options parameter, if any.
		if(queryOptions && queryOptions.deep){
			return this._arrayOfAllItems; 
		}
		return this._arrayOfTopLevelItems;
	},

	close: function(/*dojo.data.api.Request || keywordArgs || null */ request){
		 //	summary: 
		 //		See dojo.data.api.Read.close()
		 if(this.clearOnClose && 
			this._loadFinished && 
			!this._loadInProgress){
			 //Reset all internalsback to default state.  This will force a reload
			 //on next fetch.  This also checks that the data or url param was set 
			 //so that the store knows it can get data.  Without one of those being set,
			 //the next fetch will trigger an error.

			 if(((this._jsonFileUrl == "" || this._jsonFileUrl == null) && 
				 (this.url == "" || this.url == null)
				) && this.data == null){
				 console.debug("dojo.data.ItemFileReadStore: WARNING!  Data reload " +
					" information has not been provided." + 
					"  Please set 'url' or 'data' to the appropriate value before" +
					" the next fetch");
			 }
			 this._arrayOfAllItems = [];
			 this._arrayOfTopLevelItems = [];
			 this._loadFinished = false;
			 this._itemsByIdentity = null;
			 this._loadInProgress = false;
			 this._queuedFetches = [];
		 }
	},

	_getItemsFromLoadedData: function(/* Object */ dataObject){
		//	summary:
		//		Function to parse the loaded data into item format and build the internal items array.
		//	description:
		//		Function to parse the loaded data into item format and build the internal items array.
		//
		//	dataObject:
		//		The JS data object containing the raw data to convery into item format.
		//
		// 	returns: array
		//		Array of items in store item format.
		
		// First, we define a couple little utility functions...
		var addingArrays = false;
		var self = this;
		
		function valueIsAnItem(/* anything */ aValue){
			// summary:
			//		Given any sort of value that could be in the raw json data,
			//		return true if we should interpret the value as being an
			//		item itself, rather than a literal value or a reference.
			// example:
			// 	|	false == valueIsAnItem("Kermit");
			// 	|	false == valueIsAnItem(42);
			// 	|	false == valueIsAnItem(new Date());
			// 	|	false == valueIsAnItem({_type:'Date', _value:'May 14, 1802'});
			// 	|	false == valueIsAnItem({_reference:'Kermit'});
			// 	|	true == valueIsAnItem({name:'Kermit', color:'green'});
			// 	|	true == valueIsAnItem({iggy:'pop'});
			// 	|	true == valueIsAnItem({foo:42});
			var isItem = (
				(aValue !== null) &&
				(typeof aValue === "object") &&
				(!dojo.isArray(aValue) || addingArrays) &&
				(!dojo.isFunction(aValue)) &&
				(aValue.constructor == Object || dojo.isArray(aValue)) &&
				(typeof aValue._reference === "undefined") && 
				(typeof aValue._type === "undefined") && 
				(typeof aValue._value === "undefined") &&
				self.hierarchical
			);
			return isItem;
		}
		
		function addItemAndSubItemsToArrayOfAllItems(/* Item */ anItem){
			self._arrayOfAllItems.push(anItem);
			for(var attribute in anItem){
				var valueForAttribute = anItem[attribute];
				if(valueForAttribute){
					if(dojo.isArray(valueForAttribute)){
						var valueArray = valueForAttribute;
						for(var k = 0; k < valueArray.length; ++k){
							var singleValue = valueArray[k];
							if(valueIsAnItem(singleValue)){
								addItemAndSubItemsToArrayOfAllItems(singleValue);
							}
						}
					}else{
						if(valueIsAnItem(valueForAttribute)){
							addItemAndSubItemsToArrayOfAllItems(valueForAttribute);
						}
					}
				}
			}
		}

		this._labelAttr = dataObject.label;

		// We need to do some transformations to convert the data structure
		// that we read from the file into a format that will be convenient
		// to work with in memory.

		// Step 1: Walk through the object hierarchy and build a list of all items
		var i;
		var item;
		this._arrayOfAllItems = [];
		this._arrayOfTopLevelItems = dataObject.items;

		for(i = 0; i < this._arrayOfTopLevelItems.length; ++i){
			item = this._arrayOfTopLevelItems[i];
			if(dojo.isArray(item)){
				addingArrays = true;
			}
			addItemAndSubItemsToArrayOfAllItems(item);
			item[this._rootItemPropName]=true;
		}

		// Step 2: Walk through all the attribute values of all the items, 
		// and replace single values with arrays.  For example, we change this:
		//		{ name:'Miss Piggy', pets:'Foo-Foo'}
		// into this:
		//		{ name:['Miss Piggy'], pets:['Foo-Foo']}
		// 
		// We also store the attribute names so we can validate our store  
		// reference and item id special properties for the O(1) isItem
		var allAttributeNames = {};
		var key;

		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i];
			for(key in item){
				if(key !== this._rootItemPropName){
					var value = item[key];
					if(value !== null){
						if(!dojo.isArray(value)){
							item[key] = [value];
						}
					}else{
						item[key] = [null];
					}
				}
				allAttributeNames[key]=key;
			}
		}

		// Step 3: Build unique property names to use for the _storeRefPropName and _itemNumPropName
		// This should go really fast, it will generally never even run the loop.
		while(allAttributeNames[this._storeRefPropName]){
			this._storeRefPropName += "_";
		}
		while(allAttributeNames[this._itemNumPropName]){
			this._itemNumPropName += "_";
		}
		while(allAttributeNames[this._reverseRefMap]){
			this._reverseRefMap += "_";
		}

		// Step 4: Some data files specify an optional 'identifier', which is 
		// the name of an attribute that holds the identity of each item. 
		// If this data file specified an identifier attribute, then build a 
		// hash table of items keyed by the identity of the items.
		var arrayOfValues;

		var identifier = dataObject.identifier;
		if(identifier){
			this._itemsByIdentity = {};
			this._features['dojo.data.api.Identity'] = identifier;
			for(i = 0; i < this._arrayOfAllItems.length; ++i){
				item = this._arrayOfAllItems[i];
				arrayOfValues = item[identifier];
				var identity = arrayOfValues[0];
				if(!this._itemsByIdentity[identity]){
					this._itemsByIdentity[identity] = item;
				}else{
					if(this._jsonFileUrl){
						throw new Error("dojo.data.ItemFileReadStore:  The json data as specified by: [" + this._jsonFileUrl + "] is malformed.  Items within the list have identifier: [" + identifier + "].  Value collided: [" + identity + "]");
					}else if(this._jsonData){
						throw new Error("dojo.data.ItemFileReadStore:  The json data provided by the creation arguments is malformed.  Items within the list have identifier: [" + identifier + "].  Value collided: [" + identity + "]");
					}
				}
			}
		}else{
			this._features['dojo.data.api.Identity'] = Number;
		}

		// Step 5: Walk through all the items, and set each item's properties 
		// for _storeRefPropName and _itemNumPropName, so that store.isItem() will return true.
		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i];
			item[this._storeRefPropName] = this;
			item[this._itemNumPropName] = i;
		}

		// Step 6: We walk through all the attribute values of all the items,
		// looking for type/value literals and item-references.
		//
		// We replace item-references with pointers to items.  For example, we change:
		//		{ name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
		// into this:
		//		{ name:['Kermit'], friends:[miss_piggy] } 
		// (where miss_piggy is the object representing the 'Miss Piggy' item).
		//
		// We replace type/value pairs with typed-literals.  For example, we change:
		//		{ name:['Nelson Mandela'], born:[{_type:'Date', _value:'July 18, 1918'}] }
		// into this:
		//		{ name:['Kermit'], born:(new Date('July 18, 1918')) } 
		//
		// We also generate the associate map for all items for the O(1) isItem function.
		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i]; // example: { name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
			for(key in item){
				arrayOfValues = item[key]; // example: [{_reference:{name:'Miss Piggy'}}]
				for(var j = 0; j < arrayOfValues.length; ++j){
					value = arrayOfValues[j]; // example: {_reference:{name:'Miss Piggy'}}
					if(value !== null && typeof value == "object"){
						if(("_type" in value) && ("_value" in value)){
							var type = value._type; // examples: 'Date', 'Color', or 'ComplexNumber'
							var mappingObj = this._datatypeMap[type]; // examples: Date, dojo.Color, foo.math.ComplexNumber, {type: dojo.Color, deserialize(value){ return new dojo.Color(value)}}
							if(!mappingObj){ 
								throw new Error("dojo.data.ItemFileReadStore: in the typeMap constructor arg, no object class was specified for the datatype '" + type + "'");
							}else if(dojo.isFunction(mappingObj)){
								arrayOfValues[j] = new mappingObj(value._value);
							}else if(dojo.isFunction(mappingObj.deserialize)){
								arrayOfValues[j] = mappingObj.deserialize(value._value);
							}else{
								throw new Error("dojo.data.ItemFileReadStore: Value provided in typeMap was neither a constructor, nor a an object with a deserialize function");
							}
						}
						if(value._reference){
							var referenceDescription = value._reference; // example: {name:'Miss Piggy'}
							if(!dojo.isObject(referenceDescription)){
								// example: 'Miss Piggy'
								// from an item like: { name:['Kermit'], friends:[{_reference:'Miss Piggy'}]}
								arrayOfValues[j] = this._itemsByIdentity[referenceDescription];
							}else{
								// example: {name:'Miss Piggy'}
								// from an item like: { name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
								for(var k = 0; k < this._arrayOfAllItems.length; ++k){
									var candidateItem = this._arrayOfAllItems[k];
									var found = true;
									for(var refKey in referenceDescription){
										if(candidateItem[refKey] != referenceDescription[refKey]){ 
											found = false; 
										}
									}
									if(found){ 
										arrayOfValues[j] = candidateItem; 
									}
								}
							}
							if(this.referenceIntegrity){
								var refItem = arrayOfValues[j];
								if(this.isItem(refItem)){
									this._addReferenceToMap(refItem, item, key);
								}
							}
						}else if(this.isItem(value)){
							//It's a child item (not one referenced through _reference).  
							//We need to treat this as a referenced item, so it can be cleaned up
							//in a write store easily.
							if(this.referenceIntegrity){
								this._addReferenceToMap(value, item, key);
							}
						}
					}
				}
			}
		}
	},

	_addReferenceToMap: function(/*item*/ refItem, /*item*/ parentItem, /*string*/ attribute){
		 //	summary:
		 //		Method to add an reference map entry for an item and attribute.
		 //	description:
		 //		Method to add an reference map entry for an item and attribute. 		 //
		 //	refItem:
		 //		The item that is referenced.
		 //	parentItem:
		 //		The item that holds the new reference to refItem.
		 //	attribute:
		 //		The attribute on parentItem that contains the new reference.
		 
		 //Stub function, does nothing.  Real processing is in ItemFileWriteStore.
	},

	getIdentity: function(/* item */ item){
		//	summary: 
		//		See dojo.data.api.Identity.getIdentity()
		var identifier = this._features['dojo.data.api.Identity'];
		if(identifier === Number){
			return item[this._itemNumPropName]; // Number
		}else{
			var arrayOfValues = item[identifier];
			if(arrayOfValues){
				return arrayOfValues[0]; // Object || String
			}
		}
		return null; // null
	},

	fetchItemByIdentity: function(/* Object */ keywordArgs){
		//	summary: 
		//		See dojo.data.api.Identity.fetchItemByIdentity()

		// Hasn't loaded yet, we have to trigger the load.
		var item;
		var scope;
		if(!this._loadFinished){
			var self = this;
			//Do a check on the JsonFileUrl and crosscheck it.
			//If it doesn't match the cross-check, it needs to be updated
			//This allows for either url or _jsonFileUrl to he changed to
			//reset the store load location.  Done this way for backwards 
			//compatibility.  People use _jsonFileUrl (even though officially
			//private.
			if(this._jsonFileUrl !== this._ccUrl){
				dojo.deprecated("dojo.data.ItemFileReadStore: ", 
					"To change the url, set the url property of the store," +
					" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
				this._ccUrl = this._jsonFileUrl;
				this.url = this._jsonFileUrl;
			}else if(this.url !== this._ccUrl){
				this._jsonFileUrl = this.url;
				this._ccUrl = this.url;
			}
			
			//See if there was any forced reset of data.
			if(this.data != null && this._jsonData == null){
				this._jsonData = this.data;
				this.data = null;
			}

			if(this._jsonFileUrl){

				if(this._loadInProgress){
					this._queuedFetches.push({args: keywordArgs});
				}else{
					this._loadInProgress = true;
					var getArgs = {
							url: self._jsonFileUrl, 
							handleAs: "json-comment-optional",
							preventCache: this.urlPreventCache,
							failOk: this.failOk
					};
					var getHandler = dojo.xhrGet(getArgs);
					getHandler.addCallback(function(data){
						var scope = keywordArgs.scope?keywordArgs.scope:dojo.global;
						try{
							self._getItemsFromLoadedData(data);
							self._loadFinished = true;
							self._loadInProgress = false;
							item = self._getItemByIdentity(keywordArgs.identity);
							if(keywordArgs.onItem){
								keywordArgs.onItem.call(scope, item);
							}
							self._handleQueuedFetches();
						}catch(error){
							self._loadInProgress = false;
							if(keywordArgs.onError){
								keywordArgs.onError.call(scope, error);
							}
						}
					});
					getHandler.addErrback(function(error){
						self._loadInProgress = false;
						if(keywordArgs.onError){
							var scope = keywordArgs.scope?keywordArgs.scope:dojo.global;
							keywordArgs.onError.call(scope, error);
						}
					});
				}

			}else if(this._jsonData){
				// Passed in data, no need to xhr.
				self._getItemsFromLoadedData(self._jsonData);
				self._jsonData = null;
				self._loadFinished = true;
				item = self._getItemByIdentity(keywordArgs.identity);
				if(keywordArgs.onItem){
					scope = keywordArgs.scope?keywordArgs.scope:dojo.global;
					keywordArgs.onItem.call(scope, item);
				}
			} 
		}else{
			// Already loaded.  We can just look it up and call back.
			item = this._getItemByIdentity(keywordArgs.identity);
			if(keywordArgs.onItem){
				scope = keywordArgs.scope?keywordArgs.scope:dojo.global;
				keywordArgs.onItem.call(scope, item);
			}
		}
	},

	_getItemByIdentity: function(/* Object */ identity){
		//	summary:
		//		Internal function to look an item up by its identity map.
		var item = null;
		if(this._itemsByIdentity){
			item = this._itemsByIdentity[identity];
		}else{
			item = this._arrayOfAllItems[identity];
		}
		if(item === undefined){
			item = null;
		}
		return item; // Object
	},

	getIdentityAttributes: function(/* item */ item){
		//	summary: 
		//		See dojo.data.api.Identity.getIdentifierAttributes()
		 
		var identifier = this._features['dojo.data.api.Identity'];
		if(identifier === Number){
			// If (identifier === Number) it means getIdentity() just returns
			// an integer item-number for each item.  The dojo.data.api.Identity
			// spec says we need to return null if the identity is not composed 
			// of attributes 
			return null; // null
		}else{
			return [identifier]; // Array
		}
	},
	
	_forceLoad: function(){
		//	summary: 
		//		Internal function to force a load of the store if it hasn't occurred yet.  This is required
		//		for specific functions to work properly.  
		var self = this;
		//Do a check on the JsonFileUrl and crosscheck it.
		//If it doesn't match the cross-check, it needs to be updated
		//This allows for either url or _jsonFileUrl to he changed to
		//reset the store load location.  Done this way for backwards 
		//compatibility.  People use _jsonFileUrl (even though officially
		//private.
		if(this._jsonFileUrl !== this._ccUrl){
			dojo.deprecated("dojo.data.ItemFileReadStore: ", 
				"To change the url, set the url property of the store," +
				" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
			this._ccUrl = this._jsonFileUrl;
			this.url = this._jsonFileUrl;
		}else if(this.url !== this._ccUrl){
			this._jsonFileUrl = this.url;
			this._ccUrl = this.url;
		}

		//See if there was any forced reset of data.
		if(this.data != null && this._jsonData == null){
			this._jsonData = this.data;
			this.data = null;
		}

		if(this._jsonFileUrl){
				var getArgs = {
					url: this._jsonFileUrl, 
					handleAs: "json-comment-optional",
					preventCache: this.urlPreventCache,
					failOk: this.failOk,
					sync: true
				};
			var getHandler = dojo.xhrGet(getArgs);
			getHandler.addCallback(function(data){
				try{
					//Check to be sure there wasn't another load going on concurrently 
					//So we don't clobber data that comes in on it.  If there is a load going on
					//then do not save this data.  It will potentially clobber current data.
					//We mainly wanted to sync/wait here.
					//TODO:  Revisit the loading scheme of this store to improve multi-initial
					//request handling.
					if(self._loadInProgress !== true && !self._loadFinished){
						self._getItemsFromLoadedData(data);
						self._loadFinished = true;
					}else if(self._loadInProgress){
						//Okay, we hit an error state we can't recover from.  A forced load occurred
						//while an async load was occurring.  Since we cannot block at this point, the best
						//that can be managed is to throw an error.
						throw new Error("dojo.data.ItemFileReadStore:  Unable to perform a synchronous load, an async load is in progress."); 
					}
				}catch(e){
					console.log(e);
					throw e;
				}
			});
			getHandler.addErrback(function(error){
				throw error;
			});
		}else if(this._jsonData){
			self._getItemsFromLoadedData(self._jsonData);
			self._jsonData = null;
			self._loadFinished = true;
		} 
	}
});
//Mix in the simple fetch implementation to this class.
dojo.extend(dojo.data.ItemFileReadStore,dojo.data.util.simpleFetch);

}

if(!dojo._hasResource["dojox.data.QueryReadStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.data.QueryReadStore"] = true;
dojo.provide("dojox.data.QueryReadStore");




dojo.declare("dojox.data.QueryReadStore",
	null,
	{
		//	summary:
		//		This class provides a store that is mainly intended to be used
		//		for loading data dynamically from the server, used i.e. for
		//		retreiving chunks of data from huge data stores on the server (by server-side filtering!).
		//		Upon calling the fetch() method of this store the data are requested from
		//		the server if they are not yet loaded for paging (or cached).
		//
		//		For example used for a combobox which works on lots of data. It
		//		can be used to retreive the data partially upon entering the
		//		letters "ac" it returns only items like "action", "acting", etc.
		//
		// note:
		//		The field name "id" in a query is reserved for looking up data
		//		by id. This is necessary as before the first fetch, the store
		//		has no way of knowing which field the server will declare as
		//		identifier.
		//
		//	example:
		// |	// The parameter "query" contains the data that are sent to the server.
		// |	var store = new dojox.data.QueryReadStore({url:'/search.php'});
		// |	store.fetch({query:{name:'a'}, queryOptions:{ignoreCase:false}});
		//
		// |	// Since "serverQuery" is given, it overrules and those data are
		// |	// sent to the server.
		// |	var store = new dojox.data.QueryReadStore({url:'/search.php'});
		// |	store.fetch({serverQuery:{name:'a'}, queryOptions:{ignoreCase:false}});
		//
		// |	<div dojoType="dojox.data.QueryReadStore"
		// |		jsId="store2"
		// |		url="../tests/stores/QueryReadStore.php"
		// |		requestMethod="post"></div>
		// |	<div dojoType="dojox.grid.data.DojoData"
		// |		jsId="model2"
		// |		store="store2"
		// |		sortFields="[{attribute: 'name', descending: true}]"
		// |		rowsPerPage="30"></div>
		// |	<div dojoType="dojox.Grid" id="grid2"
		// |		model="model2"
		// |		structure="gridLayout"
		// |		style="height:300px; width:800px;"></div>
	
		//
		//	todo:
		//		- there is a bug in the paging, when i set start:2, count:5 after an initial fetch() and doClientPaging:true
		//		  it returns 6 elemetns, though count=5, try it in QueryReadStore.html
		//		- add optional caching
		//		- when the first query searched for "a" and the next for a subset of
		//		  the first, i.e. "ab" then we actually dont need a server request, if
		//		  we have client paging, we just need to filter the items we already have
		//		  that might also be tooo much logic
		
		url:"",
		requestMethod:"get",
		//useCache:false,
		
		// We use the name in the errors, once the name is fixed hardcode it, may be.
		_className:"dojox.data.QueryReadStore",
		
		// This will contain the items we have loaded from the server.
		// The contents of this array is optimized to satisfy all read-api requirements
		// and for using lesser storage, so the keys and their content need some explaination:
		// 		this._items[0].i - the item itself 
		//		this._items[0].r - a reference to the store, so we can identify the item
		//			securly. We set this reference right after receiving the item from the
		//			server.
		_items:[],
		
		// Store the last query that triggered xhr request to the server.
		// So we can compare if the request changed and if we shall reload 
		// (this also depends on other factors, such as is caching used, etc).
		_lastServerQuery:null,
		
		// Store how many rows we have so that we can pass it to a clientPaging handler
		_numRows:-1,
		
		// Store a hash of the last server request. Actually I introduced this
		// for testing, so I can check if no unnecessary requests were issued for
		// client-side-paging.
		lastRequestHash:null,
		
		// summary:
		//		By default every request for paging is sent to the server.
		doClientPaging:false,
	
		// summary:
		//		By default all the sorting is done serverside before the data is returned
		//		which is the proper place to be doing it for really large datasets.
		doClientSorting:false,
	
		// Items by identify for Identify API
		_itemsByIdentity:null,
		
		// Identifier used
		_identifier:null,
	
		_features: {'dojo.data.api.Read':true, 'dojo.data.api.Identity':true},
	
		_labelAttr: "label",
		
		constructor: function(/* Object */ params){
			dojo.mixin(this,params);
		},
		
		getValue: function(/* item */ item, /* attribute-name-string */ attribute, /* value? */ defaultValue){
			//	According to the Read API comments in getValue() and exception is
			//	thrown when an item is not an item or the attribute not a string!
			this._assertIsItem(item);
			if(!dojo.isString(attribute)){
				throw new Error(this._className+".getValue(): Invalid attribute, string expected!");
			}
			if(!this.hasAttribute(item, attribute)){
				// read api says: return defaultValue "only if *item* does not have a value for *attribute*." 
				// Is this the case here? The attribute doesn't exist, but a defaultValue, sounds reasonable.
				if(defaultValue){
					return defaultValue;
				}
				console.log(this._className+".getValue(): Item does not have the attribute '"+attribute+"'.");
			}
			return item.i[attribute];
		},
		
		getValues: function(/* item */ item, /* attribute-name-string */ attribute){
			this._assertIsItem(item);
			var ret = [];
			if(this.hasAttribute(item, attribute)){
				ret.push(item.i[attribute]);
			}
			return ret;
		},
		
		getAttributes: function(/* item */ item){
			this._assertIsItem(item);
			var ret = [];
			for(var i in item.i){
				ret.push(i);
			}
			return ret;
		},
	
		hasAttribute: function(/* item */ item,	/* attribute-name-string */ attribute){
			//	summary: 
			//		See dojo.data.api.Read.hasAttribute()
			return this.isItem(item) && typeof item.i[attribute]!="undefined";
		},
		
		containsValue: function(/* item */ item, /* attribute-name-string */ attribute, /* anything */ value){
			var values = this.getValues(item, attribute);
			var len = values.length;
			for(var i=0; i<len; i++){
				if(values[i] == value){
					return true;
				}
			}
			return false;
		},
		
		isItem: function(/* anything */ something){
			// Some basic tests, that are quick and easy to do here.
			// >>> var store = new dojox.data.QueryReadStore({});
			// >>> store.isItem("");
			// false
			//
			// >>> var store = new dojox.data.QueryReadStore({});
			// >>> store.isItem({});
			// false
			//
			// >>> var store = new dojox.data.QueryReadStore({});
			// >>> store.isItem(0);
			// false
			//
			// >>> var store = new dojox.data.QueryReadStore({});
			// >>> store.isItem({name:"me", label:"me too"});
			// false
			//
			if(something){
				return typeof something.r != "undefined" && something.r == this;
			}
			return false;
		},
		
		isItemLoaded: function(/* anything */ something){
			// Currently we dont have any state that tells if an item is loaded or not
			// if the item exists its also loaded.
			// This might change when we start working with refs inside items ...
			return this.isItem(something);
		},
	
		loadItem: function(/* object */ args){
			if(this.isItemLoaded(args.item)){
				return;
			}
			// Actually we have nothing to do here, or at least I dont know what to do here ...
		},
	
		fetch:function(/* Object? */ request){
			//	summary:
			//		See dojo.data.util.simpleFetch.fetch() this is just a copy and I adjusted
			//		only the paging, since it happens on the server if doClientPaging is
			//		false, thx to http://trac.dojotoolkit.org/ticket/4761 reporting this.
			//		Would be nice to be able to use simpleFetch() to reduce copied code,
			//		but i dont know how yet. Ideas please!
			request = request || {};
			if(!request.store){
				request.store = this;
			}
			var self = this;
		
			var _errorHandler = function(errorData, requestObject){
				if(requestObject.onError){
					var scope = requestObject.scope || dojo.global;
					requestObject.onError.call(scope, errorData, requestObject);
				}
			};
		
			var _fetchHandler = function(items, requestObject, numRows){
				var oldAbortFunction = requestObject.abort || null;
				var aborted = false;
				
				var startIndex = requestObject.start?requestObject.start:0;
				if(self.doClientPaging == false){
					// For client paging we dont need no slicing of the result.
					startIndex = 0;
				}
				var endIndex = requestObject.count?(startIndex + requestObject.count):items.length;
		
				requestObject.abort = function(){
					aborted = true;
					if(oldAbortFunction){
						oldAbortFunction.call(requestObject);
					}
				};
		
				var scope = requestObject.scope || dojo.global;
				if(!requestObject.store){
					requestObject.store = self;
				}
				if(requestObject.onBegin){
					requestObject.onBegin.call(scope, numRows, requestObject);
				}
				if(requestObject.sort && self.doClientSorting){
					items.sort(dojo.data.util.sorter.createSortFunction(requestObject.sort, self));
				}
				if(requestObject.onItem){
					for(var i = startIndex; (i < items.length) && (i < endIndex); ++i){
						var item = items[i];
						if(!aborted){
							requestObject.onItem.call(scope, item, requestObject);
						}
					}
				}
				if(requestObject.onComplete && !aborted){
					var subset = null;
					if(!requestObject.onItem){
						subset = items.slice(startIndex, endIndex);
					}
					requestObject.onComplete.call(scope, subset, requestObject);
				}
			};
			this._fetchItems(request, _fetchHandler, _errorHandler);
			return request;	// Object
		},
	
		getFeatures: function(){
			return this._features;
		},
	
		close: function(/*dojo.data.api.Request || keywordArgs || null */ request){
			// I have no idea if this is really needed ... 
		},
	
		getLabel: function(/* item */ item){
			//	summary:
			//		See dojo.data.api.Read.getLabel()
			if(this._labelAttr && this.isItem(item)){
				return this.getValue(item, this._labelAttr); //String
			}
			return undefined; //undefined
		},
	
		getLabelAttributes: function(/* item */ item){
			//	summary:
			//		See dojo.data.api.Read.getLabelAttributes()
			if(this._labelAttr){
				return [this._labelAttr]; //array
			}
			return null; //null
		},
		
		_xhrFetchHandler: function(data, request, fetchHandler, errorHandler){
			data = this._filterResponse(data);
			if(data.label){
				this._labelAttr = data.label;
			}
			var numRows = data.numRows || -1;

			this._items = [];
			// Store a ref to "this" in each item, so we can simply check if an item
			// really origins form here (idea is from ItemFileReadStore, I just don't know
			// how efficient the real storage use, garbage collection effort, etc. is).
			dojo.forEach(data.items,function(e){ 
				this._items.push({i:e, r:this}); 
			},this); 
			
			var identifier = data.identifier;
			this._itemsByIdentity = {};
			if(identifier){
				this._identifier = identifier;
				var i;
				for(i = 0; i < this._items.length; ++i){
					var item = this._items[i].i;
					var identity = item[identifier];
					if(!this._itemsByIdentity[identity]){
						this._itemsByIdentity[identity] = item;
					}else{
						throw new Error(this._className+":  The json data as specified by: [" + this.url + "] is malformed.  Items within the list have identifier: [" + identifier + "].  Value collided: [" + identity + "]");
					}
				}
			}else{
				this._identifier = Number;
				for(i = 0; i < this._items.length; ++i){
					this._items[i].n = i;
				}
			}
			
			// TODO actually we should do the same as dojo.data.ItemFileReadStore._getItemsFromLoadedData() to sanitize
			// (does it really sanititze them) and store the data optimal. should we? for security reasons???
			numRows = this._numRows = (numRows === -1) ? this._items.length : numRows;
			fetchHandler(this._items, request, numRows);
			this._numRows = numRows;		
		},
		
		_fetchItems: function(request, fetchHandler, errorHandler){
			//	summary:
			// 		The request contains the data as defined in the Read-API.
			// 		Additionally there is following keyword "serverQuery".
			//
			//	The *serverQuery* parameter, optional.
			//		This parameter contains the data that will be sent to the server.
			//		If this parameter is not given the parameter "query"'s
			//		data are sent to the server. This is done for some reasons:
			//		- to specify explicitly which data are sent to the server, they
			//		  might also be a mix of what is contained in "query", "queryOptions"
			//		  and the paging parameters "start" and "count" or may be even
			//		  completely different things.
			//		- don't modify the request.query data, so the interface using this
			//		  store can rely on unmodified data, as the combobox dijit currently
			//		  does it, it compares if the query has changed
			//		- request.query is required by the Read-API
			//
			// 		I.e. the following examples might be sent via GET:
			//		  fetch({query:{name:"abc"}, queryOptions:{ignoreCase:true}})
			//		  the URL will become:   /url.php?name=abc
			//
			//		  fetch({serverQuery:{q:"abc", c:true}, query:{name:"abc"}, queryOptions:{ignoreCase:true}})
			//		  the URL will become:   /url.php?q=abc&c=true
			//		  // The serverQuery-parameter has overruled the query-parameter
			//		  // but the query parameter stays untouched, but is not sent to the server!
			//		  // The serverQuery contains more data than the query, so they might differ!
			//
	
			var serverQuery = request.serverQuery || request.query || {};
			//Need to add start and count
			if(!this.doClientPaging){
				serverQuery.start = request.start || 0;
				// Count might not be sent if not given.
				if(request.count){
					serverQuery.count = request.count;
				}
			}
			if(!this.doClientSorting){
				if(request.sort){
					var sort = request.sort[0];
					if(sort && sort.attribute){
						var sortStr = sort.attribute;
						if(sort.descending){
							sortStr = "-" + sortStr;
						}
						serverQuery.sort = sortStr;
					}
				}
			}
			// Compare the last query and the current query by simply json-encoding them,
			// so we dont have to do any deep object compare ... is there some dojo.areObjectsEqual()???
			if(this.doClientPaging && this._lastServerQuery !== null &&
				dojo.toJson(serverQuery) == dojo.toJson(this._lastServerQuery)
				){
				this._numRows = (this._numRows === -1) ? this._items.length : this._numRows;
				fetchHandler(this._items, request, this._numRows);
			}else{
				var xhrFunc = this.requestMethod.toLowerCase() == "post" ? dojo.xhrPost : dojo.xhrGet;
				var xhrHandler = xhrFunc({url:this.url, handleAs:"json-comment-optional", content:serverQuery});
				xhrHandler.addCallback(dojo.hitch(this, function(data){
					this._xhrFetchHandler(data, request, fetchHandler, errorHandler);
				}));
				xhrHandler.addErrback(function(error){
					errorHandler(error, request);
				});
				// Generate the hash using the time in milliseconds and a randon number.
				// Since Math.randon() returns something like: 0.23453463, we just remove the "0."
				// probably just for esthetic reasons :-).
				this.lastRequestHash = new Date().getTime()+"-"+String(Math.random()).substring(2);
				this._lastServerQuery = dojo.mixin({}, serverQuery);
			}
		},
		
		_filterResponse: function(data){
			//	summary:
			//		If the data from servers needs to be processed before it can be processed by this
			//		store, then this function should be re-implemented in subclass. This default 
			//		implementation just return the data unchanged.
			//	data:
			//		The data received from server
			return data;
		},
	
		_assertIsItem: function(/* item */ item){
			//	summary:
			//		It throws an error if item is not valid, so you can call it in every method that needs to
			//		throw an error when item is invalid.
			//	item: 
			//		The item to test for being contained by the store.
			if(!this.isItem(item)){
				throw new Error(this._className+": Invalid item argument.");
			}
		},
	
		_assertIsAttribute: function(/* attribute-name-string */ attribute){
			//	summary:
			//		This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.
			//	attribute: 
			//		The attribute to test for being contained by the store.
			if(typeof attribute !== "string"){ 
				throw new Error(this._className+": Invalid attribute argument ('"+attribute+"').");
			}
		},
	
		fetchItemByIdentity: function(/* Object */ keywordArgs){
			//	summary: 
			//		See dojo.data.api.Identity.fetchItemByIdentity()
	
			// See if we have already loaded the item with that id
			// In case there hasn't been a fetch yet, _itemsByIdentity is null
			// and thus a fetch will be triggered below.
			if(this._itemsByIdentity){
				var item = this._itemsByIdentity[keywordArgs.identity];
				if(!(item === undefined)){
					if(keywordArgs.onItem){
						var scope = keywordArgs.scope ? keywordArgs.scope : dojo.global;
						keywordArgs.onItem.call(scope, {i:item, r:this});
					}
					return;
				}
			}
	
			// Otherwise we need to go remote
			// Set up error handler
			var _errorHandler = function(errorData, requestObject){
				var scope = keywordArgs.scope ? keywordArgs.scope : dojo.global;
				if(keywordArgs.onError){
					keywordArgs.onError.call(scope, errorData);
				}
			};
			
			// Set up fetch handler
			var _fetchHandler = function(items, requestObject){
				var scope = keywordArgs.scope ? keywordArgs.scope : dojo.global;
				try{
					// There is supposed to be only one result
					var item = null;
					if(items && items.length == 1){
						item = items[0];
					}
					
					// If no item was found, item is still null and we'll
					// fire the onItem event with the null here
					if(keywordArgs.onItem){
						keywordArgs.onItem.call(scope, item);
					}
				}catch(error){
					if(keywordArgs.onError){
						keywordArgs.onError.call(scope, error);
					}
				}
			};
			
			// Construct query
			var request = {serverQuery:{id:keywordArgs.identity}};
			
			// Dispatch query
			this._fetchItems(request, _fetchHandler, _errorHandler);
		},
		
		getIdentity: function(/* item */ item){
			//	summary: 
			//		See dojo.data.api.Identity.getIdentity()
			var identifier = null;
			if(this._identifier === Number){
				identifier = item.n; // Number
			}else{
				identifier = item.i[this._identifier];
			}
			return identifier;
		},
		
		getIdentityAttributes: function(/* item */ item){
			//	summary:
			//		See dojo.data.api.Identity.getIdentityAttributes()
			return [this._identifier];
		}
	}
);

}

if(!dojo._hasResource["dijit._base.manager"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.manager"] = true;
dojo.provide("dijit._base.manager");

dojo.declare("dijit.WidgetSet", null, {
	// summary:
	//		A set of widgets indexed by id. A default instance of this class is
	//		available as `dijit.registry`
	//
	// example:
	//		Create a small list of widgets:
	//		|	var ws = new dijit.WidgetSet();
	//		|	ws.add(dijit.byId("one"));
	//		| 	ws.add(dijit.byId("two"));
	//		|	// destroy both:
	//		|	ws.forEach(function(w){ w.destroy(); });
	//
	// example:
	//		Using dijit.registry:
	//		|	dijit.registry.forEach(function(w){ /* do something */ });

	constructor: function(){
		this._hash = {};
		this.length = 0;
	},

	add: function(/*dijit._Widget*/ widget){
		// summary:
		//		Add a widget to this list. If a duplicate ID is detected, a error is thrown.
		//
		// widget: dijit._Widget
		//		Any dijit._Widget subclass.
		if(this._hash[widget.id]){
			throw new Error("Tried to register widget with id==" + widget.id + " but that id is already registered");
		}
		this._hash[widget.id] = widget;
		this.length++;
	},

	remove: function(/*String*/ id){
		// summary:
		//		Remove a widget from this WidgetSet. Does not destroy the widget; simply
		//		removes the reference.
		if(this._hash[id]){
			delete this._hash[id];
			this.length--;
		}
	},

	forEach: function(/*Function*/ func, /* Object? */thisObj){
		// summary:
		//		Call specified function for each widget in this set.
		//
		// func:
		//		A callback function to run for each item. Is passed the widget, the index
		//		in the iteration, and the full hash, similar to `dojo.forEach`.
		//
		// thisObj:
		//		An optional scope parameter
		//
		// example:
		//		Using the default `dijit.registry` instance:
		//		|	dijit.registry.forEach(function(widget){
		//		|		console.log(widget.declaredClass);
		//		|	});
		//
		// returns:
		//		Returns self, in order to allow for further chaining.

		thisObj = thisObj || dojo.global;
		var i = 0, id;
		for(id in this._hash){
			func.call(thisObj, this._hash[id], i++, this._hash);
		}
		return this;	// dijit.WidgetSet
	},

	filter: function(/*Function*/ filter, /* Object? */thisObj){
		// summary:
		//		Filter down this WidgetSet to a smaller new WidgetSet
		//		Works the same as `dojo.filter` and `dojo.NodeList.filter`
		//
		// filter:
		//		Callback function to test truthiness. Is passed the widget
		//		reference and the pseudo-index in the object.
		//
		// thisObj: Object?
		//		Option scope to use for the filter function.
		//
		// example:
		//		Arbitrary: select the odd widgets in this list
		//		|	dijit.registry.filter(function(w, i){
		//		|		return i % 2 == 0;
		//		|	}).forEach(function(w){ /* odd ones */ });

		thisObj = thisObj || dojo.global;
		var res = new dijit.WidgetSet(), i = 0, id;
		for(id in this._hash){
			var w = this._hash[id];
			if(filter.call(thisObj, w, i++, this._hash)){
				res.add(w);
			}
		}
		return res; // dijit.WidgetSet
	},

	byId: function(/*String*/ id){
		// summary:
		//		Find a widget in this list by it's id.
		// example:
		//		Test if an id is in a particular WidgetSet
		//		| var ws = new dijit.WidgetSet();
		//		| ws.add(dijit.byId("bar"));
		//		| var t = ws.byId("bar") // returns a widget
		//		| var x = ws.byId("foo"); // returns undefined

		return this._hash[id];	// dijit._Widget
	},

	byClass: function(/*String*/ cls){
		// summary:
		//		Reduce this widgetset to a new WidgetSet of a particular `declaredClass`
		//
		// cls: String
		//		The Class to scan for. Full dot-notated string.
		//
		// example:
		//		Find all `dijit.TitlePane`s in a page:
		//		|	dijit.registry.byClass("dijit.TitlePane").forEach(function(tp){ tp.close(); });

		var res = new dijit.WidgetSet(), id, widget;
		for(id in this._hash){
			widget = this._hash[id];
			if(widget.declaredClass == cls){
				res.add(widget);
			}
		 }
		 return res; // dijit.WidgetSet
},

	toArray: function(){
		// summary:
		//		Convert this WidgetSet into a true Array
		//
		// example:
		//		Work with the widget .domNodes in a real Array
		//		|	dojo.map(dijit.registry.toArray(), function(w){ return w.domNode; });

		var ar = [];
		for(var id in this._hash){
			ar.push(this._hash[id]);
		}
		return ar;	// dijit._Widget[]
},

	map: function(/* Function */func, /* Object? */thisObj){
		// summary:
		//		Create a new Array from this WidgetSet, following the same rules as `dojo.map`
		// example:
		//		|	var nodes = dijit.registry.map(function(w){ return w.domNode; });
		//
		// returns:
		//		A new array of the returned values.
		return dojo.map(this.toArray(), func, thisObj); // Array
	},

	every: function(func, thisObj){
		// summary:
		// 		A synthetic clone of `dojo.every` acting explictly on this WidgetSet
		//
		// func: Function
		//		A callback function run for every widget in this list. Exits loop
		//		when the first false return is encountered.
		//
		// thisObj: Object?
		//		Optional scope parameter to use for the callback

		thisObj = thisObj || dojo.global;
		var x = 0, i;
		for(i in this._hash){
			if(!func.call(thisObj, this._hash[i], x++, this._hash)){
				return false; // Boolean
			}
		}
		return true; // Boolean
	},

	some: function(func, thisObj){
		// summary:
		// 		A synthetic clone of `dojo.some` acting explictly on this WidgetSet
		//
		// func: Function
		//		A callback function run for every widget in this list. Exits loop
		//		when the first true return is encountered.
		//
		// thisObj: Object?
		//		Optional scope parameter to use for the callback

		thisObj = thisObj || dojo.global;
		var x = 0, i;
		for(i in this._hash){
			if(func.call(thisObj, this._hash[i], x++, this._hash)){
				return true; // Boolean
			}
		}
		return false; // Boolean
	}

});

/*=====
dijit.registry = {
	// summary:
	//		A list of widgets on a page.
	// description:
	//		Is an instance of `dijit.WidgetSet`
};
=====*/
dijit.registry= new dijit.WidgetSet();

dijit._widgetTypeCtr = {};

dijit.getUniqueId = function(/*String*/widgetType){
	// summary:
	//		Generates a unique id for a given widgetType

	var id;
	do{
		id = widgetType + "_" +
			(widgetType in dijit._widgetTypeCtr ?
				++dijit._widgetTypeCtr[widgetType] : dijit._widgetTypeCtr[widgetType] = 0);
	}while(dijit.byId(id));
	return dijit._scopeName == "dijit" ? id : dijit._scopeName + "_" + id; // String
};

dijit.findWidgets = function(/*DomNode*/ root){
	// summary:
	//		Search subtree under root returning widgets found.
	//		Doesn't search for nested widgets (ie, widgets inside other widgets).

	var outAry = [];

	function getChildrenHelper(root){
		for(var node = root.firstChild; node; node = node.nextSibling){
			if(node.nodeType == 1){
				var widgetId = node.getAttribute("widgetId");
				if(widgetId){
					var widget = dijit.byId(widgetId);
					outAry.push(widget);
				}else{
					getChildrenHelper(node);
				}
			}
		}
	}

	getChildrenHelper(root);
	return outAry;
};

dijit._destroyAll = function(){
	// summary:
	//		Code to destroy all widgets and do other cleanup on page unload

	// Clean up focus manager lingering references to widgets and nodes
	dijit._curFocus = null;
	dijit._prevFocus = null;
	dijit._activeStack = [];

	// Destroy all the widgets, top down
	dojo.forEach(dijit.findWidgets(dojo.body()), function(widget){
		// Avoid double destroy of widgets like Menu that are attached to <body>
		// even though they are logically children of other widgets.
		if(!widget._destroyed){
			if(widget.destroyRecursive){
				widget.destroyRecursive();
			}else if(widget.destroy){
				widget.destroy();
			}
		}
	});
};

if(dojo.isIE){
	// Only run _destroyAll() for IE because we think it's only necessary in that case,
	// and because it causes problems on FF.  See bug #3531 for details.
	dojo.addOnWindowUnload(function(){
		dijit._destroyAll();
	});
}

dijit.byId = function(/*String|Widget*/id){
	// summary:
	//		Returns a widget by it's id, or if passed a widget, no-op (like dojo.byId())
	return typeof id == "string" ? dijit.registry._hash[id] : id; // dijit._Widget
};

dijit.byNode = function(/* DOMNode */ node){
	// summary:
	//		Returns the widget corresponding to the given DOMNode
	return dijit.registry.byId(node.getAttribute("widgetId")); // dijit._Widget
};

dijit.getEnclosingWidget = function(/* DOMNode */ node){
	// summary:
	//		Returns the widget whose DOM tree contains the specified DOMNode, or null if
	//		the node is not contained within the DOM tree of any widget
	while(node){
		var id = node.getAttribute && node.getAttribute("widgetId");
		if(id){
			return dijit.byId(id);
		}
		node = node.parentNode;
	}
	return null;
};

dijit._isElementShown = function(/*Element*/elem){
	var style = dojo.style(elem);
	return (style.visibility != "hidden")
		&& (style.visibility != "collapsed")
		&& (style.display != "none")
		&& (dojo.attr(elem, "type") != "hidden");
}

dijit.isTabNavigable = function(/*Element*/elem){
	// summary:
	//		Tests if an element is tab-navigable

	// TODO: convert (and rename method) to return effectivite tabIndex; will save time in _getTabNavigable()
	if(dojo.attr(elem, "disabled")){
		return false;
	}else if(dojo.hasAttr(elem, "tabIndex")){
		// Explicit tab index setting
		return dojo.attr(elem, "tabIndex") >= 0; // boolean
	}else{
		// No explicit tabIndex setting, need to investigate node type
		switch(elem.nodeName.toLowerCase()){
			case "a":
				// An <a> w/out a tabindex is only navigable if it has an href
				return dojo.hasAttr(elem, "href");
			case "area":
			case "button":
			case "input":
			case "object":
			case "select":
			case "textarea":
				// These are navigable by default
				return true;
			case "iframe":
				// If it's an editor <iframe> then it's tab navigable.
				if(dojo.isMoz){
					return elem.contentDocument.designMode == "on";
				}else if(dojo.isWebKit){
					var doc = elem.contentDocument,
						body = doc && doc.body;
					return body && body.contentEditable == 'true';
				}else{
					// contentWindow.document isn't accessible within IE7/8
					// if the iframe.src points to a foreign url and this
					// page contains an element, that could get focus
					try{
						doc = elem.contentWindow.document;
						body = doc && doc.body;
						return body && body.firstChild && body.firstChild.contentEditable == 'true';
					}catch(e){
						return false;
					}
				}
			default:
				return elem.contentEditable == 'true';
		}
	}
};

dijit._getTabNavigable = function(/*DOMNode*/root){
	// summary:
	//		Finds descendants of the specified root node.
	//
	// description:
	//		Finds the following descendants of the specified root node:
	//		* the first tab-navigable element in document order
	//		  without a tabIndex or with tabIndex="0"
	//		* the last tab-navigable element in document order
	//		  without a tabIndex or with tabIndex="0"
	//		* the first element in document order with the lowest
	//		  positive tabIndex value
	//		* the last element in document order with the highest
	//		  positive tabIndex value
	var first, last, lowest, lowestTabindex, highest, highestTabindex;
	var walkTree = function(/*DOMNode*/parent){
		dojo.query("> *", parent).forEach(function(child){
			var isShown = dijit._isElementShown(child);
			if(isShown && dijit.isTabNavigable(child)){
				var tabindex = dojo.attr(child, "tabIndex");
				if(!dojo.hasAttr(child, "tabIndex") || tabindex == 0){
					if(!first){ first = child; }
					last = child;
				}else if(tabindex > 0){
					if(!lowest || tabindex < lowestTabindex){
						lowestTabindex = tabindex;
						lowest = child;
					}
					if(!highest || tabindex >= highestTabindex){
						highestTabindex = tabindex;
						highest = child;
					}
				}
			}
			if(isShown && child.nodeName.toUpperCase() != 'SELECT'){ walkTree(child) }
		});
	};
	if(dijit._isElementShown(root)){ walkTree(root) }
	return { first: first, last: last, lowest: lowest, highest: highest };
}
dijit.getFirstInTabbingOrder = function(/*String|DOMNode*/root){
	// summary:
	//		Finds the descendant of the specified root node
	//		that is first in the tabbing order
	var elems = dijit._getTabNavigable(dojo.byId(root));
	return elems.lowest ? elems.lowest : elems.first; // DomNode
};

dijit.getLastInTabbingOrder = function(/*String|DOMNode*/root){
	// summary:
	//		Finds the descendant of the specified root node
	//		that is last in the tabbing order
	var elems = dijit._getTabNavigable(dojo.byId(root));
	return elems.last ? elems.last : elems.highest; // DomNode
};

/*=====
dojo.mixin(dijit, {
	// defaultDuration: Integer
	//		The default animation speed (in ms) to use for all Dijit
	//		transitional animations, unless otherwise specified
	//		on a per-instance basis. Defaults to 200, overrided by
	//		`djConfig.defaultDuration`
	defaultDuration: 300
});
=====*/

dijit.defaultDuration = dojo.config["defaultDuration"] || 200;

}

if(!dojo._hasResource["dijit._base.focus"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.focus"] = true;
dojo.provide("dijit._base.focus");

	// for dijit.isTabNavigable()

// summary:
//		These functions are used to query or set the focus and selection.
//
//		Also, they trace when widgets become activated/deactivated,
//		so that the widget can fire _onFocus/_onBlur events.
//		"Active" here means something similar to "focused", but
//		"focus" isn't quite the right word because we keep track of
//		a whole stack of "active" widgets.  Example: ComboButton --> Menu -->
//		MenuItem.  The onBlur event for ComboButton doesn't fire due to focusing
//		on the Menu or a MenuItem, since they are considered part of the
//		ComboButton widget.  It only happens when focus is shifted
//		somewhere completely different.

dojo.mixin(dijit, {
	// _curFocus: DomNode
	//		Currently focused item on screen
	_curFocus: null,

	// _prevFocus: DomNode
	//		Previously focused item on screen
	_prevFocus: null,

	isCollapsed: function(){
		// summary:
		//		Returns true if there is no text selected
		return dijit.getBookmark().isCollapsed;
	},

	getBookmark: function(){
		// summary:
		//		Retrieves a bookmark that can be used with moveToBookmark to return to the same range
		var bm, rg, tg, sel = dojo.doc.selection, cf = dijit._curFocus;

		if(dojo.global.getSelection){
			//W3C Range API for selections.
			sel = dojo.global.getSelection();
			if(sel){
				if(sel.isCollapsed){
					tg = cf? cf.tagName : "";
					if(tg){
						//Create a fake rangelike item to restore selections.
						tg = tg.toLowerCase();
						if(tg == "textarea" ||
								(tg == "input" && (!cf.type || cf.type.toLowerCase() == "text"))){
							sel = {
								start: cf.selectionStart,
								end: cf.selectionEnd,
								node: cf,
								pRange: true
							};
							return {isCollapsed: (sel.end <= sel.start), mark: sel}; //Object.
						}
					}
					bm = {isCollapsed:true};
				}else{
					rg = sel.getRangeAt(0);
					bm = {isCollapsed: false, mark: rg.cloneRange()};
				}
			}
		}else if(sel){
			// If the current focus was a input of some sort and no selection, don't bother saving
			// a native bookmark.  This is because it causes issues with dialog/page selection restore.
			// So, we need to create psuedo bookmarks to work with.
			tg = cf ? cf.tagName : "";
			tg = tg.toLowerCase();
			if(cf && tg && (tg == "button" || tg == "textarea" || tg == "input")){
				if(sel.type && sel.type.toLowerCase() == "none"){
					return {
						isCollapsed: true,
						mark: null
					}
				}else{
					rg = sel.createRange();
					return {
						isCollapsed: rg.text && rg.text.length?false:true,
						mark: {
							range: rg,
							pRange: true
						}
					};
				}
			}
			bm = {};

			//'IE' way for selections.
			try{
				// createRange() throws exception when dojo in iframe
				//and nothing selected, see #9632
				rg = sel.createRange();
				bm.isCollapsed = !(sel.type == 'Text' ? rg.htmlText.length : rg.length);
			}catch(e){
				bm.isCollapsed = true;
				return bm;
			}
			if(sel.type.toUpperCase() == 'CONTROL'){
				if(rg.length){
					bm.mark=[];
					var i=0,len=rg.length;
					while(i<len){
						bm.mark.push(rg.item(i++));
					}
				}else{
					bm.isCollapsed = true;
					bm.mark = null;
				}
			}else{
				bm.mark = rg.getBookmark();
			}
		}else{
			console.warn("No idea how to store the current selection for this browser!");
		}
		return bm; // Object
	},

	moveToBookmark: function(/*Object*/bookmark){
		// summary:
		//		Moves current selection to a bookmark
		// bookmark:
		//		This should be a returned object from dijit.getBookmark()

		var _doc = dojo.doc,
			mark = bookmark.mark;
		if(mark){
			if(dojo.global.getSelection){
				//W3C Rangi API (FF, WebKit, Opera, etc)
				var sel = dojo.global.getSelection();
				if(sel && sel.removeAllRanges){
					if(mark.pRange){
						var r = mark;
						var n = r.node;
						n.selectionStart = r.start;
						n.selectionEnd = r.end;
					}else{
						sel.removeAllRanges();
						sel.addRange(mark);
					}
				}else{
					console.warn("No idea how to restore selection for this browser!");
				}
			}else if(_doc.selection && mark){
				//'IE' way.
				var rg;
				if(mark.pRange){
					rg = mark.range;
				}else if(dojo.isArray(mark)){
					rg = _doc.body.createControlRange();
					//rg.addElement does not have call/apply method, so can not call it directly
					//rg is not available in "range.addElement(item)", so can't use that either
					dojo.forEach(mark, function(n){
						rg.addElement(n);
					});
				}else{
					rg = _doc.body.createTextRange();
					rg.moveToBookmark(mark);
				}
				rg.select();
			}
		}
	},

	getFocus: function(/*Widget?*/ menu, /*Window?*/ openedForWindow){
		// summary:
		//		Called as getFocus(), this returns an Object showing the current focus
		//		and selected text.
		//
		//		Called as getFocus(widget), where widget is a (widget representing) a button
		//		that was just pressed, it returns where focus was before that button
		//		was pressed.   (Pressing the button may have either shifted focus to the button,
		//		or removed focus altogether.)   In this case the selected text is not returned,
		//		since it can't be accurately determined.
		//
		// menu: dijit._Widget or {domNode: DomNode} structure
		//		The button that was just pressed.  If focus has disappeared or moved
		//		to this button, returns the previous focus.  In this case the bookmark
		//		information is already lost, and null is returned.
		//
		// openedForWindow:
		//		iframe in which menu was opened
		//
		// returns:
		//		A handle to restore focus/selection, to be passed to `dijit.focus`
		var node = !dijit._curFocus || (menu && dojo.isDescendant(dijit._curFocus, menu.domNode)) ? dijit._prevFocus : dijit._curFocus;
		return {
			node: node,
			bookmark: (node == dijit._curFocus) && dojo.withGlobal(openedForWindow || dojo.global, dijit.getBookmark),
			openedForWindow: openedForWindow
		}; // Object
	},

	focus: function(/*Object || DomNode */ handle){
		// summary:
		//		Sets the focused node and the selection according to argument.
		//		To set focus to an iframe's content, pass in the iframe itself.
		// handle:
		//		object returned by get(), or a DomNode

		if(!handle){ return; }

		var node = "node" in handle ? handle.node : handle,		// because handle is either DomNode or a composite object
			bookmark = handle.bookmark,
			openedForWindow = handle.openedForWindow,
			collapsed = bookmark ? bookmark.isCollapsed : false;

		// Set the focus
		// Note that for iframe's we need to use the <iframe> to follow the parentNode chain,
		// but we need to set focus to iframe.contentWindow
		if(node){
			var focusNode = (node.tagName.toLowerCase() == "iframe") ? node.contentWindow : node;
			if(focusNode && focusNode.focus){
				try{
					// Gecko throws sometimes if setting focus is impossible,
					// node not displayed or something like that
					focusNode.focus();
				}catch(e){/*quiet*/}
			}
			dijit._onFocusNode(node);
		}

		// set the selection
		// do not need to restore if current selection is not empty
		// (use keyboard to select a menu item) or if previous selection was collapsed
		// as it may cause focus shift (Esp in IE).
		if(bookmark && dojo.withGlobal(openedForWindow || dojo.global, dijit.isCollapsed) && !collapsed){
			if(openedForWindow){
				openedForWindow.focus();
			}
			try{
				dojo.withGlobal(openedForWindow || dojo.global, dijit.moveToBookmark, null, [bookmark]);
			}catch(e2){
				/*squelch IE internal error, see http://trac.dojotoolkit.org/ticket/1984 */
			}
		}
	},

	// _activeStack: dijit._Widget[]
	//		List of currently active widgets (focused widget and it's ancestors)
	_activeStack: [],

	registerIframe: function(/*DomNode*/ iframe){
		// summary:
		//		Registers listeners on the specified iframe so that any click
		//		or focus event on that iframe (or anything in it) is reported
		//		as a focus/click event on the <iframe> itself.
		// description:
		//		Currently only used by editor.
		// returns:
		//		Handle to pass to unregisterIframe()
		return dijit.registerWin(iframe.contentWindow, iframe);
	},

	unregisterIframe: function(/*Object*/ handle){
		// summary:
		//		Unregisters listeners on the specified iframe created by registerIframe.
		//		After calling be sure to delete or null out the handle itself.
		// handle:
		//		Handle returned by registerIframe()

		dijit.unregisterWin(handle);
	},

	registerWin: function(/*Window?*/targetWindow, /*DomNode?*/ effectiveNode){
		// summary:
		//		Registers listeners on the specified window (either the main
		//		window or an iframe's window) to detect when the user has clicked somewhere
		//		or focused somewhere.
		// description:
		//		Users should call registerIframe() instead of this method.
		// targetWindow:
		//		If specified this is the window associated with the iframe,
		//		i.e. iframe.contentWindow.
		// effectiveNode:
		//		If specified, report any focus events inside targetWindow as
		//		an event on effectiveNode, rather than on evt.target.
		// returns:
		//		Handle to pass to unregisterWin()

		// TODO: make this function private in 2.0; Editor/users should call registerIframe(),

		var mousedownListener = function(evt){
			dijit._justMouseDowned = true;
			setTimeout(function(){ dijit._justMouseDowned = false; }, 0);
			dijit._onTouchNode(effectiveNode || evt.target || evt.srcElement, "mouse");
		};
		//dojo.connect(targetWindow, "onscroll", ???);

		// Listen for blur and focus events on targetWindow's document.
		// IIRC, I'm using attachEvent() rather than dojo.connect() because focus/blur events don't bubble
		// through dojo.connect(), and also maybe to catch the focus events early, before onfocus handlers
		// fire.
		// Connect to <html> (rather than document) on IE to avoid memory leaks, but document on other browsers because
		// (at least for FF) the focus event doesn't fire on <html> or <body>.
		var doc = dojo.isIE ? targetWindow.document.documentElement : targetWindow.document;
		if(doc){
			if(dojo.isIE){
				doc.attachEvent('onmousedown', mousedownListener);
				var activateListener = function(evt){
					// IE reports that nodes like <body> have gotten focus, even though they have tabIndex=-1,
					// Should consider those more like a mouse-click than a focus....
					if(evt.srcElement.tagName.toLowerCase() != "#document" &&
						dijit.isTabNavigable(evt.srcElement)){
						dijit._onFocusNode(effectiveNode || evt.srcElement);
					}else{
						dijit._onTouchNode(effectiveNode || evt.srcElement);
					}
				};
				doc.attachEvent('onactivate', activateListener);
				var deactivateListener =  function(evt){
					dijit._onBlurNode(effectiveNode || evt.srcElement);
				};
				doc.attachEvent('ondeactivate', deactivateListener);

				return function(){
					doc.detachEvent('onmousedown', mousedownListener);
					doc.detachEvent('onactivate', activateListener);
					doc.detachEvent('ondeactivate', deactivateListener);
					doc = null;	// prevent memory leak (apparent circular reference via closure)
				};
			}else{
				doc.addEventListener('mousedown', mousedownListener, true);
				var focusListener = function(evt){
					dijit._onFocusNode(effectiveNode || evt.target);
				};
				doc.addEventListener('focus', focusListener, true);
				var blurListener = function(evt){
					dijit._onBlurNode(effectiveNode || evt.target);
				};
				doc.addEventListener('blur', blurListener, true);

				return function(){
					doc.removeEventListener('mousedown', mousedownListener, true);
					doc.removeEventListener('focus', focusListener, true);
					doc.removeEventListener('blur', blurListener, true);
					doc = null;	// prevent memory leak (apparent circular reference via closure)
				};
			}
		}
	},

	unregisterWin: function(/*Handle*/ handle){
		// summary:
		//		Unregisters listeners on the specified window (either the main
		//		window or an iframe's window) according to handle returned from registerWin().
		//		After calling be sure to delete or null out the handle itself.

		// Currently our handle is actually a function
		handle && handle();
	},

	_onBlurNode: function(/*DomNode*/ node){
		// summary:
		// 		Called when focus leaves a node.
		//		Usually ignored, _unless_ it *isn't* follwed by touching another node,
		//		which indicates that we tabbed off the last field on the page,
		//		in which case every widget is marked inactive
		dijit._prevFocus = dijit._curFocus;
		dijit._curFocus = null;

		if(dijit._justMouseDowned){
			// the mouse down caused a new widget to be marked as active; this blur event
			// is coming late, so ignore it.
			return;
		}

		// if the blur event isn't followed by a focus event then mark all widgets as inactive.
		if(dijit._clearActiveWidgetsTimer){
			clearTimeout(dijit._clearActiveWidgetsTimer);
		}
		dijit._clearActiveWidgetsTimer = setTimeout(function(){
			delete dijit._clearActiveWidgetsTimer;
			dijit._setStack([]);
			dijit._prevFocus = null;
		}, 100);
	},

	_onTouchNode: function(/*DomNode*/ node, /*String*/ by){
		// summary:
		//		Callback when node is focused or mouse-downed
		// node:
		//		The node that was touched.
		// by:
		//		"mouse" if the focus/touch was caused by a mouse down event

		// ignore the recent blurNode event
		if(dijit._clearActiveWidgetsTimer){
			clearTimeout(dijit._clearActiveWidgetsTimer);
			delete dijit._clearActiveWidgetsTimer;
		}

		// compute stack of active widgets (ex: ComboButton --> Menu --> MenuItem)
		var newStack=[];
		try{
			while(node){
				var popupParent = dojo.attr(node, "dijitPopupParent");
				if(popupParent){
					node=dijit.byId(popupParent).domNode;
				}else if(node.tagName && node.tagName.toLowerCase() == "body"){
					// is this the root of the document or just the root of an iframe?
					if(node === dojo.body()){
						// node is the root of the main document
						break;
					}
					// otherwise, find the iframe this node refers to (can't access it via parentNode,
					// need to do this trick instead). window.frameElement is supported in IE/FF/Webkit
					node=dijit.getDocumentWindow(node.ownerDocument).frameElement;
				}else{
					var id = node.getAttribute && node.getAttribute("widgetId");
					if(id){
						newStack.unshift(id);
					}
					node=node.parentNode;
				}
			}
		}catch(e){ /* squelch */ }

		dijit._setStack(newStack, by);
	},

	_onFocusNode: function(/*DomNode*/ node){
		// summary:
		//		Callback when node is focused

		if(!node){
			return;
		}

		if(node.nodeType == 9){
			// Ignore focus events on the document itself.  This is here so that
			// (for example) clicking the up/down arrows of a spinner
			// (which don't get focus) won't cause that widget to blur. (FF issue)
			return;
		}

		dijit._onTouchNode(node);

		if(node == dijit._curFocus){ return; }
		if(dijit._curFocus){
			dijit._prevFocus = dijit._curFocus;
		}
		dijit._curFocus = node;
		dojo.publish("focusNode", [node]);
	},

	_setStack: function(/*String[]*/ newStack, /*String*/ by){
		// summary:
		//		The stack of active widgets has changed.  Send out appropriate events and records new stack.
		// newStack:
		//		array of widget id's, starting from the top (outermost) widget
		// by:
		//		"mouse" if the focus/touch was caused by a mouse down event

		var oldStack = dijit._activeStack;
		dijit._activeStack = newStack;

		// compare old stack to new stack to see how many elements they have in common
		for(var nCommon=0; nCommon<Math.min(oldStack.length, newStack.length); nCommon++){
			if(oldStack[nCommon] != newStack[nCommon]){
				break;
			}
		}

		var widget;
		// for all elements that have gone out of focus, send blur event
		for(var i=oldStack.length-1; i>=nCommon; i--){
			widget = dijit.byId(oldStack[i]);
			if(widget){
				widget._focused = false;
				widget._hasBeenBlurred = true;
				if(widget._onBlur){
					widget._onBlur(by);
				}
				if(widget._setStateClass){
					widget._setStateClass();
				}
				dojo.publish("widgetBlur", [widget, by]);
			}
		}

		// for all element that have come into focus, send focus event
		for(i=nCommon; i<newStack.length; i++){
			widget = dijit.byId(newStack[i]);
			if(widget){
				widget._focused = true;
				if(widget._onFocus){
					widget._onFocus(by);
				}
				if(widget._setStateClass){
					widget._setStateClass();
				}
				dojo.publish("widgetFocus", [widget, by]);
			}
		}
	}
});

// register top window and all the iframes it contains
dojo.addOnLoad(function(){
	var handle = dijit.registerWin(window);
	if(dojo.isIE){
		dojo.addOnWindowUnload(function(){
			dijit.unregisterWin(handle);
			handle = null;
		})
	}
});

}

if(!dojo._hasResource["dojo.AdapterRegistry"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.AdapterRegistry"] = true;
dojo.provide("dojo.AdapterRegistry");

dojo.AdapterRegistry = function(/*Boolean?*/ returnWrappers){
	//	summary:
	//		A registry to make contextual calling/searching easier.
	//	description:
	//		Objects of this class keep list of arrays in the form [name, check,
	//		wrap, directReturn] that are used to determine what the contextual
	//		result of a set of checked arguments is. All check/wrap functions
	//		in this registry should be of the same arity.
	//	example:
	//	|	// create a new registry
	//	|	var reg = new dojo.AdapterRegistry();
	//	|	reg.register("handleString",
	//	|		dojo.isString,
	//	|		function(str){
	//	|			// do something with the string here
	//	|		}
	//	|	);
	//	|	reg.register("handleArr",
	//	|		dojo.isArray,
	//	|		function(arr){
	//	|			// do something with the array here
	//	|		}
	//	|	);
	//	|
	//	|	// now we can pass reg.match() *either* an array or a string and
	//	|	// the value we pass will get handled by the right function
	//	|	reg.match("someValue"); // will call the first function
	//	|	reg.match(["someValue"]); // will call the second

	this.pairs = [];
	this.returnWrappers = returnWrappers || false; // Boolean
}

dojo.extend(dojo.AdapterRegistry, {
	register: function(/*String*/ name, /*Function*/ check, /*Function*/ wrap, /*Boolean?*/ directReturn, /*Boolean?*/ override){
		//	summary: 
		//		register a check function to determine if the wrap function or
		//		object gets selected
		//	name:
		//		a way to identify this matcher.
		//	check:
		//		a function that arguments are passed to from the adapter's
		//		match() function.  The check function should return true if the
		//		given arguments are appropriate for the wrap function.
		//	directReturn:
		//		If directReturn is true, the value passed in for wrap will be
		//		returned instead of being called. Alternately, the
		//		AdapterRegistry can be set globally to "return not call" using
		//		the returnWrappers property. Either way, this behavior allows
		//		the registry to act as a "search" function instead of a
		//		function interception library.
		//	override:
		//		If override is given and true, the check function will be given
		//		highest priority. Otherwise, it will be the lowest priority
		//		adapter.
		this.pairs[((override) ? "unshift" : "push")]([name, check, wrap, directReturn]);
	},

	match: function(/* ... */){
		// summary:
		//		Find an adapter for the given arguments. If no suitable adapter
		//		is found, throws an exception. match() accepts any number of
		//		arguments, all of which are passed to all matching functions
		//		from the registered pairs.
		for(var i = 0; i < this.pairs.length; i++){
			var pair = this.pairs[i];
			if(pair[1].apply(this, arguments)){
				if((pair[3])||(this.returnWrappers)){
					return pair[2];
				}else{
					return pair[2].apply(this, arguments);
				}
			}
		}
		throw new Error("No match found");
	},

	unregister: function(name){
		// summary: Remove a named adapter from the registry

		// FIXME: this is kind of a dumb way to handle this. On a large
		// registry this will be slow-ish and we can use the name as a lookup
		// should we choose to trade memory for speed.
		for(var i = 0; i < this.pairs.length; i++){
			var pair = this.pairs[i];
			if(pair[0] == name){
				this.pairs.splice(i, 1);
				return true;
			}
		}
		return false;
	}
});

}

if(!dojo._hasResource["dijit._base.place"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.place"] = true;
dojo.provide("dijit._base.place");



// ported from dojo.html.util

dijit.getViewport = function(){
	// summary:
	//		Returns the dimensions and scroll position of the viewable area of a browser window

	var scrollRoot = (dojo.doc.compatMode == 'BackCompat')? dojo.body() : dojo.doc.documentElement;

	// get scroll position
	var scroll = dojo._docScroll(); // scrollRoot.scrollTop/Left should work
	return { w: scrollRoot.clientWidth, h: scrollRoot.clientHeight, l: scroll.x, t: scroll.y };
};

/*=====
dijit.__Position = function(){
	// x: Integer
	//		horizontal coordinate in pixels, relative to document body
	// y: Integer
	//		vertical coordinate in pixels, relative to document body

	thix.x = x;
	this.y = y;
}
=====*/


dijit.placeOnScreen = function(
	/* DomNode */			node,
	/* dijit.__Position */	pos,
	/* String[] */			corners,
	/* dijit.__Position? */	padding){
	// summary:
	//		Positions one of the node's corners at specified position
	//		such that node is fully visible in viewport.
	// description:
	//		NOTE: node is assumed to be absolutely or relatively positioned.
	//	pos:
	//		Object like {x: 10, y: 20}
	//	corners:
	//		Array of Strings representing order to try corners in, like ["TR", "BL"].
	//		Possible values are:
	//			* "BL" - bottom left
	//			* "BR" - bottom right
	//			* "TL" - top left
	//			* "TR" - top right
	//	padding:
	//		set padding to put some buffer around the element you want to position.
	// example:
	//		Try to place node's top right corner at (10,20).
	//		If that makes node go (partially) off screen, then try placing
	//		bottom left corner at (10,20).
	//	|	placeOnScreen(node, {x: 10, y: 20}, ["TR", "BL"])

	var choices = dojo.map(corners, function(corner){
		var c = { corner: corner, pos: {x:pos.x,y:pos.y} };
		if(padding){
			c.pos.x += corner.charAt(1) == 'L' ? padding.x : -padding.x;
			c.pos.y += corner.charAt(0) == 'T' ? padding.y : -padding.y;
		}
		return c;
	});

	return dijit._place(node, choices);
}

dijit._place = function(/*DomNode*/ node, /* Array */ choices, /* Function */ layoutNode){
	// summary:
	//		Given a list of spots to put node, put it at the first spot where it fits,
	//		of if it doesn't fit anywhere then the place with the least overflow
	// choices: Array
	//		Array of elements like: {corner: 'TL', pos: {x: 10, y: 20} }
	//		Above example says to put the top-left corner of the node at (10,20)
	// layoutNode: Function(node, aroundNodeCorner, nodeCorner)
	//		for things like tooltip, they are displayed differently (and have different dimensions)
	//		based on their orientation relative to the parent.   This adjusts the popup based on orientation.

	// get {x: 10, y: 10, w: 100, h:100} type obj representing position of
	// viewport over document
	var view = dijit.getViewport();

	// This won't work if the node is inside a <div style="position: relative">,
	// so reattach it to dojo.doc.body.   (Otherwise, the positioning will be wrong
	// and also it might get cutoff)
	if(!node.parentNode || String(node.parentNode.tagName).toLowerCase() != "body"){
		dojo.body().appendChild(node);
	}

	var best = null;
	dojo.some(choices, function(choice){
		var corner = choice.corner;
		var pos = choice.pos;

		// configure node to be displayed in given position relative to button
		// (need to do this in order to get an accurate size for the node, because
		// a tooltips size changes based on position, due to triangle)
		if(layoutNode){
			layoutNode(node, choice.aroundCorner, corner);
		}

		// get node's size
		var style = node.style;
		var oldDisplay = style.display;
		var oldVis = style.visibility;
		style.visibility = "hidden";
		style.display = "";
		var mb = dojo.marginBox(node);
		style.display = oldDisplay;
		style.visibility = oldVis;

		// coordinates and size of node with specified corner placed at pos,
		// and clipped by viewport
		var startX = Math.max(view.l, corner.charAt(1) == 'L' ? pos.x : (pos.x - mb.w)),
			startY = Math.max(view.t, corner.charAt(0) == 'T' ? pos.y : (pos.y - mb.h)),
			endX = Math.min(view.l + view.w, corner.charAt(1) == 'L' ? (startX + mb.w) : pos.x),
			endY = Math.min(view.t + view.h, corner.charAt(0) == 'T' ? (startY + mb.h) : pos.y),
			width = endX - startX,
			height = endY - startY,
			overflow = (mb.w - width) + (mb.h - height);

		if(best == null || overflow < best.overflow){
			best = {
				corner: corner,
				aroundCorner: choice.aroundCorner,
				x: startX,
				y: startY,
				w: width,
				h: height,
				overflow: overflow
			};
		}
		return !overflow;
	});

	node.style.left = best.x + "px";
	node.style.top = best.y + "px";
	if(best.overflow && layoutNode){
		layoutNode(node, best.aroundCorner, best.corner);
	}
	return best;
}

dijit.placeOnScreenAroundNode = function(
	/* DomNode */		node,
	/* DomNode */		aroundNode,
	/* Object */		aroundCorners,
	/* Function? */		layoutNode){

	// summary:
	//		Position node adjacent or kitty-corner to aroundNode
	//		such that it's fully visible in viewport.
	//
	// description:
	//		Place node such that corner of node touches a corner of
	//		aroundNode, and that node is fully visible.
	//
	// aroundCorners:
	//		Ordered list of pairs of corners to try matching up.
	//		Each pair of corners is represented as a key/value in the hash,
	//		where the key corresponds to the aroundNode's corner, and
	//		the value corresponds to the node's corner:
	//
	//	|	{ aroundNodeCorner1: nodeCorner1, aroundNodeCorner2: nodeCorner2, ...}
	//
	//		The following strings are used to represent the four corners:
	//			* "BL" - bottom left
	//			* "BR" - bottom right
	//			* "TL" - top left
	//			* "TR" - top right
	//
	// layoutNode: Function(node, aroundNodeCorner, nodeCorner)
	//		For things like tooltip, they are displayed differently (and have different dimensions)
	//		based on their orientation relative to the parent.   This adjusts the popup based on orientation.
	//
	// example:
	//	|	dijit.placeOnScreenAroundNode(node, aroundNode, {'BL':'TL', 'TR':'BR'});
	//		This will try to position node such that node's top-left corner is at the same position
	//		as the bottom left corner of the aroundNode (ie, put node below
	//		aroundNode, with left edges aligned).  If that fails it will try to put
	// 		the bottom-right corner of node where the top right corner of aroundNode is
	//		(ie, put node above aroundNode, with right edges aligned)
	//

	// get coordinates of aroundNode
	aroundNode = dojo.byId(aroundNode);
	var oldDisplay = aroundNode.style.display;
	aroundNode.style.display="";
	// #3172: use the slightly tighter border box instead of marginBox
	var aroundNodePos = dojo.position(aroundNode, true);
	aroundNode.style.display=oldDisplay;

	// place the node around the calculated rectangle
	return dijit._placeOnScreenAroundRect(node,
		aroundNodePos.x, aroundNodePos.y, aroundNodePos.w, aroundNodePos.h,	// rectangle
		aroundCorners, layoutNode);
};

/*=====
dijit.__Rectangle = function(){
	// x: Integer
	//		horizontal offset in pixels, relative to document body
	// y: Integer
	//		vertical offset in pixels, relative to document body
	// width: Integer
	//		width in pixels
	// height: Integer
	//		height in pixels

	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
}
=====*/


dijit.placeOnScreenAroundRectangle = function(
	/* DomNode */			node,
	/* dijit.__Rectangle */	aroundRect,
	/* Object */			aroundCorners,
	/* Function */			layoutNode){

	// summary:
	//		Like dijit.placeOnScreenAroundNode(), except that the "around"
	//		parameter is an arbitrary rectangle on the screen (x, y, width, height)
	//		instead of a dom node.

	return dijit._placeOnScreenAroundRect(node,
		aroundRect.x, aroundRect.y, aroundRect.width, aroundRect.height,	// rectangle
		aroundCorners, layoutNode);
};

dijit._placeOnScreenAroundRect = function(
	/* DomNode */		node,
	/* Number */		x,
	/* Number */		y,
	/* Number */		width,
	/* Number */		height,
	/* Object */		aroundCorners,
	/* Function */		layoutNode){

	// summary:
	//		Like dijit.placeOnScreenAroundNode(), except it accepts coordinates
	//		of a rectangle to place node adjacent to.

	// TODO: combine with placeOnScreenAroundRectangle()

	// Generate list of possible positions for node
	var choices = [];
	for(var nodeCorner in aroundCorners){
		choices.push( {
			aroundCorner: nodeCorner,
			corner: aroundCorners[nodeCorner],
			pos: {
				x: x + (nodeCorner.charAt(1) == 'L' ? 0 : width),
				y: y + (nodeCorner.charAt(0) == 'T' ? 0 : height)
			}
		});
	}

	return dijit._place(node, choices, layoutNode);
};

dijit.placementRegistry= new dojo.AdapterRegistry();
dijit.placementRegistry.register("node",
	function(n, x){
		return typeof x == "object" &&
			typeof x.offsetWidth != "undefined" && typeof x.offsetHeight != "undefined";
	},
	dijit.placeOnScreenAroundNode);
dijit.placementRegistry.register("rect",
	function(n, x){
		return typeof x == "object" &&
			"x" in x && "y" in x && "width" in x && "height" in x;
	},
	dijit.placeOnScreenAroundRectangle);

dijit.placeOnScreenAroundElement = function(
	/* DomNode */		node,
	/* Object */		aroundElement,
	/* Object */		aroundCorners,
	/* Function */		layoutNode){

	// summary:
	//		Like dijit.placeOnScreenAroundNode(), except it accepts an arbitrary object
	//		for the "around" argument and finds a proper processor to place a node.

	return dijit.placementRegistry.match.apply(dijit.placementRegistry, arguments);
};

dijit.getPopupAlignment = function(/*Array*/ position, /*Boolean*/ leftToRight){
	// summary:
	//		Transforms the passed array of preferred positions into a format suitable for passing as the aroundCorners argument to dijit.placeOnScreenAroundElement.
	//
	// position: String[]
	//		This variable controls the position of the drop down.
	//		It's an array of strings with the following values:
	//
	//			* before: places drop down to the left of the target node/widget, or to the right in
	//			  the case of RTL scripts like Hebrew and Arabic
	//			* after: places drop down to the right of the target node/widget, or to the left in
	//			  the case of RTL scripts like Hebrew and Arabic
	//			* above: drop down goes above target node
	//			* below: drop down goes below target node
	//
	//		The list is positions is tried, in order, until a position is found where the drop down fits
	//		within the viewport.
	//
	// leftToRight: Boolean
	//		Whether the popup will be displaying in leftToRight mode.
	//
	var align = {};
	dojo.forEach(position, function(pos){
		switch(pos){
			case "after":
				align[leftToRight ? "BR" : "BL"] = leftToRight ? "BL" : "BR";
				break;
			case "before":
				align[leftToRight ? "BL" : "BR"] = leftToRight ? "BR" : "BL";
				break;
			case "below":
				// first try to align left borders, next try to align right borders (or reverse for RTL mode)
				align[leftToRight ? "BL" : "BR"] = leftToRight ? "TL" : "TR";
				align[leftToRight ? "BR" : "BL"] = leftToRight ? "TR" : "TL";
				break;
			case "above":
			default:
				// first try to align left borders, next try to align right borders (or reverse for RTL mode)
				align[leftToRight ? "TL" : "TR"] = leftToRight ? "BL" : "BR";
				align[leftToRight ? "TR" : "TL"] = leftToRight ? "BR" : "BL";
				break;
		}
	});
	return align;
};
dijit.getPopupAroundAlignment = function(/*Array*/ position, /*Boolean*/ leftToRight){
	// summary:
	//		Transforms the passed array of preferred positions into a format suitable for passing as the aroundCorners argument to dijit.placeOnScreenAroundElement.
	//
	// position: String[]
	//		This variable controls the position of the drop down.
	//		It's an array of strings with the following values:
	//
	//			* before: places drop down to the left of the target node/widget, or to the right in
	//			  the case of RTL scripts like Hebrew and Arabic
	//			* after: places drop down to the right of the target node/widget, or to the left in
	//			  the case of RTL scripts like Hebrew and Arabic
	//			* above: drop down goes above target node
	//			* below: drop down goes below target node
	//
	//		The list is positions is tried, in order, until a position is found where the drop down fits
	//		within the viewport.
	//
	// leftToRight: Boolean
	//		Whether the popup will be displaying in leftToRight mode.
	//
	var align = {};
	dojo.forEach(position, function(pos){
		switch(pos){
			case "after":
				align[leftToRight ? "BR" : "BL"] = leftToRight ? "BL" : "BR";
				break;
			case "before":
				align[leftToRight ? "BL" : "BR"] = leftToRight ? "BR" : "BL";
				break;
			case "below":
				// first try to align left borders, next try to align right borders (or reverse for RTL mode)
				align[leftToRight ? "BL" : "BR"] = leftToRight ? "TL" : "TR";
				align[leftToRight ? "BR" : "BL"] = leftToRight ? "TR" : "TL";
				break;
			case "above":
			default:
				// first try to align left borders, next try to align right borders (or reverse for RTL mode)
				align[leftToRight ? "TL" : "TR"] = leftToRight ? "BL" : "BR";
				align[leftToRight ? "TR" : "TL"] = leftToRight ? "BR" : "BL";
				break;
		}
	});
	return align;
};

}

if(!dojo._hasResource["dijit._base.window"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.window"] = true;
dojo.provide("dijit._base.window");

// TODO: remove this in 2.0, it's not used anymore, or at least not internally

dijit.getDocumentWindow = function(doc){
	// summary:
	// 		Get window object associated with document doc

	// In some IE versions (at least 6.0), document.parentWindow does not return a
	// reference to the real window object (maybe a copy), so we must fix it as well
	// We use IE specific execScript to attach the real window reference to
	// document._parentWindow for later use
	if(dojo.isIE && window !== document.parentWindow && !doc._parentWindow){
		/*
		In IE 6, only the variable "window" can be used to connect events (others
		may be only copies).
		*/
		doc.parentWindow.execScript("document._parentWindow = window;", "Javascript");
		//to prevent memory leak, unset it after use
		//another possibility is to add an onUnload handler which seems overkill to me (liucougar)
		var win = doc._parentWindow;
		doc._parentWindow = null;
		return win;	//	Window
	}

	return doc._parentWindow || doc.parentWindow || doc.defaultView;	//	Window
}

}

if(!dojo._hasResource["dijit._base.popup"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.popup"] = true;
dojo.provide("dijit._base.popup");





dijit.popup = new function(){
	// summary:
	//		This class is used to show/hide widgets as popups.

	var stack = [],
		beginZIndex=1000,
		idGen = 1;

	this.moveOffScreen = function(/*DomNode*/ node){
		// summary:
		//		Moves node offscreen without hiding it (so that all layout widgets included 
		//		in this node can still layout properly)
		//
		// description:
		//		Attaches node to dojo.doc.body, and
		//		positions it off screen, but not display:none, so that
		//		the widget doesn't appear in the page flow and/or cause a blank
		//		area at the bottom of the viewport (making scrollbar longer), but
		//		initialization of contained widgets works correctly

		var s = node.style;
		s.visibility = "hidden";	// so TAB key doesn't navigate to hidden popup
		s.position = "absolute";
		s.top = "-9999px";
		if(s.display == "none"){
			s.display="";
		}
		dojo.body().appendChild(node);
	};

/*=====
dijit.popup.__OpenArgs = function(){
	// popup: Widget
	//		widget to display
	// parent: Widget
	//		the button etc. that is displaying this popup
	// around: DomNode
	//		DOM node (typically a button); place popup relative to this node.  (Specify this *or* "x" and "y" parameters.)
	// x: Integer
	//		Absolute horizontal position (in pixels) to place node at.  (Specify this *or* "around" parameter.)
	// y: Integer
	//		Absolute vertical position (in pixels) to place node at.  (Specity this *or* "around" parameter.)
	// orient: Object || String
	//		When the around parameter is specified, orient should be an
	//		ordered list of tuples of the form (around-node-corner, popup-node-corner).
	//		dijit.popup.open() tries to position the popup according to each tuple in the list, in order,
	//		until the popup appears fully within the viewport.
	//
	//		The default value is {BL:'TL', TL:'BL'}, which represents a list of two tuples:
	//			1. (BL, TL)
	//			2. (TL, BL)
	//		where BL means "bottom left" and "TL" means "top left".
	//		So by default, it first tries putting the popup below the around node, left-aligning them,
	//		and then tries to put it above the around node, still left-aligning them.   Note that the
	//		default is horizontally reversed when in RTL mode.
	//
	//		When an (x,y) position is specified rather than an around node, orient is either
	//		"R" or "L".  R (for right) means that it tries to put the popup to the right of the mouse,
	//		specifically positioning the popup's top-right corner at the mouse position, and if that doesn't
	//		fit in the viewport, then it tries, in order, the bottom-right corner, the top left corner,
	//		and the top-right corner.
	// onCancel: Function
	//		callback when user has canceled the popup by
	//			1. hitting ESC or
	//			2. by using the popup widget's proprietary cancel mechanism (like a cancel button in a dialog);
	//			   i.e. whenever popupWidget.onCancel() is called, args.onCancel is called
	// onClose: Function
	//		callback whenever this popup is closed
	// onExecute: Function
	//		callback when user "executed" on the popup/sub-popup by selecting a menu choice, etc. (top menu only)
	// padding: dijit.__Position
	//		adding a buffer around the opening position. This is only useful when around is not set.
	this.popup = popup;
	this.parent = parent;
	this.around = around;
	this.x = x;
	this.y = y;
	this.orient = orient;
	this.onCancel = onCancel;
	this.onClose = onClose;
	this.onExecute = onExecute;
	this.padding = padding;
}
=====*/

	// Compute the closest ancestor popup that's *not* a child of another popup.
	// Ex: For a TooltipDialog with a button that spawns a tree of menus, find the popup of the button.
	var getTopPopup = function(){
		for(var pi=stack.length-1; pi > 0 && stack[pi].parent === stack[pi-1].widget; pi--){
			/* do nothing, just trying to get right value for pi */
		}
		return stack[pi];
	};

	var wrappers=[];
	this.open = function(/*dijit.popup.__OpenArgs*/ args){
		// summary:
		//		Popup the widget at the specified position
		//
		// example:
		//		opening at the mouse position
		//		|		dijit.popup.open({popup: menuWidget, x: evt.pageX, y: evt.pageY});
		//
		// example:
		//		opening the widget as a dropdown
		//		|		dijit.popup.open({parent: this, popup: menuWidget, around: this.domNode, onClose: function(){...}});
		//
		//		Note that whatever widget called dijit.popup.open() should also listen to its own _onBlur callback
		//		(fired from _base/focus.js) to know that focus has moved somewhere else and thus the popup should be closed.

		var widget = args.popup,
			orient = args.orient || (
				dojo._isBodyLtr() ?
				{'BL':'TL', 'BR':'TR', 'TL':'BL', 'TR':'BR'} :
				{'BR':'TR', 'BL':'TL', 'TR':'BR', 'TL':'BL'}
			),
			around = args.around,
			id = (args.around && args.around.id) ? (args.around.id+"_dropdown") : ("popup_"+idGen++);

		// make wrapper div to hold widget and possibly hold iframe behind it.
		// we can't attach the iframe as a child of the widget.domNode because
		// widget.domNode might be a <table>, <ul>, etc.

		var wrapperobj = wrappers.pop(), wrapper, iframe;
		if(!wrapperobj){
			wrapper = dojo.create("div",{
				"class":"dijitPopup"
			}, dojo.body());
			dijit.setWaiRole(wrapper, "presentation");
		}else{
			// recycled a old wrapper, so that we don't need to reattach the iframe
			// which is slow even if the iframe is empty, see #10167
			wrapper = wrapperobj[0];
			iframe = wrapperobj[1];
		}

		dojo.attr(wrapper,{
			id: id,
			style:{
				zIndex: beginZIndex + stack.length,
				visibility:"hidden",
				// prevent transient scrollbar causing misalign (#5776), and initial flash in upper left (#10111)
				top: "-9999px"
			},
			dijitPopupParent: args.parent ? args.parent.id : ""
		});

		var s = widget.domNode.style;
		s.display = "";
		s.visibility = "";
		s.position = "";
		s.top = "0px";
		wrapper.appendChild(widget.domNode);

		if(!iframe){
			iframe = new dijit.BackgroundIframe(wrapper);
		}else{
			iframe.resize(wrapper)
		}

		// position the wrapper node
		var best = around ?
			dijit.placeOnScreenAroundElement(wrapper, around, orient, widget.orient ? dojo.hitch(widget, "orient") : null) :
			dijit.placeOnScreen(wrapper, args, orient == 'R' ? ['TR','BR','TL','BL'] : ['TL','BL','TR','BR'], args.padding);

		wrapper.style.visibility = "visible";
		// TODO: use effects to fade in wrapper

		var handlers = [];

		// provide default escape and tab key handling
		// (this will work for any widget, not just menu)
		handlers.push(dojo.connect(wrapper, "onkeypress", this, function(evt){
			if(evt.charOrCode == dojo.keys.ESCAPE && args.onCancel){
				dojo.stopEvent(evt);
				args.onCancel();
			}else if(evt.charOrCode === dojo.keys.TAB){
				dojo.stopEvent(evt);
				var topPopup = getTopPopup();
				if(topPopup && topPopup.onCancel){
					topPopup.onCancel();
				}
			}
		}));

		// watch for cancel/execute events on the popup and notify the caller
		// (for a menu, "execute" means clicking an item)
		if(widget.onCancel){
			handlers.push(dojo.connect(widget, "onCancel", args.onCancel));
		}

		handlers.push(dojo.connect(widget, widget.onExecute ? "onExecute" : "onChange", function(){
			var topPopup = getTopPopup();
			if(topPopup && topPopup.onExecute){
				topPopup.onExecute();
			}
		}));

		stack.push({
			wrapper: wrapper,
			iframe: iframe,
			widget: widget,
			parent: args.parent,
			onExecute: args.onExecute,
			onCancel: args.onCancel,
 			onClose: args.onClose,
			handlers: handlers
		});

		if(widget.onOpen){
			// TODO: in 2.0 standardize onShow() (used by StackContainer) and onOpen() (used here)
			widget.onOpen(best);
		}

		return best;
	};

	this.close = function(/*dijit._Widget*/ popup){
		// summary:
		//		Close specified popup and any popups that it parented
		
		// Basically work backwards from the top of the stack closing popups
		// until we hit the specified popup, but IIRC there was some issue where closing
		// a popup would cause others to close too.  Thus if we are trying to close B in [A,B,C]
		// closing C might close B indirectly and then the while() condition will run where stack==[A]...
		// so the while condition is constructed defensively.
		while(dojo.some(stack, function(elem){return elem.widget == popup;})){
			var top = stack.pop(),
				wrapper = top.wrapper,
				iframe = top.iframe,
				widget = top.widget,
				onClose = top.onClose;

			if(widget.onClose){
				// TODO: in 2.0 standardize onHide() (used by StackContainer) and onClose() (used here)
				widget.onClose();
			}
			dojo.forEach(top.handlers, dojo.disconnect);

			// Move the widget offscreen, unless it has already been destroyed in above onClose() etc.
			if(widget && widget.domNode){
				this.moveOffScreen(widget.domNode);
			}
                        
			// recycle the wrapper plus iframe, so we prevent reattaching iframe everytime an popup opens
			// don't use moveOffScreen which would also reattach the wrapper to body, which causes reloading of iframe
			wrapper.style.top = "-9999px";
			wrapper.style.visibility = "hidden";
			wrappers.push([wrapper,iframe]);

			if(onClose){
				onClose();
			}
		}
	};
}();

dijit._frames = new function(){
	// summary:
	//		cache of iframes
	var queue = [];

	this.pop = function(){
		var iframe;
		if(queue.length){
			iframe = queue.pop();
			iframe.style.display="";
		}else{
			if(dojo.isIE){
				var burl = dojo.config["dojoBlankHtmlUrl"] || (dojo.moduleUrl("dojo", "resources/blank.html")+"") || "javascript:\"\"";
				var html="<iframe src='" + burl + "'"
					+ " style='position: absolute; left: 0px; top: 0px;"
					+ "z-index: -1; filter:Alpha(Opacity=\"0\");'>";
				iframe = dojo.doc.createElement(html);
			}else{
			 	iframe = dojo.create("iframe");
				iframe.src = 'javascript:""';
				iframe.className = "dijitBackgroundIframe";
				dojo.style(iframe, "opacity", 0.1);
			}
			iframe.tabIndex = -1; // Magic to prevent iframe from getting focus on tab keypress - as style didnt work.
		}
		return iframe;
	};

	this.push = function(iframe){
		iframe.style.display="none";
		queue.push(iframe);
	}
}();


dijit.BackgroundIframe = function(/* DomNode */node){
	// summary:
	//		For IE/FF z-index schenanigans. id attribute is required.
	//
	// description:
	//		new dijit.BackgroundIframe(node)
	//			Makes a background iframe as a child of node, that fills
	//			area (and position) of node

	if(!node.id){ throw new Error("no id"); }
	if(dojo.isIE || dojo.isMoz){
		var iframe = dijit._frames.pop();
		node.appendChild(iframe);
		if(dojo.isIE<7){
			this.resize(node);
			this._conn = dojo.connect(node, 'onresize', this, function(){
				this.resize(node);
			});
		}else{
			dojo.style(iframe, {
				width: '100%',
				height: '100%'
			});
		}
		this.iframe = iframe;
	}
};

dojo.extend(dijit.BackgroundIframe, {
	resize: function(node){
		// summary:
		// 		resize the iframe so its the same size as node
		// description:
		//		this function is a no-op in all browsers except
		//		IE6, which does not support 100% width/height 
		//		of absolute positioned iframes
		if(this.iframe && dojo.isIE<7){
			dojo.style(this.iframe, {
				width: node.offsetWidth + 'px',
				height: node.offsetHeight + 'px'
			});
		}
	},
	destroy: function(){
		// summary:
		//		destroy the iframe
		if(this._conn){
			dojo.disconnect(this._conn);
			this._conn = null;
		}
		if(this.iframe){
			dijit._frames.push(this.iframe);
			delete this.iframe;
		}
	}
});

}

if(!dojo._hasResource["dijit._base.scroll"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.scroll"] = true;
dojo.provide("dijit._base.scroll");

dijit.scrollIntoView = function(/*DomNode*/ node, /*Object?*/ pos){
	// summary:
	//		Scroll the passed node into view, if it is not already.
	
	// don't rely on that node.scrollIntoView works just because the function is there

	try{ // catch unexpected/unrecreatable errors (#7808) since we can recover using a semi-acceptable native method
	node = dojo.byId(node);
	var doc = node.ownerDocument || dojo.doc,
		body = doc.body || dojo.body(),
		html = doc.documentElement || body.parentNode,
		isIE = dojo.isIE, isWK = dojo.isWebKit;
	// if an untested browser, then use the native method
	if((!(dojo.isMoz || isIE || isWK) || node == body || node == html) && (typeof node.scrollIntoView != "undefined")){
		node.scrollIntoView(false); // short-circuit to native if possible
		return;
	}
	var backCompat = doc.compatMode == 'BackCompat',
		clientAreaRoot = backCompat? body : html,
		scrollRoot = isWK ? body : clientAreaRoot,
		rootWidth = clientAreaRoot.clientWidth,
		rootHeight = clientAreaRoot.clientHeight,
		rtl = !dojo._isBodyLtr(),
		nodePos = pos || dojo.position(node),
		el = node.parentNode,
		isFixed = function(el){
			return ((isIE <= 6 || (isIE && backCompat))? false : (dojo.style(el, 'position').toLowerCase() == "fixed"));
		};
	if(isFixed(node)){ return; } // nothing to do
	while(el){
		if(el == body){ el = scrollRoot; }
		var elPos = dojo.position(el),
			fixedPos = isFixed(el);
		with(elPos){
			if(el == scrollRoot){
				w = rootWidth, h = rootHeight;
				if(scrollRoot == html && isIE && rtl){ x += scrollRoot.offsetWidth-w; } // IE workaround where scrollbar causes negative x
				if(x < 0 || !isIE){ x = 0; } // IE can have values > 0
				if(y < 0 || !isIE){ y = 0; }
			}else{
				var pb = dojo._getPadBorderExtents(el);
				w -= pb.w; h -= pb.h; x += pb.l; y += pb.t;
			}
			with(el){
				if(el != scrollRoot){ // body, html sizes already have the scrollbar removed
					var clientSize = clientWidth,
						scrollBarSize = w - clientSize;
					if(clientSize > 0 && scrollBarSize > 0){
						w = clientSize;
						if(isIE && rtl){ x += scrollBarSize; }
					}
					clientSize = clientHeight;
					scrollBarSize = h - clientSize;
					if(clientSize > 0 && scrollBarSize > 0){
						h = clientSize;
					}
				}
				if(fixedPos){ // bounded by viewport, not parents
					if(y < 0){
						h += y, y = 0;
					}
					if(x < 0){
						w += x, x = 0;
					}
					if(y + h > rootHeight){
						h = rootHeight - y;
					}
					if(x + w > rootWidth){
						w = rootWidth - x;
					}
				}
				// calculate overflow in all 4 directions
				var l = nodePos.x - x, // beyond left: < 0
					t = nodePos.y - Math.max(y, 0), // beyond top: < 0
					r = l + nodePos.w - w, // beyond right: > 0
					bot = t + nodePos.h - h; // beyond bottom: > 0
				if(r * l > 0){
					var s = Math[l < 0? "max" : "min"](l, r);
					nodePos.x += scrollLeft;
					scrollLeft += (isIE >= 8 && !backCompat && rtl)? -s : s;
					nodePos.x -= scrollLeft;
				}
				if(bot * t > 0){
					nodePos.y += scrollTop;
					scrollTop += Math[t < 0? "max" : "min"](t, bot);
					nodePos.y -= scrollTop;
				}
			}
		}
		el = (el != scrollRoot) && !fixedPos && el.parentNode;
	}
	}catch(error){
		console.error('scrollIntoView: ' + error);
		node.scrollIntoView(false);
	}
};

}

if(!dojo._hasResource["dijit._base.sniff"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.sniff"] = true;
// summary:
//		Applies pre-set CSS classes to the top-level HTML node, based on:
// 			- browser (ex: dj_ie)
//			- browser version (ex: dj_ie6)
//			- box model (ex: dj_contentBox)
//			- text direction (ex: dijitRtl)
//
//		In addition, browser, browser version, and box model are
//		combined with an RTL flag when browser text is RTL.  ex: dj_ie-rtl.
//
//		Simply doing a require on this module will
//		establish this CSS.  Modified version of Morris' CSS hack.

dojo.provide("dijit._base.sniff");

(function(){

	var d = dojo,
		html = d.doc.documentElement,
		ie = d.isIE,
		opera = d.isOpera,
		maj = Math.floor,
		ff = d.isFF,
		boxModel = d.boxModel.replace(/-/,''),

		classes = {
			dj_ie: ie,
			dj_ie6: maj(ie) == 6,
			dj_ie7: maj(ie) == 7,
			dj_ie8: maj(ie) == 8,
			dj_iequirks: ie && d.isQuirks,

			// NOTE: Opera not supported by dijit
			dj_opera: opera,

			dj_khtml: d.isKhtml,

			dj_webkit: d.isWebKit,
			dj_safari: d.isSafari,
			dj_chrome: d.isChrome,

			dj_gecko: d.isMozilla,
			dj_ff3: maj(ff) == 3
		}; // no dojo unsupported browsers

	classes["dj_" + boxModel] = true;

	// apply browser, browser version, and box model class names
	for(var p in classes){
		if(classes[p]){
			if(html.className){
				html.className += " " + p;
			}else{
				html.className = p;
			}
		}
	}

	// If RTL mode then add dijitRtl flag plus repeat existing classes
	// with -rtl extension
	// (unshift is to make this code run after <body> node is loaded but before parser runs)
	dojo._loaders.unshift(function(){
		if(!dojo._isBodyLtr()){
			html.className += " dijitRtl";
			for(var p in classes){
				if(classes[p]){
					html.className += " " + p + "-rtl";
				}
			}
		}
	});

})();

}

if(!dojo._hasResource["dijit._base.typematic"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.typematic"] = true;
dojo.provide("dijit._base.typematic");

dijit.typematic = {
	// summary:
	//		These functions are used to repetitively call a user specified callback
	//		method when a specific key or mouse click over a specific DOM node is
	//		held down for a specific amount of time.
	//		Only 1 such event is allowed to occur on the browser page at 1 time.

	_fireEventAndReload: function(){
		this._timer = null;
		this._callback(++this._count, this._node, this._evt);
		
		// Schedule next event, reducing the timer a little bit each iteration, bottoming-out at 10 to avoid
		// browser overload (particularly avoiding starving DOH robot so it never gets to send a mouseup)
		this._currentTimeout = Math.max(
			this._currentTimeout < 0 ? this._initialDelay :
				(this._subsequentDelay > 1 ? this._subsequentDelay : Math.round(this._currentTimeout * this._subsequentDelay)),
			10);
		this._timer = setTimeout(dojo.hitch(this, "_fireEventAndReload"), this._currentTimeout);
	},

	trigger: function(/*Event*/ evt, /* Object */ _this, /*DOMNode*/ node, /* Function */ callback, /* Object */ obj, /* Number */ subsequentDelay, /* Number */ initialDelay){
		// summary:
		//		Start a timed, repeating callback sequence.
		//		If already started, the function call is ignored.
		//		This method is not normally called by the user but can be
		//		when the normal listener code is insufficient.
		// evt:
		//		key or mouse event object to pass to the user callback
		// _this:
		//		pointer to the user's widget space.
		// node:
		//		the DOM node object to pass the the callback function
		// callback:
		//		function to call until the sequence is stopped called with 3 parameters:
		// count:
		//		integer representing number of repeated calls (0..n) with -1 indicating the iteration has stopped
		// node:
		//		the DOM node object passed in
		// evt:
		//		key or mouse event object
		// obj:
		//		user space object used to uniquely identify each typematic sequence
		// subsequentDelay:
		//		if > 1, the number of milliseconds until the 3->n events occur
		//		or else the fractional time multiplier for the next event's delay, default=0.9
		// initialDelay:
		//		the number of milliseconds until the 2nd event occurs, default=500ms
		if(obj != this._obj){
			this.stop();
			this._initialDelay = initialDelay || 500;
			this._subsequentDelay = subsequentDelay || 0.90;
			this._obj = obj;
			this._evt = evt;
			this._node = node;
			this._currentTimeout = -1;
			this._count = -1;
			this._callback = dojo.hitch(_this, callback);
			this._fireEventAndReload();
		}
	},

	stop: function(){
		// summary:
		//		Stop an ongoing timed, repeating callback sequence.
		if(this._timer){
			clearTimeout(this._timer);
			this._timer = null;
		}
		if(this._obj){
			this._callback(-1, this._node, this._evt);
			this._obj = null;
		}
	},

	addKeyListener: function(/*DOMNode*/ node, /*Object*/ keyObject, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay){
		// summary:
		//		Start listening for a specific typematic key.
		//		See also the trigger method for other parameters.
		// keyObject:
		//		an object defining the key to listen for.
		// charOrCode:
		//		the printable character (string) or keyCode (number) to listen for.
		// keyCode:
		//		(deprecated - use charOrCode) the keyCode (number) to listen for (implies charCode = 0).
		// charCode:
		//		(deprecated - use charOrCode) the charCode (number) to listen for.
		// ctrlKey:
		//		desired ctrl key state to initiate the calback sequence:
		//			- pressed (true)
		//			- released (false)
		//			- either (unspecified)
		// altKey:
		//		same as ctrlKey but for the alt key
		// shiftKey:
		//		same as ctrlKey but for the shift key
		// returns:
		//		an array of dojo.connect handles
		if(keyObject.keyCode){
			keyObject.charOrCode = keyObject.keyCode;
			dojo.deprecated("keyCode attribute parameter for dijit.typematic.addKeyListener is deprecated. Use charOrCode instead.", "", "2.0");
		}else if(keyObject.charCode){
			keyObject.charOrCode = String.fromCharCode(keyObject.charCode);
			dojo.deprecated("charCode attribute parameter for dijit.typematic.addKeyListener is deprecated. Use charOrCode instead.", "", "2.0");
		}
		return [
			dojo.connect(node, "onkeypress", this, function(evt){
				if(evt.charOrCode == keyObject.charOrCode &&
				(keyObject.ctrlKey === undefined || keyObject.ctrlKey == evt.ctrlKey) &&
				(keyObject.altKey === undefined || keyObject.altKey == evt.altKey) &&
				(keyObject.metaKey === undefined || keyObject.metaKey == (evt.metaKey || false)) && // IE doesn't even set metaKey
				(keyObject.shiftKey === undefined || keyObject.shiftKey == evt.shiftKey)){
					dojo.stopEvent(evt);
					dijit.typematic.trigger(keyObject, _this, node, callback, keyObject, subsequentDelay, initialDelay);
				}else if(dijit.typematic._obj == keyObject){
					dijit.typematic.stop();
				}
			}),
			dojo.connect(node, "onkeyup", this, function(evt){
				if(dijit.typematic._obj == keyObject){
					dijit.typematic.stop();
				}
			})
		];
	},

	addMouseListener: function(/*DOMNode*/ node, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay){
		// summary:
		//		Start listening for a typematic mouse click.
		//		See the trigger method for other parameters.
		// returns:
		//		an array of dojo.connect handles
		var dc = dojo.connect;
		return [
			dc(node, "mousedown", this, function(evt){
				dojo.stopEvent(evt);
				dijit.typematic.trigger(evt, _this, node, callback, node, subsequentDelay, initialDelay);
			}),
			dc(node, "mouseup", this, function(evt){
				dojo.stopEvent(evt);
				dijit.typematic.stop();
			}),
			dc(node, "mouseout", this, function(evt){
				dojo.stopEvent(evt);
				dijit.typematic.stop();
			}),
			dc(node, "mousemove", this, function(evt){
				dojo.stopEvent(evt);
			}),
			dc(node, "dblclick", this, function(evt){
				dojo.stopEvent(evt);
				if(dojo.isIE){
					dijit.typematic.trigger(evt, _this, node, callback, node, subsequentDelay, initialDelay);
					setTimeout(dojo.hitch(this, dijit.typematic.stop), 50);
				}
			})
		];
	},

	addListener: function(/*Node*/ mouseNode, /*Node*/ keyNode, /*Object*/ keyObject, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay){
		// summary:
		//		Start listening for a specific typematic key and mouseclick.
		//		This is a thin wrapper to addKeyListener and addMouseListener.
		//		See the addMouseListener and addKeyListener methods for other parameters.
		// mouseNode:
		//		the DOM node object to listen on for mouse events.
		// keyNode:
		//		the DOM node object to listen on for key events.
		// returns:
		//		an array of dojo.connect handles
		return this.addKeyListener(keyNode, keyObject, _this, callback, subsequentDelay, initialDelay).concat(
			this.addMouseListener(mouseNode, _this, callback, subsequentDelay, initialDelay));
	}
};

}

if(!dojo._hasResource["dijit._base.wai"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.wai"] = true;
dojo.provide("dijit._base.wai");

dijit.wai = {
	onload: function(){
		// summary:
		//		Detects if we are in high-contrast mode or not

		// This must be a named function and not an anonymous
		// function, so that the widget parsing code can make sure it
		// registers its onload function after this function.
		// DO NOT USE "this" within this function.

		// create div for testing if high contrast mode is on or images are turned off
		var div = dojo.create("div",{
			id: "a11yTestNode",
			style:{
				cssText:'border: 1px solid;'
					+ 'border-color:red green;'
					+ 'position: absolute;'
					+ 'height: 5px;'
					+ 'top: -999px;'
					+ 'background-image: url("' + (dojo.config.blankGif || dojo.moduleUrl("dojo", "resources/blank.gif")) + '");'
			}
		}, dojo.body());

		// test it
		var cs = dojo.getComputedStyle(div);
		if(cs){
			var bkImg = cs.backgroundImage;
			var needsA11y = (cs.borderTopColor == cs.borderRightColor) || (bkImg != null && (bkImg == "none" || bkImg == "url(invalid-url:)" ));
			dojo[needsA11y ? "addClass" : "removeClass"](dojo.body(), "dijit_a11y");
			if(dojo.isIE){
				div.outerHTML = "";		// prevent mixed-content warning, see http://support.microsoft.com/kb/925014
			}else{
				dojo.body().removeChild(div);
			}
		}
	}
};

// Test if computer is in high contrast mode.
// Make sure the a11y test runs first, before widgets are instantiated.
if(dojo.isIE || dojo.isMoz){	// NOTE: checking in Safari messes things up
	dojo._loaders.unshift(dijit.wai.onload);
}

dojo.mixin(dijit, {
	_XhtmlRoles: /banner|contentinfo|definition|main|navigation|search|note|secondary|seealso/,

	hasWaiRole: function(/*Element*/ elem, /*String*/ role){
		// summary:
		//		Determines if an element has a particular non-XHTML role.
		// returns:
		//		True if elem has the specific non-XHTML role attribute and false if not.
		// 		For backwards compatibility if role parameter not provided,
		// 		returns true if has non XHTML role
		var waiRole = this.getWaiRole(elem);
		return role ? (waiRole.indexOf(role) > -1) : (waiRole.length > 0);
	},

	getWaiRole: function(/*Element*/ elem){
		// summary:
		//		Gets the non-XHTML role for an element (which should be a wai role).
		// returns:
		//		The non-XHTML role of elem or an empty string if elem
		//		does not have a role.
		 return dojo.trim((dojo.attr(elem, "role") || "").replace(this._XhtmlRoles,"").replace("wairole:",""));
	},

	setWaiRole: function(/*Element*/ elem, /*String*/ role){
		// summary:
		//		Sets the role on an element.
		// description:
		//		Replace existing role attribute with new role.
		//		If elem already has an XHTML role, append this role to XHTML role
		//		and remove other ARIA roles.

		var curRole = dojo.attr(elem, "role") || "";
		if(!this._XhtmlRoles.test(curRole)){
			dojo.attr(elem, "role", role);
		}else{
			if((" "+ curRole +" ").indexOf(" " + role + " ") < 0){
				var clearXhtml = dojo.trim(curRole.replace(this._XhtmlRoles, ""));
				var cleanRole = dojo.trim(curRole.replace(clearXhtml, ""));
				dojo.attr(elem, "role", cleanRole + (cleanRole ? ' ' : '') + role);
			}
		}
	},

	removeWaiRole: function(/*Element*/ elem, /*String*/ role){
		// summary:
		//		Removes the specified non-XHTML role from an element.
		// 		Removes role attribute if no specific role provided (for backwards compat.)

		var roleValue = dojo.attr(elem, "role");
		if(!roleValue){ return; }
		if(role){
			var t = dojo.trim((" " + roleValue + " ").replace(" " + role + " ", " "));
			dojo.attr(elem, "role", t);
		}else{
			elem.removeAttribute("role");
		}
	},

	hasWaiState: function(/*Element*/ elem, /*String*/ state){
		// summary:
		//		Determines if an element has a given state.
		// description:
		//		Checks for an attribute called "aria-"+state.
		// returns:
		//		true if elem has a value for the given state and
		//		false if it does not.

		return elem.hasAttribute ? elem.hasAttribute("aria-"+state) : !!elem.getAttribute("aria-"+state);
	},

	getWaiState: function(/*Element*/ elem, /*String*/ state){
		// summary:
		//		Gets the value of a state on an element.
		// description:
		//		Checks for an attribute called "aria-"+state.
		// returns:
		//		The value of the requested state on elem
		//		or an empty string if elem has no value for state.

		return elem.getAttribute("aria-"+state) || "";
	},

	setWaiState: function(/*Element*/ elem, /*String*/ state, /*String*/ value){
		// summary:
		//		Sets a state on an element.
		// description:
		//		Sets an attribute called "aria-"+state.

		elem.setAttribute("aria-"+state, value);
	},

	removeWaiState: function(/*Element*/ elem, /*String*/ state){
		// summary:
		//		Removes a state from an element.
		// description:
		//		Sets an attribute called "aria-"+state.

		elem.removeAttribute("aria-"+state);
	}
});

}

if(!dojo._hasResource["dijit._base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base"] = true;
dojo.provide("dijit._base");











}

if(!dojo._hasResource["dijit._Widget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._Widget"] = true;
dojo.provide("dijit._Widget");

dojo.require( "dijit._base" );


// This code is to assist deferring dojo.connect() calls in widgets (connecting to events on the widgets'
// DOM nodes) until someone actually needs to monitor that event.
dojo.connect(dojo, "_connect",
	function(/*dijit._Widget*/ widget, /*String*/ event){
		if(widget && dojo.isFunction(widget._onConnect)){
			widget._onConnect(event);
		}
	});

dijit._connectOnUseEventHandler = function(/*Event*/ event){};

// Keep track of where the last keydown event was, to help avoid generating
// spurious ondijitclick events when:
// 1. focus is on a <button> or <a>
// 2. user presses then releases the ENTER key
// 3. onclick handler fires and shifts focus to another node, with an ondijitclick handler
// 4. onkeyup event fires, causing the ondijitclick handler to fire
dijit._lastKeyDownNode = null;
if(dojo.isIE){
	(function(){
		var keydownCallback = function(evt){
			dijit._lastKeyDownNode = evt.srcElement;
		};
		dojo.doc.attachEvent('onkeydown', keydownCallback);
		dojo.addOnWindowUnload(function(){
			dojo.doc.detachEvent('onkeydown', keydownCallback);
		});
	})();
}else{
	dojo.doc.addEventListener('keydown', function(evt){
		dijit._lastKeyDownNode = evt.target;
	}, true);
}

(function(){

var _attrReg = {},	// cached results from getSetterAttributes
	getSetterAttributes = function(widget){
		// summary:
		//		Returns list of attributes with custom setters for specified widget
		var dc = widget.declaredClass;
		if(!_attrReg[dc]){
			var r = [],
				attrs,
				proto = widget.constructor.prototype;
			for(var fxName in proto){
				if(dojo.isFunction(proto[fxName]) && (attrs = fxName.match(/^_set([a-zA-Z]*)Attr$/)) && attrs[1]){
					r.push(attrs[1].charAt(0).toLowerCase() + attrs[1].substr(1));
				}
			}
			_attrReg[dc] = r;
		}
		return _attrReg[dc] || [];	// String[]
	};

dojo.declare("dijit._Widget", null, {
	// summary:
	//		Base class for all Dijit widgets.

	// id: [const] String
	//		A unique, opaque ID string that can be assigned by users or by the
	//		system. If the developer passes an ID which is known not to be
	//		unique, the specified ID is ignored and the system-generated ID is
	//		used instead.
	id: "",

	// lang: [const] String
	//		Rarely used.  Overrides the default Dojo locale used to render this widget,
	//		as defined by the [HTML LANG](http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang) attribute.
	//		Value must be among the list of locales specified during by the Dojo bootstrap,
	//		formatted according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt) (like en-us).
	lang: "",

	// dir: [const] String
	//		Unsupported by Dijit, but here for completeness.  Dijit only supports setting text direction on the
	//		entire document.
	//		Bi-directional support, as defined by the [HTML DIR](http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir)
	//		attribute. Either left-to-right "ltr" or right-to-left "rtl".
	dir: "",

	// class: String
	//		HTML class attribute
	"class": "",

	// style: String||Object
	//		HTML style attributes as cssText string or name/value hash
	style: "",

	// title: String
	//		HTML title attribute.
	//
	//		For form widgets this specifies a tooltip to display when hovering over
	//		the widget (just like the native HTML title attribute).
	//
	//		For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
	//		etc., it's used to specify the tab label, accordion pane title, etc.
	title: "",

	// tooltip: String
	//		When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
	//		this specifies the tooltip to appear when the mouse is hovered over that text.
	tooltip: "",

	// srcNodeRef: [readonly] DomNode
	//		pointer to original DOM node
	srcNodeRef: null,

	// domNode: [readonly] DomNode
	//		This is our visible representation of the widget! Other DOM
	//		Nodes may by assigned to other properties, usually through the
	//		template system's dojoAttachPoint syntax, but the domNode
	//		property is the canonical "top level" node in widget UI.
	domNode: null,

	// containerNode: [readonly] DomNode
	//		Designates where children of the source DOM node will be placed.
	//		"Children" in this case refers to both DOM nodes and widgets.
	//		For example, for myWidget:
	//
	//		|	<div dojoType=myWidget>
	//		|		<b> here's a plain DOM node
	//		|		<span dojoType=subWidget>and a widget</span>
	//		|		<i> and another plain DOM node </i>
	//		|	</div>
	//
	//		containerNode would point to:
	//
	//		|		<b> here's a plain DOM node
	//		|		<span dojoType=subWidget>and a widget</span>
	//		|		<i> and another plain DOM node </i>
	//
	//		In templated widgets, "containerNode" is set via a
	//		dojoAttachPoint assignment.
	//
	//		containerNode must be defined for any widget that accepts innerHTML
	//		(like ContentPane or BorderContainer or even Button), and conversely
	//		is null for widgets that don't, like TextBox.
	containerNode: null,

/*=====
	// _started: Boolean
	//		startup() has completed.
	_started: false,
=====*/

	// attributeMap: [protected] Object
	//		attributeMap sets up a "binding" between attributes (aka properties)
	//		of the widget and the widget's DOM.
	//		Changes to widget attributes listed in attributeMap will be
	//		reflected into the DOM.
	//
	//		For example, calling attr('title', 'hello')
	//		on a TitlePane will automatically cause the TitlePane's DOM to update
	//		with the new title.
	//
	//		attributeMap is a hash where the key is an attribute of the widget,
	//		and the value reflects a binding to a:
	//
	//		- DOM node attribute
	// |		focus: {node: "focusNode", type: "attribute"}
	// 		Maps this.focus to this.focusNode.focus
	//
	//		- DOM node innerHTML
	//	|		title: { node: "titleNode", type: "innerHTML" }
	//		Maps this.title to this.titleNode.innerHTML
	//
	//		- DOM node innerText
	//	|		title: { node: "titleNode", type: "innerText" }
	//		Maps this.title to this.titleNode.innerText
	//
	//		- DOM node CSS class
	// |		myClass: { node: "domNode", type: "class" }
	//		Maps this.myClass to this.domNode.className
	//
	//		If the value is an array, then each element in the array matches one of the
	//		formats of the above list.
	//
	//		There are also some shorthands for backwards compatibility:
	//		- string --> { node: string, type: "attribute" }, for example:
	//	|	"focusNode" ---> { node: "focusNode", type: "attribute" }
	//		- "" --> { node: "domNode", type: "attribute" }
	attributeMap: {id:"", dir:"", lang:"", "class":"", style:"", title:""},

	// _deferredConnects: [protected] Object
	//		attributeMap addendum for event handlers that should be connected only on first use
	_deferredConnects: {
		onClick: "",
		onDblClick: "",
		onKeyDown: "",
		onKeyPress: "",
		onKeyUp: "",
		onMouseMove: "",
		onMouseDown: "",
		onMouseOut: "",
		onMouseOver: "",
		onMouseLeave: "",
		onMouseEnter: "",
		onMouseUp: ""
	},

	onClick: dijit._connectOnUseEventHandler,
	/*=====
	onClick: function(event){
		// summary:
		//		Connect to this function to receive notifications of mouse click events.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onDblClick: dijit._connectOnUseEventHandler,
	/*=====
	onDblClick: function(event){
		// summary:
		//		Connect to this function to receive notifications of mouse double click events.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onKeyDown: dijit._connectOnUseEventHandler,
	/*=====
	onKeyDown: function(event){
		// summary:
		//		Connect to this function to receive notifications of keys being pressed down.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onKeyPress: dijit._connectOnUseEventHandler,
	/*=====
	onKeyPress: function(event){
		// summary:
		//		Connect to this function to receive notifications of printable keys being typed.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onKeyUp: dijit._connectOnUseEventHandler,
	/*=====
	onKeyUp: function(event){
		// summary:
		//		Connect to this function to receive notifications of keys being released.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onMouseDown: dijit._connectOnUseEventHandler,
	/*=====
	onMouseDown: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse button is pressed down.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseMove: dijit._connectOnUseEventHandler,
	/*=====
	onMouseMove: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseOut: dijit._connectOnUseEventHandler,
	/*=====
	onMouseOut: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseOver: dijit._connectOnUseEventHandler,
	/*=====
	onMouseOver: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseLeave: dijit._connectOnUseEventHandler,
	/*=====
	onMouseLeave: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves off of this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseEnter: dijit._connectOnUseEventHandler,
	/*=====
	onMouseEnter: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves onto this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseUp: dijit._connectOnUseEventHandler,
	/*=====
	onMouseUp: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse button is released.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/

	// Constants used in templates

	// _blankGif: [protected] String
	//		Path to a blank 1x1 image.
	//		Used by <img> nodes in templates that really get their image via CSS background-image.
	_blankGif: (dojo.config.blankGif || dojo.moduleUrl("dojo", "resources/blank.gif")).toString(),

	//////////// INITIALIZATION METHODS ///////////////////////////////////////

	postscript: function(/*Object?*/params, /*DomNode|String*/srcNodeRef){
		// summary:
		//		Kicks off widget instantiation.  See create() for details.
		// tags:
		//		private
		this.create(params, srcNodeRef);
	},

	create: function(/*Object?*/params, /*DomNode|String?*/srcNodeRef){
		// summary:
		//		Kick off the life-cycle of a widget
		// params:
		//		Hash of initialization parameters for widget, including
		//		scalar values (like title, duration etc.) and functions,
		//		typically callbacks like onClick.
		// srcNodeRef:
		//		If a srcNodeRef (DOM node) is specified:
		//			- use srcNodeRef.innerHTML as my contents
		//			- if this is a behavioral widget then apply behavior
		//			  to that srcNodeRef
		//			- otherwise, replace srcNodeRef with my generated DOM
		//			  tree
		// description:
		//		Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,
		//		etc.), some of which of you'll want to override. See http://docs.dojocampus.org/dijit/_Widget
		//		for a discussion of the widget creation lifecycle.
		//
		//		Of course, adventurous developers could override create entirely, but this should
		//		only be done as a last resort.
		// tags:
		//		private

		// store pointer to original DOM tree
		this.srcNodeRef = dojo.byId(srcNodeRef);

		// For garbage collection.  An array of handles returned by Widget.connect()
		// Each handle returned from Widget.connect() is an array of handles from dojo.connect()
		this._connects = [];

		// For garbage collection.  An array of handles returned by Widget.subscribe()
		// The handle returned from Widget.subscribe() is the handle returned from dojo.subscribe()
		this._subscribes = [];

		// To avoid double-connects, remove entries from _deferredConnects
		// that have been setup manually by a subclass (ex, by dojoAttachEvent).
		// If a subclass has redefined a callback (ex: onClick) then assume it's being
		// connected to manually.
		this._deferredConnects = dojo.clone(this._deferredConnects);
		for(var attr in this.attributeMap){
			delete this._deferredConnects[attr]; // can't be in both attributeMap and _deferredConnects
		}
		for(attr in this._deferredConnects){
			if(this[attr] !== dijit._connectOnUseEventHandler){
				delete this._deferredConnects[attr];	// redefined, probably dojoAttachEvent exists
			}
		}

		//mixin our passed parameters
		if(this.srcNodeRef && (typeof this.srcNodeRef.id == "string")){ this.id = this.srcNodeRef.id; }
		if(params){
			this.params = params;
			dojo.mixin(this,params);
		}
		this.postMixInProperties();

		// generate an id for the widget if one wasn't specified
		// (be sure to do this before buildRendering() because that function might
		// expect the id to be there.)
		if(!this.id){
			this.id = dijit.getUniqueId(this.declaredClass.replace(/\./g,"_"));
		}
		dijit.registry.add(this);

		this.buildRendering();

		if(this.domNode){
			// Copy attributes listed in attributeMap into the [newly created] DOM for the widget.
			this._applyAttributes();

			var source = this.srcNodeRef;
			if(source && source.parentNode){
				source.parentNode.replaceChild(this.domNode, source);
			}

			// If the developer has specified a handler as a widget parameter
			// (ex: new Button({onClick: ...})
			// then naturally need to connect from DOM node to that handler immediately,
			for(attr in this.params){
				this._onConnect(attr);
			}
		}

		if(this.domNode){
			this.domNode.setAttribute("widgetId", this.id);
		}
		this.postCreate();

		// If srcNodeRef has been processed and removed from the DOM (e.g. TemplatedWidget) then delete it to allow GC.
		if(this.srcNodeRef && !this.srcNodeRef.parentNode){
			delete this.srcNodeRef;
		}

		this._created = true;
	},

	_applyAttributes: function(){
		// summary:
		//		Step during widget creation to copy all widget attributes to the
		//		DOM as per attributeMap and _setXXXAttr functions.
		// description:
		//		Skips over blank/false attribute values, unless they were explicitly specified
		//		as parameters to the widget, since those are the default anyway,
		//		and setting tabIndex="" is different than not setting tabIndex at all.
		//
		//		It processes the attributes in the attribute map first, and then
		//		it goes through and processes the attributes for the _setXXXAttr
		//		functions that have been specified
		// tags:
		//		private
		var condAttrApply = function(attr, scope){
			if((scope.params && attr in scope.params) || scope[attr]){
				scope.attr(attr, scope[attr]);
			}
		};

		// Do the attributes in attributeMap
		for(var attr in this.attributeMap){
			condAttrApply(attr, this);
		}

		// And also any attributes with custom setters
		dojo.forEach(getSetterAttributes(this), function(a){
			if(!(a in this.attributeMap)){
				condAttrApply(a, this);
			}
		}, this);
	},

	postMixInProperties: function(){
		// summary:
		//		Called after the parameters to the widget have been read-in,
		//		but before the widget template is instantiated. Especially
		//		useful to set properties that are referenced in the widget
		//		template.
		// tags:
		//		protected
	},

	buildRendering: function(){
		// summary:
		//		Construct the UI for this widget, setting this.domNode
		// description:
		//		Most widgets will mixin `dijit._Templated`, which implements this
		//		method.
		// tags:
		//		protected
		this.domNode = this.srcNodeRef || dojo.create('div');
	},

	postCreate: function(){
		// summary:
		//		Processing after the DOM fragment is created
		// description:
		//		Called after the DOM fragment has been created, but not necessarily
		//		added to the document.  Do not include any operations which rely on
		//		node dimensions or placement.
		// tags:
		//		protected
	},

	startup: function(){
		// summary:
		//		Processing after the DOM fragment is added to the document
		// description:
		//		Called after a widget and its children have been created and added to the page,
		//		and all related widgets have finished their create() cycle, up through postCreate().
		//		This is useful for composite widgets that need to control or layout sub-widgets.
		//		Many layout widgets can use this as a wiring phase.
		this._started = true;
	},

	//////////// DESTROY FUNCTIONS ////////////////////////////////

	destroyRecursive: function(/*Boolean?*/ preserveDom){
		// summary:
		// 		Destroy this widget and its descendants
		// description:
		//		This is the generic "destructor" function that all widget users
		// 		should call to cleanly discard with a widget. Once a widget is
		// 		destroyed, it is removed from the manager object.
		// preserveDom:
		//		If true, this method will leave the original DOM structure
		//		alone of descendant Widgets. Note: This will NOT work with
		//		dijit._Templated widgets.

		this._beingDestroyed = true;
		this.destroyDescendants(preserveDom);
		this.destroy(preserveDom);
	},

	destroy: function(/*Boolean*/ preserveDom){
		// summary:
		// 		Destroy this widget, but not its descendants.
		//		This method will, however, destroy internal widgets such as those used within a template.
		// preserveDom: Boolean
		//		If true, this method will leave the original DOM structure alone.
		//		Note: This will not yet work with _Templated widgets

		this._beingDestroyed = true;
		this.uninitialize();
		var d = dojo,
			dfe = d.forEach,
			dun = d.unsubscribe;
		dfe(this._connects, function(array){
			dfe(array, d.disconnect);
		});
		dfe(this._subscribes, function(handle){
			dun(handle);
		});

		// destroy widgets created as part of template, etc.
		dfe(this._supportingWidgets || [], function(w){
			if(w.destroyRecursive){
				w.destroyRecursive();
			}else if(w.destroy){
				w.destroy();
			}
		});

		this.destroyRendering(preserveDom);
		dijit.registry.remove(this.id);
		this._destroyed = true;
	},

	destroyRendering: function(/*Boolean?*/ preserveDom){
		// summary:
		//		Destroys the DOM nodes associated with this widget
		// preserveDom:
		//		If true, this method will leave the original DOM structure alone
		//		during tear-down. Note: this will not work with _Templated
		//		widgets yet.
		// tags:
		//		protected

		if(this.bgIframe){
			this.bgIframe.destroy(preserveDom);
			delete this.bgIframe;
		}

		if(this.domNode){
			if(preserveDom){
				dojo.removeAttr(this.domNode, "widgetId");
			}else{
				dojo.destroy(this.domNode);
			}
			delete this.domNode;
		}

		if(this.srcNodeRef){
			if(!preserveDom){
				dojo.destroy(this.srcNodeRef);
			}
			delete this.srcNodeRef;
		}
	},

	destroyDescendants: function(/*Boolean?*/ preserveDom){
		// summary:
		//		Recursively destroy the children of this widget and their
		//		descendants.
		// preserveDom:
		//		If true, the preserveDom attribute is passed to all descendant
		//		widget's .destroy() method. Not for use with _Templated
		//		widgets.

		// get all direct descendants and destroy them recursively
		dojo.forEach(this.getChildren(), function(widget){
			if(widget.destroyRecursive){
				widget.destroyRecursive(preserveDom);
			}
		});
	},


	uninitialize: function(){
		// summary:
		//		Stub function. Override to implement custom widget tear-down
		//		behavior.
		// tags:
		//		protected
		return false;
	},

	////////////////// MISCELLANEOUS METHODS ///////////////////

	onFocus: function(){
		// summary:
		//		Called when the widget becomes "active" because
		//		it or a widget inside of it either has focus, or has recently
		//		been clicked.
		// tags:
		//		callback
	},

	onBlur: function(){
		// summary:
		//		Called when the widget stops being "active" because
		//		focus moved to something outside of it, or the user
		//		clicked somewhere outside of it, or the widget was
		//		hidden.
		// tags:
		//		callback
	},

	_onFocus: function(e){
		// summary:
		//		This is where widgets do processing for when they are active,
		//		such as changing CSS classes.  See onFocus() for more details.
		// tags:
		//		protected
		this.onFocus();
	},

	_onBlur: function(){
		// summary:
		//		This is where widgets do processing for when they stop being active,
		//		such as changing CSS classes.  See onBlur() for more details.
		// tags:
		//		protected
		this.onBlur();
	},

	_onConnect: function(/*String*/ event){
		// summary:
		//		Called when someone connects to one of my handlers.
		//		"Turn on" that handler if it isn't active yet.
		//
		//		This is also called for every single initialization parameter
		//		so need to do nothing for parameters like "id".
		// tags:
		//		private
		if(event in this._deferredConnects){
			var mapNode = this[this._deferredConnects[event] || 'domNode'];
			this.connect(mapNode, event.toLowerCase(), event);
			delete this._deferredConnects[event];
		}
	},

	_setClassAttr: function(/*String*/ value){
		// summary:
		//		Custom setter for the CSS "class" attribute
		// tags:
		//		protected
		var mapNode = this[this.attributeMap["class"] || 'domNode'];
		dojo.removeClass(mapNode, this["class"])
		this["class"] = value;
		dojo.addClass(mapNode, value);
	},

	_setStyleAttr: function(/*String||Object*/ value){
		// summary:
		//		Sets the style attribut of the widget according to value,
		//		which is either a hash like {height: "5px", width: "3px"}
		//		or a plain string
		// description:
		//		Determines which node to set the style on based on style setting
		//		in attributeMap.
		// tags:
		//		protected

		var mapNode = this[this.attributeMap.style || 'domNode'];

		// Note: technically we should revert any style setting made in a previous call
		// to his method, but that's difficult to keep track of.

		if(dojo.isObject(value)){
			dojo.style(mapNode, value);
		}else{
			if(mapNode.style.cssText){
				mapNode.style.cssText += "; " + value;
			}else{
				mapNode.style.cssText = value;
			}
		}

		this.style = value;
	},

	setAttribute: function(/*String*/ attr, /*anything*/ value){
		// summary:
		//		Deprecated.  Use attr() instead.
		// tags:
		//		deprecated
		dojo.deprecated(this.declaredClass+"::setAttribute() is deprecated. Use attr() instead.", "", "2.0");
		this.attr(attr, value);
	},

	_attrToDom: function(/*String*/ attr, /*String*/ value){
		// summary:
		//		Reflect a widget attribute (title, tabIndex, duration etc.) to
		//		the widget DOM, as specified in attributeMap.
		//
		// description:
		//		Also sets this["attr"] to the new value.
		//		Note some attributes like "type"
		//		cannot be processed this way as they are not mutable.
		//
		// tags:
		//		private

		var commands = this.attributeMap[attr];
		dojo.forEach(dojo.isArray(commands) ? commands : [commands], function(command){

			// Get target node and what we are doing to that node
			var mapNode = this[command.node || command || "domNode"];	// DOM node
			var type = command.type || "attribute";	// class, innerHTML, innerText, or attribute

			switch(type){
				case "attribute":
					if(dojo.isFunction(value)){ // functions execute in the context of the widget
						value = dojo.hitch(this, value);
					}

					// Get the name of the DOM node attribute; usually it's the same
					// as the name of the attribute in the widget (attr), but can be overridden.
					// Also maps handler names to lowercase, like onSubmit --> onsubmit
					var attrName = command.attribute ? command.attribute :
						(/^on[A-Z][a-zA-Z]*$/.test(attr) ? attr.toLowerCase() : attr);

					dojo.attr(mapNode, attrName, value);
					break;
				case "innerText":
					mapNode.innerHTML = "";
					mapNode.appendChild(dojo.doc.createTextNode(value));
					break;
				case "innerHTML":
					mapNode.innerHTML = value;
					break;
				case "class":
					dojo.removeClass(mapNode, this[attr]);
					dojo.addClass(mapNode, value);
					break;
			}
		}, this);
		this[attr] = value;
	},

	attr: function(/*String|Object*/name, /*Object?*/value){
		// summary:
		//		Set or get properties on a widget instance.
		//	name:
		//		The property to get or set. If an object is passed here and not
		//		a string, its keys are used as names of attributes to be set
		//		and the value of the object as values to set in the widget.
		//	value:
		//		Optional. If provided, attr() operates as a setter. If omitted,
		//		the current value of the named property is returned.
		// description:
		//		Get or set named properties on a widget. If no value is
		//		provided, the current value of the attribute is returned,
		//		potentially via a getter method. If a value is provided, then
		//		the method acts as a setter, assigning the value to the name,
		//		potentially calling any explicitly provided setters to handle
		//		the operation. For instance, if the widget has properties "foo"
		//		and "bar" and a method named "_setFooAttr", calling:
		//	|	myWidget.attr("foo", "Howdy!");
		//		would be equivalent to calling:
		//	|	widget._setFooAttr("Howdy!");
		//		while calling:
		//	|	myWidget.attr("bar", "Howdy!");
		//		would be the same as writing:
		//	|	widget.bar = "Howdy!";
		//		It also tries to copy the changes to the widget's DOM according
		//		to settings in attributeMap (see description of `dijit._Widget.attributeMap`
		//		for details)
		//		For example, calling:
		//	|	myTitlePane.attr("title", "Howdy!");
		//		will do
		//	|	myTitlePane.title = "Howdy!";
		//	|	myTitlePane.title.innerHTML = "Howdy!";
		//		It works for DOM node attributes too.  Calling
		//	|	widget.attr("disabled", true)
		//		will set the disabled attribute on the widget's focusNode,
		//		among other housekeeping for a change in disabled state.

		//	open questions:
		//		- how to handle build shortcut for attributes which want to map
		//		into DOM attributes?
		//		- what relationship should setAttribute()/attr() have to
		//		layout() calls?
		var args = arguments.length;
		if(args == 1 && !dojo.isString(name)){
			for(var x in name){ this.attr(x, name[x]); }
			return this;
		}
		var names = this._getAttrNames(name);
		if(args >= 2){ // setter
			if(this[names.s]){
				// use the explicit setter
				args = dojo._toArray(arguments, 1);
				return this[names.s].apply(this, args) || this;
			}else{
				// if param is specified as DOM node attribute, copy it
				if(name in this.attributeMap){
					this._attrToDom(name, value);
				}

				// FIXME: what about function assignments? Any way to connect() here?
				this[name] = value;
			}
			return this;
		}else{ // getter
			return this[names.g] ? this[names.g]() : this[name];
		}
	},

	_attrPairNames: {},		// shared between all widgets
	_getAttrNames: function(name){
		// summary:
		//		Helper function for Widget.attr().
		//		Caches attribute name values so we don't do the string ops every time.
		// tags:
		//		private

		var apn = this._attrPairNames;
		if(apn[name]){ return apn[name]; }
		var uc = name.charAt(0).toUpperCase() + name.substr(1);
		return (apn[name] = {
			n: name+"Node",
			s: "_set"+uc+"Attr",
			g: "_get"+uc+"Attr"
		});
	},

	toString: function(){
		// summary:
		//		Returns a string that represents the widget
		// description:
		//		When a widget is cast to a string, this method will be used to generate the
		//		output. Currently, it does not implement any sort of reversible
		//		serialization.
		return '[Widget ' + this.declaredClass + ', ' + (this.id || 'NO ID') + ']'; // String
	},

	getDescendants: function(){
		// summary:
		//		Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
		//		This method should generally be avoided as it returns widgets declared in templates, which are
		//		supposed to be internal/hidden, but it's left here for back-compat reasons.

		return this.containerNode ? dojo.query('[widgetId]', this.containerNode).map(dijit.byNode) : []; // dijit._Widget[]
	},

	getChildren: function(){
		// summary:
		//		Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
		//		Does not return nested widgets, nor widgets that are part of this widget's template.
		return this.containerNode ? dijit.findWidgets(this.containerNode) : []; // dijit._Widget[]
	},

	// nodesWithKeyClick: [private] String[]
	//		List of nodes that correctly handle click events via native browser support,
	//		and don't need dijit's help
	nodesWithKeyClick: ["input", "button"],

	connect: function(
			/*Object|null*/ obj,
			/*String|Function*/ event,
			/*String|Function*/ method){
		// summary:
		//		Connects specified obj/event to specified method of this object
		//		and registers for disconnect() on widget destroy.
		// description:
		//		Provide widget-specific analog to dojo.connect, except with the
		//		implicit use of this widget as the target object.
		//		This version of connect also provides a special "ondijitclick"
		//		event which triggers on a click or space or enter keyup
		// returns:
		//		A handle that can be passed to `disconnect` in order to disconnect before
		//		the widget is destroyed.
		// example:
		//	|	var btn = new dijit.form.Button();
		//	|	// when foo.bar() is called, call the listener we're going to
		//	|	// provide in the scope of btn
		//	|	btn.connect(foo, "bar", function(){
		//	|		console.debug(this.toString());
		//	|	});
		// tags:
		//		protected

		var d = dojo,
			dc = d._connect,
			handles = [];
		if(event == "ondijitclick"){
			// add key based click activation for unsupported nodes.
			// do all processing onkey up to prevent spurious clicks
			// for details see comments at top of this file where _lastKeyDownNode is defined
			if(!this.nodesWithKeyClick[obj.tagName.toLowerCase()]){
				var m = d.hitch(this, method);
				handles.push(
					dc(obj, "onkeydown", this, function(e){
						//console.log(this.id + ": onkeydown, e.target = ", e.target, ", lastKeyDownNode was ", dijit._lastKeyDownNode, ", equality is ", (e.target === dijit._lastKeyDownNode));
						if((e.keyCode == d.keys.ENTER || e.keyCode == d.keys.SPACE) &&
							!e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey){
							// needed on IE for when focus changes between keydown and keyup - otherwise dropdown menus do not work
							dijit._lastKeyDownNode = e.target;
							d.stopEvent(e);		// stop event to prevent scrolling on space key in IE
						}
			 		}),
					dc(obj, "onkeyup", this, function(e){
						//console.log(this.id + ": onkeyup, e.target = ", e.target, ", lastKeyDownNode was ", dijit._lastKeyDownNode, ", equality is ", (e.target === dijit._lastKeyDownNode));
						if( (e.keyCode == d.keys.ENTER || e.keyCode == d.keys.SPACE) &&
							e.target === dijit._lastKeyDownNode &&
							!e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey){
								//need reset here or have problems in FF when focus returns to trigger element after closing popup/alert
								dijit._lastKeyDownNode = null;
								return m(e);
						}
					})
				);
			}
			event = "onclick";
		}
		handles.push(dc(obj, event, this, method));

		this._connects.push(handles);
		return handles;		// _Widget.Handle
	},

	disconnect: function(/* _Widget.Handle */ handles){
		// summary:
		//		Disconnects handle created by `connect`.
		//		Also removes handle from this widget's list of connects.
		// tags:
		//		protected
		for(var i=0; i<this._connects.length; i++){
			if(this._connects[i] == handles){
				dojo.forEach(handles, dojo.disconnect);
				this._connects.splice(i, 1);
				return;
			}
		}
	},

	subscribe: function(
			/*String*/ topic,
			/*String|Function*/ method){
		// summary:
		//		Subscribes to the specified topic and calls the specified method
		//		of this object and registers for unsubscribe() on widget destroy.
		// description:
		//		Provide widget-specific analog to dojo.subscribe, except with the
		//		implicit use of this widget as the target object.
		// example:
		//	|	var btn = new dijit.form.Button();
		//	|	// when /my/topic is published, this button changes its label to
		//	|   // be the parameter of the topic.
		//	|	btn.subscribe("/my/topic", function(v){
		//	|		this.attr("label", v);
		//	|	});
		var d = dojo,
			handle = d.subscribe(topic, this, method);

		// return handles for Any widget that may need them
		this._subscribes.push(handle);
		return handle;
	},

	unsubscribe: function(/*Object*/ handle){
		// summary:
		//		Unsubscribes handle created by this.subscribe.
		//		Also removes handle from this widget's list of subscriptions
		for(var i=0; i<this._subscribes.length; i++){
			if(this._subscribes[i] == handle){
				dojo.unsubscribe(handle);
				this._subscribes.splice(i, 1);
				return;
			}
		}
	},

	isLeftToRight: function(){
		// summary:
		//		Checks the page for text direction
		// tags:
		//		protected
		return dojo._isBodyLtr(); //Boolean
	},

	isFocusable: function(){
		// summary:
		//		Return true if this widget can currently be focused
		//		and false if not
		return this.focus && (dojo.style(this.domNode, "display") != "none");
	},

	placeAt: function(/* String|DomNode|_Widget */reference, /* String?|Int? */position){
		// summary:
		//		Place this widget's domNode reference somewhere in the DOM based
		//		on standard dojo.place conventions, or passing a Widget reference that
		//		contains and addChild member.
		//
		// description:
		//		A convenience function provided in all _Widgets, providing a simple
		//		shorthand mechanism to put an existing (or newly created) Widget
		//		somewhere in the dom, and allow chaining.
		//
		// reference:
		//		The String id of a domNode, a domNode reference, or a reference to a Widget posessing
		//		an addChild method.
		//
		// position:
		//		If passed a string or domNode reference, the position argument
		//		accepts a string just as dojo.place does, one of: "first", "last",
		//		"before", or "after".
		//
		//		If passed a _Widget reference, and that widget reference has an ".addChild" method,
		//		it will be called passing this widget instance into that method, supplying the optional
		//		position index passed.
		//
		// returns:
		//		dijit._Widget
		//		Provides a useful return of the newly created dijit._Widget instance so you
		//		can "chain" this function by instantiating, placing, then saving the return value
		//		to a variable.
		//
		// example:
		// | 	// create a Button with no srcNodeRef, and place it in the body:
		// | 	var button = new dijit.form.Button({ label:"click" }).placeAt(dojo.body());
		// | 	// now, 'button' is still the widget reference to the newly created button
		// | 	dojo.connect(button, "onClick", function(e){ console.log('click'); });
		//
		// example:
		// |	// create a button out of a node with id="src" and append it to id="wrapper":
		// | 	var button = new dijit.form.Button({},"src").placeAt("wrapper");
		//
		// example:
		// |	// place a new button as the first element of some div
		// |	var button = new dijit.form.Button({ label:"click" }).placeAt("wrapper","first");
		//
		// example:
		// |	// create a contentpane and add it to a TabContainer
		// |	var tc = dijit.byId("myTabs");
		// |	new dijit.layout.ContentPane({ href:"foo.html", title:"Wow!" }).placeAt(tc)

		if(reference.declaredClass && reference.addChild){
			reference.addChild(this, position);
		}else{
			dojo.place(this.domNode, reference, position);
		}
		return this;
	},

	_onShow: function(){
		// summary:
		//		Internal method called when this widget is made visible.
		//		See `onShow` for details.
		this.onShow();
	},

	onShow: function(){
		// summary:
		//		Called when this widget becomes the selected pane in a
		//		`dijit.layout.TabContainer`, `dijit.layout.StackContainer`,
		//		`dijit.layout.AccordionContainer`, etc.
		//
		//		Also called to indicate display of a `dijit.Dialog`, `dijit.TooltipDialog`, or `dijit.TitlePane`.
		// tags:
		//		callback
	},

	onHide: function(){
		// summary:
			//		Called when another widget becomes the selected pane in a
			//		`dijit.layout.TabContainer`, `dijit.layout.StackContainer`,
			//		`dijit.layout.AccordionContainer`, etc.
			//
			//		Also called to indicate hide of a `dijit.Dialog`, `dijit.TooltipDialog`, or `dijit.TitlePane`.
			// tags:
			//		callback
	}
});

})();

}

if(!dojo._hasResource["dijit._Contained"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._Contained"] = true;
dojo.provide("dijit._Contained");

dojo.declare("dijit._Contained",
		null,
		{
			// summary:
			//		Mixin for widgets that are children of a container widget
			//
			// example:
			// | 	// make a basic custom widget that knows about it's parents
			// |	dojo.declare("my.customClass",[dijit._Widget,dijit._Contained],{});

			getParent: function(){
				// summary:
				//		Returns the parent widget of this widget, assuming the parent
				//		specifies isContainer
				var parent = dijit.getEnclosingWidget(this.domNode.parentNode);
				return parent && parent.isContainer ? parent : null;
			},

			_getSibling: function(/*String*/ which){
				// summary:
				//      Returns next or previous sibling
				// which:
				//      Either "next" or "previous"
				// tags:
				//      private
				var node = this.domNode;
				do{
					node = node[which+"Sibling"];
				}while(node && node.nodeType != 1);
				return node && dijit.byNode(node);	// dijit._Widget
			},

			getPreviousSibling: function(){
				// summary:
				//		Returns null if this is the first child of the parent,
				//		otherwise returns the next element sibling to the "left".

				return this._getSibling("previous"); // dijit._Widget
			},

			getNextSibling: function(){
				// summary:
				//		Returns null if this is the last child of the parent,
				//		otherwise returns the next element sibling to the "right".

				return this._getSibling("next"); // dijit._Widget
			},

			getIndexInParent: function(){
				// summary:
				//		Returns the index of this widget within its container parent.
				//		It returns -1 if the parent does not exist, or if the parent
				//		is not a dijit._Container

				var p = this.getParent();
				if(!p || !p.getIndexOfChild){
					return -1; // int
				}
				return p.getIndexOfChild(this); // int
			}
		}
	);


}

if(!dojo._hasResource["dijit._Container"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._Container"] = true;
dojo.provide("dijit._Container");

dojo.declare("dijit._Container",
	null,
	{
		// summary:
		//		Mixin for widgets that contain a set of widget children.
		// description:
		//		Use this mixin for widgets that needs to know about and
		//		keep track of their widget children. Suitable for widgets like BorderContainer
		//		and TabContainer which contain (only) a set of child widgets.
		//
		//		It's not suitable for widgets like ContentPane
		//		which contains mixed HTML (plain DOM nodes in addition to widgets),
		//		and where contained widgets are not necessarily directly below
		//		this.containerNode.   In that case calls like addChild(node, position)
		//		wouldn't make sense.

		// isContainer: [protected] Boolean
		//		Indicates that this widget acts as a "parent" to the descendant widgets.
		//		When the parent is started it will call startup() on the child widgets.
		//		See also `isLayoutContainer`.
		isContainer: true,

		buildRendering: function(){
			this.inherited(arguments);
			if(!this.containerNode){
				// all widgets with descendants must set containerNode
	 				this.containerNode = this.domNode;
			}
		},

		addChild: function(/*dijit._Widget*/ widget, /*int?*/ insertIndex){
			// summary:
			//		Makes the given widget a child of this widget.
			// description:
			//		Inserts specified child widget's dom node as a child of this widget's
			//		container node, and possibly does other processing (such as layout).

			var refNode = this.containerNode;
			if(insertIndex && typeof insertIndex == "number"){
				var children = this.getChildren();
				if(children && children.length >= insertIndex){
					refNode = children[insertIndex-1].domNode;
					insertIndex = "after";
				}
			}
			dojo.place(widget.domNode, refNode, insertIndex);

			// If I've been started but the child widget hasn't been started,
			// start it now.  Make sure to do this after widget has been
			// inserted into the DOM tree, so it can see that it's being controlled by me,
			// so it doesn't try to size itself.
			if(this._started && !widget._started){
				widget.startup();
			}
		},

		removeChild: function(/*Widget or int*/ widget){
			// summary:
			//		Removes the passed widget instance from this widget but does
			//		not destroy it.  You can also pass in an integer indicating
			//		the index within the container to remove

			if(typeof widget == "number" && widget > 0){
				widget = this.getChildren()[widget];
			}

			if(widget && widget.domNode){
				var node = widget.domNode;
				node.parentNode.removeChild(node); // detach but don't destroy
			}
		},

		getChildren: function(){
			// summary:
			//		Returns array of children widgets.
			// description:
			//		Returns the widgets that are directly under this.containerNode.
			return dojo.query("> [widgetId]", this.containerNode).map(dijit.byNode); // Widget[]
		},

		hasChildren: function(){
			// summary:
			//		Returns true if widget has children, i.e. if this.containerNode contains something.
			return dojo.query("> [widgetId]", this.containerNode).length > 0;	// Boolean
		},

		destroyDescendants: function(/*Boolean*/ preserveDom){
			// summary:
			//      Destroys all the widgets inside this.containerNode,
			//      but not this widget itself
			dojo.forEach(this.getChildren(), function(child){ child.destroyRecursive(preserveDom); });
		},

		_getSiblingOfChild: function(/*dijit._Widget*/ child, /*int*/ dir){
			// summary:
			//		Get the next or previous widget sibling of child
			// dir:
			//		if 1, get the next sibling
			//		if -1, get the previous sibling
			// tags:
			//      private
			var node = child.domNode,
				which = (dir>0 ? "nextSibling" : "previousSibling");
			do{
				node = node[which];
			}while(node && (node.nodeType != 1 || !dijit.byNode(node)));
			return node && dijit.byNode(node);	// dijit._Widget
		},

		getIndexOfChild: function(/*dijit._Widget*/ child){
			// summary:
			//		Gets the index of the child in this container or -1 if not found
			return dojo.indexOf(this.getChildren(), child);	// int
		},

		startup: function(){
			// summary:
			//		Called after all the widgets have been instantiated and their
			//		dom nodes have been inserted somewhere under dojo.doc.body.
			//
			//		Widgets should override this method to do any initialization
			//		dependent on other widgets existing, and then call
			//		this superclass method to finish things off.
			//
			//		startup() in subclasses shouldn't do anything
			//		size related because the size of the widget hasn't been set yet.

			if(this._started){ return; }

			// Startup all children of this widget
			dojo.forEach(this.getChildren(), function(child){ child.startup(); });

			this.inherited(arguments);
		}
	}
);

}

if(!dojo._hasResource["dijit.layout._LayoutWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout._LayoutWidget"] = true;
dojo.provide("dijit.layout._LayoutWidget");





dojo.declare("dijit.layout._LayoutWidget",
	[dijit._Widget, dijit._Container, dijit._Contained],
	{
		// summary:
		//		Base class for a _Container widget which is responsible for laying out its children.
		//		Widgets which mixin this code must define layout() to manage placement and sizing of the children.

		// baseClass: [protected extension] String
		//		This class name is applied to the widget's domNode
		//		and also may be used to generate names for sub nodes,
		//		for example dijitTabContainer-content.
		baseClass: "dijitLayoutContainer",

		// isLayoutContainer: [protected] Boolean
		//		Indicates that this widget is going to call resize() on its
		//		children widgets, setting their size, when they become visible.
		isLayoutContainer: true,

		postCreate: function(){
			dojo.addClass(this.domNode, "dijitContainer");
			dojo.addClass(this.domNode, this.baseClass);

			this.inherited(arguments);
		},

		startup: function(){
			// summary:
			//		Called after all the widgets have been instantiated and their
			//		dom nodes have been inserted somewhere under dojo.doc.body.
			//
			//		Widgets should override this method to do any initialization
			//		dependent on other widgets existing, and then call
			//		this superclass method to finish things off.
			//
			//		startup() in subclasses shouldn't do anything
			//		size related because the size of the widget hasn't been set yet.

			if(this._started){ return; }

			// Need to call inherited first - so that child widgets get started
			// up correctly
			this.inherited(arguments);

			// If I am a not being controlled by a parent layout widget...
			var parent = this.getParent && this.getParent()
			if(!(parent && parent.isLayoutContainer)){
				// Do recursive sizing and layout of all my descendants
				// (passing in no argument to resize means that it has to glean the size itself)
				this.resize();

				// Since my parent isn't a layout container, and my style *may be* width=height=100%
				// or something similar (either set directly or via a CSS class),
				// monitor when my size changes so that I can re-layout.
				// For browsers where I can't directly monitor when my size changes,
				// monitor when the viewport changes size, which *may* indicate a size change for me.
				this.connect(dojo.isIE ? this.domNode : dojo.global, 'onresize', function(){
					// Using function(){} closure to ensure no arguments to resize.
					this.resize();
				});
			}
		},

		resize: function(changeSize, resultSize){
			// summary:
			//		Call this to resize a widget, or after its size has changed.
			// description:
			//		Change size mode:
			//			When changeSize is specified, changes the marginBox of this widget
			//			and forces it to relayout its contents accordingly.
			//			changeSize may specify height, width, or both.
			//
			//			If resultSize is specified it indicates the size the widget will
			//			become after changeSize has been applied.
			//
			//		Notification mode:
			//			When changeSize is null, indicates that the caller has already changed
			//			the size of the widget, or perhaps it changed because the browser
			//			window was resized.  Tells widget to relayout its contents accordingly.
			//
			//			If resultSize is also specified it indicates the size the widget has
			//			become.
			//
			//		In either mode, this method also:
			//			1. Sets this._borderBox and this._contentBox to the new size of
			//				the widget.  Queries the current domNode size if necessary.
			//			2. Calls layout() to resize contents (and maybe adjust child widgets).
			//
			// changeSize: Object?
			//		Sets the widget to this margin-box size and position.
			//		May include any/all of the following properties:
			//	|	{w: int, h: int, l: int, t: int}
			//
			// resultSize: Object?
			//		The margin-box size of this widget after applying changeSize (if
			//		changeSize is specified).  If caller knows this size and
			//		passes it in, we don't need to query the browser to get the size.
			//	|	{w: int, h: int}

			var node = this.domNode;

			// set margin box size, unless it wasn't specified, in which case use current size
			if(changeSize){
				dojo.marginBox(node, changeSize);

				// set offset of the node
				if(changeSize.t){ node.style.top = changeSize.t + "px"; }
				if(changeSize.l){ node.style.left = changeSize.l + "px"; }
			}

			// If either height or width wasn't specified by the user, then query node for it.
			// But note that setting the margin box and then immediately querying dimensions may return
			// inaccurate results, so try not to depend on it.
			var mb = resultSize || {};
			dojo.mixin(mb, changeSize || {});	// changeSize overrides resultSize
			if( !("h" in mb) || !("w" in mb) ){
				mb = dojo.mixin(dojo.marginBox(node), mb);	// just use dojo.marginBox() to fill in missing values
			}

			// Compute and save the size of my border box and content box
			// (w/out calling dojo.contentBox() since that may fail if size was recently set)
			var cs = dojo.getComputedStyle(node);
			var me = dojo._getMarginExtents(node, cs);
			var be = dojo._getBorderExtents(node, cs);
			var bb = (this._borderBox = {
				w: mb.w - (me.w + be.w),
				h: mb.h - (me.h + be.h)
			});
			var pe = dojo._getPadExtents(node, cs);
			this._contentBox = {
				l: dojo._toPixelValue(node, cs.paddingLeft),
				t: dojo._toPixelValue(node, cs.paddingTop),
				w: bb.w - pe.w,
				h: bb.h - pe.h
			};

			// Callback for widget to adjust size of its children
			this.layout();
		},

		layout: function(){
			// summary:
			//		Widgets override this method to size and position their contents/children.
			//		When this is called this._contentBox is guaranteed to be set (see resize()).
			//
			//		This is called after startup(), and also when the widget's size has been
			//		changed.
			// tags:
			//		protected extension
		},

		_setupChild: function(/*dijit._Widget*/child){
			// summary:
			//		Common setup for initial children and children which are added after startup
			// tags:
			//		protected extension

			dojo.addClass(child.domNode, this.baseClass+"-child");
			if(child.baseClass){
				dojo.addClass(child.domNode, this.baseClass+"-"+child.baseClass);
			}
		},

		addChild: function(/*dijit._Widget*/ child, /*Integer?*/ insertIndex){
			// Overrides _Container.addChild() to call _setupChild()
			this.inherited(arguments);
			if(this._started){
				this._setupChild(child);
			}
		},

		removeChild: function(/*dijit._Widget*/ child){
			// Overrides _Container.removeChild() to remove class added by _setupChild()
			dojo.removeClass(child.domNode, this.baseClass+"-child");
			if(child.baseClass){
				dojo.removeClass(child.domNode, this.baseClass+"-"+child.baseClass);
			}
			this.inherited(arguments);
		}
	}
);

dijit.layout.marginBox2contentBox = function(/*DomNode*/ node, /*Object*/ mb){
	// summary:
	//		Given the margin-box size of a node, return its content box size.
	//		Functions like dojo.contentBox() but is more reliable since it doesn't have
	//		to wait for the browser to compute sizes.
	var cs = dojo.getComputedStyle(node);
	var me = dojo._getMarginExtents(node, cs);
	var pb = dojo._getPadBorderExtents(node, cs);
	return {
		l: dojo._toPixelValue(node, cs.paddingLeft),
		t: dojo._toPixelValue(node, cs.paddingTop),
		w: mb.w - (me.w + pb.w),
		h: mb.h - (me.h + pb.h)
	};
};

(function(){
	var capitalize = function(word){
		return word.substring(0,1).toUpperCase() + word.substring(1);
	};

	var size = function(widget, dim){
		// size the child
		widget.resize ? widget.resize(dim) : dojo.marginBox(widget.domNode, dim);

		// record child's size, but favor our own numbers when we have them.
		// the browser lies sometimes
		dojo.mixin(widget, dojo.marginBox(widget.domNode));
		dojo.mixin(widget, dim);
	};

	dijit.layout.layoutChildren = function(/*DomNode*/ container, /*Object*/ dim, /*Object[]*/ children){
		// summary
		//		Layout a bunch of child dom nodes within a parent dom node
		// container:
		//		parent node
		// dim:
		//		{l, t, w, h} object specifying dimensions of container into which to place children
		// children:
		//		an array like [ {domNode: foo, layoutAlign: "bottom" }, {domNode: bar, layoutAlign: "client"} ]

		// copy dim because we are going to modify it
		dim = dojo.mixin({}, dim);

		dojo.addClass(container, "dijitLayoutContainer");

		// Move "client" elements to the end of the array for layout.  a11y dictates that the author
		// needs to be able to put them in the document in tab-order, but this algorithm requires that
		// client be last.
		children = dojo.filter(children, function(item){ return item.layoutAlign != "client"; })
			.concat(dojo.filter(children, function(item){ return item.layoutAlign == "client"; }));

		// set positions/sizes
		dojo.forEach(children, function(child){
			var elm = child.domNode,
				pos = child.layoutAlign;

			// set elem to upper left corner of unused space; may move it later
			var elmStyle = elm.style;
			elmStyle.left = dim.l+"px";
			elmStyle.top = dim.t+"px";
			elmStyle.bottom = elmStyle.right = "auto";

			dojo.addClass(elm, "dijitAlign" + capitalize(pos));

			// set size && adjust record of remaining space.
			// note that setting the width of a <div> may affect its height.
			if(pos == "top" || pos == "bottom"){
				size(child, { w: dim.w });
				dim.h -= child.h;
				if(pos == "top"){
					dim.t += child.h;
				}else{
					elmStyle.top = dim.t + dim.h + "px";
				}
			}else if(pos == "left" || pos == "right"){
				size(child, { h: dim.h });
				dim.w -= child.w;
				if(pos == "left"){
					dim.l += child.w;
				}else{
					elmStyle.left = dim.l + dim.w + "px";
				}
			}else if(pos == "client"){
				size(child, dim);
			}
		});
	};

})();

}

if(!dojo._hasResource["dojo.html"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.html"] = true;
dojo.provide("dojo.html");

// the parser might be needed..
 

(function(){ // private scope, sort of a namespace

	// idCounter is incremented with each instantiation to allow asignment of a unique id for tracking, logging purposes
	var idCounter = 0, 
		d = dojo;
	
	dojo.html._secureForInnerHtml = function(/*String*/ cont){
		// summary:
		//		removes !DOCTYPE and title elements from the html string.
		// 
		//		khtml is picky about dom faults, you can't attach a style or <title> node as child of body
		//		must go into head, so we need to cut out those tags
		//	cont:
		//		An html string for insertion into the dom
		//	
		return cont.replace(/(?:\s*<!DOCTYPE\s[^>]+>|<title[^>]*>[\s\S]*?<\/title>)/ig, ""); // String
	};

/*====
	dojo.html._emptyNode = function(node){
		// summary:
		//		removes all child nodes from the given node
		//	node: DOMNode
		//		the parent element
	};
=====*/
	dojo.html._emptyNode = dojo.empty;

	dojo.html._setNodeContent = function(/* DomNode */ node, /* String|DomNode|NodeList */ cont){
		// summary:
		//		inserts the given content into the given node
		//	node:
		//		the parent element
		//	content:
		//		the content to be set on the parent element. 
		//		This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes
		
		// always empty
		d.empty(node);

		if(cont) {
			if(typeof cont == "string") {
				cont = d._toDom(cont, node.ownerDocument);
			}
			if(!cont.nodeType && d.isArrayLike(cont)) {
				// handle as enumerable, but it may shrink as we enumerate it
				for(var startlen=cont.length, i=0; i<cont.length; i=startlen==cont.length ? i+1 : 0) {
					d.place( cont[i], node, "last");
				}
			} else {
				// pass nodes, documentFragments and unknowns through to dojo.place
				d.place(cont, node, "last");
			}
		}

		// return DomNode
		return node;
	};

	// we wrap up the content-setting operation in a object
	dojo.declare("dojo.html._ContentSetter", null, 
		{
			// node: DomNode|String
			//		An node which will be the parent element that we set content into
			node: "",

			// content: String|DomNode|DomNode[]
			//		The content to be placed in the node. Can be an HTML string, a node reference, or a enumerable list of nodes
			content: "",
			
			// id: String?
			//		Usually only used internally, and auto-generated with each instance 
			id: "",

			// cleanContent: Boolean
			//		Should the content be treated as a full html document, 
			//		and the real content stripped of <html>, <body> wrapper before injection
			cleanContent: false,
			
			// extractContent: Boolean
			//		Should the content be treated as a full html document, and the real content stripped of <html>, <body> wrapper before injection
			extractContent: false,

			// parseContent: Boolean
			//		Should the node by passed to the parser after the new content is set
			parseContent: false,
			
			// lifecyle methods
			constructor: function(/* Object */params, /* String|DomNode */node){
				//	summary:
				//		Provides a configurable, extensible object to wrap the setting on content on a node
				//		call the set() method to actually set the content..
 
				// the original params are mixed directly into the instance "this"
				dojo.mixin(this, params || {});

				// give precedence to params.node vs. the node argument
				// and ensure its a node, not an id string
				node = this.node = dojo.byId( this.node || node );
	
				if(!this.id){
					this.id = [
						"Setter",
						(node) ? node.id || node.tagName : "", 
						idCounter++
					].join("_");
				}

				if(! (this.node || node)){
					new Error(this.declaredClass + ": no node provided to " + this.id);
				}
			},
			set: function(/* String|DomNode|NodeList? */ cont, /* Object? */ params){
				// summary:
				//		front-end to the set-content sequence 
				//	cont:
				//		An html string, node or enumerable list of nodes for insertion into the dom
				//		If not provided, the object's content property will be used
				if(undefined !== cont){
					this.content = cont;
				}
				// in the re-use scenario, set needs to be able to mixin new configuration
				if(params){
					this._mixin(params);
				}

				this.onBegin();
				this.setContent();
				this.onEnd();

				return this.node;
			},
			setContent: function(){
				// summary:
				//		sets the content on the node 

				var node = this.node; 
				if(!node) {
					console.error("setContent given no node");
				}
				try{
					node = dojo.html._setNodeContent(node, this.content);
				}catch(e){
					// check if a domfault occurs when we are appending this.errorMessage
					// like for instance if domNode is a UL and we try append a DIV
	
					// FIXME: need to allow the user to provide a content error message string
					var errMess = this.onContentError(e); 
					try{
						node.innerHTML = errMess;
					}catch(e){
						console.error('Fatal ' + this.declaredClass + '.setContent could not change content due to '+e.message, e);
					}
				}
				// always put back the node for the next method
				this.node = node; // DomNode
			},
			
			empty: function() {
				// summary
				//	cleanly empty out existing content

				// destroy any widgets from a previous run
				// NOTE: if you dont want this you'll need to empty 
				// the parseResults array property yourself to avoid bad things happenning
				if(this.parseResults && this.parseResults.length) {
					dojo.forEach(this.parseResults, function(w) {
						if(w.destroy){
							w.destroy();
						}
					});
					delete this.parseResults;
				}
				// this is fast, but if you know its already empty or safe, you could 
				// override empty to skip this step
				dojo.html._emptyNode(this.node);
			},
	
			onBegin: function(){
				// summary
				//		Called after instantiation, but before set(); 
				//		It allows modification of any of the object properties 
				//		- including the node and content provided - before the set operation actually takes place
				//		This default implementation checks for cleanContent and extractContent flags to 
				//		optionally pre-process html string content
				var cont = this.content;
	
				if(dojo.isString(cont)){
					if(this.cleanContent){
						cont = dojo.html._secureForInnerHtml(cont);
					}
  
					if(this.extractContent){
						var match = cont.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
						if(match){ cont = match[1]; }
					}
				}

				// clean out the node and any cruft associated with it - like widgets
				this.empty();
				
				this.content = cont;
				return this.node; /* DomNode */
			},
	
			onEnd: function(){
				// summary
				//		Called after set(), when the new content has been pushed into the node
				//		It provides an opportunity for post-processing before handing back the node to the caller
				//		This default implementation checks a parseContent flag to optionally run the dojo parser over the new content
				if(this.parseContent){
					// populates this.parseResults if you need those..
					this._parse();
				}
				return this.node; /* DomNode */
			},
	
			tearDown: function(){
				// summary
				//		manually reset the Setter instance if its being re-used for example for another set()
				// description
				//		tearDown() is not called automatically. 
				//		In normal use, the Setter instance properties are simply allowed to fall out of scope
				//		but the tearDown method can be called to explicitly reset this instance.
				delete this.parseResults; 
				delete this.node; 
				delete this.content; 
			},
  
			onContentError: function(err){
				return "Error occured setting content: " + err; 
			},
			
			_mixin: function(params){
				// mix properties/methods into the instance
				// TODO: the intention with tearDown is to put the Setter's state 
				// back to that of the original constructor (vs. deleting/resetting everything regardless of ctor params)
				// so we could do something here to move the original properties aside for later restoration
				var empty = {}, key;
				for(key in params){
					if(key in empty){ continue; }
					// TODO: here's our opportunity to mask the properties we dont consider configurable/overridable
					// .. but history shows we'll almost always guess wrong
					this[key] = params[key]; 
				}
			},
			_parse: function(){
				// summary: 
				//		runs the dojo parser over the node contents, storing any results in this.parseResults
				//		Any errors resulting from parsing are passed to _onError for handling

				var rootNode = this.node;
				try{
					// store the results (widgets, whatever) for potential retrieval
					this.parseResults = dojo.parser.parse(rootNode, true);
				}catch(e){
					this._onError('Content', e, "Error parsing in _ContentSetter#"+this.id);
				}
			},
  
			_onError: function(type, err, consoleText){
				// summary:
				//		shows user the string that is returned by on[type]Error
				//		overide/implement on[type]Error and return your own string to customize
				var errText = this['on' + type + 'Error'].call(this, err);
				if(consoleText){
					console.error(consoleText, err);
				}else if(errText){ // a empty string won't change current content
					dojo.html._setNodeContent(this.node, errText, true);
				}
			}
	}); // end dojo.declare()

	dojo.html.set = function(/* DomNode */ node, /* String|DomNode|NodeList */ cont, /* Object? */ params){
			// summary:
			//		inserts (replaces) the given content into the given node. dojo.place(cont, node, "only")
			//		may be a better choice for simple HTML insertion.
			// description:
			//		Unless you need to use the params capabilities of this method, you should use
			//		dojo.place(cont, node, "only"). dojo.place() has more robust support for injecting
			//		an HTML string into the DOM, but it only handles inserting an HTML string as DOM
			//		elements, or inserting a DOM node. dojo.place does not handle NodeList insertions
			//		or the other capabilities as defined by the params object for this method.
			//	node:
			//		the parent element that will receive the content
			//	cont:
			//		the content to be set on the parent element. 
			//		This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes
			//	params: 
			//		Optional flags/properties to configure the content-setting. See dojo.html._ContentSetter
			//	example:
			//		A safe string/node/nodelist content replacement/injection with hooks for extension
			//		Example Usage: 
			//		dojo.html.set(node, "some string"); 
			//		dojo.html.set(node, contentNode, {options}); 
			//		dojo.html.set(node, myNode.childNodes, {options}); 
		if(undefined == cont){
			console.warn("dojo.html.set: no cont argument provided, using empty string");
			cont = "";
		}	
		if(!params){
			// simple and fast
			return dojo.html._setNodeContent(node, cont, true);
		}else{ 
			// more options but slower
			// note the arguments are reversed in order, to match the convention for instantiation via the parser
			var op = new dojo.html._ContentSetter(dojo.mixin( 
					params, 
					{ content: cont, node: node } 
			));
			return op.set();
		}
	};
})();

}

if(!dojo._hasResource["dojo.i18n"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.i18n"] = true;
dojo.provide("dojo.i18n");

/*=====
dojo.i18n = {
	// summary: Utility classes to enable loading of resources for internationalization (i18n)
};
=====*/

dojo.i18n.getLocalization = function(/*String*/packageName, /*String*/bundleName, /*String?*/locale){
	//	summary:
	//		Returns an Object containing the localization for a given resource
	//		bundle in a package, matching the specified locale.
	//	description:
	//		Returns a hash containing name/value pairs in its prototypesuch
	//		that values can be easily overridden.  Throws an exception if the
	//		bundle is not found.  Bundle must have already been loaded by
	//		`dojo.requireLocalization()` or by a build optimization step.  NOTE:
	//		try not to call this method as part of an object property
	//		definition (`var foo = { bar: dojo.i18n.getLocalization() }`).  In
	//		some loading situations, the bundle may not be available in time
	//		for the object definition.  Instead, call this method inside a
	//		function that is run after all modules load or the page loads (like
	//		in `dojo.addOnLoad()`), or in a widget lifecycle method.
	//	packageName:
	//		package which is associated with this resource
	//	bundleName:
	//		the base filename of the resource bundle (without the ".js" suffix)
	//	locale:
	//		the variant to load (optional).  By default, the locale defined by
	//		the host environment: dojo.locale

	locale = dojo.i18n.normalizeLocale(locale);

	// look for nearest locale match
	var elements = locale.split('-');
	var module = [packageName,"nls",bundleName].join('.');
	var bundle = dojo._loadedModules[module];
	if(bundle){
		var localization;
		for(var i = elements.length; i > 0; i--){
			var loc = elements.slice(0, i).join('_');
			if(bundle[loc]){
				localization = bundle[loc];
				break;
			}
		}
		if(!localization){
			localization = bundle.ROOT;
		}

		// make a singleton prototype so that the caller won't accidentally change the values globally
		if(localization){
			var clazz = function(){};
			clazz.prototype = localization;
			return new clazz(); // Object
		}
	}

	throw new Error("Bundle not found: " + bundleName + " in " + packageName+" , locale=" + locale);
};

dojo.i18n.normalizeLocale = function(/*String?*/locale){
	//	summary:
	//		Returns canonical form of locale, as used by Dojo.
	//
	//  description:
	//		All variants are case-insensitive and are separated by '-' as specified in [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt).
	//		If no locale is specified, the dojo.locale is returned.  dojo.locale is defined by
	//		the user agent's locale unless overridden by djConfig.

	var result = locale ? locale.toLowerCase() : dojo.locale;
	if(result == "root"){
		result = "ROOT";
	}
	return result; // String
};

dojo.i18n._requireLocalization = function(/*String*/moduleName, /*String*/bundleName, /*String?*/locale, /*String?*/availableFlatLocales){
	//	summary:
	//		See dojo.requireLocalization()
	//	description:
	// 		Called by the bootstrap, but factored out so that it is only
	// 		included in the build when needed.

	var targetLocale = dojo.i18n.normalizeLocale(locale);
 	var bundlePackage = [moduleName, "nls", bundleName].join(".");
	// NOTE: 
	//		When loading these resources, the packaging does not match what is
	//		on disk.  This is an implementation detail, as this is just a
	//		private data structure to hold the loaded resources.  e.g.
	//		`tests/hello/nls/en-us/salutations.js` is loaded as the object
	//		`tests.hello.nls.salutations.en_us={...}` The structure on disk is
	//		intended to be most convenient for developers and translators, but
	//		in memory it is more logical and efficient to store in a different
	//		order.  Locales cannot use dashes, since the resulting path will
	//		not evaluate as valid JS, so we translate them to underscores.
	
	//Find the best-match locale to load if we have available flat locales.
	var bestLocale = "";
	if(availableFlatLocales){
		var flatLocales = availableFlatLocales.split(",");
		for(var i = 0; i < flatLocales.length; i++){
			//Locale must match from start of string.
			//Using ["indexOf"] so customBase builds do not see
			//this as a dojo._base.array dependency.
			if(targetLocale["indexOf"](flatLocales[i]) == 0){
				if(flatLocales[i].length > bestLocale.length){
					bestLocale = flatLocales[i];
				}
			}
		}
		if(!bestLocale){
			bestLocale = "ROOT";
		}		
	}

	//See if the desired locale is already loaded.
	var tempLocale = availableFlatLocales ? bestLocale : targetLocale;
	var bundle = dojo._loadedModules[bundlePackage];
	var localizedBundle = null;
	if(bundle){
		if(dojo.config.localizationComplete && bundle._built){return;}
		var jsLoc = tempLocale.replace(/-/g, '_');
		var translationPackage = bundlePackage+"."+jsLoc;
		localizedBundle = dojo._loadedModules[translationPackage];
	}

	if(!localizedBundle){
		bundle = dojo["provide"](bundlePackage);
		var syms = dojo._getModuleSymbols(moduleName);
		var modpath = syms.concat("nls").join("/");
		var parent;

		dojo.i18n._searchLocalePath(tempLocale, availableFlatLocales, function(loc){
			var jsLoc = loc.replace(/-/g, '_');
			var translationPackage = bundlePackage + "." + jsLoc;
			var loaded = false;
			if(!dojo._loadedModules[translationPackage]){
				// Mark loaded whether it's found or not, so that further load attempts will not be made
				dojo["provide"](translationPackage);
				var module = [modpath];
				if(loc != "ROOT"){module.push(loc);}
				module.push(bundleName);
				var filespec = module.join("/") + '.js';
				loaded = dojo._loadPath(filespec, null, function(hash){
					// Use singleton with prototype to point to parent bundle, then mix-in result from loadPath
					var clazz = function(){};
					clazz.prototype = parent;
					bundle[jsLoc] = new clazz();
					for(var j in hash){ bundle[jsLoc][j] = hash[j]; }
				});
			}else{
				loaded = true;
			}
			if(loaded && bundle[jsLoc]){
				parent = bundle[jsLoc];
			}else{
				bundle[jsLoc] = parent;
			}
			
			if(availableFlatLocales){
				//Stop the locale path searching if we know the availableFlatLocales, since
				//the first call to this function will load the only bundle that is needed.
				return true;
			}
		});
	}

	//Save the best locale bundle as the target locale bundle when we know the
	//the available bundles.
	if(availableFlatLocales && targetLocale != bestLocale){
		bundle[targetLocale.replace(/-/g, '_')] = bundle[bestLocale.replace(/-/g, '_')];
	}
};

(function(){
	// If other locales are used, dojo.requireLocalization should load them as
	// well, by default. 
	// 
	// Override dojo.requireLocalization to do load the default bundle, then
	// iterate through the extraLocale list and load those translations as
	// well, unless a particular locale was requested.

	var extra = dojo.config.extraLocale;
	if(extra){
		if(!extra instanceof Array){
			extra = [extra];
		}

		var req = dojo.i18n._requireLocalization;
		dojo.i18n._requireLocalization = function(m, b, locale, availableFlatLocales){
			req(m,b,locale, availableFlatLocales);
			if(locale){return;}
			for(var i=0; i<extra.length; i++){
				req(m,b,extra[i], availableFlatLocales);
			}
		};
	}
})();

dojo.i18n._searchLocalePath = function(/*String*/locale, /*Boolean*/down, /*Function*/searchFunc){
	//	summary:
	//		A helper method to assist in searching for locale-based resources.
	//		Will iterate through the variants of a particular locale, either up
	//		or down, executing a callback function.  For example, "en-us" and
	//		true will try "en-us" followed by "en" and finally "ROOT".

	locale = dojo.i18n.normalizeLocale(locale);

	var elements = locale.split('-');
	var searchlist = [];
	for(var i = elements.length; i > 0; i--){
		searchlist.push(elements.slice(0, i).join('-'));
	}
	searchlist.push(false);
	if(down){searchlist.reverse();}

	for(var j = searchlist.length - 1; j >= 0; j--){
		var loc = searchlist[j] || "ROOT";
		var stop = searchFunc(loc);
		if(stop){ break; }
	}
};

dojo.i18n._preloadLocalizations = function(/*String*/bundlePrefix, /*Array*/localesGenerated){
	//	summary:
	//		Load built, flattened resource bundles, if available for all
	//		locales used in the page. Only called by built layer files.

	function preload(locale){
		locale = dojo.i18n.normalizeLocale(locale);
		dojo.i18n._searchLocalePath(locale, true, function(loc){
			for(var i=0; i<localesGenerated.length;i++){
				if(localesGenerated[i] == loc){
					dojo["require"](bundlePrefix+"_"+loc);
					return true; // Boolean
				}
			}
			return false; // Boolean
		});
	}
	preload();
	var extra = dojo.config.extraLocale||[];
	for(var i=0; i<extra.length; i++){
		preload(extra[i]);
	}
};

}

if(!dojo._hasResource["dijit.layout.ContentPane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.ContentPane"] = true;
dojo.provide("dijit.layout.ContentPane");



	// for dijit.layout.marginBox2contentBox()






dojo.declare(
	"dijit.layout.ContentPane", dijit._Widget,
{
	// summary:
	//		A widget that acts as a container for mixed HTML and widgets, and includes an Ajax interface
	// description:
	//		A widget that can be used as a stand alone widget
	//		or as a base class for other widgets.
	//
	//		Handles replacement of document fragment using either external uri or javascript
	//		generated markup or DOM content, instantiating widgets within that content.
	//		Don't confuse it with an iframe, it only needs/wants document fragments.
	//		It's useful as a child of LayoutContainer, SplitContainer, or TabContainer.
	//		But note that those classes can contain any widget as a child.
	// example:
	//		Some quick samples:
	//		To change the innerHTML use .attr('content', '<b>new content</b>')
	//
	//		Or you can send it a NodeList, .attr('content', dojo.query('div [class=selected]', userSelection))
	//		please note that the nodes in NodeList will copied, not moved
	//
	//		To do a ajax update use .attr('href', url)

	// href: String
	//		The href of the content that displays now.
	//		Set this at construction if you want to load data externally when the
	//		pane is shown.  (Set preload=true to load it immediately.)
	//		Changing href after creation doesn't have any effect; use attr('href', ...);
	href: "",

/*=====
	// content: String || DomNode || NodeList || dijit._Widget
	//		The innerHTML of the ContentPane.
	//		Note that the initialization parameter / argument to attr("content", ...)
	//		can be a String, DomNode, Nodelist, or _Widget.
	content: "",
=====*/

	// extractContent: Boolean
	//		Extract visible content from inside of <body> .... </body>.
	//		I.e., strip <html> and <head> (and it's contents) from the href
	extractContent: false,

	// parseOnLoad: Boolean
	//		Parse content and create the widgets, if any.
	parseOnLoad: true,

	// preventCache: Boolean
	//		Prevent caching of data from href's by appending a timestamp to the href.
	preventCache: false,

	// preload: Boolean
	//		Force load of data on initialization even if pane is hidden.
	preload: false,

	// refreshOnShow: Boolean
	//		Refresh (re-download) content when pane goes from hidden to shown
	refreshOnShow: false,

	// loadingMessage: String
	//		Message that shows while downloading
	loadingMessage: "<span class='dijitContentPaneLoading'>${loadingState}</span>",

	// errorMessage: String
	//		Message that shows if an error occurs
	errorMessage: "<span class='dijitContentPaneError'>${errorState}</span>",

	// isLoaded: [readonly] Boolean
	//		True if the ContentPane has data in it, either specified
	//		during initialization (via href or inline content), or set
	//		via attr('content', ...) / attr('href', ...)
	//
	//		False if it doesn't have any content, or if ContentPane is
	//		still in the process of downloading href.
	isLoaded: false,

	baseClass: "dijitContentPane",

	// doLayout: Boolean
	//		- false - don't adjust size of children
	//		- true - if there is a single visible child widget, set it's size to
	//				however big the ContentPane is
	doLayout: true,

	// ioArgs: Object
	//		Parameters to pass to xhrGet() request, for example:
	// |	<div dojoType="dijit.layout.ContentPane" href="./bar" ioArgs="{timeout: 500}">
	ioArgs: {},

	// isContainer: [protected] Boolean
	//		Indicates that this widget acts as a "parent" to the descendant widgets.
	//		When the parent is started it will call startup() on the child widgets.
	//		See also `isLayoutContainer`.
	isContainer: true,

	// isLayoutContainer: [protected] Boolean
	//		Indicates that this widget will call resize() on it's child widgets
	//		when they become visible.
	isLayoutContainer: true,

	// onLoadDeferred: [readonly] dojo.Deferred
	//		This is the `dojo.Deferred` returned by attr('href', ...) and refresh().
	//		Calling onLoadDeferred.addCallback() or addErrback() registers your
	//		callback to be called only once, when the prior attr('href', ...) call or
	//		the initial href parameter to the constructor finishes loading.
	//
	//		This is different than an onLoad() handler which gets called any time any href is loaded.
	onLoadDeferred: null,

	// Override _Widget's attributeMap because we don't want the title attribute (used to specify
	// tab labels) to be copied to ContentPane.domNode... otherwise a tooltip shows up over the
	// entire pane.
	attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
		title: []
	}),

	postMixInProperties: function(){
		this.inherited(arguments);
		var messages = dojo.i18n.getLocalization("dijit", "loading", this.lang);
		this.loadingMessage = dojo.string.substitute(this.loadingMessage, messages);
		this.errorMessage = dojo.string.substitute(this.errorMessage, messages);

		// Detect if we were initialized with data
		if(!this.href && this.srcNodeRef && this.srcNodeRef.innerHTML){
			this.isLoaded = true;
		}
	},

	buildRendering: function(){
		// Overrides Widget.buildRendering().
		// Since we have no template we need to set this.containerNode ourselves.
		// For subclasses of ContentPane do have a template, does nothing.
		this.inherited(arguments);
		if(!this.containerNode){
			// make getDescendants() work
			this.containerNode = this.domNode;
		}
	},

	postCreate: function(){
		// remove the title attribute so it doesn't show up when hovering
		// over a node
		this.domNode.title = "";

		if(!dojo.attr(this.domNode,"role")){
			dijit.setWaiRole(this.domNode, "group");
		}

		dojo.addClass(this.domNode, this.baseClass);
	},

	startup: function(){
		// summary:
		//		See `dijit.layout._LayoutWidget.startup` for description.
		//		Although ContentPane doesn't extend _LayoutWidget, it does implement
		//		the same API.
		if(this._started){ return; }

		var parent = dijit._Contained.prototype.getParent.call(this);
		this._childOfLayoutWidget = parent && parent.isLayoutContainer;

		// I need to call resize() on my child/children (when I become visible), unless
		// I'm the child of a layout widget in which case my parent will call resize() on me and I'll do it then.
		this._needLayout = !this._childOfLayoutWidget;

		if(this.isLoaded){
			dojo.forEach(this.getChildren(), function(child){
				child.startup();
			});
		}

		if(this._isShown() || this.preload){
			this._onShow();
		}

		this.inherited(arguments);
	},

	_checkIfSingleChild: function(){
		// summary:
		//		Test if we have exactly one visible widget as a child,
		//		and if so assume that we are a container for that widget,
		//		and should propogate startup() and resize() calls to it.
		//		Skips over things like data stores since they aren't visible.

		var childNodes = dojo.query("> *", this.containerNode).filter(function(node){
				return node.tagName !== "SCRIPT"; // or a regexp for hidden elements like script|area|map|etc..
			}),
			childWidgetNodes = childNodes.filter(function(node){
				return dojo.hasAttr(node, "dojoType") || dojo.hasAttr(node, "widgetId");
			}),
			candidateWidgets = dojo.filter(childWidgetNodes.map(dijit.byNode), function(widget){
				return widget && widget.domNode && widget.resize;
			});

		if(
			// all child nodes are widgets
			childNodes.length == childWidgetNodes.length &&

			// all but one are invisible (like dojo.data)
			candidateWidgets.length == 1
		){
			this._singleChild = candidateWidgets[0];
		}else{
			delete this._singleChild;
		}

		// So we can set overflow: hidden to avoid a safari bug w/scrollbars showing up (#9449)
		dojo.toggleClass(this.containerNode, this.baseClass + "SingleChild", !!this._singleChild);
	},

	setHref: function(/*String|Uri*/ href){
		// summary:
		//		Deprecated.   Use attr('href', ...) instead.
		dojo.deprecated("dijit.layout.ContentPane.setHref() is deprecated. Use attr('href', ...) instead.", "", "2.0");
		return this.attr("href", href);
	},
	_setHrefAttr: function(/*String|Uri*/ href){
		// summary:
		//		Hook so attr("href", ...) works.
		// description:
		//		Reset the (external defined) content of this pane and replace with new url
		//		Note: It delays the download until widget is shown if preload is false.
		//	href:
		//		url to the page you want to get, must be within the same domain as your mainpage

		// Cancel any in-flight requests (an attr('href') will cancel any in-flight attr('href', ...))
		this.cancel();

		this.onLoadDeferred = new dojo.Deferred(dojo.hitch(this, "cancel"));

		this.href = href;

		// _setHrefAttr() is called during creation and by the user, after creation.
		// only in the second case do we actually load the URL; otherwise it's done in startup()
		if(this._created && (this.preload || this._isShown())){
			this._load();
		}else{
			// Set flag to indicate that href needs to be loaded the next time the
			// ContentPane is made visible
			this._hrefChanged = true;
		}

		return this.onLoadDeferred;		// dojo.Deferred
	},

	setContent: function(/*String|DomNode|Nodelist*/data){
		// summary:
		//		Deprecated.   Use attr('content', ...) instead.
		dojo.deprecated("dijit.layout.ContentPane.setContent() is deprecated.  Use attr('content', ...) instead.", "", "2.0");
		this.attr("content", data);
	},
	_setContentAttr: function(/*String|DomNode|Nodelist*/data){
		// summary:
		//		Hook to make attr("content", ...) work.
		//		Replaces old content with data content, include style classes from old content
		//	data:
		//		the new Content may be String, DomNode or NodeList
		//
		//		if data is a NodeList (or an array of nodes) nodes are copied
		//		so you can import nodes from another document implicitly

		// clear href so we can't run refresh and clear content
		// refresh should only work if we downloaded the content
		this.href = "";

		// Cancel any in-flight requests (an attr('content') will cancel any in-flight attr('href', ...))
		this.cancel();

		// Even though user is just setting content directly, still need to define an onLoadDeferred
		// because the _onLoadHandler() handler is still getting called from setContent()
		this.onLoadDeferred = new dojo.Deferred(dojo.hitch(this, "cancel"));

		this._setContent(data || "");

		this._isDownloaded = false; // mark that content is from a attr('content') not an attr('href')

		return this.onLoadDeferred; 	// dojo.Deferred
	},
	_getContentAttr: function(){
		// summary:
		//		Hook to make attr("content") work
		return this.containerNode.innerHTML;
	},

	cancel: function(){
		// summary:
		//		Cancels an in-flight download of content
		if(this._xhrDfd && (this._xhrDfd.fired == -1)){
			this._xhrDfd.cancel();
		}
		delete this._xhrDfd; // garbage collect

		this.onLoadDeferred = null;
	},

	uninitialize: function(){
		if(this._beingDestroyed){
			this.cancel();
		}
		this.inherited(arguments);
	},

	destroyRecursive: function(/*Boolean*/ preserveDom){
		// summary:
		//		Destroy the ContentPane and its contents

		// if we have multiple controllers destroying us, bail after the first
		if(this._beingDestroyed){
			return;
		}
		this.inherited(arguments);
	},

	resize: function(changeSize, resultSize){
		// summary:
		//		See `dijit.layout._LayoutWidget.resize` for description.
		//		Although ContentPane doesn't extend _LayoutWidget, it does implement
		//		the same API.

		// For the TabContainer --> BorderContainer --> ContentPane case, _onShow() is
		// never called, so resize() is our trigger to do the initial href download.
		if(!this._wasShown){
			this._onShow();
		}

		this._resizeCalled = true;

		// Set margin box size, unless it wasn't specified, in which case use current size.
		if(changeSize){
			dojo.marginBox(this.domNode, changeSize);
		}

		// Compute content box size of containerNode in case we [later] need to size our single child.
		var cn = this.containerNode;
		if(cn === this.domNode){
			// If changeSize or resultSize was passed to this method and this.containerNode ==
			// this.domNode then we can compute the content-box size without querying the node,
			// which is more reliable (similar to LayoutWidget.resize) (see for example #9449).
			var mb = resultSize || {};
			dojo.mixin(mb, changeSize || {}); // changeSize overrides resultSize
			if(!("h" in mb) || !("w" in mb)){
				mb = dojo.mixin(dojo.marginBox(cn), mb); // just use dojo.marginBox() to fill in missing values
			}
			this._contentBox = dijit.layout.marginBox2contentBox(cn, mb);
		}else{
			this._contentBox = dojo.contentBox(cn);
		}

		// Make my children layout, or size my single child widget
		this._layoutChildren();
	},

	_isShown: function(){
		// summary:
		//		Returns true if the content is currently shown.
		// description:
		//		If I am a child of a layout widget then it actually returns true if I've ever been visible,
		//		not whether I'm currently visible, since that's much faster than tracing up the DOM/widget
		//		tree every call, and at least solves the performance problem on page load by deferring loading
		//		hidden ContentPanes until they are first shown

		if(this._childOfLayoutWidget){
			// If we are TitlePane, etc - we return that only *IF* we've been resized
			if(this._resizeCalled && "open" in this){
				return this.open;
			}
			return this._resizeCalled;
		}else if("open" in this){
			return this.open;		// for TitlePane, etc.
		}else{
			// TODO: with _childOfLayoutWidget check maybe this branch no longer necessary?
			var node = this.domNode;
			return (node.style.display != 'none') && (node.style.visibility != 'hidden') && !dojo.hasClass(node, "dijitHidden");
		}
	},

	_onShow: function(){
		// summary:
		//		Called when the ContentPane is made visible
		// description:
		//		For a plain ContentPane, this is called on initialization, from startup().
		//		If the ContentPane is a hidden pane of a TabContainer etc., then it's
		//		called whenever the pane is made visible.
		//
		//		Does necessary processing, including href download and layout/resize of
		//		child widget(s)

		if(this.href){
			if(!this._xhrDfd && // if there's an href that isn't already being loaded
				(!this.isLoaded || this._hrefChanged || this.refreshOnShow)
			){
				this.refresh();
			}
		}else{
			// If we are the child of a layout widget then the layout widget will call resize() on
			// us, and then we will size our child/children.   Otherwise, we need to do it now.
			if(!this._childOfLayoutWidget && this._needLayout){
				// If a layout has been scheduled for when we become visible, do it now
				this._layoutChildren();
			}
		}

		this.inherited(arguments);

		// Need to keep track of whether ContentPane has been shown (which is different than
		// whether or not it's currently visible).
		this._wasShown = true;
	},

	refresh: function(){
		// summary:
		//		[Re]download contents of href and display
		// description:
		//		1. cancels any currently in-flight requests
		//		2. posts "loading..." message
		//		3. sends XHR to download new data

		// Cancel possible prior in-flight request
		this.cancel();

		this.onLoadDeferred = new dojo.Deferred(dojo.hitch(this, "cancel"));
		this._load();
		return this.onLoadDeferred;
	},

	_load: function(){
		// summary:
		//		Load/reload the href specified in this.href

		// display loading message
		this._setContent(this.onDownloadStart(), true);

		var self = this;
		var getArgs = {
			preventCache: (this.preventCache || this.refreshOnShow),
			url: this.href,
			handleAs: "text"
		};
		if(dojo.isObject(this.ioArgs)){
			dojo.mixin(getArgs, this.ioArgs);
		}

		var hand = (this._xhrDfd = (this.ioMethod || dojo.xhrGet)(getArgs));

		hand.addCallback(function(html){
			try{
				self._isDownloaded = true;
				self._setContent(html, false);
				self.onDownloadEnd();
			}catch(err){
				self._onError('Content', err); // onContentError
			}
			delete self._xhrDfd;
			return html;
		});

		hand.addErrback(function(err){
			if(!hand.canceled){
				// show error message in the pane
				self._onError('Download', err); // onDownloadError
			}
			delete self._xhrDfd;
			return err;
		});

		// Remove flag saying that a load is needed
		delete this._hrefChanged;
	},

	_onLoadHandler: function(data){
		// summary:
		//		This is called whenever new content is being loaded
		this.isLoaded = true;
		try{
			this.onLoadDeferred.callback(data);
			this.onLoad(data);
		}catch(e){
			console.error('Error '+this.widgetId+' running custom onLoad code: ' + e.message);
		}
	},

	_onUnloadHandler: function(){
		// summary:
		//		This is called whenever the content is being unloaded
		this.isLoaded = false;
		try{
			this.onUnload();
		}catch(e){
			console.error('Error '+this.widgetId+' running custom onUnload code: ' + e.message);
		}
	},

	destroyDescendants: function(){
		// summary:
		//		Destroy all the widgets inside the ContentPane and empty containerNode

		// Make sure we call onUnload (but only when the ContentPane has real content)
		if(this.isLoaded){
			this._onUnloadHandler();
		}

		// Even if this.isLoaded == false there might still be a "Loading..." message
		// to erase, so continue...

		// For historical reasons we need to delete all widgets under this.containerNode,
		// even ones that the user has created manually.
		var setter = this._contentSetter;
		dojo.forEach(this.getChildren(), function(widget){
			if(widget.destroyRecursive){
				widget.destroyRecursive();
			}
		});
		if(setter){
			// Most of the widgets in setter.parseResults have already been destroyed, but
			// things like Menu that have been moved to <body> haven't yet
			dojo.forEach(setter.parseResults, function(widget){
				if(widget.destroyRecursive && widget.domNode && widget.domNode.parentNode == dojo.body()){
					widget.destroyRecursive();
				}
			});
			delete setter.parseResults;
		}

		// And then clear away all the DOM nodes
		dojo.html._emptyNode(this.containerNode);

		// Delete any state information we have about current contents
		delete this._singleChild;
	},

	_setContent: function(cont, isFakeContent){
		// summary:
		//		Insert the content into the container node

		// first get rid of child widgets
		this.destroyDescendants();

		// dojo.html.set will take care of the rest of the details
		// we provide an override for the error handling to ensure the widget gets the errors
		// configure the setter instance with only the relevant widget instance properties
		// NOTE: unless we hook into attr, or provide property setters for each property,
		// we need to re-configure the ContentSetter with each use
		var setter = this._contentSetter;
		if(! (setter && setter instanceof dojo.html._ContentSetter)){
			setter = this._contentSetter = new dojo.html._ContentSetter({
				node: this.containerNode,
				_onError: dojo.hitch(this, this._onError),
				onContentError: dojo.hitch(this, function(e){
					// fires if a domfault occurs when we are appending this.errorMessage
					// like for instance if domNode is a UL and we try append a DIV
					var errMess = this.onContentError(e);
					try{
						this.containerNode.innerHTML = errMess;
					}catch(e){
						console.error('Fatal '+this.id+' could not change content due to '+e.message, e);
					}
				})/*,
				_onError */
			});
		};

		var setterParams = dojo.mixin({
			cleanContent: this.cleanContent,
			extractContent: this.extractContent,
			parseContent: this.parseOnLoad
		}, this._contentSetterParams || {});

		dojo.mixin(setter, setterParams);

		setter.set( (dojo.isObject(cont) && cont.domNode) ? cont.domNode : cont );

		// setter params must be pulled afresh from the ContentPane each time
		delete this._contentSetterParams;

		if(!isFakeContent){
			// Startup each top level child widget (and they will start their children, recursively)
			dojo.forEach(this.getChildren(), function(child){
				// The parser has already called startup on all widgets *without* a getParent() method
				if(!this.parseOnLoad || child.getParent){
					child.startup();
				}
			}, this);

			// Call resize() on each of my child layout widgets,
			// or resize() on my single child layout widget...
			// either now (if I'm currently visible)
			// or when I become visible
			this._scheduleLayout();

			this._onLoadHandler(cont);
		}
	},

	_onError: function(type, err, consoleText){
		this.onLoadDeferred.errback(err);

		// shows user the string that is returned by on[type]Error
		// overide on[type]Error and return your own string to customize
		var errText = this['on' + type + 'Error'].call(this, err);
		if(consoleText){
			console.error(consoleText, err);
		}else if(errText){// a empty string won't change current content
			this._setContent(errText, true);
		}
	},

	_scheduleLayout: function(){
		// summary:
		//		Call resize() on each of my child layout widgets, either now
		//		(if I'm currently visible) or when I become visible
		if(this._isShown()){
			this._layoutChildren();
		}else{
			this._needLayout = true;
		}
	},

	_layoutChildren: function(){
		// summary:
		//		Since I am a Container widget, each of my children expects me to
		//		call resize() or layout() on them.
		// description:
		//		Should be called on initialization and also whenever we get new content
		//		(from an href, or from attr('content', ...))... but deferred until
		//		the ContentPane is visible

		if(this.doLayout){
			this._checkIfSingleChild();
		}

		if(this._singleChild && this._singleChild.resize){
			var cb = this._contentBox || dojo.contentBox(this.containerNode);

			// note: if widget has padding this._contentBox will have l and t set,
			// but don't pass them to resize() or it will doubly-offset the child
			this._singleChild.resize({w: cb.w, h: cb.h});
		}else{
			// All my child widgets are independently sized (rather than matching my size),
			// but I still need to call resize() on each child to make it layout.
			dojo.forEach(this.getChildren(), function(widget){
				if(widget.resize){
					widget.resize();
				}
			});
		}
		delete this._needLayout;
	},

	// EVENT's, should be overide-able
	onLoad: function(data){
		// summary:
		//		Event hook, is called after everything is loaded and widgetified
		// tags:
		//		callback
	},

	onUnload: function(){
		// summary:
		//		Event hook, is called before old content is cleared
		// tags:
		//		callback
	},

	onDownloadStart: function(){
		// summary:
		//		Called before download starts.
		// description:
		//		The string returned by this function will be the html
		//		that tells the user we are loading something.
		//		Override with your own function if you want to change text.
		// tags:
		//		extension
		return this.loadingMessage;
	},

	onContentError: function(/*Error*/ error){
		// summary:
		//		Called on DOM faults, require faults etc. in content.
		//
		//		In order to display an error message in the pane, return
		//		the error message from this method, as an HTML string.
		//
		//		By default (if this method is not overriden), it returns
		//		nothing, so the error message is just printed to the console.
		// tags:
		//		extension
	},

	onDownloadError: function(/*Error*/ error){
		// summary:
		//		Called when download error occurs.
		//
		//		In order to display an error message in the pane, return
		//		the error message from this method, as an HTML string.
		//
		//		Default behavior (if this method is not overriden) is to display
		//		the error message inside the pane.
		// tags:
		//		extension
		return this.errorMessage;
	},

	onDownloadEnd: function(){
		// summary:
		//		Called when download is finished.
		// tags:
		//		callback
	}
});

}

if(!dojo._hasResource["dojox.html._base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.html._base"] = true;
/*
	Status: dont know where this will all live exactly
	Need to pull in the implementation of the various helper methods
	Some can be static method, others maybe methods of the ContentSetter (?)
	
	Gut the ContentPane, replace its _setContent with our own call to dojox.html.set()
	

*/

dojo.provide("dojox.html._base");

 

(function() {

	if(dojo.isIE){
		var alphaImageLoader = /(AlphaImageLoader\([^)]*?src=(['"]))(?![a-z]+:|\/)([^\r\n;}]+?)(\2[^)]*\)\s*[;}]?)/g;
	}

	// css at-rules must be set before any css declarations according to CSS spec
	// match:
	// @import 'http://dojotoolkit.org/dojo.css';
	// @import 'you/never/thought/' print;
	// @import url("it/would/work") tv, screen;
	// @import url(/did/you/now.css);
	// but not:
	// @namespace dojo "http://dojotoolkit.org/dojo.css"; /* namespace URL should always be a absolute URI */
	// @charset 'utf-8';
	// @media print{ #menuRoot {display:none;} }
		
	// we adjust all paths that dont start on '/' or contains ':'
	//(?![a-z]+:|\/)

	var cssPaths = /(?:(?:@import\s*(['"])(?![a-z]+:|\/)([^\r\n;{]+?)\1)|url\(\s*(['"]?)(?![a-z]+:|\/)([^\r\n;]+?)\3\s*\))([a-z, \s]*[;}]?)/g;

	var adjustCssPaths = dojox.html._adjustCssPaths = function(cssUrl, cssText){
		//	summary:
		//		adjusts relative paths in cssText to be relative to cssUrl
		//		a path is considered relative if it doesn't start with '/' and not contains ':'
		//	description:
		//		Say we fetch a HTML page from level1/page.html
		//		It has some inline CSS:
		//			@import "css/page.css" tv, screen;
		//			...
		//			background-image: url(images/aplhaimage.png);
		//
		//		as we fetched this HTML and therefore this CSS
		//		from level1/page.html, these paths needs to be adjusted to:
		//			@import 'level1/css/page.css' tv, screen;
		//			...
		//			background-image: url(level1/images/alphaimage.png);
		//		
		//		In IE it will also adjust relative paths in AlphaImageLoader()
		//			filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='images/alphaimage.png');
		//		will be adjusted to:
		//			filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='level1/images/alphaimage.png');
		//
		//		Please note that any relative paths in AlphaImageLoader in external css files wont work, as
		//		the paths in AlphaImageLoader is MUST be declared relative to the HTML page,
		//		not relative to the CSS file that declares it

		if(!cssText || !cssUrl){ return; }

		// support the ImageAlphaFilter if it exists, most people use it in IE 6 for transparent PNGs
		// We are NOT going to kill it in IE 7 just because the PNGs work there. Somebody might have
		// other uses for it.
		// If user want to disable css filter in IE6  he/she should
		// unset filter in a declaration that just IE 6 doesn't understands
		// like * > .myselector { filter:none; }
		if(alphaImageLoader){
			cssText = cssText.replace(alphaImageLoader, function(ignore, pre, delim, url, post){
				return pre + (new dojo._Url(cssUrl, './'+url).toString()) + post;
			});
		}

		return cssText.replace(cssPaths, function(ignore, delimStr, strUrl, delimUrl, urlUrl, media){
			if(strUrl){
				return '@import "' + (new dojo._Url(cssUrl, './'+strUrl).toString()) + '"' + media;
			}else{
				return 'url(' + (new dojo._Url(cssUrl, './'+urlUrl).toString()) + ')' + media;
			}
		});
	};

	// attributepaths one tag can have multiple paths, example:
	// <input src="..." style="url(..)"/> or <a style="url(..)" href="..">
	// <img style='filter:progid...AlphaImageLoader(src="noticeTheSrcHereRunsThroughHtmlSrc")' src="img">
	var htmlAttrPaths = /(<[a-z][a-z0-9]*\s[^>]*)(?:(href|src)=(['"]?)([^>]*?)\3|style=(['"]?)([^>]*?)\5)([^>]*>)/gi;

	var adjustHtmlPaths = dojox.html._adjustHtmlPaths = function(htmlUrl, cont){
		var url = htmlUrl || "./";

		return cont.replace(htmlAttrPaths,
			function(tag, start, name, delim, relUrl, delim2, cssText, end){
				return start + (name ?
							(name + '=' + delim + (new dojo._Url(url, relUrl).toString()) + delim)
						: ('style=' + delim2 + adjustCssPaths(url, cssText) + delim2)
				) + end;
			}
		);
	};
	
	var snarfStyles = dojox.html._snarfStyles = function	(/*String*/cssUrl, /*String*/cont, /*Array*/styles){
		/****************  cut out all <style> and <link rel="stylesheet" href=".."> **************/
		// also return any attributes from this tag (might be a media attribute)
		// if cssUrl is set it will adjust paths accordingly
		styles.attributes = [];

		return cont.replace(/(?:<style([^>]*)>([\s\S]*?)<\/style>|<link\s+(?=[^>]*rel=['"]?stylesheet)([^>]*?href=(['"])([^>]*?)\4[^>\/]*)\/?>)/gi,
			function(ignore, styleAttr, cssText, linkAttr, delim, href){
				// trim attribute
				var i, attr = (styleAttr||linkAttr||"").replace(/^\s*([\s\S]*?)\s*$/i, "$1"); 
				if(cssText){
					i = styles.push(cssUrl ? adjustCssPaths(cssUrl, cssText) : cssText);
				}else{
					i = styles.push('@import "' + href + '";');
					attr = attr.replace(/\s*(?:rel|href)=(['"])?[^\s]*\1\s*/gi, ""); // remove rel=... and href=...
				}
				if(attr){
					attr = attr.split(/\s+/);// split on both "\n", "\t", " " etc
					var atObj = {}, tmp;
					for(var j = 0, e = attr.length; j < e; j++){
						tmp = attr[j].split('='); // split name='value'
						atObj[tmp[0]] = tmp[1].replace(/^\s*['"]?([\s\S]*?)['"]?\s*$/, "$1"); // trim and remove ''
					}
					styles.attributes[i - 1] = atObj;
				}
				return ""; // squelsh the <style> or <link>
			}
		);
	};

	var snarfScripts = dojox.html._snarfScripts = function(cont, byRef){
		// summary
		//		strips out script tags from cont
		// invoke with 
		//	byRef = {errBack:function(){/*add your download error code here*/, downloadRemote: true(default false)}}
		//	byRef will have {code: 'jscode'} when this scope leaves
		byRef.code = "";

		//Update script tags nested in comments so that the script tag collector doesn't pick
		//them up.
		cont = cont.replace(/<[!][-][-](.|\s){5,}?[-][-]>/g,
			function(comment){
				return comment.replace(/<(\/?)script\b/ig,"&lt;$1Script");
			}
		);

		function download(src){
			if(byRef.downloadRemote){
				// console.debug('downloading',src);
				//Fix up src, in case there were entity character encodings in it.
				//Probably only need to worry about a subset.
				src = src.replace(/&([a-z0-9#]+);/g, function(m, name) {
					switch(name) {
						case "amp"	: return "&";
						case "gt"	: return ">";
						case "lt"	: return "<";
						default:
							return name.charAt(0)=="#" ? String.fromCharCode(name.substring(1)) : "&"+name+";";
					}
				});
				dojo.xhrGet({
					url: src,
					sync: true,
					load: function(code){
						byRef.code += code+";";
					},
					error: byRef.errBack
				});
			}
		}
		
		// match <script>, <script type="text/..., but not <script type="dojo(/method)...
		return cont.replace(/<script\s*(?![^>]*type=['"]?(?:dojo\/|text\/html\b))(?:[^>]*?(?:src=(['"]?)([^>]*?)\1[^>]*)?)*>([\s\S]*?)<\/script>/gi,
			function(ignore, delim, src, code){
				if(src){
					download(src);
				}else{
					byRef.code += code;
				}
				return "";
			}
		);
	}; 
	
	var evalInGlobal = dojox.html.evalInGlobal = function(code, appendNode){
		// we do our own eval here as dojo.eval doesn't eval in global crossbrowser
		// This work X browser but but it relies on a DOM
		// plus it doesn't return anything, thats unrelevant here but not for dojo core
		appendNode = appendNode || dojo.doc.body;
		var n = appendNode.ownerDocument.createElement('script');
		n.type = "text/javascript";
		appendNode.appendChild(n);
		n.text = code; // DOM 1 says this should work
	};

	dojo.declare("dojox.html._ContentSetter", [dojo.html._ContentSetter], {
		// adjustPaths: Boolean
		//		Adjust relative paths in html string content to point to this page
		//		Only useful if you grab content from a another folder than the current one
		adjustPaths: false,
		referencePath: ".",
		renderStyles: false, 

		executeScripts: false,
		scriptHasHooks: false,
		scriptHookReplacement: null,
		
		_renderStyles: function(styles){
			// insert css from content into document head
			this._styleNodes = [];
			var st, att, cssText, doc = this.node.ownerDocument;
			var head = doc.getElementsByTagName('head')[0];

			for(var i = 0, e = styles.length; i < e; i++){
				cssText = styles[i]; att = styles.attributes[i];
				st = doc.createElement('style');
				st.setAttribute("type", "text/css"); // this is required in CSS spec!

				for(var x in att){
					st.setAttribute(x, att[x]);
				}

				this._styleNodes.push(st);
				head.appendChild(st); // must insert into DOM before setting cssText

				if(st.styleSheet){ // IE
					st.styleSheet.cssText = cssText;
				}else{ // w3c
					st.appendChild(doc.createTextNode(cssText));
				}
			}
		}, 

		empty: function() {
			this.inherited("empty", arguments);
			
			// empty out the styles array from any previous use
			this._styles = [];
		}, 
		
		onBegin: function() {
			// summary
			//		Called after instantiation, but before set(); 
			//		It allows modification of any of the object properties - including the node and content 
			//		provided - before the set operation actually takes place
			//		This implementation extends that of dojo.html._ContentSetter 
			//		to add handling for adjustPaths, renderStyles on the html string content before it is set
			this.inherited("onBegin", arguments);
			
			var cont = this.content, 
				node = this.node; 
				
			var styles = this._styles;// init vars

			if(dojo.isString(cont)){
				if(this.adjustPaths && this.referencePath){
					cont = adjustHtmlPaths(this.referencePath, cont);
				}

				if(this.renderStyles || this.cleanContent){
					cont = snarfStyles(this.referencePath, cont, styles);
				}

				// because of a bug in IE, script tags that is first in html hierarchy doesnt make it into the DOM 
				//	when content is innerHTML'ed, so we can't use dojo.query to retrieve scripts from DOM
				if(this.executeScripts){
					var _t = this; 
					var byRef = {
						downloadRemote: true,
						errBack:function(e){
							_t._onError.call(_t, 'Exec', 'Error downloading remote script in "'+_t.id+'"', e);
						}
					};
					cont = snarfScripts(cont, byRef);
					this._code = byRef.code;
				}
			}
			this.content = cont;
		},
		
		onEnd: function() {
			// summary
			//		Called after set(), when the new content has been pushed into the node
			//		It provides an opportunity for post-processing before handing back the node to the caller
			//		This implementation extends that of dojo.html._ContentSetter
			
			var code = this._code, 
				styles = this._styles;
				
			// clear old stylenodes from the DOM
			// these were added by the last set call
			// (in other words, if you dont keep and reuse the ContentSetter for a particular node
			// .. you'll have no practical way to do this)
			if(this._styleNodes && this._styleNodes.length){
				while(this._styleNodes.length){
					dojo.destroy(this._styleNodes.pop());
				}
			}
			// render new style nodes
			if(this.renderStyles && styles && styles.length){
			      try{
				this._renderStyles(styles);
				}catch(e){
 				  // IE issue	
  				  console.info("Error while adding styles : "+e);
				}
			}

			if(this.executeScripts && code){
				if(this.cleanContent){
					// clean JS from html comments and other crap that browser
					// parser takes care of in a normal page load
					code = code.replace(/(<!--|(?:\/\/)?-->|<!\[CDATA\[|\]\]>)/g, '');
				}
				if(this.scriptHasHooks){
					// replace _container_ with this.scriptHookReplace()
					// the scriptHookReplacement can be a string 
					// or a function, which when invoked returns the string you want to substitute in
					code = code.replace(/_container_(?!\s*=[^=])/g, this.scriptHookReplacement);
				}
				try{
					evalInGlobal(code, this.node);
				}catch(e){
					this._onError('Exec', 'Error eval script in '+this.id+', '+e.message, e);
				}
			}
			this.inherited("onEnd", arguments);
		},
		tearDown: function() {
			this.inherited(arguments);
			delete this._styles;
			// only tear down -or another set() - will explicitly throw away the
			// references to the style nodes we added
			if(this._styleNodes && this._styleNodes.length){
				while(this._styleNodes.length){
					dojo.destroy(this._styleNodes.pop());
				}
			}
			delete this._styleNodes; 
			// reset the defaults from the prototype
			dojo.mixin(this, dojo.getObject(this.declaredClass).prototype);
		}
		
	});
	
	dojox.html.set = function(/* DomNode */ node, /* String|DomNode|NodeList */ cont, /* Object? */ params){
		// TODO: add all the other options
			// summary:
			//		inserts (replaces) the given content into the given node
			//	node:
			//		the parent element that will receive the content
			//	cont:
			//		the content to be set on the parent element. 
			//		This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes
			//	params: 
			//		Optional flags/properties to configure the content-setting. See dojo.html._ContentSetter
			//	example:
			//		A safe string/node/nodelist content replacement/injection with hooks for extension
			//		Example Usage: 
			//		dojo.html.set(node, "some string"); 
			//		dojo.html.set(node, contentNode, {options}); 
			//		dojo.html.set(node, myNode.childNodes, {options}); 
	 
		if(!params){
			// simple and fast
			return dojo.html._setNodeContent(node, cont, true);
		}else{ 
			// more options but slower
			var op = new dojox.html._ContentSetter(dojo.mixin( 
					params, 
					{ content: cont, node: node } 
			));
			return op.set();
		}
	};
	
})();

}

if(!dojo._hasResource["dojox.layout.ContentPane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.layout.ContentPane"] = true;
dojo.provide("dojox.layout.ContentPane");


 

dojo.declare("dojox.layout.ContentPane", dijit.layout.ContentPane, {
	// summary:
	//		An extended version of dijit.layout.ContentPane.
	//		Supports infile scripts and external ones declared by <script src=''
	//		relative path adjustments (content fetched from a different folder)
	//		<style> and <link rel='stylesheet' href='..'> tags,
	//		css paths inside cssText is adjusted (if you set adjustPaths = true)
	//
	//		NOTE that dojo.require in script in the fetched file isn't recommended
	//		Many widgets need to be required at page load to work properly

	// adjustPaths: Boolean
	//		Adjust relative paths in html string content to point to this page.
	//		Only useful if you grab content from a another folder then the current one
	adjustPaths: false,

	// cleanContent: Boolean
	//	summary:
	//		cleans content to make it less likely to generate DOM/JS errors.
	//	description:
	//		useful if you send ContentPane a complete page, instead of a html fragment
	//		scans for 
	//
	//			* title Node, remove
	//			* DOCTYPE tag, remove
	cleanContent: false,

	// renderStyles: Boolean
	//		trigger/load styles in the content
	renderStyles: false,

	// executeScripts: Boolean
	//		Execute (eval) scripts that is found in the content
	executeScripts: true,

	// scriptHasHooks: Boolean
	//		replace keyword '_container_' in scripts with 'dijit.byId(this.id)'
	// NOTE this name might change in the near future
	scriptHasHooks: false,

	/*======
	// ioMethod: dojo.xhrGet|dojo.xhrPost
	//		reference to the method that should grab the content
	ioMethod: dojo.xhrGet,
	
	// ioArgs: Object
	//		makes it possible to add custom args to xhrGet, like ioArgs.headers['X-myHeader'] = 'true'
	ioArgs: {},
	======*/

	constructor: function(){
		// init per instance properties, initializer doesn't work here because how things is hooked up in dijit._Widget
		this.ioArgs = {};
		this.ioMethod = dojo.xhrGet;
	},

	onExecError: function(e){
		// summary:
		//		event callback, called on script error or on java handler error
		//		overide and return your own html string if you want a some text 
		//		displayed within the ContentPane
	},

	_setContent: function(cont){
		// override dijit.layout.ContentPane._setContent, to enable path adjustments
		
		var setter = this._contentSetter; 
		if(! (setter && setter instanceof dojox.html._ContentSetter)) {
			setter = this._contentSetter = new dojox.html._ContentSetter({
				node: this.containerNode,
				_onError: dojo.hitch(this, this._onError),
				onContentError: dojo.hitch(this, function(e){
					// fires if a domfault occurs when we are appending this.errorMessage
					// like for instance if domNode is a UL and we try append a DIV
					var errMess = this.onContentError(e);
					try{
						this.containerNode.innerHTML = errMess;
					}catch(e){
						console.error('Fatal '+this.id+' could not change content due to '+e.message, e);
					}
				})/*,
				_onError */
			});
		};

		// stash the params for the contentSetter to allow inheritance to work for _setContent
		this._contentSetterParams = {
			adjustPaths: Boolean(this.adjustPaths && (this.href||this.referencePath)),
			referencePath: this.href || this.referencePath,
			renderStyles: this.renderStyles,
			executeScripts: this.executeScripts,
			scriptHasHooks: this.scriptHasHooks,
			scriptHookReplacement: "dijit.byId('"+this.id+"')"
		};

		this.inherited("_setContent", arguments);
	}
	// could put back _renderStyles by wrapping/aliasing dojox.html._ContentSetter.prototype._renderStyles
});

}

if(!dojo._hasResource["dojo.cache"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.cache"] = true;
dojo.provide("dojo.cache");

/*=====
dojo.cache = { 
	// summary:
	// 		A way to cache string content that is fetchable via `dojo.moduleUrl`.
};
=====*/

(function(){
	var cache = {};
	dojo.cache = function(/*String||Object*/module, /*String*/url, /*String||Object?*/value){
		// summary:
		// 		A getter and setter for storing the string content associated with the
		// 		module and url arguments.
		// description:
		// 		module and url are used to call `dojo.moduleUrl()` to generate a module URL.
		// 		If value is specified, the cache value for the moduleUrl will be set to
		// 		that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
		// 		in its internal cache and return that cached value for the URL. To clear
		// 		a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
		// 		the URL contents, only modules on the same domain of the page can use this capability.
		// 		The build system can inline the cache values though, to allow for xdomain hosting.
		// module: String||Object
		// 		If a String, the module name to use for the base part of the URL, similar to module argument
		// 		to `dojo.moduleUrl`. If an Object, something that has a .toString() method that
		// 		generates a valid path for the cache item. For example, a dojo._Url object.
		// url: String
		// 		The rest of the path to append to the path derived from the module argument. If
		// 		module is an object, then this second argument should be the "value" argument instead.
		// value: String||Object?
		// 		If a String, the value to use in the cache for the module/url combination.
		// 		If an Object, it can have two properties: value and sanitize. The value property
		// 		should be the value to use in the cache, and sanitize can be set to true or false,
		// 		to indicate if XML declarations should be removed from the value and if the HTML
		// 		inside a body tag in the value should be extracted as the real value. The value argument
		// 		or the value property on the value argument are usually only used by the build system
		// 		as it inlines cache content.
		//	example:
		//		To ask dojo.cache to fetch content and store it in the cache (the dojo["cache"] style
		// 		of call is used to avoid an issue with the build system erroneously trying to intern
		// 		this example. To get the build system to intern your dojo.cache calls, use the
		// 		"dojo.cache" style of call):
		// 		|	//If template.html contains "<h1>Hello</h1>" that will be
		// 		|	//the value for the text variable.
		//		|	var text = dojo["cache"]("my.module", "template.html");
		//	example:
		//		To ask dojo.cache to fetch content and store it in the cache, and sanitize the input
		// 		 (the dojo["cache"] style of call is used to avoid an issue with the build system 
		// 		erroneously trying to intern this example. To get the build system to intern your
		// 		dojo.cache calls, use the "dojo.cache" style of call):
		// 		|	//If template.html contains "<html><body><h1>Hello</h1></body></html>", the
		// 		|	//text variable will contain just "<h1>Hello</h1>".
		//		|	var text = dojo["cache"]("my.module", "template.html", {sanitize: true});
		//	example:
		//		Same example as previous, but demostrates how an object can be passed in as
		//		the first argument, then the value argument can then be the second argument.
		// 		|	//If template.html contains "<html><body><h1>Hello</h1></body></html>", the
		// 		|	//text variable will contain just "<h1>Hello</h1>".
		//		|	var text = dojo["cache"](new dojo._Url("my/module/template.html"), {sanitize: true});

		//Module could be a string, or an object that has a toString() method
		//that will return a useful path. If it is an object, then the "url" argument
		//will actually be the value argument.
		if(typeof module == "string"){
			var pathObj = dojo.moduleUrl(module, url);
		}else{
			pathObj = module;
			value = url;
		}
		var key = pathObj.toString();

		var val = value;
		if(value !== undefined && !dojo.isString(value)){
			val = ("value" in value ? value.value : undefined);
		}

		var sanitize = value && value.sanitize ? true : false;

		if(val || val === null){
			//We have a value, either clear or set the cache value.
			if(val == null){
				delete cache[key];
			}else{
				val = cache[key] = sanitize ? dojo.cache._sanitize(val) : val;
			}
		}else{
			//Allow cache values to be empty strings. If key property does
			//not exist, fetch it.
			if(!(key in cache)){
				val = dojo._getText(key);
				cache[key] = sanitize ? dojo.cache._sanitize(val) : val;
			}
			val = cache[key];
		}
		return val; //String
	};

	dojo.cache._sanitize = function(/*String*/val){
		// summary: 
		//		Strips <?xml ...?> declarations so that external SVG and XML
		// 		documents can be added to a document without worry. Also, if the string
		//		is an HTML document, only the part inside the body tag is returned.
		// description:
		// 		Copied from dijit._Templated._sanitizeTemplateString.
		if(val){
			val = val.replace(/^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im, "");
			var matches = val.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
			if(matches){
				val = matches[1];
			}
		}else{
			val = "";
		}
		return val; //String
	};
})();

}

if(!dojo._hasResource["dijit._Templated"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._Templated"] = true;
dojo.provide("dijit._Templated");






dojo.declare("dijit._Templated",
	null,
	{
		// summary:
		//		Mixin for widgets that are instantiated from a template

		// templateString: [protected] String
		//		A string that represents the widget template. Pre-empts the
		//		templatePath. In builds that have their strings "interned", the
		//		templatePath is converted to an inline templateString, thereby
		//		preventing a synchronous network call.
		//
		//		Use in conjunction with dojo.cache() to load from a file.
		templateString: null,

		// templatePath: [protected deprecated] String
		//		Path to template (HTML file) for this widget relative to dojo.baseUrl.
		//		Deprecated: use templateString with dojo.cache() instead.
		templatePath: null,

		// widgetsInTemplate: [protected] Boolean
		//		Should we parse the template to find widgets that might be
		//		declared in markup inside it?  False by default.
		widgetsInTemplate: false,

		// skipNodeCache: [protected] Boolean
		//		If using a cached widget template node poses issues for a
		//		particular widget class, it can set this property to ensure
		//		that its template is always re-built from a string
		_skipNodeCache: false,

		// _earlyTemplatedStartup: Boolean
		//		A fallback to preserve the 1.0 - 1.3 behavior of children in
		//		templates having their startup called before the parent widget
		//		fires postCreate. Defaults to 'false', causing child widgets to
		//		have their .startup() called immediately before a parent widget
		//		.startup(), but always after the parent .postCreate(). Set to
		//		'true' to re-enable to previous, arguably broken, behavior.
		_earlyTemplatedStartup: false,

		// _attachPoints: [private] String[]
		//		List of widget attribute names associated with dojoAttachPoint=... in the
		//		template, ex: ["containerNode", "labelNode"]
/*=====
 		_attachPoints: [],
 =====*/

		constructor: function(){
			this._attachPoints = [];
		},

		_stringRepl: function(tmpl){
			// summary:
			//		Does substitution of ${foo} type properties in template string
			// tags:
			//		private
			var className = this.declaredClass, _this = this;
			// Cache contains a string because we need to do property replacement
			// do the property replacement
			return dojo.string.substitute(tmpl, this, function(value, key){
				if(key.charAt(0) == '!'){ value = dojo.getObject(key.substr(1), false, _this); }
				if(typeof value == "undefined"){ throw new Error(className+" template:"+key); } // a debugging aide
				if(value == null){ return ""; }

				// Substitution keys beginning with ! will skip the transform step,
				// in case a user wishes to insert unescaped markup, e.g. ${!foo}
				return key.charAt(0) == "!" ? value :
					// Safer substitution, see heading "Attribute values" in
					// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
					value.toString().replace(/"/g,"&quot;"); //TODO: add &amp? use encodeXML method?
			}, this);
		},

		// method over-ride
		buildRendering: function(){
			// summary:
			//		Construct the UI for this widget from a template, setting this.domNode.
			// tags:
			//		protected

			// Lookup cached version of template, and download to cache if it
			// isn't there already.  Returns either a DomNode or a string, depending on
			// whether or not the template contains ${foo} replacement parameters.
			var cached = dijit._Templated.getCachedTemplate(this.templatePath, this.templateString, this._skipNodeCache);

			var node;
			if(dojo.isString(cached)){
				node = dojo._toDom(this._stringRepl(cached));
				if(node.nodeType != 1){
					// Flag common problems such as templates with multiple top level nodes (nodeType == 11)
					throw new Error("Invalid template: " + cached);
				}
			}else{
				// if it's a node, all we have to do is clone it
				node = cached.cloneNode(true);
			}

			this.domNode = node;

			// recurse through the node, looking for, and attaching to, our
			// attachment points and events, which should be defined on the template node.
			this._attachTemplateNodes(node);

			if(this.widgetsInTemplate){
				// Make sure dojoType is used for parsing widgets in template.
				// The dojo.parser.query could be changed from multiversion support.
				var parser = dojo.parser, qry, attr;
				if(parser._query != "[dojoType]"){
					qry = parser._query;
					attr = parser._attrName;
					parser._query = "[dojoType]";
					parser._attrName = "dojoType";
				}

				// Store widgets that we need to start at a later point in time
				var cw = (this._startupWidgets = dojo.parser.parse(node, {
					noStart: !this._earlyTemplatedStartup
				}));

				// Restore the query.
				if(qry){
					parser._query = qry;
					parser._attrName = attr;
				}

				this._supportingWidgets = dijit.findWidgets(node);

				this._attachTemplateNodes(cw, function(n,p){
					return n[p];
				});
			}

			this._fillContent(this.srcNodeRef);
		},

		_fillContent: function(/*DomNode*/ source){
			// summary:
			//		Relocate source contents to templated container node.
			//		this.containerNode must be able to receive children, or exceptions will be thrown.
			// tags:
			//		protected
			var dest = this.containerNode;
			if(source && dest){
				while(source.hasChildNodes()){
					dest.appendChild(source.firstChild);
				}
			}
		},

		_attachTemplateNodes: function(rootNode, getAttrFunc){
			// summary:
			//		Iterate through the template and attach functions and nodes accordingly.
			// description:
			//		Map widget properties and functions to the handlers specified in
			//		the dom node and it's descendants. This function iterates over all
			//		nodes and looks for these properties:
			//			* dojoAttachPoint
			//			* dojoAttachEvent
			//			* waiRole
			//			* waiState
			// rootNode: DomNode|Array[Widgets]
			//		the node to search for properties. All children will be searched.
			// getAttrFunc: Function?
			//		a function which will be used to obtain property for a given
			//		DomNode/Widget
			// tags:
			//		private

			getAttrFunc = getAttrFunc || function(n,p){ return n.getAttribute(p); };

			var nodes = dojo.isArray(rootNode) ? rootNode : (rootNode.all || rootNode.getElementsByTagName("*"));
			var x = dojo.isArray(rootNode) ? 0 : -1;
			for(; x<nodes.length; x++){
				var baseNode = (x == -1) ? rootNode : nodes[x];
				if(this.widgetsInTemplate && getAttrFunc(baseNode, "dojoType")){
					continue;
				}
				// Process dojoAttachPoint
				var attachPoint = getAttrFunc(baseNode, "dojoAttachPoint");
				if(attachPoint){
					var point, points = attachPoint.split(/\s*,\s*/);
					while((point = points.shift())){
						if(dojo.isArray(this[point])){
							this[point].push(baseNode);
						}else{
							this[point]=baseNode;
						}
						this._attachPoints.push(point);
					}
				}

				// Process dojoAttachEvent
				var attachEvent = getAttrFunc(baseNode, "dojoAttachEvent");
				if(attachEvent){
					// NOTE: we want to support attributes that have the form
					// "domEvent: nativeEvent; ..."
					var event, events = attachEvent.split(/\s*,\s*/);
					var trim = dojo.trim;
					while((event = events.shift())){
						if(event){
							var thisFunc = null;
							if(event.indexOf(":") != -1){
								// oh, if only JS had tuple assignment
								var funcNameArr = event.split(":");
								event = trim(funcNameArr[0]);
								thisFunc = trim(funcNameArr[1]);
							}else{
								event = trim(event);
							}
							if(!thisFunc){
								thisFunc = event;
							}
							this.connect(baseNode, event, thisFunc);
						}
					}
				}

				// waiRole, waiState
				var role = getAttrFunc(baseNode, "waiRole");
				if(role){
					dijit.setWaiRole(baseNode, role);
				}
				var values = getAttrFunc(baseNode, "waiState");
				if(values){
					dojo.forEach(values.split(/\s*,\s*/), function(stateValue){
						if(stateValue.indexOf('-') != -1){
							var pair = stateValue.split('-');
							dijit.setWaiState(baseNode, pair[0], pair[1]);
						}
					});
				}
			}
		},

		startup: function(){
			dojo.forEach(this._startupWidgets, function(w){
				if(w && !w._started && w.startup){
					w.startup();
				}
			});
			this.inherited(arguments);
		},

		destroyRendering: function(){
			// Delete all attach points to prevent IE6 memory leaks.
			dojo.forEach(this._attachPoints, function(point){
				delete this[point];
			}, this);
			this._attachPoints = [];

			this.inherited(arguments);
		}
	}
);

// key is either templatePath or templateString; object is either string or DOM tree
dijit._Templated._templateCache = {};

dijit._Templated.getCachedTemplate = function(templatePath, templateString, alwaysUseString){
	// summary:
	//		Static method to get a template based on the templatePath or
	//		templateString key
	// templatePath: String||dojo.uri.Uri
	//		The URL to get the template from.
	// templateString: String?
	//		a string to use in lieu of fetching the template from a URL. Takes precedence
	//		over templatePath
	// returns: Mixed
	//		Either string (if there are ${} variables that need to be replaced) or just
	//		a DOM tree (if the node can be cloned directly)

	// is it already cached?
	var tmplts = dijit._Templated._templateCache;
	var key = templateString || templatePath;
	var cached = tmplts[key];
	if(cached){
		try{
			// if the cached value is an innerHTML string (no ownerDocument) or a DOM tree created within the current document, then use the current cached value
			if(!cached.ownerDocument || cached.ownerDocument == dojo.doc){
				// string or node of the same document
				return cached;
			}
		}catch(e){ /* squelch */ } // IE can throw an exception if cached.ownerDocument was reloaded
		dojo.destroy(cached);
	}

	// If necessary, load template string from template path
	if(!templateString){
		templateString = dojo.cache(templatePath, {sanitize: true});
	}
	templateString = dojo.string.trim(templateString);

	if(alwaysUseString || templateString.match(/\$\{([^\}]+)\}/g)){
		// there are variables in the template so all we can do is cache the string
		return (tmplts[key] = templateString); //String
	}else{
		// there are no variables in the template so we can cache the DOM tree
		var node = dojo._toDom(templateString);
		if(node.nodeType != 1){
			throw new Error("Invalid template: " + templateString);
		}
		return (tmplts[key] = node); //Node
	}
};

if(dojo.isIE){
	dojo.addOnWindowUnload(function(){
		var cache = dijit._Templated._templateCache;
		for(var key in cache){
			var value = cache[key];
			if(typeof value == "object"){ // value is either a string or a DOM node template
				dojo.destroy(value);
			}
			delete cache[key];
		}
	});
}

// These arguments can be specified for widgets which are used in templates.
// Since any widget can be specified as sub widgets in template, mix it
// into the base widget class.  (This is a hack, but it's effective.)
dojo.extend(dijit._Widget,{
	dojoAttachEvent: "",
	dojoAttachPoint: "",
	waiRole: "",
	waiState:""
});

}

if(!dojo._hasResource["dijit.form._FormWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form._FormWidget"] = true;
dojo.provide("dijit.form._FormWidget");




dojo.declare("dijit.form._FormWidget", [dijit._Widget, dijit._Templated],
	{
	// summary:
	//		Base class for widgets corresponding to native HTML elements such as <checkbox> or <button>,
	//		which can be children of a <form> node or a `dijit.form.Form` widget.
	//
	// description:
	//		Represents a single HTML element.
	//		All these widgets should have these attributes just like native HTML input elements.
	//		You can set them during widget construction or afterwards, via `dijit._Widget.attr`.
	//
	//		They also share some common methods.

	// baseClass: [protected] String
	//		Root CSS class of the widget (ex: dijitTextBox), used to add CSS classes of widget
	//		(ex: "dijitTextBox dijitTextBoxInvalid dijitTextBoxFocused dijitTextBoxInvalidFocused")
	//		See _setStateClass().
	baseClass: "",

	// name: String
	//		Name used when submitting form; same as "name" attribute or plain HTML elements
	name: "",

	// alt: String
	//		Corresponds to the native HTML <input> element's attribute.
	alt: "",

	// value: String
	//		Corresponds to the native HTML <input> element's attribute.
	value: "",

	// type: String
	//		Corresponds to the native HTML <input> element's attribute.
	type: "text",

	// tabIndex: Integer
	//		Order fields are traversed when user hits the tab key
	tabIndex: "0",

	// disabled: Boolean
	//		Should this widget respond to user input?
	//		In markup, this is specified as "disabled='disabled'", or just "disabled".
	disabled: false,

	// intermediateChanges: Boolean
	//		Fires onChange for each value change or only on demand
	intermediateChanges: false,

	// scrollOnFocus: Boolean
	//		On focus, should this widget scroll into view?
	scrollOnFocus: true,

	// These mixins assume that the focus node is an INPUT, as many but not all _FormWidgets are.
	attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
		value: "focusNode",
		id: "focusNode",
		tabIndex: "focusNode",
		alt: "focusNode",
		title: "focusNode"
	}),

	postMixInProperties: function(){
		// Setup name=foo string to be referenced from the template (but only if a name has been specified)
		// Unfortunately we can't use attributeMap to set the name due to IE limitations, see #8660
		this.nameAttrSetting = this.name ? ("name='" + this.name + "'") : "";
		this.inherited(arguments);
	},

	_setDisabledAttr: function(/*Boolean*/ value){
		this.disabled = value;
		dojo.attr(this.focusNode, 'disabled', value);
		if(this.valueNode){
			dojo.attr(this.valueNode, 'disabled', value);
		}
		dijit.setWaiState(this.focusNode, "disabled", value);

		if(value){
			// reset those, because after the domNode is disabled, we can no longer receive
			// mouse related events, see #4200
			this._hovering = false;
			this._active = false;
			// remove the tabIndex, especially for FF
			this.focusNode.setAttribute('tabIndex', "-1");
		}else{
			this.focusNode.setAttribute('tabIndex', this.tabIndex);
		}
		this._setStateClass();
	},

	setDisabled: function(/*Boolean*/ disabled){
		// summary:
		//		Deprecated.   Use attr('disabled', ...) instead.
		dojo.deprecated("setDisabled("+disabled+") is deprecated. Use attr('disabled',"+disabled+") instead.", "", "2.0");
		this.attr('disabled', disabled);
	},

	_onFocus: function(e){
		if(this.scrollOnFocus){
			dijit.scrollIntoView(this.domNode);
		}
		this.inherited(arguments);
	},

	_onMouse : function(/*Event*/ event){
		// summary:
		//	Sets _hovering, _active, and stateModifier properties depending on mouse state,
		//	then calls setStateClass() to set appropriate CSS classes for this.domNode.
		//
		//	To get a different CSS class for hover, send onmouseover and onmouseout events to this method.
		//	To get a different CSS class while mouse button is depressed, send onmousedown to this method.

		var mouseNode = event.currentTarget;
		if(mouseNode && mouseNode.getAttribute){
			this.stateModifier = mouseNode.getAttribute("stateModifier") || "";
		}

		if(!this.disabled){
			switch(event.type){
				case "mouseenter":
				case "mouseover":
					this._hovering = true;
					this._active = this._mouseDown;
					break;

				case "mouseout":
				case "mouseleave":
					this._hovering = false;
					this._active = false;
					break;

				case "mousedown" :
					this._active = true;
					this._mouseDown = true;
					// set a global event to handle mouseup, so it fires properly
					//	even if the cursor leaves the button
					var mouseUpConnector = this.connect(dojo.body(), "onmouseup", function(){
						// if user clicks on the button, even if the mouse is released outside of it,
						// this button should get focus (which mimics native browser buttons)
						if(this._mouseDown && this.isFocusable()){
							this.focus();
						}
						this._active = false;
						this._mouseDown = false;
						this._setStateClass();
						this.disconnect(mouseUpConnector);
					});
					break;
			}
			this._setStateClass();
		}
	},

	isFocusable: function(){
		// summary:
		//		Tells if this widget is focusable or not.   Used internally by dijit.
		// tags:
		//		protected
		return !this.disabled && !this.readOnly && this.focusNode && (dojo.style(this.domNode, "display") != "none");
	},

	focus: function(){
		// summary:
		//		Put focus on this widget
		dijit.focus(this.focusNode);
	},

	_setStateClass: function(){
		// summary:
		//		Update the visual state of the widget by setting the css classes on this.domNode
		//		(or this.stateNode if defined) by combining this.baseClass with
		//		various suffixes that represent the current widget state(s).
		//
		// description:
		//		In the case where a widget has multiple
		//		states, it sets the class based on all possible
		//	 	combinations.  For example, an invalid form widget that is being hovered
		//		will be "dijitInput dijitInputInvalid dijitInputHover dijitInputInvalidHover".
		//
		//		For complex widgets with multiple regions, there can be various hover/active states,
		//		such as "Hover" or "CloseButtonHover" (for tab buttons).
		//		This is controlled by a stateModifier="CloseButton" attribute on the close button node.
		//
		//		The widget may have one or more of the following states, determined
		//		by this.state, this.checked, this.valid, and this.selected:
		//			- Error - ValidationTextBox sets this.state to "Error" if the current input value is invalid
		//			- Checked - ex: a checkmark or a ToggleButton in a checked state, will have this.checked==true
		//			- Selected - ex: currently selected tab will have this.selected==true
		//
		//		In addition, it may have one or more of the following states,
		//		based on this.disabled and flags set in _onMouse (this._active, this._hovering, this._focused):
		//			- Disabled	- if the widget is disabled
		//			- Active		- if the mouse (or space/enter key?) is being pressed down
		//			- Focused		- if the widget has focus
		//			- Hover		- if the mouse is over the widget

		// Compute new set of classes
		var newStateClasses = this.baseClass.split(" ");

		function multiply(modifier){
			newStateClasses = newStateClasses.concat(dojo.map(newStateClasses, function(c){ return c+modifier; }), "dijit"+modifier);
		}

		if(this.checked){
			multiply("Checked");
		}
		if(this.state){
			multiply(this.state);
		}
		if(this.selected){
			multiply("Selected");
		}

		if(this.disabled){
			multiply("Disabled");
		}else if(this.readOnly){
			multiply("ReadOnly");
		}else if(this._active){
			multiply(this.stateModifier+"Active");
		}else{
			if(this._focused){
				multiply("Focused");
			}
			if(this._hovering){
				multiply(this.stateModifier+"Hover");
			}
		}

		// Remove old state classes and add new ones.
		// For performance concerns we only write into domNode.className once.
		var tn = this.stateNode || this.domNode,
			classHash = {};	// set of all classes (state and otherwise) for node

		dojo.forEach(tn.className.split(" "), function(c){ classHash[c] = true; });

		if("_stateClasses" in this){
			dojo.forEach(this._stateClasses, function(c){ delete classHash[c]; });
		}

		dojo.forEach(newStateClasses, function(c){ classHash[c] = true; });

		var newClasses = [];
		for(var c in classHash){
			newClasses.push(c);
		}
		tn.className = newClasses.join(" ");

		this._stateClasses = newStateClasses;
	},

	compare: function(/*anything*/val1, /*anything*/val2){
		// summary:
		//		Compare 2 values (as returned by attr('value') for this widget).
		// tags:
		//		protected
		if(typeof val1 == "number" && typeof val2 == "number"){
			return (isNaN(val1) && isNaN(val2)) ? 0 : val1 - val2;
		}else if(val1 > val2){
			return 1;
		}else if(val1 < val2){
			return -1;
		}else{
			return 0;
		}
	},

	onChange: function(newValue){
		// summary:
		//		Callback when this widget's value is changed.
		// tags:
		//		callback
	},

	// _onChangeActive: [private] Boolean
	//		Indicates that changes to the value should call onChange() callback.
	//		This is false during widget initialization, to avoid calling onChange()
	//		when the initial value is set.
	_onChangeActive: false,

	_handleOnChange: function(/*anything*/ newValue, /* Boolean? */ priorityChange){
		// summary:
		//		Called when the value of the widget is set.  Calls onChange() if appropriate
		// newValue:
		//		the new value
		// priorityChange:
		//		For a slider, for example, dragging the slider is priorityChange==false,
		//		but on mouse up, it's priorityChange==true.  If intermediateChanges==true,
		//		onChange is only called form priorityChange=true events.
		// tags:
		//		private
		this._lastValue = newValue;
		if(this._lastValueReported == undefined && (priorityChange === null || !this._onChangeActive)){
			// this block executes not for a change, but during initialization,
			// and is used to store away the original value (or for ToggleButton, the original checked state)
			this._resetValue = this._lastValueReported = newValue;
		}
		if((this.intermediateChanges || priorityChange || priorityChange === undefined) &&
			((typeof newValue != typeof this._lastValueReported) ||
				this.compare(newValue, this._lastValueReported) != 0)){
			this._lastValueReported = newValue;
			if(this._onChangeActive){
				if(this._onChangeHandle){
					clearTimeout(this._onChangeHandle);
				}
				// setTimout allows hidden value processing to run and
				// also the onChange handler can safely adjust focus, etc
				this._onChangeHandle = setTimeout(dojo.hitch(this,
					function(){
						this._onChangeHandle = null;
						this.onChange(newValue);
					}), 0); // try to collapse multiple onChange's fired faster than can be processed
			}
		}
	},

	create: function(){
		// Overrides _Widget.create()
		this.inherited(arguments);
		this._onChangeActive = true;
		this._setStateClass();
	},

	destroy: function(){
		if(this._onChangeHandle){ // destroy called before last onChange has fired
			clearTimeout(this._onChangeHandle);
			this.onChange(this._lastValueReported);
		}
		this.inherited(arguments);
	},

	setValue: function(/*String*/ value){
		// summary:
		//		Deprecated.   Use attr('value', ...) instead.
		dojo.deprecated("dijit.form._FormWidget:setValue("+value+") is deprecated.  Use attr('value',"+value+") instead.", "", "2.0");
		this.attr('value', value);
	},

	getValue: function(){
		// summary:
		//		Deprecated.   Use attr('value') instead.
		dojo.deprecated(this.declaredClass+"::getValue() is deprecated. Use attr('value') instead.", "", "2.0");
		return this.attr('value');
	}
});

dojo.declare("dijit.form._FormValueWidget", dijit.form._FormWidget,
{
	// summary:
	//		Base class for widgets corresponding to native HTML elements such as <input> or <select> that have user changeable values.
	// description:
	//		Each _FormValueWidget represents a single input value, and has a (possibly hidden) <input> element,
	//		to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
	//		works as expected.

	// Don't attempt to mixin the 'type', 'name' attributes here programatically -- they must be declared
	// directly in the template as read by the parser in order to function. IE is known to specifically
	// require the 'name' attribute at element creation time.   See #8484, #8660.
	// TODO: unclear what that {value: ""} is for; FormWidget.attributeMap copies value to focusNode,
	// so maybe {value: ""} is so the value *doesn't* get copied to focusNode?
	// Seems like we really want value removed from attributeMap altogether
	// (although there's no easy way to do that now)

	// readOnly: Boolean
	//		Should this widget respond to user input?
	//		In markup, this is specified as "readOnly".
	//		Similar to disabled except readOnly form values are submitted.
	readOnly: false,

	attributeMap: dojo.delegate(dijit.form._FormWidget.prototype.attributeMap, {
		value: "",
		readOnly: "focusNode"
	}),

	_setReadOnlyAttr: function(/*Boolean*/ value){
		this.readOnly = value;
		dojo.attr(this.focusNode, 'readOnly', value);
		dijit.setWaiState(this.focusNode, "readonly", value);
		this._setStateClass();
	},

	postCreate: function(){
		if(dojo.isIE){ // IE won't stop the event with keypress
			this.connect(this.focusNode || this.domNode, "onkeydown", this._onKeyDown);
		}
		// Update our reset value if it hasn't yet been set (because this.attr
		// is only called when there *is* a value
		if(this._resetValue === undefined){
			this._resetValue = this.value;
		}
	},

	_setValueAttr: function(/*anything*/ newValue, /*Boolean, optional*/ priorityChange){
		// summary:
		//		Hook so attr('value', value) works.
		// description:
		//		Sets the value of the widget.
		//		If the value has changed, then fire onChange event, unless priorityChange
		//		is specified as null (or false?)
		this.value = newValue;
		this._handleOnChange(newValue, priorityChange);
	},

	_getValueAttr: function(){
		// summary:
		//		Hook so attr('value') works.
		return this._lastValue;
	},

	undo: function(){
		// summary:
		//		Restore the value to the last value passed to onChange
		this._setValueAttr(this._lastValueReported, false);
	},

	reset: function(){
		// summary:
		//		Reset the widget's value to what it was at initialization time
		this._hasBeenBlurred = false;
		this._setValueAttr(this._resetValue, true);
	},

	_onKeyDown: function(e){
		if(e.keyCode == dojo.keys.ESCAPE && !(e.ctrlKey || e.altKey || e.metaKey)){
			var te;
			if(dojo.isIE){
				e.preventDefault(); // default behavior needs to be stopped here since keypress is too late
				te = document.createEventObject();
				te.keyCode = dojo.keys.ESCAPE;
				te.shiftKey = e.shiftKey;
				e.srcElement.fireEvent('onkeypress', te);
			}
		}
	},

	_layoutHackIE7: function(){
		// summary:
		//		Work around table sizing bugs on IE7 by forcing redraw

		if(dojo.isIE == 7){ // fix IE7 layout bug when the widget is scrolled out of sight
			var domNode = this.domNode;
			var parent = domNode.parentNode;
			var pingNode = domNode.firstChild || domNode; // target node most unlikely to have a custom filter
			var origFilter = pingNode.style.filter; // save custom filter, most likely nothing
			while(parent && parent.clientHeight == 0){ // search for parents that haven't rendered yet
				parent._disconnectHandle = this.connect(parent, "onscroll", dojo.hitch(this, function(e){
					this.disconnect(parent._disconnectHandle); // only call once
					parent.removeAttribute("_disconnectHandle"); // clean up DOM node
					pingNode.style.filter = (new Date()).getMilliseconds(); // set to anything that's unique
					setTimeout(function(){ pingNode.style.filter = origFilter }, 0); // restore custom filter, if any
				}));
				parent = parent.parentNode;
			}
		}
	}
});

}

if(!dojo._hasResource["dijit._HasDropDown"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._HasDropDown"] = true;
dojo.provide("dijit._HasDropDown");




dojo.declare("dijit._HasDropDown",
	null,
	{
		// summary:
		//		Mixin for widgets that need drop down ability.

		// _buttonNode: [protected] DomNode
		//		The button/icon/node to click to display the drop down.
		//		Can be set via a dojoAttachPoint assignment.
		//		If missing, then either focusNode or domNode (if focusNode is also missing) will be used.
		_buttonNode: null,

		// _arrowWrapperNode: [protected] DomNode
		//		Will set CSS class dijitUpArrow, dijitDownArrow, dijitRightArrow etc. on this node depending
		//		on where the drop down is set to be positioned.
		//		Can be set via a dojoAttachPoint assignment.
		//		If missing, then _buttonNode will be used.
		_arrowWrapperNode: null,

		// _popupStateNode: [protected] DomNode
		//		The node to set the popupActive class on.
		//		Can be set via a dojoAttachPoint assignment.
		//		If missing, then focusNode or _buttonNode (if focusNode is missing) will be used.
		_popupStateNode: null,

		// _aroundNode: [protected] DomNode
		//		The node to display the popup around.
		//		Can be set via a dojoAttachPoint assignment.
		//		If missing, then domNode will be used.
		_aroundNode: null,

		// dropDown: [protected] Widget
		//		The widget to display as a popup.  This widget *must* be
		//		defined before the startup function is called.
		dropDown: null,

		// autoWidth: [protected] Boolean
		//		Set to true to make the drop down at least as wide as this
		//		widget.  Set to false if the drop down should just be its
		//		default width
		autoWidth: true,

		// forceWidth: [protected] Boolean
		//		Set to true to make the drop down exactly as wide as this
		//		widget.  Overrides autoWidth.
		forceWidth: false,

		// maxHeight: [protected] Integer
		//		The max height for our dropdown.  Set to 0 for no max height.
		//		any dropdown taller than this will have scrollbars
		maxHeight: 0,

		// dropDownPosition: [const] String[]
		//		This variable controls the position of the drop down.
		//		It's an array of strings with the following values:
		//
		//			* before: places drop down to the left of the target node/widget, or to the right in
		//			  the case of RTL scripts like Hebrew and Arabic
		//			* after: places drop down to the right of the target node/widget, or to the left in
		//			  the case of RTL scripts like Hebrew and Arabic
		//			* above: drop down goes above target node
		//			* below: drop down goes below target node
		//
		//		The list is positions is tried, in order, until a position is found where the drop down fits
		//		within the viewport.
		//
		dropDownPosition: ["below","above"],

		// _stopClickEvents: Boolean
		//		When set to false, the click events will not be stopped, in
		//		case you want to use them in your subwidget
		_stopClickEvents: true,

		_onDropDownMouse: function(/*Event*/ e){
			// summary:
			//		Callback when the user mouse clicks on the arrow icon, or presses the down
			//		arrow key, to open the drop down.

			// We handle mouse events using onmousedown in order to allow for selecting via
			// a mouseDown --> mouseMove --> mouseUp.  So, our click is already handled, unless
			// we are executed via keypress - in which case, this._seenKeydown
			// will be set to true.
			if(e.type == "click" && !this._seenKeydown){ return; }
			this._seenKeydown = false;

			// If we are a mouse event, set up the mouseup handler.  See _onDropDownMouse() for
			// details on this handler.
			if(e.type == "mousedown"){
				this._docHandler = this.connect(dojo.doc, "onmouseup", "_onDropDownMouseup");
			}
			if(this.disabled || this.readOnly){ return; }
			if(this._stopClickEvents){
				dojo.stopEvent(e);
			}
			this.toggleDropDown();

			// If we are a click, then we'll pretend we did a mouse up
			if(e.type == "click" || e.type == "keypress"){
				this._onDropDownMouseup();
			}
		},

		_onDropDownMouseup: function(/*Event?*/ e){
			// summary:
			//		Callback when the user lifts their mouse after mouse down on the arrow icon.
			//		If the drop is a simple menu and the mouse is over the menu, we execute it, otherwise, we focus our
			//		dropDown node.  If the event is missing, then we are not
			//		a mouseup event.
			//
			//		This is useful for the common mouse movement pattern
			//		with native browser <select> nodes:
			//			1. mouse down on the select node (probably on the arrow)
			//			2. move mouse to a menu item while holding down the mouse button
			//			3. mouse up.  this selects the menu item as though the user had clicked it.

			if(e && this._docHandler){
				this.disconnect(this._docHandler);
			}
			var dropDown = this.dropDown, overMenu = false;

			if(e && this._opened){
				// This code deals with the corner-case when the drop down covers the original widget,
				// because it's so large.  In that case mouse-up shouldn't select a value from the menu.
				// Find out if our target is somewhere in our dropdown widget,
				// but not over our _buttonNode (the clickable node)
				var c = dojo.position(this._buttonNode, true);
				if(!(e.pageX >= c.x && e.pageX <= c.x + c.w) ||
					!(e.pageY >= c.y && e.pageY <= c.y + c.h)){
					var t = e.target;
					while(t && !overMenu){
						if(dojo.hasClass(t, "dijitPopup")){
							overMenu = true;
						}else{
							t = t.parentNode;
						}
					}
					if(overMenu){
						t = e.target;
						if(dropDown.onItemClick){
							var menuItem;
							while(t && !(menuItem = dijit.byNode(t))){
								t = t.parentNode;
							}
							if(menuItem && menuItem.onClick && menuItem.getParent){
								menuItem.getParent().onItemClick(menuItem, e);
							}
						}
						return;
					}
				}
			}
			if(this._opened && dropDown.focus){
				// Focus the dropdown widget - do it on a delay so that we
				// don't steal our own focus.
				window.setTimeout(dojo.hitch(dropDown, "focus"), 1);
			}
		},

		_setupDropdown: function(){
			// summary:
			//		set up nodes and connect our mouse and keypress events
			this._buttonNode = this._buttonNode || this.focusNode || this.domNode;
			this._popupStateNode = this._popupStateNode || this.focusNode || this._buttonNode;
			this._aroundNode = this._aroundNode || this.domNode;
			this.connect(this._buttonNode, "onmousedown", "_onDropDownMouse");
			this.connect(this._buttonNode, "onclick", "_onDropDownMouse");
			this.connect(this._buttonNode, "onkeydown", "_onDropDownKeydown");
			this.connect(this._buttonNode, "onblur", "_onDropDownBlur");
			this.connect(this._buttonNode, "onkeypress", "_onKey");

			// If we have a _setStateClass function (which happens when
			// we are a form widget), then we need to connect our open/close
			// functions to it
			if(this._setStateClass){
				this.connect(this, "openDropDown", "_setStateClass");
				this.connect(this, "closeDropDown", "_setStateClass");
			}

			// Add a class to the "dijitDownArrowButton" type class to _buttonNode so theme can set direction of arrow
			// based on where drop down will normally appear
			var defaultPos = {
					"after" : this.isLeftToRight() ? "Right" : "Left",
					"before" : this.isLeftToRight() ? "Left" : "Right",
					"above" : "Up",
					"below" : "Down",
					"left" : "Left",
					"right" : "Right"
			}[this.dropDownPosition[0]] || this.dropDownPosition[0] || "Down";
			dojo.addClass(this._arrowWrapperNode || this._buttonNode, "dijit" + defaultPos + "ArrowButton");
		},

		postCreate: function(){
			this._setupDropdown();
			this.inherited(arguments);
		},

		destroyDescendants: function(){
			if(this.dropDown){
				// Destroy the drop down, unless it's already been destroyed.  This can happen because
				// the drop down is a direct child of <body> even though it's logically my child.
				if(!this.dropDown._destroyed){
					this.dropDown.destroyRecursive();
				}
				delete this.dropDown;
			}
			this.inherited(arguments);
		},

		_onDropDownKeydown: function(/*Event*/ e){
			this._seenKeydown = true;
		},

		_onKeyPress: function(/*Event*/ e){
			if(this._opened && e.charOrCode == dojo.keys.ESCAPE && !e.shiftKey && !e.ctrlKey && !e.altKey){
				this.toggleDropDown();
				dojo.stopEvent(e);
				return;
			}
			this.inherited(arguments);
		},

		_onDropDownBlur: function(/*Event*/ e){
			this._seenKeydown = false;
		},

		_onKey: function(/*Event*/ e){
			// summary:
			//		Callback when the user presses a key on menu popup node

			if(this.disabled || this.readOnly){ return; }
			var d = this.dropDown;
			if(d && this._opened && d.handleKey){
				if(d.handleKey(e) === false){ return; }
			}
			if(d && this._opened && e.keyCode == dojo.keys.ESCAPE){
				this.toggleDropDown();
				return;
			}
			if(e.keyCode == dojo.keys.DOWN_ARROW || e.keyCode == dojo.keys.ENTER || e.charOrCode == " "){
				this._onDropDownMouse(e);
			}
		},

		_onBlur: function(){
			// summary:
			//		Called magically when focus has shifted away from this widget and it's dropdown

			this.closeDropDown();
			// don't focus on button.  the user has explicitly focused on something else.
			this.inherited(arguments);
		},

		isLoaded: function(){
			// summary:
			//		Returns whether or not the dropdown is loaded.  This can
			//		be overridden in order to force a call to loadDropDown().
			// tags:
			//		protected

			return true;
		},

		loadDropDown: function(/* Function */ loadCallback){
			// summary:
			//		Loads the data for the dropdown, and at some point, calls
			//		the given callback
			// tags:
			//		protected

			loadCallback();
		},

		toggleDropDown: function(){
			// summary:
			//		Toggle the drop-down widget; if it is up, close it, if not, open it
			// tags:
			//		protected

			if(this.disabled || this.readOnly){ return; }
			this.focus();
			var dropDown = this.dropDown;
			if(!dropDown){ return; }
			if(!this._opened){
				// If we aren't loaded, load it first so there isn't a flicker
				if(!this.isLoaded()){
					this.loadDropDown(dojo.hitch(this, "openDropDown"));
					return;
				}else{
					this.openDropDown();
				}
			}else{
				this.closeDropDown();
			}
		},

		openDropDown: function(){
			// summary:
			//		Opens the dropdown for this widget - it returns the
			//		return value of dijit.popup.open
			// tags:
			//		protected

			var dropDown = this.dropDown;
			var ddNode = dropDown.domNode;
			var self = this;

			// Prepare our popup's height and honor maxHeight if it exists.

			// TODO: isn't maxHeight dependent on the return value from dijit.popup.open(),
			// ie, dependent on how much space is available (BK)

			if(!this._preparedNode){
				dijit.popup.moveOffScreen(ddNode);
				this._preparedNode = true;			
				// Check if we have explicitly set width and height on the dropdown widget dom node
				if(ddNode.style.width){
					this._explicitDDWidth = true;
				}
				if(ddNode.style.height){
					this._explicitDDHeight = true;
				}
			}
			if(this.maxHeight || this.forceWidth || this.autoWidth){
				var myStyle = {
					display: "",
					visibility: "hidden"
				};
				if(!this._explicitDDWidth){
					myStyle.width = "";
				}
				if(!this._explicitDDHeight){
					myStyle.height = "";
				}
				dojo.style(ddNode, myStyle);
				var mb = dojo.marginBox(ddNode);
				var overHeight = (this.maxHeight && mb.h > this.maxHeight);
				dojo.style(ddNode, {overflow: overHeight ? "auto" : "hidden"});
				if(this.forceWidth){
					mb.w = this.domNode.offsetWidth;
				}else if(this.autoWidth){
					mb.w = Math.max(mb.w, this.domNode.offsetWidth);
				}else{
					delete mb.w;
				}
				if(overHeight){
					mb.h = this.maxHeight;
					if("w" in mb){
						mb.w += 16;
					}
				}else{
					delete mb.h;
				}
				delete mb.t;
				delete mb.l;
				if(dojo.isFunction(dropDown.resize)){
					dropDown.resize(mb);
				}else{
					dojo.marginBox(ddNode, mb);
				}
			}
			var retVal = dijit.popup.open({
				parent: this,
				popup: dropDown,
				around: this._aroundNode,
				orient: dijit.getPopupAroundAlignment((this.dropDownPosition && this.dropDownPosition.length) ? this.dropDownPosition : ["below"],this.isLeftToRight()),
				onExecute: function(){
					self.closeDropDown(true);
				},
				onCancel: function(){
					self.closeDropDown(true);
				},
				onClose: function(){
					dojo.attr(self._popupStateNode, "popupActive", false);
					dojo.removeClass(self._popupStateNode, "dijitHasDropDownOpen");
					self._opened = false;
					self.state = "";
				}
			});
			dojo.attr(this._popupStateNode, "popupActive", "true");
			dojo.addClass(self._popupStateNode, "dijitHasDropDownOpen");
			this._opened=true;
			this.state="Opened";
			// TODO: set this.checked and call setStateClass(), to affect button look while drop down is shown
			return retVal;
		},

		closeDropDown: function(/*Boolean*/ focus){
			// summary:
			//		Closes the drop down on this widget
			// tags:
			//		protected

			if(this._opened){
				dijit.popup.close(this.dropDown);
				if(focus){ this.focus(); }
				this._opened = false;
				this.state = "";
			}
		}

	}
);

}

if(!dojo._hasResource["dijit.form.Button"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.Button"] = true;
dojo.provide("dijit.form.Button");





dojo.declare("dijit.form.Button",
	dijit.form._FormWidget,
	{
	// summary:
	//		Basically the same thing as a normal HTML button, but with special styling.
	// description:
	//		Buttons can display a label, an icon, or both.
	//		A label should always be specified (through innerHTML) or the label
	//		attribute.  It can be hidden via showLabel=false.
	// example:
	// |	<button dojoType="dijit.form.Button" onClick="...">Hello world</button>
	//
	// example:
	// |	var button1 = new dijit.form.Button({label: "hello world", onClick: foo});
	// |	dojo.body().appendChild(button1.domNode);

	// label: HTML String
	//		Text to display in button.
	//		If the label is hidden (showLabel=false) then and no title has
	//		been specified, then label is also set as title attribute of icon.
	label: "",

	// showLabel: Boolean
	//		Set this to true to hide the label text and display only the icon.
	//		(If showLabel=false then iconClass must be specified.)
	//		Especially useful for toolbars.
	//		If showLabel=true, the label will become the title (a.k.a. tooltip/hint) of the icon.
	//
	//		The exception case is for computers in high-contrast mode, where the label
	//		will still be displayed, since the icon doesn't appear.
	showLabel: true,

	// iconClass: String
	//		Class to apply to DOMNode in button to make it display an icon
	iconClass: "",

	// type: String
	//		Defines the type of button.  "button", "submit", or "reset".
	type: "button",

	baseClass: "dijitButton",

	templateString: dojo.cache("dijit.form", "templates/Button.html", "<span class=\"dijit dijitReset dijitLeft dijitInline\"\r\n\tdojoAttachEvent=\"onclick:_onButtonClick,onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse\"\r\n\t><span class=\"dijitReset dijitRight dijitInline\"\r\n\t\t><span class=\"dijitReset dijitInline dijitButtonNode\"\r\n\t\t\t><button class=\"dijitReset dijitStretch dijitButtonContents\"\r\n\t\t\t\tdojoAttachPoint=\"titleNode,focusNode\"\r\n\t\t\t\t${nameAttrSetting} type=\"${type}\" value=\"${value}\" waiRole=\"button\" waiState=\"labelledby-${id}_label\"\r\n\t\t\t\t><span class=\"dijitReset dijitInline\" dojoAttachPoint=\"iconNode\"\r\n\t\t\t\t\t><span class=\"dijitReset dijitToggleButtonIconChar\">&#10003;</span\r\n\t\t\t\t></span\r\n\t\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\r\n\t\t\t\t\tid=\"${id}_label\"\r\n\t\t\t\t\tdojoAttachPoint=\"containerNode\"\r\n\t\t\t\t></span\r\n\t\t\t></button\r\n\t\t></span\r\n\t></span\r\n></span>\r\n"),

	attributeMap: dojo.delegate(dijit.form._FormWidget.prototype.attributeMap, {
		label: { node: "containerNode", type: "innerHTML" },
		iconClass: { node: "iconNode", type: "class" }
	}),


	_onClick: function(/*Event*/ e){
		// summary:
		//		Internal function to handle click actions
		if(this.disabled){
			return false;
		}
		this._clicked(); // widget click actions
		return this.onClick(e); // user click actions
	},

	_onButtonClick: function(/*Event*/ e){
		// summary:
		//		Handler when the user activates the button portion.
		if(this._onClick(e) === false){ // returning nothing is same as true
			e.preventDefault(); // needed for checkbox
		}else if(this.type == "submit" && !this.focusNode.form){ // see if a nonform widget needs to be signalled
			for(var node=this.domNode; node.parentNode/*#5935*/; node=node.parentNode){
				var widget=dijit.byNode(node);
				if(widget && typeof widget._onSubmit == "function"){
					widget._onSubmit(e);
					break;
				}
			}
		}
	},

	_setValueAttr: function(/*String*/ value){
		// Verify that value cannot be set for BUTTON elements.
		var attr = this.attributeMap.value || '';
		if(this[attr.node || attr || 'domNode'].tagName == 'BUTTON'){
			// On IE, setting value actually overrides innerHTML, so disallow for everyone for consistency
			if(value != this.value){
				console.debug('Cannot change the value attribute on a Button widget.');
			}
		}
	},

	_fillContent: function(/*DomNode*/ source){
		// Overrides _Templated._fillContent().
		// If button label is specified as srcNodeRef.innerHTML rather than
		// this.params.label, handle it here.
		if(source && (!this.params || !("label" in this.params))){
			this.attr('label', source.innerHTML);
		}
	},

	postCreate: function(){
		dojo.setSelectable(this.focusNode, false);
		this.inherited(arguments);
	},

	_setShowLabelAttr: function(val){
		if(this.containerNode){
			dojo.toggleClass(this.containerNode, "dijitDisplayNone", !val);
		}
		this.showLabel = val;
	},

	onClick: function(/*Event*/ e){
		// summary:
		//		Callback for when button is clicked.
		//		If type="submit", return true to perform submit, or false to cancel it.
		// type:
		//		callback
		return true;		// Boolean
	},

	_clicked: function(/*Event*/ e){
		// summary:
		//		Internal overridable function for when the button is clicked
	},

	setLabel: function(/*String*/ content){
		// summary:
		//		Deprecated.  Use attr('label', ...) instead.
		dojo.deprecated("dijit.form.Button.setLabel() is deprecated.  Use attr('label', ...) instead.", "", "2.0");
		this.attr("label", content);
	},
	_setLabelAttr: function(/*String*/ content){
		// summary:
		//		Hook for attr('label', ...) to work.
		// description:
		//		Set the label (text) of the button; takes an HTML string.
		this.containerNode.innerHTML = this.label = content;
		if(this.showLabel == false && !this.params.title){
			this.titleNode.title = dojo.trim(this.containerNode.innerText || this.containerNode.textContent || '');
		}
	}
});


dojo.declare("dijit.form.DropDownButton", [dijit.form.Button, dijit._Container, dijit._HasDropDown], {
	// summary:
	//		A button with a drop down
	//
	// example:
	// |	<button dojoType="dijit.form.DropDownButton" label="Hello world">
	// |		<div dojotype="dijit.Menu">...</div>
	// |	</button>
	//
	// example:
	// |	var button1 = new dijit.form.DropDownButton({ label: "hi", dropDown: new dijit.Menu(...) });
	// |	dojo.body().appendChild(button1);
	//

	baseClass : "dijitDropDownButton",

	templateString: dojo.cache("dijit.form", "templates/DropDownButton.html", "<span class=\"dijit dijitReset dijitLeft dijitInline\"\r\n\tdojoAttachPoint=\"_buttonNode\"\r\n\tdojoAttachEvent=\"onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse\"\r\n\t><span class='dijitReset dijitRight dijitInline'\r\n\t\t><span class='dijitReset dijitInline dijitButtonNode'\r\n\t\t\t><button class=\"dijitReset dijitStretch dijitButtonContents\"\r\n\t\t\t\t${nameAttrSetting} type=\"${type}\" value=\"${value}\"\r\n\t\t\t\tdojoAttachPoint=\"focusNode,titleNode,_arrowWrapperNode\"\r\n\t\t\t\twaiRole=\"button\" waiState=\"haspopup-true,labelledby-${id}_label\"\r\n\t\t\t\t><span class=\"dijitReset dijitInline\"\r\n\t\t\t\t\tdojoAttachPoint=\"iconNode\"\r\n\t\t\t\t></span\r\n\t\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\r\n\t\t\t\t\tdojoAttachPoint=\"containerNode,_popupStateNode\"\r\n\t\t\t\t\tid=\"${id}_label\"\r\n\t\t\t\t></span\r\n\t\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonInner\">&thinsp;</span\r\n\t\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonChar\">&#9660;</span\r\n\t\t\t></button\r\n\t\t></span\r\n\t></span\r\n></span>\r\n"),

	_fillContent: function(){
		// Overrides Button._fillContent().
		//
		// My inner HTML contains both the button contents and a drop down widget, like
		// <DropDownButton>  <span>push me</span>  <Menu> ... </Menu> </DropDownButton>
		// The first node is assumed to be the button content. The widget is the popup.

		if(this.srcNodeRef){ // programatically created buttons might not define srcNodeRef
			//FIXME: figure out how to filter out the widget and use all remaining nodes as button
			//	content, not just nodes[0]
			var nodes = dojo.query("*", this.srcNodeRef);
			dijit.form.DropDownButton.superclass._fillContent.call(this, nodes[0]);

			// save pointer to srcNode so we can grab the drop down widget after it's instantiated
			this.dropDownContainer = this.srcNodeRef;
		}
	},

	startup: function(){
		if(this._started){ return; }

		// the child widget from srcNodeRef is the dropdown widget.  Insert it in the page DOM,
		// make it invisible, and store a reference to pass to the popup code.
		if(!this.dropDown){
			var dropDownNode = dojo.query("[widgetId]", this.dropDownContainer)[0];
			this.dropDown = dijit.byNode(dropDownNode);
			delete this.dropDownContainer;
		}
		dijit.popup.moveOffScreen(this.dropDown.domNode);

		this.inherited(arguments);
	},

	isLoaded: function(){
		// Returns whether or not we are loaded - if our dropdown has an href,
		// then we want to check that.
		var dropDown = this.dropDown;
		return (!dropDown.href || dropDown.isLoaded);
	},

	loadDropDown: function(){
		// Loads our dropdown
		var dropDown = this.dropDown;
		if(!dropDown){ return; }
		if(!this.isLoaded()){
			var handler = dojo.connect(dropDown, "onLoad", this, function(){
				dojo.disconnect(handler);
				this.openDropDown();
			});
			dropDown.refresh();
		}else{
			this.openDropDown();
		}
	},

	isFocusable: function(){
		// Overridden so that focus is handled by the _HasDropDown mixin, not by
		// the _FormWidget mixin.
		return this.inherited(arguments) && !this._mouseDown;
	}
});

dojo.declare("dijit.form.ComboButton", dijit.form.DropDownButton, {
	// summary:
	//		A combination button and drop-down button.
	//		Users can click one side to "press" the button, or click an arrow
	//		icon to display the drop down.
	//
	// example:
	// |	<button dojoType="dijit.form.ComboButton" onClick="...">
	// |		<span>Hello world</span>
	// |		<div dojoType="dijit.Menu">...</div>
	// |	</button>
	//
	// example:
	// |	var button1 = new dijit.form.ComboButton({label: "hello world", onClick: foo, dropDown: "myMenu"});
	// |	dojo.body().appendChild(button1.domNode);
	//

	templateString: dojo.cache("dijit.form", "templates/ComboButton.html", "<table class='dijit dijitReset dijitInline dijitLeft'\r\n\tcellspacing='0' cellpadding='0' waiRole=\"presentation\"\r\n\t><tbody waiRole=\"presentation\"><tr waiRole=\"presentation\"\r\n\t\t><td class=\"dijitReset dijitStretch dijitButtonNode\"><button id=\"${id}_button\" class=\"dijitReset dijitButtonContents\"\r\n\t\t\tdojoAttachEvent=\"onclick:_onButtonClick,onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse,onkeypress:_onButtonKeyPress\"  dojoAttachPoint=\"titleNode\"\r\n\t\t\twaiRole=\"button\" waiState=\"labelledby-${id}_label\"\r\n\t\t\t><div class=\"dijitReset dijitInline\" dojoAttachPoint=\"iconNode\" waiRole=\"presentation\"></div\r\n\t\t\t><div class=\"dijitReset dijitInline dijitButtonText\" id=\"${id}_label\" dojoAttachPoint=\"containerNode\" waiRole=\"presentation\"></div\r\n\t\t></button></td\r\n\t\t><td id=\"${id}_arrow\" class='dijitReset dijitRight dijitButtonNode dijitArrowButton'\r\n\t\t\tdojoAttachPoint=\"_popupStateNode,focusNode,_buttonNode\"\r\n\t\t\tdojoAttachEvent=\"onmouseenter:_onMouse,onmouseleave:_onMouse,onkeypress:_onArrowKeyPress\"\r\n\t\t\tstateModifier=\"DownArrow\"\r\n\t\t\ttitle=\"${optionsTitle}\" ${nameAttrSetting}\r\n\t\t\twaiRole=\"button\" waiState=\"haspopup-true\"\r\n\t\t\t><div class=\"dijitReset dijitArrowButtonInner\" waiRole=\"presentation\">&thinsp;</div\r\n\t\t\t><div class=\"dijitReset dijitArrowButtonChar\" waiRole=\"presentation\">&#9660;</div\r\n\t\t></td\r\n\t></tr></tbody\r\n></table>\r\n"),

	attributeMap: dojo.mixin(dojo.clone(dijit.form.Button.prototype.attributeMap), {
		id: "",
		tabIndex: ["focusNode", "titleNode"],
		title: "titleNode"
	}),

	// optionsTitle: String
	//		Text that describes the options menu (accessibility)
	optionsTitle: "",

	baseClass: "dijitComboButton",

	_focusedNode: null,

	postCreate: function(){
		this.inherited(arguments);
		this._focalNodes = [this.titleNode, this._popupStateNode];
		var isIE = dojo.isIE;
		dojo.forEach(this._focalNodes, dojo.hitch(this, function(node){
			this.connect(node, isIE? "onactivate" : "onfocus", this._onNodeFocus);
			this.connect(node, isIE? "ondeactivate" : "onblur", this._onNodeBlur);
		}));
		if(isIE && (isIE < 8 || dojo.isQuirks)){ // fixed in IE8/strict
			with(this.titleNode){ // resize BUTTON tag so parent TD won't inherit extra padding
				style.width = scrollWidth + "px";
				this.connect(this.titleNode, "onresize", function(){
					setTimeout( function(){ style.width = scrollWidth + "px"; }, 0);
				});
			}
		}
	},

	_onNodeFocus: function(evt){
		this._focusedNode = evt.currentTarget;
		var fnc = this._focusedNode == this.focusNode ? "dijitDownArrowButtonFocused" : "dijitButtonContentsFocused";
		dojo.addClass(this._focusedNode, fnc);
	},

	_onNodeBlur: function(evt){
		var fnc = evt.currentTarget == this.focusNode ? "dijitDownArrowButtonFocused" : "dijitButtonContentsFocused";
		dojo.removeClass(evt.currentTarget, fnc);
	},

	_onBlur: function(){
		this.inherited(arguments);
		this._focusedNode = null;
	},
	
	_onButtonKeyPress: function(/*Event*/ evt){
		// summary:
		//		Handler for right arrow key when focus is on left part of button
		if(evt.charOrCode == dojo.keys[this.isLeftToRight() ? "RIGHT_ARROW" : "LEFT_ARROW"]){
			dijit.focus(this._popupStateNode);
			dojo.stopEvent(evt);
		}
	},

	_onArrowKeyPress: function(/*Event*/ evt){
		// summary:
		//		Handler for left arrow key when focus is on right part of button
		if(evt.charOrCode == dojo.keys[this.isLeftToRight() ? "LEFT_ARROW" : "RIGHT_ARROW"]){
			dijit.focus(this.titleNode);
			dojo.stopEvent(evt);
		}
	},
	
	focus: function(/*String*/ position){
		// summary:
		//		Focuses this widget to according to position, if specified,
		//		otherwise on arrow node
		// position:
		//		"start" or "end"
		
		dijit.focus(position == "start" ? this.titleNode : this._popupStateNode);
	}
});

dojo.declare("dijit.form.ToggleButton", dijit.form.Button, {
	// summary:
	//		A button that can be in two states (checked or not).
	//		Can be base class for things like tabs or checkbox or radio buttons

	baseClass: "dijitToggleButton",

	// checked: Boolean
	//		Corresponds to the native HTML <input> element's attribute.
	//		In markup, specified as "checked='checked'" or just "checked".
	//		True if the button is depressed, or the checkbox is checked,
	//		or the radio button is selected, etc.
	checked: false,

	attributeMap: dojo.mixin(dojo.clone(dijit.form.Button.prototype.attributeMap), {
		checked:"focusNode"
	}),

	_clicked: function(/*Event*/ evt){
		this.attr('checked', !this.checked);
	},

	_setCheckedAttr: function(/*Boolean*/ value){
		this.checked = value;
		dojo.attr(this.focusNode || this.domNode, "checked", value);
		dijit.setWaiState(this.focusNode || this.domNode, "pressed", value);
		this._setStateClass();
		this._handleOnChange(value, true);
	},

	setChecked: function(/*Boolean*/ checked){
		// summary:
		//		Deprecated.   Use attr('checked', true/false) instead.
		dojo.deprecated("setChecked("+checked+") is deprecated. Use attr('checked',"+checked+") instead.", "", "2.0");
		this.attr('checked', checked);
	},

	reset: function(){
		// summary:
		//		Reset the widget's value to what it was at initialization time

		this._hasBeenBlurred = false;

		// set checked state to original setting
		this.attr('checked', this.params.checked || false);
	}
});

}

if(!dojo._hasResource["dijit.form.CheckBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.CheckBox"] = true;
dojo.provide("dijit.form.CheckBox");



dojo.declare(
	"dijit.form.CheckBox",
	dijit.form.ToggleButton,
	{
		// summary:
		// 		Same as an HTML checkbox, but with fancy styling.
		//
		// description:
		// User interacts with real html inputs.
		// On onclick (which occurs by mouse click, space-bar, or
		// using the arrow keys to switch the selected radio button),
		// we update the state of the checkbox/radio.
		//
		// There are two modes:
		//   1. High contrast mode
		//   2. Normal mode
		// In case 1, the regular html inputs are shown and used by the user.
		// In case 2, the regular html inputs are invisible but still used by
		// the user. They are turned quasi-invisible and overlay the background-image.

		templateString: dojo.cache("dijit.form", "templates/CheckBox.html", "<div class=\"dijitReset dijitInline\" waiRole=\"presentation\"\r\n\t><input\r\n\t \t${nameAttrSetting} type=\"${type}\" ${checkedAttrSetting}\r\n\t\tclass=\"dijitReset dijitCheckBoxInput\"\r\n\t\tdojoAttachPoint=\"focusNode\"\r\n\t \tdojoAttachEvent=\"onmouseover:_onMouse,onmouseout:_onMouse,onclick:_onClick\"\r\n/></div>\r\n"),

		baseClass: "dijitCheckBox",

		// type: [private] String
		//		type attribute on <input> node.
		//		Overrides `dijit.form.Button.type`.   Users should not change this value.
		type: "checkbox",

		// value: String
		//		As an initialization parameter, equivalent to value field on normal checkbox
		//		(if checked, the value is passed as the value when form is submitted).
		//
		//		However, attr('value') will return either the string or false depending on
		//		whether or not the checkbox is checked.
		//
		//		attr('value', string) will check the checkbox and change the value to the
		//		specified string
		//
		//		attr('value', boolean) will change the checked state.
		value: "on",

		// readOnly: Boolean
		//		Should this widget respond to user input?
		//		In markup, this is specified as "readOnly".
		//		Similar to disabled except readOnly form values are submitted.
		readOnly: false,

		attributeMap: dojo.delegate(dijit.form.ToggleButton.prototype.attributeMap, {
			readOnly: "focusNode"
		}),

		_setReadOnlyAttr: function(/*Boolean*/ value){
			this.readOnly = value;
			dojo.attr(this.focusNode, 'readOnly', value);
			dijit.setWaiState(this.focusNode, "readonly", value);
			this._setStateClass();
		},

		_setValueAttr: function(/*String or Boolean*/ newValue){
			// summary:
			//		Handler for value= attribute to constructor, and also calls to
			//		attr('value', val).
			// description:
			//		During initialization, just saves as attribute to the <input type=checkbox>.
			//
			//		After initialization,
			//		when passed a boolean, controls whether or not the CheckBox is checked.
			//		If passed a string, changes the value attribute of the CheckBox (the one
			//		specified as "value" when the CheckBox was constructed (ex: <input
			//		dojoType="dijit.CheckBox" value="chicken">)
			if(typeof newValue == "string"){
				this.value = newValue;
				dojo.attr(this.focusNode, 'value', newValue);
				newValue = true;
			}
			if(this._created){
				this.attr('checked', newValue);
			}
		},
		_getValueAttr: function(){
			// summary:
			//		Hook so attr('value') works.
			// description:
			//		If the CheckBox is checked, returns the value attribute.
			//		Otherwise returns false.
			return (this.checked ? this.value : false);
		},

		postMixInProperties: function(){
			if(this.value == ""){
				this.value = "on";
			}

			// Need to set initial checked state as part of template, so that form submit works.
			// dojo.attr(node, "checked", bool) doesn't work on IEuntil node has been attached
			// to <body>, see #8666
			this.checkedAttrSetting = this.checked ? "checked" : "";

			this.inherited(arguments);
		},

		 _fillContent: function(/*DomNode*/ source){
			// Override Button::_fillContent() since it doesn't make sense for CheckBox,
			// since CheckBox doesn't even have a container
		},

		reset: function(){
			// Override ToggleButton.reset()

			this._hasBeenBlurred = false;

			this.attr('checked', this.params.checked || false);

			// Handle unlikely event that the <input type=checkbox> value attribute has changed
			this.value = this.params.value || "on";
			dojo.attr(this.focusNode, 'value', this.value);
		},

		_onFocus: function(){
			if(this.id){
				dojo.query("label[for='"+this.id+"']").addClass("dijitFocusedLabel");
			}
		},

		_onBlur: function(){
			if(this.id){
				dojo.query("label[for='"+this.id+"']").removeClass("dijitFocusedLabel");
			}
		},

		_onClick: function(/*Event*/ e){
			// summary:
			//		Internal function to handle click actions - need to check
			//		readOnly, since button no longer does that check.
			if(this.readOnly){
				return false;
			}
			return this.inherited(arguments);
		}
	}
);

dojo.declare(
	"dijit.form.RadioButton",
	dijit.form.CheckBox,
	{
		// summary:
		// 		Same as an HTML radio, but with fancy styling.

		type: "radio",
		baseClass: "dijitRadio",

		_setCheckedAttr: function(/*Boolean*/ value){
			// If I am being checked then have to deselect currently checked radio button
			this.inherited(arguments);
			if(!this._created){ return; }
			if(value){
				var _this = this;
				// search for radio buttons with the same name that need to be unchecked
				dojo.query("INPUT[type=radio]", this.focusNode.form || dojo.doc).forEach( // can't use name= since dojo.query doesn't support [] in the name
					function(inputNode){
						if(inputNode.name == _this.name && inputNode != _this.focusNode && inputNode.form == _this.focusNode.form){
							var widget = dijit.getEnclosingWidget(inputNode);
							if(widget && widget.checked){
								widget.attr('checked', false);
							}
						}
					}
				);
			}
		},

		_clicked: function(/*Event*/ e){
			if(!this.checked){
				this.attr('checked', true);
			}
		}
	}
);

}

if(!dojo._hasResource["dijit.form.RadioButton"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.RadioButton"] = true;
dojo.provide("dijit.form.RadioButton");


// TODO: for 2.0, move the RadioButton code into this file

}

if(!dojo._hasResource["dijit.form.TextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.TextBox"] = true;
dojo.provide("dijit.form.TextBox");



dojo.declare(
	"dijit.form.TextBox",
	dijit.form._FormValueWidget,
	{
		// summary:
		//		A base class for textbox form inputs

		// trim: Boolean
		//		Removes leading and trailing whitespace if true.  Default is false.
		trim: false,

		// uppercase: Boolean
		//		Converts all characters to uppercase if true.  Default is false.
		uppercase: false,

		// lowercase: Boolean
		//		Converts all characters to lowercase if true.  Default is false.
		lowercase: false,

		// propercase: Boolean
		//		Converts the first character of each word to uppercase if true.
		propercase: false,

		//	maxLength: String
		//		HTML INPUT tag maxLength declaration.
		maxLength: "",

		//	selectOnClick: [const] Boolean
		//		If true, all text will be selected when focused with mouse
		selectOnClick: false,

		templateString: dojo.cache("dijit.form", "templates/TextBox.html", "<input class=\"dijit dijitReset dijitLeft\" dojoAttachPoint='textbox,focusNode'\r\n\tdojoAttachEvent='onmouseenter:_onMouse,onmouseleave:_onMouse'\r\n\tautocomplete=\"off\" type=\"${type}\" ${nameAttrSetting}\r\n\t/>\r\n"),
		baseClass: "dijitTextBox",

		attributeMap: dojo.delegate(dijit.form._FormValueWidget.prototype.attributeMap, {
			maxLength: "focusNode"
		}),

		_getValueAttr: function(){
			// summary:
			//		Hook so attr('value') works as we like.
			// description:
			//		For `dijit.form.TextBox` this basically returns the value of the <input>.
			//
			//		For `dijit.form.MappedTextBox` subclasses, which have both
			//		a "displayed value" and a separate "submit value",
			//		This treats the "displayed value" as the master value, computing the
			//		submit value from it via this.parse().
			return this.parse(this.attr('displayedValue'), this.constraints);
		},

		_setValueAttr: function(value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			// summary:
			//		Hook so attr('value', ...) works.
			//
			// description:
			//		Sets the value of the widget to "value" which can be of
			//		any type as determined by the widget.
			//
			// value:
			//		The visual element value is also set to a corresponding,
			//		but not necessarily the same, value.
			//
			// formattedValue:
			//		If specified, used to set the visual element value,
			//		otherwise a computed visual value is used.
			//
			// priorityChange:
			//		If true, an onChange event is fired immediately instead of
			//		waiting for the next blur event.

			var filteredValue;
			if(value !== undefined){
				// TODO: this is calling filter() on both the display value and the actual value.
				// I added a comment to the filter() definition about this, but it should be changed.
				filteredValue = this.filter(value);
				if(typeof formattedValue != "string"){
					if(filteredValue !== null && ((typeof filteredValue != "number") || !isNaN(filteredValue))){
						formattedValue = this.filter(this.format(filteredValue, this.constraints));
					}else{ formattedValue = ''; }
				}
			}
			if(formattedValue != null && formattedValue != undefined && ((typeof formattedValue) != "number" || !isNaN(formattedValue)) && this.textbox.value != formattedValue){
				this.textbox.value = formattedValue;
			}
			this.inherited(arguments, [filteredValue, priorityChange]);
		},

		// displayedValue: String
		//		For subclasses like ComboBox where the displayed value
		//		(ex: Kentucky) and the serialized value (ex: KY) are different,
		//		this represents the displayed value.
		//
		//		Setting 'displayedValue' through attr('displayedValue', ...)
		//		updates 'value', and vice-versa.  Othewise 'value' is updated
		//		from 'displayedValue' periodically, like onBlur etc.
		//
		//		TODO: move declaration to MappedTextBox?
		//		Problem is that ComboBox references displayedValue,
		//		for benefit of FilteringSelect.
		displayedValue: "",

		getDisplayedValue: function(){
			// summary:
			//		Deprecated.   Use attr('displayedValue') instead.
			// tags:
			//		deprecated
			dojo.deprecated(this.declaredClass+"::getDisplayedValue() is deprecated. Use attr('displayedValue') instead.", "", "2.0");
			return this.attr('displayedValue');
		},

		_getDisplayedValueAttr: function(){
			// summary:
			//		Hook so attr('displayedValue') works.
			// description:
			//		Returns the displayed value (what the user sees on the screen),
			// 		after filtering (ie, trimming spaces etc.).
			//
			//		For some subclasses of TextBox (like ComboBox), the displayed value
			//		is different from the serialized value that's actually
			//		sent to the server (see dijit.form.ValidationTextBox.serialize)

			return this.filter(this.textbox.value);
		},

		setDisplayedValue: function(/*String*/value){
			// summary:
			//		Deprecated.   Use attr('displayedValue', ...) instead.
			// tags:
			//		deprecated
			dojo.deprecated(this.declaredClass+"::setDisplayedValue() is deprecated. Use attr('displayedValue', ...) instead.", "", "2.0");
			this.attr('displayedValue', value);
		},

		_setDisplayedValueAttr: function(/*String*/value){
			// summary:
			//		Hook so attr('displayedValue', ...) works.
			// description:
			//		Sets the value of the visual element to the string "value".
			//		The widget value is also set to a corresponding,
			//		but not necessarily the same, value.

			if(value === null || value === undefined){ value = '' }
			else if(typeof value != "string"){ value = String(value) }
			this.textbox.value = value;
			this._setValueAttr(this.attr('value'), undefined, value);
		},

		format: function(/* String */ value, /* Object */ constraints){
			// summary:
			//		Replacable function to convert a value to a properly formatted string.
			// tags:
			//		protected extension
			return ((value == null || value == undefined) ? "" : (value.toString ? value.toString() : value));
		},

		parse: function(/* String */ value, /* Object */ constraints){
			// summary:
			//		Replacable function to convert a formatted string to a value
			// tags:
			//		protected extension

			return value;	// String
		},

		_refreshState: function(){
			// summary:
			//		After the user types some characters, etc., this method is
			//		called to check the field for validity etc.  The base method
			//		in `dijit.form.TextBox` does nothing, but subclasses override.
			// tags:
			//		protected
		},

		_onInput: function(e){
			if(e && e.type && /key/i.test(e.type) && e.keyCode){
				switch(e.keyCode){
					case dojo.keys.SHIFT:
					case dojo.keys.ALT:
					case dojo.keys.CTRL:
					case dojo.keys.TAB:
						return;
				}
			}
			if(this.intermediateChanges){
				var _this = this;
				// the setTimeout allows the key to post to the widget input box
				setTimeout(function(){ _this._handleOnChange(_this.attr('value'), false); }, 0);
			}
			this._refreshState();
		},

		postCreate: function(){
			// setting the value here is needed since value="" in the template causes "undefined"
			// and setting in the DOM (instead of the JS object) helps with form reset actions
			this.textbox.setAttribute("value", this.textbox.value); // DOM and JS values shuld be the same
			this.inherited(arguments);
			if(dojo.isMoz || dojo.isOpera){
				this.connect(this.textbox, "oninput", this._onInput);
			}else{
				this.connect(this.textbox, "onkeydown", this._onInput);
				this.connect(this.textbox, "onkeyup", this._onInput);
				this.connect(this.textbox, "onpaste", this._onInput);
				this.connect(this.textbox, "oncut", this._onInput);
			}
		},

		_blankValue: '', // if the textbox is blank, what value should be reported
		filter: function(val){
			// summary:
			//		Auto-corrections (such as trimming) that are applied to textbox
			//		value on blur or form submit.
			// description:
			//		For MappedTextBox subclasses, this is called twice
			// 			- once with the display value
			//			- once the value as set/returned by attr('value', ...)
			//		and attr('value'), ex: a Number for NumberTextBox.
			//
			//		In the latter case it does corrections like converting null to NaN.  In
			//		the former case the NumberTextBox.filter() method calls this.inherited()
			//		to execute standard trimming code in TextBox.filter().
			//
			//		TODO: break this into two methods in 2.0
			//
			// tags:
			//		protected extension
			if(val === null){ return this._blankValue; }
			if(typeof val != "string"){ return val; }
			if(this.trim){
				val = dojo.trim(val);
			}
			if(this.uppercase){
				val = val.toUpperCase();
			}
			if(this.lowercase){
				val = val.toLowerCase();
			}
			if(this.propercase){
				val = val.replace(/[^\s]+/g, function(word){
					return word.substring(0,1).toUpperCase() + word.substring(1);
				});
			}
			return val;
		},

		_setBlurValue: function(){
			this._setValueAttr(this.attr('value'), true);
		},

		_onBlur: function(e){
			if(this.disabled){ return; }
			this._setBlurValue();
			this.inherited(arguments);

			if(this._selectOnClickHandle){
				this.disconnect(this._selectOnClickHandle);
			}
			if(this.selectOnClick && dojo.isMoz){
				this.textbox.selectionStart = this.textbox.selectionEnd = undefined; // clear selection so that the next mouse click doesn't reselect
			}
		},

		_onFocus: function(/*String*/ by){
			if(this.disabled || this.readOnly){ return; }

			// Select all text on focus via click if nothing already selected.
			// Since mouse-up will clear the selection need to defer selection until after mouse-up.
			// Don't do anything on focus by tabbing into the widgetm since there's no associated mouse-up event.
			if(this.selectOnClick && by == "mouse"){
				this._selectOnClickHandle = this.connect(this.domNode, "onmouseup", function(){
					// Only select all text on first click; otherwise users would have no way to clear
					// the selection.
					this.disconnect(this._selectOnClickHandle);

					// Check if the user selected some text manually (mouse-down, mouse-move, mouse-up)
					// and if not, then select all the text
					var textIsNotSelected;
					if(dojo.isIE){
						var range = dojo.doc.selection.createRange();
						var parent = range.parentElement();
						textIsNotSelected = parent == this.textbox && range.text.length == 0;
					}else{
						textIsNotSelected = this.textbox.selectionStart == this.textbox.selectionEnd;
					}
					if(textIsNotSelected){
						dijit.selectInputText(this.textbox);
					}
				});
			}

			this._refreshState();
			this.inherited(arguments);
		},

		reset: function(){
			// Overrides dijit._FormWidget.reset().
			// Additionally resets the displayed textbox value to ''
			this.textbox.value = '';
			this.inherited(arguments);
		}
	}
);

dijit.selectInputText = function(/*DomNode*/element, /*Number?*/ start, /*Number?*/ stop){
	// summary:
	//		Select text in the input element argument, from start (default 0), to stop (default end).

	// TODO: use functions in _editor/selection.js?
	var _window = dojo.global;
	var _document = dojo.doc;
	element = dojo.byId(element);
	if(isNaN(start)){ start = 0; }
	if(isNaN(stop)){ stop = element.value ? element.value.length : 0; }
	dijit.focus(element);
	if(_document["selection"] && dojo.body()["createTextRange"]){ // IE
		if(element.createTextRange){
			var range = element.createTextRange();
			with(range){
				collapse(true);
				moveStart("character", -99999); // move to 0
				moveStart("character", start); // delta from 0 is the correct position
				moveEnd("character", stop-start);
				select();
			}
		}
	}else if(_window["getSelection"]){
		if(element.setSelectionRange){
			element.setSelectionRange(start, stop);
		}
	}
};

}

if(!dojo._hasResource["dijit.form._FormMixin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form._FormMixin"] = true;
dojo.provide("dijit.form._FormMixin");

dojo.declare("dijit.form._FormMixin", null,
	{
	// summary:
	//		Mixin for containers of form widgets (i.e. widgets that represent a single value
	//		and can be children of a <form> node or dijit.form.Form widget)
	// description:
	//		Can extract all the form widgets
	//		values and combine them into a single javascript object, or alternately
	//		take such an object and set the values for all the contained
	//		form widgets

/*=====
    // value: Object
	//		Name/value hash for each form element.
	//		If there are multiple elements w/the same name, value is an array,
	//		unless they are radio buttons in which case value is a scalar since only
	//		one can be checked at a time.
	//
	//		If the name is a dot separated list (like a.b.c.d), it's a nested structure.
	//		Only works on widget form elements.
	// example:
	//	| { name: "John Smith", interests: ["sports", "movies"] }
=====*/

	//	TODO:
	//	* Repeater
	//	* better handling for arrays.  Often form elements have names with [] like
	//	* people[3].sex (for a list of people [{name: Bill, sex: M}, ...])
	//
	//

		reset: function(){
			dojo.forEach(this.getDescendants(), function(widget){
				if(widget.reset){
					widget.reset();
				}
			});
		},

		validate: function(){
			// summary:
			//		returns if the form is valid - same as isValid - but
			//			provides a few additional (ui-specific) features.
			//			1 - it will highlight any sub-widgets that are not
			//				valid
			//			2 - it will call focus() on the first invalid
			//				sub-widget
			var didFocus = false;
			return dojo.every(dojo.map(this.getDescendants(), function(widget){
				// Need to set this so that "required" widgets get their
				// state set.
				widget._hasBeenBlurred = true;
				var valid = widget.disabled || !widget.validate || widget.validate();
				if(!valid && !didFocus){
					// Set focus of the first non-valid widget
					dijit.scrollIntoView(widget.containerNode || widget.domNode);
					widget.focus();
					didFocus = true;
				}
	 			return valid;
	 		}), function(item){ return item; });
		},

		setValues: function(val){
			dojo.deprecated(this.declaredClass+"::setValues() is deprecated. Use attr('value', val) instead.", "", "2.0");
			return this.attr('value', val);
		},
		_setValueAttr: function(/*object*/obj){
			// summary:
			//		Fill in form values from according to an Object (in the format returned by attr('value'))

			// generate map from name --> [list of widgets with that name]
			var map = { };
			dojo.forEach(this.getDescendants(), function(widget){
				if(!widget.name){ return; }
				var entry = map[widget.name] || (map[widget.name] = [] );
				entry.push(widget);
			});

			for(var name in map){
				if(!map.hasOwnProperty(name)){
					continue;
				}
				var widgets = map[name],						// array of widgets w/this name
					values = dojo.getObject(name, false, obj);	// list of values for those widgets

				if(values === undefined){
					continue;
				}
				if(!dojo.isArray(values)){
					values = [ values ];
				}
				if(typeof widgets[0].checked == 'boolean'){
					// for checkbox/radio, values is a list of which widgets should be checked
					dojo.forEach(widgets, function(w, i){
						w.attr('value', dojo.indexOf(values, w.value) != -1);
					});
				}else if(widgets[0].multiple){
					// it takes an array (e.g. multi-select)
					widgets[0].attr('value', values);
				}else{
					// otherwise, values is a list of values to be assigned sequentially to each widget
					dojo.forEach(widgets, function(w, i){
						w.attr('value', values[i]);
					});
				}
			}

			/***
			 * 	TODO: code for plain input boxes (this shouldn't run for inputs that are part of widgets)

			dojo.forEach(this.containerNode.elements, function(element){
				if(element.name == ''){return};	// like "continue"
				var namePath = element.name.split(".");
				var myObj=obj;
				var name=namePath[namePath.length-1];
				for(var j=1,len2=namePath.length;j<len2;++j){
					var p=namePath[j - 1];
					// repeater support block
					var nameA=p.split("[");
					if(nameA.length > 1){
						if(typeof(myObj[nameA[0]]) == "undefined"){
							myObj[nameA[0]]=[ ];
						} // if

						nameIndex=parseInt(nameA[1]);
						if(typeof(myObj[nameA[0]][nameIndex]) == "undefined"){
							myObj[nameA[0]][nameIndex] = { };
						}
						myObj=myObj[nameA[0]][nameIndex];
						continue;
					} // repeater support ends

					if(typeof(myObj[p]) == "undefined"){
						myObj=undefined;
						break;
					};
					myObj=myObj[p];
				}

				if(typeof(myObj) == "undefined"){
					return;		// like "continue"
				}
				if(typeof(myObj[name]) == "undefined" && this.ignoreNullValues){
					return;		// like "continue"
				}

				// TODO: widget values (just call attr('value', ...) on the widget)

				// TODO: maybe should call dojo.getNodeProp() instead
				switch(element.type){
					case "checkbox":
						element.checked = (name in myObj) &&
							dojo.some(myObj[name], function(val){ return val == element.value; });
						break;
					case "radio":
						element.checked = (name in myObj) && myObj[name] == element.value;
						break;
					case "select-multiple":
						element.selectedIndex=-1;
						dojo.forEach(element.options, function(option){
							option.selected = dojo.some(myObj[name], function(val){ return option.value == val; });
						});
						break;
					case "select-one":
						element.selectedIndex="0";
						dojo.forEach(element.options, function(option){
							option.selected = option.value == myObj[name];
						});
						break;
					case "hidden":
					case "text":
					case "textarea":
					case "password":
						element.value = myObj[name] || "";
						break;
				}
	  		});
	  		*/
		},

		getValues: function(){
			dojo.deprecated(this.declaredClass+"::getValues() is deprecated. Use attr('value') instead.", "", "2.0");
			return this.attr('value');
		},
		_getValueAttr: function(){
			// summary:
			// 		Returns Object representing form values.
			// description:
			//		Returns name/value hash for each form element.
			//		If there are multiple elements w/the same name, value is an array,
			//		unless they are radio buttons in which case value is a scalar since only
			//		one can be checked at a time.
			//
			//		If the name is a dot separated list (like a.b.c.d), creates a nested structure.
			//		Only works on widget form elements.
			// example:
			//		| { name: "John Smith", interests: ["sports", "movies"] }

			// get widget values
			var obj = { };
			dojo.forEach(this.getDescendants(), function(widget){
				var name = widget.name;
				if(!name || widget.disabled){ return; }

				// Single value widget (checkbox, radio, or plain <input> type widget
				var value = widget.attr('value');

				// Store widget's value(s) as a scalar, except for checkboxes which are automatically arrays
				if(typeof widget.checked == 'boolean'){
					if(/Radio/.test(widget.declaredClass)){
						// radio button
						if(value !== false){
							dojo.setObject(name, value, obj);
						}else{
							// give radio widgets a default of null
							value = dojo.getObject(name, false, obj);
							if(value === undefined){
								dojo.setObject(name, null, obj);
							}
						}
					}else{
						// checkbox/toggle button
						var ary=dojo.getObject(name, false, obj);
						if(!ary){
							ary=[];
							dojo.setObject(name, ary, obj);
						}
						if(value !== false){
							ary.push(value);
						}
					}
				}else{
					var prev=dojo.getObject(name, false, obj);
					if(typeof prev != "undefined"){
						if(dojo.isArray(prev)){
							prev.push(value);
						}else{
							dojo.setObject(name, [prev, value], obj);
						}
					}else{
						// unique name
						dojo.setObject(name, value, obj);
					}
				}
			});

			/***
			 * code for plain input boxes (see also dojo.formToObject, can we use that instead of this code?
			 * but it doesn't understand [] notation, presumably)
			var obj = { };
			dojo.forEach(this.containerNode.elements, function(elm){
				if(!elm.name)	{
					return;		// like "continue"
				}
				var namePath = elm.name.split(".");
				var myObj=obj;
				var name=namePath[namePath.length-1];
				for(var j=1,len2=namePath.length;j<len2;++j){
					var nameIndex = null;
					var p=namePath[j - 1];
					var nameA=p.split("[");
					if(nameA.length > 1){
						if(typeof(myObj[nameA[0]]) == "undefined"){
							myObj[nameA[0]]=[ ];
						} // if
						nameIndex=parseInt(nameA[1]);
						if(typeof(myObj[nameA[0]][nameIndex]) == "undefined"){
							myObj[nameA[0]][nameIndex] = { };
						}
					} else if(typeof(myObj[nameA[0]]) == "undefined"){
						myObj[nameA[0]] = { }
					} // if

					if(nameA.length == 1){
						myObj=myObj[nameA[0]];
					} else{
						myObj=myObj[nameA[0]][nameIndex];
					} // if
				} // for

				if((elm.type != "select-multiple" && elm.type != "checkbox" && elm.type != "radio") || (elm.type == "radio" && elm.checked)){
					if(name == name.split("[")[0]){
						myObj[name]=elm.value;
					} else{
						// can not set value when there is no name
					}
				} else if(elm.type == "checkbox" && elm.checked){
					if(typeof(myObj[name]) == 'undefined'){
						myObj[name]=[ ];
					}
					myObj[name].push(elm.value);
				} else if(elm.type == "select-multiple"){
					if(typeof(myObj[name]) == 'undefined'){
						myObj[name]=[ ];
					}
					for(var jdx=0,len3=elm.options.length; jdx<len3; ++jdx){
						if(elm.options[jdx].selected){
							myObj[name].push(elm.options[jdx].value);
						}
					}
				} // if
				name=undefined;
			}); // forEach
			***/
			return obj;
		},

		// TODO: ComboBox might need time to process a recently input value.  This should be async?
	 	isValid: function(){
	 		// summary:
	 		//		Returns true if all of the widgets are valid

	 		// This also populate this._invalidWidgets[] array with list of invalid widgets...
	 		// TODO: put that into separate function?   It's confusing to have that as a side effect
	 		// of a method named isValid().

			this._invalidWidgets = dojo.filter(this.getDescendants(), function(widget){
				return !widget.disabled && widget.isValid && !widget.isValid();
	 		});
			return !this._invalidWidgets.length;
		},


		onValidStateChange: function(isValid){
			// summary:
			//		Stub function to connect to if you want to do something
			//		(like disable/enable a submit button) when the valid
			//		state changes on the form as a whole.
		},

		_widgetChange: function(widget){
			// summary:
			//		Connected to a widget's onChange function - update our
			//		valid state, if needed.
			var isValid = this._lastValidState;
			if(!widget || this._lastValidState === undefined){
				// We have passed a null widget, or we haven't been validated
				// yet - let's re-check all our children
				// This happens when we connect (or reconnect) our children
				isValid = this.isValid();
				if(this._lastValidState === undefined){
					// Set this so that we don't fire an onValidStateChange
					// the first time
					this._lastValidState = isValid;
				}
			}else if(widget.isValid){
				this._invalidWidgets = dojo.filter(this._invalidWidgets || [], function(w){
					return (w != widget);
				}, this);
				if(!widget.isValid() && !widget.attr("disabled")){
					this._invalidWidgets.push(widget);
				}
				isValid = (this._invalidWidgets.length === 0);
			}
			if(isValid !== this._lastValidState){
				this._lastValidState = isValid;
				this.onValidStateChange(isValid);
			}
		},

		connectChildren: function(){
			// summary:
			//		Connects to the onChange function of all children to
			//		track valid state changes.  You can call this function
			//		directly, ex. in the event that you programmatically
			//		add a widget to the form *after* the form has been
			//		initialized.
			dojo.forEach(this._changeConnections, dojo.hitch(this, "disconnect"));
			var _this = this;

			// we connect to validate - so that it better reflects the states
			// of the widgets - also, we only connect if it has a validate
			// function (to avoid too many unneeded connections)
			var conns = this._changeConnections = [];
			dojo.forEach(dojo.filter(this.getDescendants(),
				function(item){ return item.validate; }
			),
			function(widget){
				// We are interested in whenever the widget is validated - or
				// whenever the disabled attribute on that widget is changed
				conns.push(_this.connect(widget, "validate",
									dojo.hitch(_this, "_widgetChange", widget)));
				conns.push(_this.connect(widget, "_setDisabledAttr",
									dojo.hitch(_this, "_widgetChange", widget)));
			});

			// Call the widget change function to update the valid state, in
			// case something is different now.
			this._widgetChange(null);
		},

		startup: function(){
			this.inherited(arguments);
			// Initialize our valid state tracking.  Needs to be done in startup
			// because it's not guaranteed that our children are initialized
			// yet.
			this._changeConnections = [];
			this.connectChildren();
		}
	});

}

if(!dojo._hasResource["dijit.form.Form"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.Form"] = true;
dojo.provide("dijit.form.Form");





dojo.declare(
	"dijit.form.Form",
	[dijit._Widget, dijit._Templated, dijit.form._FormMixin],
	{
		// summary:
		//		Widget corresponding to HTML form tag, for validation and serialization
		//
		// example:
		//	|	<form dojoType="dijit.form.Form" id="myForm">
		//	|		Name: <input type="text" name="name" />
		//	|	</form>
		//	|	myObj = {name: "John Doe"};
		//	|	dijit.byId('myForm').attr('value', myObj);
		//	|
		//	|	myObj=dijit.byId('myForm').attr('value');

		// HTML <FORM> attributes

		// name: String?
		//		Name of form for scripting.
		name: "",

		// action: String?
		//		Server-side form handler.
		action: "",

		// method: String?
		//		HTTP method used to submit the form, either "GET" or "POST".
		method: "",

		// encType: String?
		//		Encoding type for the form, ex: application/x-www-form-urlencoded.
		encType: "",

		// accept-charset: String?
		//		List of supported charsets.
		"accept-charset": "",

		// accept: String?
		//		List of MIME types for file upload.
		accept: "",

		// target: String?
		//		Target frame for the document to be opened in.
		target: "",

		templateString: "<form dojoAttachPoint='containerNode' dojoAttachEvent='onreset:_onReset,onsubmit:_onSubmit' ${nameAttrSetting}></form>",

		attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
			action: "",
			method: "",
			encType: "",
			"accept-charset": "",
			accept: "",
			target: ""
		}),

		postMixInProperties: function(){
			// Setup name=foo string to be referenced from the template (but only if a name has been specified)
			// Unfortunately we can't use attributeMap to set the name due to IE limitations, see #8660
			this.nameAttrSetting = this.name ? ("name='" + this.name + "'") : "";
			this.inherited(arguments);
		},

		execute: function(/*Object*/ formContents){
			// summary:
			//		Deprecated: use submit()
			// tags:
			//		deprecated
		},

		onExecute: function(){
			// summary:
			//		Deprecated: use onSubmit()
			// tags:
			//		deprecated
		},

		_setEncTypeAttr: function(/*String*/ value){
			this.encType = value;
			dojo.attr(this.domNode, "encType", value);
			if(dojo.isIE){ this.domNode.encoding = value; }
		},

		postCreate: function(){
			// IE tries to hide encType
			// TODO: this code should be in parser, not here.
			if(dojo.isIE && this.srcNodeRef && this.srcNodeRef.attributes){
				var item = this.srcNodeRef.attributes.getNamedItem('encType');
				if(item && !item.specified && (typeof item.value == "string")){
					this.attr('encType', item.value);
				}
			}
			this.inherited(arguments);
		},

		onReset: function(/*Event?*/ e){
			// summary:
			//		Callback when user resets the form. This method is intended
			//		to be over-ridden. When the `reset` method is called
			//		programmatically, the return value from `onReset` is used
			//		to compute whether or not resetting should proceed
			// tags:
			//		callback
			return true; // Boolean
		},

		_onReset: function(e){
			// create fake event so we can know if preventDefault() is called
			var faux = {
				returnValue: true, // the IE way
				preventDefault: function(){ // not IE
							this.returnValue = false;
						},
				stopPropagation: function(){}, currentTarget: e.currentTarget, target: e.target
			};
			// if return value is not exactly false, and haven't called preventDefault(), then reset
			if(!(this.onReset(faux) === false) && faux.returnValue){
				this.reset();
			}
			dojo.stopEvent(e);
			return false;
		},

		_onSubmit: function(e){
			var fp = dijit.form.Form.prototype;
			// TODO: remove this if statement beginning with 2.0
			if(this.execute != fp.execute || this.onExecute != fp.onExecute){
				dojo.deprecated("dijit.form.Form:execute()/onExecute() are deprecated. Use onSubmit() instead.", "", "2.0");
				this.onExecute();
				this.execute(this.getValues());
			}
			if(this.onSubmit(e) === false){ // only exactly false stops submit
				dojo.stopEvent(e);
			}
		},

		onSubmit: function(/*Event?*/e){
			// summary:
			//		Callback when user submits the form.
			// description:
			//		This method is intended to be over-ridden, but by default it checks and
			//		returns the validity of form elements. When the `submit`
			//		method is called programmatically, the return value from
			//		`onSubmit` is used to compute whether or not submission
			//		should proceed
			// tags:
			//		extension

			return this.isValid(); // Boolean
		},

		submit: function(){
			// summary:
			//		programmatically submit form if and only if the `onSubmit` returns true
			if(!(this.onSubmit() === false)){
				this.containerNode.submit();
			}
		}
	}
);

}

if(!dojo._hasResource["dojo.regexp"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.regexp"] = true;
dojo.provide("dojo.regexp");

/*=====
dojo.regexp = {
	// summary: Regular expressions and Builder resources
};
=====*/

dojo.regexp.escapeString = function(/*String*/str, /*String?*/except){
	//	summary:
	//		Adds escape sequences for special characters in regular expressions
	// except:
	//		a String with special characters to be left unescaped

	return str.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, function(ch){
		if(except && except.indexOf(ch) != -1){
			return ch;
		}
		return "\\" + ch;
	}); // String
}

dojo.regexp.buildGroupRE = function(/*Object|Array*/arr, /*Function*/re, /*Boolean?*/nonCapture){
	//	summary:
	//		Builds a regular expression that groups subexpressions
	//	description:
	//		A utility function used by some of the RE generators. The
	//		subexpressions are constructed by the function, re, in the second
	//		parameter.  re builds one subexpression for each elem in the array
	//		a, in the first parameter. Returns a string for a regular
	//		expression that groups all the subexpressions.
	// arr:
	//		A single value or an array of values.
	// re:
	//		A function. Takes one parameter and converts it to a regular
	//		expression. 
	// nonCapture:
	//		If true, uses non-capturing match, otherwise matches are retained
	//		by regular expression. Defaults to false

	// case 1: a is a single value.
	if(!(arr instanceof Array)){
		return re(arr); // String
	}

	// case 2: a is an array
	var b = [];
	for(var i = 0; i < arr.length; i++){
		// convert each elem to a RE
		b.push(re(arr[i]));
	}

	 // join the REs as alternatives in a RE group.
	return dojo.regexp.group(b.join("|"), nonCapture); // String
}

dojo.regexp.group = function(/*String*/expression, /*Boolean?*/nonCapture){
	// summary:
	//		adds group match to expression
	// nonCapture:
	//		If true, uses non-capturing match, otherwise matches are retained
	//		by regular expression. 
	return "(" + (nonCapture ? "?:":"") + expression + ")"; // String
}

}

if(!dojo._hasResource["dojo.cookie"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.cookie"] = true;
dojo.provide("dojo.cookie");



/*=====
dojo.__cookieProps = function(){
	//	expires: Date|String|Number?
	//		If a number, the number of days from today at which the cookie
	//		will expire. If a date, the date past which the cookie will expire.
	//		If expires is in the past, the cookie will be deleted.
	//		If expires is omitted or is 0, the cookie will expire when the browser closes. << FIXME: 0 seems to disappear right away? FF3.
	//	path: String?
	//		The path to use for the cookie.
	//	domain: String?
	//		The domain to use for the cookie.
	//	secure: Boolean?
	//		Whether to only send the cookie on secure connections
	this.expires = expires;
	this.path = path;
	this.domain = domain;
	this.secure = secure;
}
=====*/


dojo.cookie = function(/*String*/name, /*String?*/value, /*dojo.__cookieProps?*/props){
	//	summary: 
	//		Get or set a cookie.
	//	description:
	// 		If one argument is passed, returns the value of the cookie
	// 		For two or more arguments, acts as a setter.
	//	name:
	//		Name of the cookie
	//	value:
	//		Value for the cookie
	//	props: 
	//		Properties for the cookie
	//	example:
	//		set a cookie with the JSON-serialized contents of an object which
	//		will expire 5 days from now:
	//	|	dojo.cookie("configObj", dojo.toJson(config), { expires: 5 });
	//	
	//	example:
	//		de-serialize a cookie back into a JavaScript object:
	//	|	var config = dojo.fromJson(dojo.cookie("configObj"));
	//	
	//	example:
	//		delete a cookie:
	//	|	dojo.cookie("configObj", null, {expires: -1});
	var c = document.cookie;
	if(arguments.length == 1){
		var matches = c.match(new RegExp("(?:^|; )" + dojo.regexp.escapeString(name) + "=([^;]*)"));
		return matches ? decodeURIComponent(matches[1]) : undefined; // String or undefined
	}else{
		props = props || {};
// FIXME: expires=0 seems to disappear right away, not on close? (FF3)  Change docs?
		var exp = props.expires;
		if(typeof exp == "number"){ 
			var d = new Date();
			d.setTime(d.getTime() + exp*24*60*60*1000);
			exp = props.expires = d;
		}
		if(exp && exp.toUTCString){ props.expires = exp.toUTCString(); }

		value = encodeURIComponent(value);
		var updatedCookie = name + "=" + value, propName;
		for(propName in props){
			updatedCookie += "; " + propName;
			var propValue = props[propName];
			if(propValue !== true){ updatedCookie += "=" + propValue; }
		}
		document.cookie = updatedCookie;
	}
};

dojo.cookie.isSupported = function(){
	//	summary:
	//		Use to determine if the current browser supports cookies or not.
	//		
	//		Returns true if user allows cookies.
	//		Returns false if user doesn't allow cookies.

	if(!("cookieEnabled" in navigator)){
		this("__djCookieTest__", "CookiesAllowed");
		navigator.cookieEnabled = this("__djCookieTest__") == "CookiesAllowed";
		if(navigator.cookieEnabled){
			this("__djCookieTest__", "", {expires: -1});
		}
	}
	return navigator.cookieEnabled;
};

}

if(!dojo._hasResource["dijit.form.ToggleButton"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.ToggleButton"] = true;
dojo.provide("dijit.form.ToggleButton");


}

if(!dojo._hasResource["dijit.layout.StackController"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.StackController"] = true;
dojo.provide("dijit.layout.StackController");







dojo.declare(
		"dijit.layout.StackController",
		[dijit._Widget, dijit._Templated, dijit._Container],
		{
			// summary:
			//		Set of buttons to select a page in a page list.
			// description:
			//		Monitors the specified StackContainer, and whenever a page is
			//		added, deleted, or selected, updates itself accordingly.

			templateString: "<span wairole='tablist' dojoAttachEvent='onkeypress' class='dijitStackController'></span>",

			// containerId: [const] String
			//		The id of the page container that I point to
			containerId: "",

			// buttonWidget: [const] String
			//		The name of the button widget to create to correspond to each page
			buttonWidget: "dijit.layout._StackButton",

			postCreate: function(){
				dijit.setWaiRole(this.domNode, "tablist");

				this.pane2button = {};		// mapping from pane id to buttons
				this.pane2handles = {};		// mapping from pane id to this.connect() handles

				// Listen to notifications from StackContainer
				this.subscribe(this.containerId+"-startup", "onStartup");
				this.subscribe(this.containerId+"-addChild", "onAddChild");
				this.subscribe(this.containerId+"-removeChild", "onRemoveChild");
				this.subscribe(this.containerId+"-selectChild", "onSelectChild");
				this.subscribe(this.containerId+"-containerKeyPress", "onContainerKeyPress");
			},

			onStartup: function(/*Object*/ info){
				// summary:
				//		Called after StackContainer has finished initializing
				// tags:
				//		private
				dojo.forEach(info.children, this.onAddChild, this);
				if(info.selected){
					// Show button corresponding to selected pane (unless selected
					// is null because there are no panes)
					this.onSelectChild(info.selected);
				}
			},

			destroy: function(){
				for(var pane in this.pane2button){
					this.onRemoveChild(dijit.byId(pane));
				}
				this.inherited(arguments);
			},

			onAddChild: function(/*dijit._Widget*/ page, /*Integer?*/ insertIndex){
				// summary:
				//		Called whenever a page is added to the container.
				//		Create button corresponding to the page.
				// tags:
				//		private

				// add a node that will be promoted to the button widget
				var refNode = dojo.doc.createElement("span");
				this.domNode.appendChild(refNode);
				// create an instance of the button widget
				var cls = dojo.getObject(this.buttonWidget);
				var button = new cls({
					id: this.id + "_" + page.id,
					label: page.title,
					showLabel: page.showTitle,
					iconClass: page.iconClass,
					closeButton: page.closable,
					title: page.tooltip
				}, refNode);
				dijit.setWaiState(button.focusNode,"selected", "false");
				this.pane2handles[page.id] = [
					this.connect(page, 'attr', function(name, value){
						if(arguments.length == 2){
							var buttonAttr = {
								title: 'label',
								showTitle: 'showLabel',
								iconClass: 'iconClass',
								closable: 'closeButton',
								tooltip: 'title'
							}[name];
							if(buttonAttr){
								button.attr(buttonAttr, value);
							}
						}
					}),
					this.connect(button, 'onClick', dojo.hitch(this,"onButtonClick", page)),
					this.connect(button, 'onClickCloseButton', dojo.hitch(this,"onCloseButtonClick", page))
				];
				this.addChild(button, insertIndex);
				this.pane2button[page.id] = button;
				page.controlButton = button;	// this value might be overwritten if two tabs point to same container
				if(!this._currentChild){ // put the first child into the tab order
					button.focusNode.setAttribute("tabIndex", "0");
					dijit.setWaiState(button.focusNode, "selected", "true");
					this._currentChild = page;
				}
				// make sure all tabs have the same length
				if(!this.isLeftToRight() && dojo.isIE && this._rectifyRtlTabList){
					this._rectifyRtlTabList();
				}
			},

			onRemoveChild: function(/*dijit._Widget*/ page){
				// summary:
				//		Called whenever a page is removed from the container.
				//		Remove the button corresponding to the page.
				// tags:
				//		private

				if(this._currentChild === page){ this._currentChild = null; }
				dojo.forEach(this.pane2handles[page.id], this.disconnect, this);
				delete this.pane2handles[page.id];
				var button = this.pane2button[page.id];
				if(button){
					this.removeChild(button);
					delete this.pane2button[page.id];
					button.destroy();
				}
				delete page.controlButton;
			},

			onSelectChild: function(/*dijit._Widget*/ page){
				// summary:
				//		Called when a page has been selected in the StackContainer, either by me or by another StackController
				// tags:
				//		private

				if(!page){ return; }

				if(this._currentChild){
					var oldButton=this.pane2button[this._currentChild.id];
					oldButton.attr('checked', false);
					dijit.setWaiState(oldButton.focusNode, "selected", "false");
					oldButton.focusNode.setAttribute("tabIndex", "-1");
				}

				var newButton=this.pane2button[page.id];
				newButton.attr('checked', true);
				dijit.setWaiState(newButton.focusNode, "selected", "true");
				this._currentChild = page;
				newButton.focusNode.setAttribute("tabIndex", "0");
				var container = dijit.byId(this.containerId);
				dijit.setWaiState(container.containerNode, "labelledby", newButton.id);
			},

			onButtonClick: function(/*dijit._Widget*/ page){
				// summary:
				//		Called whenever one of my child buttons is pressed in an attempt to select a page
				// tags:
				//		private

				var container = dijit.byId(this.containerId);
				container.selectChild(page);
			},

			onCloseButtonClick: function(/*dijit._Widget*/ page){
				// summary:
				//		Called whenever one of my child buttons [X] is pressed in an attempt to close a page
				// tags:
				//		private

				var container = dijit.byId(this.containerId);
				container.closeChild(page);
				if(this._currentChild){
					var b = this.pane2button[this._currentChild.id];
					if(b){
						dijit.focus(b.focusNode || b.domNode);
					}
				}
			},

			// TODO: this is a bit redundant with forward, back api in StackContainer
			adjacent: function(/*Boolean*/ forward){
				// summary:
				//		Helper for onkeypress to find next/previous button
				// tags:
				//		private

				if(!this.isLeftToRight() && (!this.tabPosition || /top|bottom/.test(this.tabPosition))){ forward = !forward; }
				// find currently focused button in children array
				var children = this.getChildren();
				var current = dojo.indexOf(children, this.pane2button[this._currentChild.id]);
				// pick next button to focus on
				var offset = forward ? 1 : children.length - 1;
				return children[ (current + offset) % children.length ]; // dijit._Widget
			},

			onkeypress: function(/*Event*/ e){
				// summary:
				//		Handle keystrokes on the page list, for advancing to next/previous button
				//		and closing the current page if the page is closable.
				// tags:
				//		private

				if(this.disabled || e.altKey ){ return; }
				var forward = null;
				if(e.ctrlKey || !e._djpage){
					var k = dojo.keys;
					switch(e.charOrCode){
						case k.LEFT_ARROW:
						case k.UP_ARROW:
							if(!e._djpage){ forward = false; }
							break;
						case k.PAGE_UP:
							if(e.ctrlKey){ forward = false; }
							break;
						case k.RIGHT_ARROW:
						case k.DOWN_ARROW:
							if(!e._djpage){ forward = true; }
							break;
						case k.PAGE_DOWN:
							if(e.ctrlKey){ forward = true; }
							break;
						case k.DELETE:
							if(this._currentChild.closable){
								this.onCloseButtonClick(this._currentChild);
							}
							dojo.stopEvent(e);
							break;
						default:
							if(e.ctrlKey){
								if(e.charOrCode === k.TAB){
									this.adjacent(!e.shiftKey).onClick();
									dojo.stopEvent(e);
								}else if(e.charOrCode == "w"){
									if(this._currentChild.closable){
										this.onCloseButtonClick(this._currentChild);
									}
									dojo.stopEvent(e); // avoid browser tab closing.
								}
							}
					}
					// handle page navigation
					if(forward !== null){
						this.adjacent(forward).onClick();
						dojo.stopEvent(e);
					}
				}
			},

			onContainerKeyPress: function(/*Object*/ info){
				// summary:
				//		Called when there was a keypress on the container
				// tags:
				//		private
				info.e._djpage = info.page;
				this.onkeypress(info.e);
			}
	});


dojo.declare("dijit.layout._StackButton",
		dijit.form.ToggleButton,
		{
		// summary:
		//		Internal widget used by StackContainer.
		// description:
		//		The button-like or tab-like object you click to select or delete a page
		// tags:
		//		private

		// Override _FormWidget.tabIndex.
		// StackContainer buttons are not in the tab order by default.
		// Probably we should be calling this.startupKeyNavChildren() instead.
		tabIndex: "-1",

		postCreate: function(/*Event*/ evt){
			dijit.setWaiRole((this.focusNode || this.domNode), "tab");
			this.inherited(arguments);
		},

		onClick: function(/*Event*/ evt){
			// summary:
			//		This is for TabContainer where the tabs are <span> rather than button,
			//		so need to set focus explicitly (on some browsers)
			//		Note that you shouldn't override this method, but you can connect to it.
			dijit.focus(this.focusNode);

			// ... now let StackController catch the event and tell me what to do
		},

		onClickCloseButton: function(/*Event*/ evt){
			// summary:
			//		StackContainer connects to this function; if your widget contains a close button
			//		then clicking it should call this function.
			//		Note that you shouldn't override this method, but you can connect to it.
			evt.stopPropagation();
		}
	});


}

if(!dojo._hasResource["dijit.layout.StackContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.StackContainer"] = true;
dojo.provide("dijit.layout.StackContainer");






dojo.declare(
	"dijit.layout.StackContainer",
	dijit.layout._LayoutWidget,
	{
	// summary:
	//		A container that has multiple children, but shows only
	//		one child at a time
	//
	// description:
	//		A container for widgets (ContentPanes, for example) That displays
	//		only one Widget at a time.
	//
	//		Publishes topics [widgetId]-addChild, [widgetId]-removeChild, and [widgetId]-selectChild
	//
	//		Can be base class for container, Wizard, Show, etc.

	// doLayout: Boolean
	//		If true, change the size of my currently displayed child to match my size
	doLayout: true,

	// persist: Boolean
	//		Remembers the selected child across sessions
	persist: false,

	baseClass: "dijitStackContainer",

/*=====
	// selectedChildWidget: [readonly] dijit._Widget
	//		References the currently selected child widget, if any.
	//		Adjust selected child with selectChild() method.
	selectedChildWidget: null,
=====*/

	postCreate: function(){
		this.inherited(arguments);
		dojo.addClass(this.domNode, "dijitLayoutContainer");
		dijit.setWaiRole(this.containerNode, "tabpanel");
		this.connect(this.domNode, "onkeypress", this._onKeyPress);
	},

	startup: function(){
		if(this._started){ return; }

		var children = this.getChildren();

		// Setup each page panel to be initially hidden
		dojo.forEach(children, this._setupChild, this);

		// Figure out which child to initially display, defaulting to first one
		if(this.persist){
			this.selectedChildWidget = dijit.byId(dojo.cookie(this.id + "_selectedChild"));
		}else{
			dojo.some(children, function(child){
				if(child.selected){
					this.selectedChildWidget = child;
				}
				return child.selected;
			}, this);
		}
		var selected = this.selectedChildWidget;
		if(!selected && children[0]){
			selected = this.selectedChildWidget = children[0];
			selected.selected = true;
		}

		// Publish information about myself so any StackControllers can initialize.
		// This needs to happen before this.inherited(arguments) so that for
		// TabContainer, this._contentBox doesn't include the space for the tab labels.
		dojo.publish(this.id+"-startup", [{children: children, selected: selected}]);

		// Startup each child widget, and do initial layout like setting this._contentBox,
		// then calls this.resize() which does the initial sizing on the selected child.
		this.inherited(arguments);
	},

	resize: function(){
		// Resize is called when we are first made visible (it's called from startup()
		// if we are initially visible).   If this is the first time we've been made
		// visible then show our first child.
		var selected = this.selectedChildWidget;
		if(selected && !this._hasBeenShown){
			this._hasBeenShown = true;
			this._showChild(selected);
		}
		this.inherited(arguments);
	},

	_setupChild: function(/*dijit._Widget*/ child){
		// Overrides _LayoutWidget._setupChild()

		this.inherited(arguments);

		dojo.removeClass(child.domNode, "dijitVisible");
		dojo.addClass(child.domNode, "dijitHidden");

		// remove the title attribute so it doesn't show up when i hover
		// over a node
		child.domNode.title = "";
	},

	addChild: function(/*dijit._Widget*/ child, /*Integer?*/ insertIndex){
		// Overrides _Container.addChild() to do layout and publish events

		this.inherited(arguments);

		if(this._started){
			dojo.publish(this.id+"-addChild", [child, insertIndex]);

			// in case the tab titles have overflowed from one line to two lines
			// (or, if this if first child, from zero lines to one line)
			// TODO: w/ScrollingTabController this is no longer necessary, although
			// ScrollTabController.resize() does need to get called to show/hide
			// the navigation buttons as appropriate, but that's handled in ScrollingTabController.onAddChild()
			this.layout();

			// if this is the first child, then select it
			if(!this.selectedChildWidget){
				this.selectChild(child);
			}
		}
	},

	removeChild: function(/*dijit._Widget*/ page){
		// Overrides _Container.removeChild() to do layout and publish events

		this.inherited(arguments);

		if(this._started){
			// this will notify any tablists to remove a button; do this first because it may affect sizing
			dojo.publish(this.id + "-removeChild", [page]);
		}

		// If we are being destroyed than don't run the code below (to select another page), because we are deleting
		// every page one by one
		if(this._beingDestroyed){ return; }

		if(this._started){
			// in case the tab titles now take up one line instead of two lines
			// TODO: this is overkill in most cases since ScrollingTabController never changes size (for >= 1 tab)
			this.layout();
		}

		if(this.selectedChildWidget === page){
			this.selectedChildWidget = undefined;
			if(this._started){
				var children = this.getChildren();
				if(children.length){
					this.selectChild(children[0]);
				}
			}
		}
	},

	selectChild: function(/*dijit._Widget|String*/ page){
		// summary:
		//		Show the given widget (which must be one of my children)
		// page:
		//		Reference to child widget or id of child widget

		page = dijit.byId(page);

		if(this.selectedChildWidget != page){
			// Deselect old page and select new one
			this._transition(page, this.selectedChildWidget);
			this.selectedChildWidget = page;
			dojo.publish(this.id+"-selectChild", [page]);

			if(this.persist){
				dojo.cookie(this.id + "_selectedChild", this.selectedChildWidget.id);
			}
		}
	},

	_transition: function(/*dijit._Widget*/newWidget, /*dijit._Widget*/oldWidget){
		// summary:
		//		Hide the old widget and display the new widget.
		//		Subclasses should override this.
		// tags:
		//		protected extension
		if(oldWidget){
			this._hideChild(oldWidget);
		}
		this._showChild(newWidget);

		// Size the new widget, in case this is the first time it's being shown,
		// or I have been resized since the last time it was shown.
		// Note that page must be visible for resizing to work.
		if(newWidget.resize){
			if(this.doLayout){
				newWidget.resize(this._containerContentBox || this._contentBox);
			}else{
				// the child should pick it's own size but we still need to call resize()
				// (with no arguments) to let the widget lay itself out
				newWidget.resize();
			}
		}
	},

	_adjacent: function(/*Boolean*/ forward){
		// summary:
		//		Gets the next/previous child widget in this container from the current selection.
		var children = this.getChildren();
		var index = dojo.indexOf(children, this.selectedChildWidget);
		index += forward ? 1 : children.length - 1;
		return children[ index % children.length ]; // dijit._Widget
	},

	forward: function(){
		// summary:
		//		Advance to next page.
		this.selectChild(this._adjacent(true));
	},

	back: function(){
		// summary:
		//		Go back to previous page.
		this.selectChild(this._adjacent(false));
	},

	_onKeyPress: function(e){
		dojo.publish(this.id+"-containerKeyPress", [{ e: e, page: this}]);
	},

	layout: function(){
		// Implement _LayoutWidget.layout() virtual method.
		if(this.doLayout && this.selectedChildWidget && this.selectedChildWidget.resize){
			this.selectedChildWidget.resize(this._contentBox);
		}
	},

	_showChild: function(/*dijit._Widget*/ page){
		// summary:
		//		Show the specified child by changing it's CSS, and call _onShow()/onShow() so
		//		it can do any updates it needs regarding loading href's etc.
		var children = this.getChildren();
		page.isFirstChild = (page == children[0]);
		page.isLastChild = (page == children[children.length-1]);
		page.selected = true;

		dojo.removeClass(page.domNode, "dijitHidden");
		dojo.addClass(page.domNode, "dijitVisible");

		page._onShow();
	},

	_hideChild: function(/*dijit._Widget*/ page){
		// summary:
		//		Hide the specified child by changing it's CSS, and call _onHide() so
		//		it's notified.
		page.selected=false;
		dojo.removeClass(page.domNode, "dijitVisible");
		dojo.addClass(page.domNode, "dijitHidden");

		page.onHide();
	},

	closeChild: function(/*dijit._Widget*/ page){
		// summary:
		//		Callback when user clicks the [X] to remove a page.
		//		If onClose() returns true then remove and destroy the child.
		// tags:
		//		private
		var remove = page.onClose(this, page);
		if(remove){
			this.removeChild(page);
			// makes sure we can clean up executeScripts in ContentPane onUnLoad
			page.destroyRecursive();
		}
	},

	destroyDescendants: function(/*Boolean*/preserveDom){
		dojo.forEach(this.getChildren(), function(child){
			this.removeChild(child);
			child.destroyRecursive(preserveDom);
		}, this);
	}
});

// For back-compat, remove for 2.0



// These arguments can be specified for the children of a StackContainer.
// Since any widget can be specified as a StackContainer child, mix them
// into the base widget class.  (This is a hack, but it's effective.)
dojo.extend(dijit._Widget, {
	// selected: Boolean
	//		Parameter for children of `dijit.layout.StackContainer` or subclasses.
	//		Specifies that this widget should be the initially displayed pane.
	//		Note: to change the selected child use `dijit.layout.StackContainer.selectChild`
	selected: false,

	// closable: Boolean
	//		Parameter for children of `dijit.layout.StackContainer` or subclasses.
	//		True if user can close (destroy) this child, such as (for example) clicking the X on the tab.
	closable: false,

	// iconClass: String
	//		Parameter for children of `dijit.layout.StackContainer` or subclasses.
	//		CSS Class specifying icon to use in label associated with this pane.
	iconClass: "",

	// showTitle: Boolean
	//		Parameter for children of `dijit.layout.StackContainer` or subclasses.
	//		When true, display title of this widget as tab label etc., rather than just using
	//		icon specified in iconClass
	showTitle: true,

	onClose: function(){
		// summary:
		//		Parameter for children of `dijit.layout.StackContainer` or subclasses.
		//		Callback if a user tries to close the child.   Child will be closed if this function returns true.
		// tags:
		//		extension

		return true;		// Boolean
	}
});

}

if(!dojo._hasResource["dijit.layout._TabContainerBase"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout._TabContainerBase"] = true;
dojo.provide("dijit.layout._TabContainerBase");




dojo.declare("dijit.layout._TabContainerBase",
	[dijit.layout.StackContainer, dijit._Templated],
	{
	// summary:
	//		Abstract base class for TabContainer.   Must define _makeController() to instantiate
	//		and return the widget that displays the tab labels
	// description:
	//		A TabContainer is a container that has multiple panes, but shows only
	//		one pane at a time.  There are a set of tabs corresponding to each pane,
	//		where each tab has the name (aka title) of the pane, and optionally a close button.

	// tabPosition: String
	//		Defines where tabs go relative to tab content.
	//		"top", "bottom", "left-h", "right-h"
	tabPosition: "top",

	baseClass: "dijitTabContainer",

	// tabStrip: Boolean
	//		Defines whether the tablist gets an extra class for layouting, putting a border/shading
	//		around the set of tabs.
	tabStrip: false,

	// nested: Boolean
	//		If true, use styling for a TabContainer nested inside another TabContainer.
	//		For tundra etc., makes tabs look like links, and hides the outer
	//		border since the outer TabContainer already has a border.
	nested: false,

	templateString: dojo.cache("dijit.layout", "templates/TabContainer.html", "<div class=\"dijitTabContainer\">\r\n\t<div class=\"dijitTabListWrapper\" dojoAttachPoint=\"tablistNode\"></div>\r\n\t<div dojoAttachPoint=\"tablistSpacer\" class=\"dijitTabSpacer ${baseClass}-spacer\"></div>\r\n\t<div class=\"dijitTabPaneWrapper ${baseClass}-container\" dojoAttachPoint=\"containerNode\"></div>\r\n</div>\r\n"),

	postMixInProperties: function(){
		// set class name according to tab position, ex: dijitTabContainerTop
		this.baseClass += this.tabPosition.charAt(0).toUpperCase() + this.tabPosition.substr(1).replace(/-.*/, "");

		this.srcNodeRef && dojo.style(this.srcNodeRef, "visibility", "hidden");

		this.inherited(arguments);
	},

	postCreate: function(){
		this.inherited(arguments);

		// Create the tab list that will have a tab (a.k.a. tab button) for each tab panel
		this.tablist = this._makeController(this.tablistNode);

		if(!this.doLayout){ dojo.addClass(this.domNode, "dijitTabContainerNoLayout"); }

		if(this.nested){
			/* workaround IE's lack of support for "a > b" selectors by
			 * tagging each node in the template.
			 */
			dojo.addClass(this.domNode, "dijitTabContainerNested");
			dojo.addClass(this.tablist.containerNode, "dijitTabContainerTabListNested");
			dojo.addClass(this.tablistSpacer, "dijitTabContainerSpacerNested");
			dojo.addClass(this.containerNode, "dijitTabPaneWrapperNested");
		}else{
			dojo.addClass(this.domNode, "tabStrip-" + (this.tabStrip ? "enabled" : "disabled"));
		}
	},

	_setupChild: function(/*dijit._Widget*/ tab){
		// Overrides StackContainer._setupChild().
		dojo.addClass(tab.domNode, "dijitTabPane");
		this.inherited(arguments);
	},

	startup: function(){
		if(this._started){ return; }

		// wire up the tablist and its tabs
		this.tablist.startup();

		this.inherited(arguments);
	},

	layout: function(){
		// Overrides StackContainer.layout().
		// Configure the content pane to take up all the space except for where the tabs are

		if(!this._contentBox || typeof(this._contentBox.l) == "undefined"){return;}

		var sc = this.selectedChildWidget;

		if(this.doLayout){
			// position and size the titles and the container node
			var titleAlign = this.tabPosition.replace(/-h/, "");
			this.tablist.layoutAlign = titleAlign;
			var children = [this.tablist, {
				domNode: this.tablistSpacer,
				layoutAlign: titleAlign
			}, {
				domNode: this.containerNode,
				layoutAlign: "client"
			}];
			dijit.layout.layoutChildren(this.domNode, this._contentBox, children);

			// Compute size to make each of my children.
			// children[2] is the margin-box size of this.containerNode, set by layoutChildren() call above
			this._containerContentBox = dijit.layout.marginBox2contentBox(this.containerNode, children[2]);

			if(sc && sc.resize){
				sc.resize(this._containerContentBox);
			}
		}else{
			// just layout the tab controller, so it can position left/right buttons etc.
			if(this.tablist.resize){
				this.tablist.resize({w: dojo.contentBox(this.domNode).w});
			}

			// and call resize() on the selected pane just to tell it that it's been made visible
			if(sc && sc.resize){
				sc.resize();
			}
		}
	},

	destroy: function(){
		if(this.tablist){
			this.tablist.destroy();
		}
		this.inherited(arguments);
	}
});


}

if(!dojo._hasResource["dijit._KeyNavContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._KeyNavContainer"] = true;
dojo.provide("dijit._KeyNavContainer");


dojo.declare("dijit._KeyNavContainer",
	dijit._Container,
	{

		// summary:
		//		A _Container with keyboard navigation of its children.
		// description:
		//		To use this mixin, call connectKeyNavHandlers() in
		//		postCreate() and call startupKeyNavChildren() in startup().
		//		It provides normalized keyboard and focusing code for Container
		//		widgets.
/*=====
		// focusedChild: [protected] Widget
		//		The currently focused child widget, or null if there isn't one
		focusedChild: null,
=====*/

		// tabIndex: Integer
		//		Tab index of the container; same as HTML tabIndex attribute.
		//		Note then when user tabs into the container, focus is immediately
		//		moved to the first item in the container.
		tabIndex: "0",

		_keyNavCodes: {},

		connectKeyNavHandlers: function(/*dojo.keys[]*/ prevKeyCodes, /*dojo.keys[]*/ nextKeyCodes){
			// summary:
			//		Call in postCreate() to attach the keyboard handlers
			//		to the container.
			// preKeyCodes: dojo.keys[]
			//		Key codes for navigating to the previous child.
			// nextKeyCodes: dojo.keys[]
			//		Key codes for navigating to the next child.
			// tags:
			//		protected

			var keyCodes = (this._keyNavCodes = {});
			var prev = dojo.hitch(this, this.focusPrev);
			var next = dojo.hitch(this, this.focusNext);
			dojo.forEach(prevKeyCodes, function(code){ keyCodes[code] = prev; });
			dojo.forEach(nextKeyCodes, function(code){ keyCodes[code] = next; });
			this.connect(this.domNode, "onkeypress", "_onContainerKeypress");
			this.connect(this.domNode, "onfocus", "_onContainerFocus");
		},

		startupKeyNavChildren: function(){
			// summary:
			//		Call in startup() to set child tabindexes to -1
			// tags:
			//		protected
			dojo.forEach(this.getChildren(), dojo.hitch(this, "_startupChild"));
		},

		addChild: function(/*dijit._Widget*/ widget, /*int?*/ insertIndex){
			// summary:
			//		Add a child to our _Container
			dijit._KeyNavContainer.superclass.addChild.apply(this, arguments);
			this._startupChild(widget);
		},

		focus: function(){
			// summary:
			//		Default focus() implementation: focus the first child.
			this.focusFirstChild();
		},

		focusFirstChild: function(){
			// summary:
			//		Focus the first focusable child in the container.
			// tags:
			//		protected
			var child = this._getFirstFocusableChild();
			if(child){ // edge case: Menu could be empty or hidden
				this.focusChild(child);
			}
		},

		focusNext: function(){
			// summary:
			//		Focus the next widget
			// tags:
			//		protected
			var child = this._getNextFocusableChild(this.focusedChild, 1);
			this.focusChild(child);
		},

		focusPrev: function(){
			// summary:
			//		Focus the last focusable node in the previous widget
			//		(ex: go to the ComboButton icon section rather than button section)
			// tags:
			//		protected
			var child = this._getNextFocusableChild(this.focusedChild, -1);
			this.focusChild(child, true);
		},

		focusChild: function(/*dijit._Widget*/ widget, /*Boolean*/ last){
			// summary:
			//		Focus widget.
			// widget:
			//		Reference to container's child widget
			// last:
			//		If true and if widget has multiple focusable nodes, focus the
			//		last one instead of the first one
			// tags:
			//		protected
			
			if(this.focusedChild && widget !== this.focusedChild){
				this._onChildBlur(this.focusedChild);
			}
			widget.focus(last ? "end" : "start");
			this.focusedChild = widget;
		},

		_startupChild: function(/*dijit._Widget*/ widget){
			// summary:
			//		Setup for each child widget
			// description:
			//		Sets tabIndex=-1 on each child, so that the tab key will 
			//		leave the container rather than visiting each child.
			// tags:
			//		private
			
			widget.attr("tabIndex", "-1");
			
			this.connect(widget, "_onFocus", function(){
				// Set valid tabIndex so tabbing away from widget goes to right place, see #10272
				widget.attr("tabIndex", this.tabIndex);
			});
			this.connect(widget, "_onBlur", function(){
				widget.attr("tabIndex", "-1");
			});
		},

		_onContainerFocus: function(evt){
			// summary:
			//		Handler for when the container gets focus
			// description:
			//		Initially the container itself has a tabIndex, but when it gets
			//		focus, switch focus to first child...
			// tags:
			//		private

			// Note that we can't use _onFocus() because switching focus from the
			// _onFocus() handler confuses the focus.js code
			// (because it causes _onFocusNode() to be called recursively)

			// focus bubbles on Firefox,
			// so just make sure that focus has really gone to the container
			if(evt.target !== this.domNode){ return; }

			this.focusFirstChild();

			// and then set the container's tabIndex to -1,
			// (don't remove as that breaks Safari 4)
			// so that tab or shift-tab will go to the fields after/before
			// the container, rather than the container itself
			dojo.attr(this.domNode, "tabIndex", "-1");
		},

		_onBlur: function(evt){
			// When focus is moved away the container, and it's descendant (popup) widgets,
			// then restore the container's tabIndex so that user can tab to it again.
			// Note that using _onBlur() so that this doesn't happen when focus is shifted
			// to one of my child widgets (typically a popup)
			if(this.tabIndex){
				dojo.attr(this.domNode, "tabIndex", this.tabIndex);
			}
			this.inherited(arguments);
		},

		_onContainerKeypress: function(evt){
			// summary:
			//		When a key is pressed, if it's an arrow key etc. then
			//		it's handled here.
			// tags:
			//		private
			if(evt.ctrlKey || evt.altKey){ return; }
			var func = this._keyNavCodes[evt.charOrCode];
			if(func){
				func();
				dojo.stopEvent(evt);
			}
		},

		_onChildBlur: function(/*dijit._Widget*/ widget){
			// summary:
			//		Called when focus leaves a child widget to go
			//		to a sibling widget.
			// tags:
			//		protected
		},

		_getFirstFocusableChild: function(){
			// summary:
			//		Returns first child that can be focused
			return this._getNextFocusableChild(null, 1);	// dijit._Widget
		},

		_getNextFocusableChild: function(child, dir){
			// summary:
			//		Returns the next or previous focusable child, compared
			//		to "child"
			// child: Widget
			//		The current widget
			// dir: Integer
			//		* 1 = after
			//		* -1 = before
			if(child){
				child = this._getSiblingOfChild(child, dir);
			}
			var children = this.getChildren();
			for(var i=0; i < children.length; i++){
				if(!child){
					child = children[(dir>0) ? 0 : (children.length-1)];
				}
				if(child.isFocusable()){
					return child;	// dijit._Widget
				}
				child = this._getSiblingOfChild(child, dir);
			}
			// no focusable child found
			return null;	// dijit._Widget
		}
	}
);

}

if(!dojo._hasResource["dijit.MenuItem"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.MenuItem"] = true;
dojo.provide("dijit.MenuItem");





dojo.declare("dijit.MenuItem",
		[dijit._Widget, dijit._Templated, dijit._Contained],
		{
		// summary:
		//		A line item in a Menu Widget

		// Make 3 columns
		// icon, label, and expand arrow (BiDi-dependent) indicating sub-menu
		templateString: dojo.cache("dijit", "templates/MenuItem.html", "<tr class=\"dijitReset dijitMenuItem\" dojoAttachPoint=\"focusNode\" waiRole=\"menuitem\" tabIndex=\"-1\"\r\n\t\tdojoAttachEvent=\"onmouseenter:_onHover,onmouseleave:_onUnhover,ondijitclick:_onClick\">\r\n\t<td class=\"dijitReset\" waiRole=\"presentation\">\r\n\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitMenuItemIcon\" dojoAttachPoint=\"iconNode\">\r\n\t</td>\r\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" dojoAttachPoint=\"containerNode\"></td>\r\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" dojoAttachPoint=\"accelKeyNode\"></td>\r\n\t<td class=\"dijitReset dijitMenuArrowCell\" waiRole=\"presentation\">\r\n\t\t<div dojoAttachPoint=\"arrowWrapper\" style=\"visibility: hidden\">\r\n\t\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitMenuExpand\">\r\n\t\t\t<span class=\"dijitMenuExpandA11y\">+</span>\r\n\t\t</div>\r\n\t</td>\r\n</tr>\r\n"),

		attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
			label: { node: "containerNode", type: "innerHTML" },
			iconClass: { node: "iconNode", type: "class" }
		}),

		// label: String
		//		Menu text
		label: '',

		// iconClass: String
		//		Class to apply to DOMNode to make it display an icon.
		iconClass: "",

		// accelKey: String
		//		Text for the accelerator (shortcut) key combination.
		//		Note that although Menu can display accelerator keys there
		//		is no infrastructure to actually catch and execute these
		//		accelerators.
		accelKey: "",

		// disabled: Boolean
		//		If true, the menu item is disabled.
		//		If false, the menu item is enabled.
		disabled: false,

		_fillContent: function(/*DomNode*/ source){
			// If button label is specified as srcNodeRef.innerHTML rather than
			// this.params.label, handle it here.
			if(source && !("label" in this.params)){
				this.attr('label', source.innerHTML);
			}
		},

		postCreate: function(){
			dojo.setSelectable(this.domNode, false);
			var label = this.id+"_text";
			dojo.attr(this.containerNode, "id", label);
			if(this.accelKeyNode){
				dojo.attr(this.accelKeyNode, "id", this.id + "_accel");
				label += " " + this.id + "_accel";
			}
			dijit.setWaiState(this.domNode, "labelledby", label);
		},

		_onHover: function(){
			// summary:
			//		Handler when mouse is moved onto menu item
			// tags:
			//		protected
			dojo.addClass(this.domNode, 'dijitMenuItemHover');
			this.getParent().onItemHover(this);
		},

		_onUnhover: function(){
			// summary:
			//		Handler when mouse is moved off of menu item,
			//		possibly to a child menu, or maybe to a sibling
			//		menuitem or somewhere else entirely.
			// tags:
			//		protected

			// if we are unhovering the currently selected item
			// then unselect it
			dojo.removeClass(this.domNode, 'dijitMenuItemHover');
			this.getParent().onItemUnhover(this);
		},

		_onClick: function(evt){
			// summary:
			//		Internal handler for click events on MenuItem.
			// tags:
			//		private
			this.getParent().onItemClick(this, evt);
			dojo.stopEvent(evt);
		},

		onClick: function(/*Event*/ evt){
			// summary:
			//		User defined function to handle clicks
			// tags:
			//		callback
		},

		focus: function(){
			// summary:
			//		Focus on this MenuItem
			try{
				if(dojo.isIE == 8){
					// needed for IE8 which won't scroll TR tags into view on focus yet calling scrollIntoView creates flicker (#10275)
					this.containerNode.focus();
				}
				dijit.focus(this.focusNode);
			}catch(e){
				// this throws on IE (at least) in some scenarios
			}
		},

		_onFocus: function(){
			// summary:
			//		This is called by the focus manager when focus
			//		goes to this MenuItem or a child menu.
			// tags:
			//		protected
			this._setSelected(true);
			this.getParent()._onItemFocus(this);

			this.inherited(arguments);
		},

		_setSelected: function(selected){
			// summary:
			//		Indicate that this node is the currently selected one
			// tags:
			//		private

			/***
			 * TODO: remove this method and calls to it, when _onBlur() is working for MenuItem.
			 * Currently _onBlur() gets called when focus is moved from the MenuItem to a child menu.
			 * That's not supposed to happen, but the problem is:
			 * In order to allow dijit.popup's getTopPopup() to work,a sub menu's popupParent
			 * points to the parent Menu, bypassing the parent MenuItem... thus the
			 * MenuItem is not in the chain of active widgets and gets a premature call to
			 * _onBlur()
			 */

			dojo.toggleClass(this.domNode, "dijitMenuItemSelected", selected);
		},

		setLabel: function(/*String*/ content){
			// summary:
			//		Deprecated.   Use attr('label', ...) instead.
			// tags:
			//		deprecated
			dojo.deprecated("dijit.MenuItem.setLabel() is deprecated.  Use attr('label', ...) instead.", "", "2.0");
			this.attr("label", content);
		},

		setDisabled: function(/*Boolean*/ disabled){
			// summary:
			//		Deprecated.   Use attr('disabled', bool) instead.
			// tags:
			//		deprecated
			dojo.deprecated("dijit.Menu.setDisabled() is deprecated.  Use attr('disabled', bool) instead.", "", "2.0");
			this.attr('disabled', disabled);
		},
		_setDisabledAttr: function(/*Boolean*/ value){
			// summary:
			//		Hook for attr('disabled', ...) to work.
			//		Enable or disable this menu item.
			this.disabled = value;
			dojo[value ? "addClass" : "removeClass"](this.domNode, 'dijitMenuItemDisabled');
			dijit.setWaiState(this.focusNode, 'disabled', value ? 'true' : 'false');
		},
		_setAccelKeyAttr: function(/*String*/ value){
			// summary:
			//		Hook for attr('accelKey', ...) to work.
			//		Set accelKey on this menu item.
			this.accelKey=value;

			this.accelKeyNode.style.display=value?"":"none";
			this.accelKeyNode.innerHTML=value;
			//have to use colSpan to make it work in IE
			dojo.attr(this.containerNode,'colSpan',value?"1":"2");
		}
	});

}

if(!dojo._hasResource["dijit.PopupMenuItem"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.PopupMenuItem"] = true;
dojo.provide("dijit.PopupMenuItem");



dojo.declare("dijit.PopupMenuItem",
		dijit.MenuItem,
		{
		_fillContent: function(){
			// summary:
			//		When Menu is declared in markup, this code gets the menu label and
			//		the popup widget from the srcNodeRef.
			// description:
			//		srcNodeRefinnerHTML contains both the menu item text and a popup widget
			//		The first part holds the menu item text and the second part is the popup
			// example:
			// |	<div dojoType="dijit.PopupMenuItem">
			// |		<span>pick me</span>
			// |		<popup> ... </popup>
			// |	</div>
			// tags:
			//		protected

			if(this.srcNodeRef){
				var nodes = dojo.query("*", this.srcNodeRef);
				dijit.PopupMenuItem.superclass._fillContent.call(this, nodes[0]);

				// save pointer to srcNode so we can grab the drop down widget after it's instantiated
				this.dropDownContainer = this.srcNodeRef;
			}
		},

		startup: function(){
			if(this._started){ return; }
			this.inherited(arguments);

			// we didn't copy the dropdown widget from the this.srcNodeRef, so it's in no-man's
			// land now.  move it to dojo.doc.body.
			if(!this.popup){
				var node = dojo.query("[widgetId]", this.dropDownContainer)[0];
				this.popup = dijit.byNode(node);
			}
			dojo.body().appendChild(this.popup.domNode);

			this.popup.domNode.style.display="none";
			if(this.arrowWrapper){
				dojo.style(this.arrowWrapper, "visibility", "");
			}
			dijit.setWaiState(this.focusNode, "haspopup", "true");
		},

		destroyDescendants: function(){
			if(this.popup){
				// Destroy the popup, unless it's already been destroyed.  This can happen because
				// the popup is a direct child of <body> even though it's logically my child.
				if(!this.popup._destroyed){
					this.popup.destroyRecursive();
				}
				delete this.popup;
			}
			this.inherited(arguments);
		}
	});


}

if(!dojo._hasResource["dijit.CheckedMenuItem"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.CheckedMenuItem"] = true;
dojo.provide("dijit.CheckedMenuItem");



dojo.declare("dijit.CheckedMenuItem",
		dijit.MenuItem,
		{
		// summary:
		//		A checkbox-like menu item for toggling on and off

		templateString: dojo.cache("dijit", "templates/CheckedMenuItem.html", "<tr class=\"dijitReset dijitMenuItem\" dojoAttachPoint=\"focusNode\" waiRole=\"menuitemcheckbox\" tabIndex=\"-1\"\r\n\t\tdojoAttachEvent=\"onmouseenter:_onHover,onmouseleave:_onUnhover,ondijitclick:_onClick\">\r\n\t<td class=\"dijitReset\" waiRole=\"presentation\">\r\n\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitMenuItemIcon dijitCheckedMenuItemIcon\" dojoAttachPoint=\"iconNode\">\r\n\t\t<span class=\"dijitCheckedMenuItemIconChar\">&#10003;</span>\r\n\t</td>\r\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" dojoAttachPoint=\"containerNode,labelNode\"></td>\r\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" dojoAttachPoint=\"accelKeyNode\"></td>\r\n\t<td class=\"dijitReset dijitMenuArrowCell\" waiRole=\"presentation\">\r\n\t</td>\r\n</tr>\r\n"),

		// checked: Boolean
		//		Our checked state
		checked: false,
		_setCheckedAttr: function(/*Boolean*/ checked){
			// summary:
			//		Hook so attr('checked', bool) works.
			//		Sets the class and state for the check box.
			dojo.toggleClass(this.domNode, "dijitCheckedMenuItemChecked", checked);
			dijit.setWaiState(this.domNode, "checked", checked);
			this.checked = checked;
		},

		onChange: function(/*Boolean*/ checked){
			// summary:
			//		User defined function to handle check/uncheck events
			// tags:
			//		callback
		},

		_onClick: function(/*Event*/ e){
			// summary:
			//		Clicking this item just toggles its state
			// tags:
			//		private
			if(!this.disabled){
				this.attr("checked", !this.checked);
				this.onChange(this.checked);
			}
			this.inherited(arguments);
		}
	});

}

if(!dojo._hasResource["dijit.MenuSeparator"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.MenuSeparator"] = true;
dojo.provide("dijit.MenuSeparator");





dojo.declare("dijit.MenuSeparator",
		[dijit._Widget, dijit._Templated, dijit._Contained],
		{
		// summary:
		//		A line between two menu items

		templateString: dojo.cache("dijit", "templates/MenuSeparator.html", "<tr class=\"dijitMenuSeparator\">\r\n\t<td colspan=\"4\">\r\n\t\t<div class=\"dijitMenuSeparatorTop\"></div>\r\n\t\t<div class=\"dijitMenuSeparatorBottom\"></div>\r\n\t</td>\r\n</tr>\r\n"),

		postCreate: function(){
			dojo.setSelectable(this.domNode, false);
		},

		isFocusable: function(){
			// summary:
			//		Override to always return false
			// tags:
			//		protected

			return false; // Boolean
		}
	});


}

if(!dojo._hasResource["dijit.Menu"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Menu"] = true;
dojo.provide("dijit.Menu");





dojo.declare("dijit._MenuBase",
	[dijit._Widget, dijit._Templated, dijit._KeyNavContainer],
{
	// summary:
	//		Base class for Menu and MenuBar

	// parentMenu: [readonly] Widget
	//		pointer to menu that displayed me
	parentMenu: null,

	// popupDelay: Integer
	//		number of milliseconds before hovering (without clicking) causes the popup to automatically open.
	popupDelay: 500,

	startup: function(){
		if(this._started){ return; }

		dojo.forEach(this.getChildren(), function(child){ child.startup(); });
		this.startupKeyNavChildren();

		this.inherited(arguments);
	},

	onExecute: function(){
		// summary:
		//		Attach point for notification about when a menu item has been executed.
		//		This is an internal mechanism used for Menus to signal to their parent to
		//		close them, because they are about to execute the onClick handler.   In
		//		general developers should not attach to or override this method.
		// tags:
		//		protected
	},

	onCancel: function(/*Boolean*/ closeAll){
		// summary:
		//		Attach point for notification about when the user cancels the current menu
		//		This is an internal mechanism used for Menus to signal to their parent to
		//		close them.  In general developers should not attach to or override this method.
		// tags:
		//		protected
	},

	_moveToPopup: function(/*Event*/ evt){
		// summary:
		//		This handles the right arrow key (left arrow key on RTL systems),
		//		which will either open a submenu, or move to the next item in the
		//		ancestor MenuBar
		// tags:
		//		private

		if(this.focusedChild && this.focusedChild.popup && !this.focusedChild.disabled){
			this.focusedChild._onClick(evt);
		}else{
			var topMenu = this._getTopMenu();
			if(topMenu && topMenu._isMenuBar){
				topMenu.focusNext();
			}
		}
	},

	_onPopupHover: function(/*Event*/ evt){
		// summary:
		//		This handler is called when the mouse moves over the popup.
		// tags:
		//		private

		// if the mouse hovers over a menu popup that is in pending-close state,
		// then stop the close operation.
		// This can't be done in onItemHover since some popup targets don't have MenuItems (e.g. ColorPicker)
		if(this.currentPopup && this.currentPopup._pendingClose_timer){
			var parentMenu = this.currentPopup.parentMenu;
			// highlight the parent menu item pointing to this popup
			if(parentMenu.focusedChild){
				parentMenu.focusedChild._setSelected(false);
			}
			parentMenu.focusedChild = this.currentPopup.from_item;
			parentMenu.focusedChild._setSelected(true);
			// cancel the pending close
			this._stopPendingCloseTimer(this.currentPopup);
		}
	},

	onItemHover: function(/*MenuItem*/ item){
		// summary:
		//		Called when cursor is over a MenuItem.
		// tags:
		//		protected

		// Don't do anything unless user has "activated" the menu by:
		//		1) clicking it
		//		2) opening it from a parent menu (which automatically focuses it)
		if(this.isActive){
			this.focusChild(item);
			if(this.focusedChild.popup && !this.focusedChild.disabled && !this.hover_timer){
				this.hover_timer = setTimeout(dojo.hitch(this, "_openPopup"), this.popupDelay);
			}
		}
		// if the user is mixing mouse and keyboard navigation,
		// then the menu may not be active but a menu item has focus,
		// but it's not the item that the mouse just hovered over.
		// To avoid both keyboard and mouse selections, use the latest.
		if(this.focusedChild){
			this.focusChild(item);
		}
		this._hoveredChild = item;
	},

	_onChildBlur: function(item){
		// summary:
		//		Called when a child MenuItem becomes inactive because focus
		//		has been removed from the MenuItem *and* it's descendant menus.
		// tags:
		//		private
		this._stopPopupTimer();
		item._setSelected(false);
		// Close all popups that are open and descendants of this menu
		var itemPopup = item.popup;
		if(itemPopup){
			this._stopPendingCloseTimer(itemPopup);
			itemPopup._pendingClose_timer = setTimeout(function(){
				itemPopup._pendingClose_timer = null;
				if(itemPopup.parentMenu){
					itemPopup.parentMenu.currentPopup = null;
				}
				dijit.popup.close(itemPopup); // this calls onClose
			}, this.popupDelay);
		}
	},

	onItemUnhover: function(/*MenuItem*/ item){
		// summary:
		//		Callback fires when mouse exits a MenuItem
		// tags:
		//		protected

		if(this.isActive){
			this._stopPopupTimer();
		}
		if(this._hoveredChild == item){ this._hoveredChild = null; }
	},

	_stopPopupTimer: function(){
		// summary:
		//		Cancels the popup timer because the user has stop hovering
		//		on the MenuItem, etc.
		// tags:
		//		private
		if(this.hover_timer){
			clearTimeout(this.hover_timer);
			this.hover_timer = null;
		}
	},

	_stopPendingCloseTimer: function(/*dijit._Widget*/ popup){
		// summary:
		//		Cancels the pending-close timer because the close has been preempted
		// tags:
		//		private
		if(popup._pendingClose_timer){
			clearTimeout(popup._pendingClose_timer);
			popup._pendingClose_timer = null;
		}
	},

	_stopFocusTimer: function(){
		// summary:
		//		Cancels the pending-focus timer because the menu was closed before focus occured
		// tags:
		//		private
		if(this._focus_timer){
			clearTimeout(this._focus_timer);
			this._focus_timer = null;
		}
	},

	_getTopMenu: function(){
		// summary:
		//		Returns the top menu in this chain of Menus
		// tags:
		//		private
		for(var top=this; top.parentMenu; top=top.parentMenu);
		return top;
	},

	onItemClick: function(/*dijit._Widget*/ item, /*Event*/ evt){
		// summary:
		//		Handle clicks on an item.
		// tags:
		//		private
		if(item.disabled){ return false; }

		// this can't be done in _onFocus since the _onFocus events occurs asynchronously
		if(typeof this.isShowingNow == 'undefined'){ // non-popup menu
			this._markActive();
		}

		this.focusChild(item);

		if(item.popup){
			this._openPopup();
		}else{
			// before calling user defined handler, close hierarchy of menus
			// and restore focus to place it was when menu was opened
			this.onExecute();

			// user defined handler for click
			item.onClick(evt);
		}
	},

	_openPopup: function(){
		// summary:
		//		Open the popup to the side of/underneath the current menu item
		// tags:
		//		protected

		this._stopPopupTimer();
		var from_item = this.focusedChild;
		if(!from_item){ return; } // the focused child lost focus since the timer was started
		var popup = from_item.popup;
		if(popup.isShowingNow){ return; }
		if(this.currentPopup){
			this._stopPendingCloseTimer(this.currentPopup);
			dijit.popup.close(this.currentPopup);
		}
		popup.parentMenu = this;
		popup.from_item = from_item; // helps finding the parent item that should be focused for this popup
		var self = this;
		dijit.popup.open({
			parent: this,
			popup: popup,
			around: from_item.domNode,
			orient: this._orient || (this.isLeftToRight() ?
									{'TR': 'TL', 'TL': 'TR', 'BR': 'BL', 'BL': 'BR'} :
									{'TL': 'TR', 'TR': 'TL', 'BL': 'BR', 'BR': 'BL'}),
			onCancel: function(){ // called when the child menu is canceled
				// set isActive=false (_closeChild vs _cleanUp) so that subsequent hovering will NOT open child menus
				// which seems aligned with the UX of most applications (e.g. notepad, wordpad, paint shop pro)
				self.focusChild(from_item);	// put focus back on my node
				self._cleanUp();			// close the submenu (be sure this is done _after_ focus is moved)
				from_item._setSelected(true); // oops, _cleanUp() deselected the item
				self.focusedChild = from_item;	// and unset focusedChild
			},
			onExecute: dojo.hitch(this, "_cleanUp")
		});

		this.currentPopup = popup;
		// detect mouseovers to handle lazy mouse movements that temporarily focus other menu items
		popup.connect(popup.domNode, "onmouseenter", dojo.hitch(self, "_onPopupHover")); // cleaned up when the popped-up widget is destroyed on close

		if(popup.focus){
			// If user is opening the popup via keyboard (right arrow, or down arrow for MenuBar),
			// if the cursor happens to collide with the popup, it will generate an onmouseover event
			// even though the mouse wasn't moved.   Use a setTimeout() to call popup.focus so that
			// our focus() call overrides the onmouseover event, rather than vice-versa.  (#8742)
			popup._focus_timer = setTimeout(dojo.hitch(popup, function(){
				this._focus_timer = null;
				this.focus();
			}), 0);
		}
	},

	_markActive: function(){
		// summary:
		//              Mark this menu's state as active.
		//		Called when this Menu gets focus from:
		//			1) clicking it (mouse or via space/arrow key)
		//			2) being opened by a parent menu.
		//		This is not called just from mouse hover.
		//		Focusing a menu via TAB does NOT automatically set isActive
		//		since TAB is a navigation operation and not a selection one.
		//		For Windows apps, pressing the ALT key focuses the menubar
		//		menus (similar to TAB navigation) but the menu is not active
		//		(ie no dropdown) until an item is clicked.
		this.isActive = true;
		dojo.addClass(this.domNode, "dijitMenuActive");
		dojo.removeClass(this.domNode, "dijitMenuPassive");
	},

	onOpen: function(/*Event*/ e){
		// summary:
		//		Callback when this menu is opened.
		//		This is called by the popup manager as notification that the menu
		//		was opened.
		// tags:
		//		private

		this.isShowingNow = true;
		this._markActive();
	},

	_markInactive: function(){
		// summary:
		//		Mark this menu's state as inactive.
		this.isActive = false; // don't do this in _onBlur since the state is pending-close until we get here
		dojo.removeClass(this.domNode, "dijitMenuActive");
		dojo.addClass(this.domNode, "dijitMenuPassive");
	},

	onClose: function(){
		// summary:
		//		Callback when this menu is closed.
		//		This is called by the popup manager as notification that the menu
		//		was closed.
		// tags:
		//		private

		this._stopFocusTimer();
		this._markInactive();
		this.isShowingNow = false;
		this.parentMenu = null;
	},

	_closeChild: function(){
		// summary:
		//		Called when submenu is clicked or focus is lost.  Close hierarchy of menus.
		// tags:
		//		private
		this._stopPopupTimer();
		if(this.focusedChild){ // unhighlight the focused item
			this.focusedChild._setSelected(false);
			this.focusedChild._onUnhover();
			this.focusedChild = null;
		}
		if(this.currentPopup){
			// Close all popups that are open and descendants of this menu
			dijit.popup.close(this.currentPopup);
			this.currentPopup = null;
		}
	},

	_onItemFocus: function(/*MenuItem*/ item){
		// summary:
		//		Called when child of this Menu gets focus from:
		//			1) clicking it
		//			2) tabbing into it
		//			3) being opened by a parent menu.
		//		This is not called just from mouse hover.
		if(this._hoveredChild && this._hoveredChild != item){
			this._hoveredChild._onUnhover(); // any previous mouse movement is trumped by focus selection
		}
	},

	_onBlur: function(){
		// summary:
		//		Called when focus is moved away from this Menu and it's submenus.
		// tags:
		//		protected
		this._cleanUp();
		this.inherited(arguments);
	},

	_cleanUp: function(){
		// summary:
		//		Called when the user is done with this menu.  Closes hierarchy of menus.
		// tags:
		//		private

		this._closeChild(); // don't call this.onClose since that's incorrect for MenuBar's that never close
		if(typeof this.isShowingNow == 'undefined'){ // non-popup menu doesn't call onClose
			this._markInactive();
		}
	}
});

dojo.declare("dijit.Menu",
	dijit._MenuBase,
	{
	// summary
	//		A context menu you can assign to multiple elements

	// TODO: most of the code in here is just for context menu (right-click menu)
	// support.  In retrospect that should have been a separate class (dijit.ContextMenu).
	// Split them for 2.0

	constructor: function(){
		this._bindings = [];
	},

	templateString: dojo.cache("dijit", "templates/Menu.html", "<table class=\"dijit dijitMenu dijitMenuPassive dijitReset dijitMenuTable\" waiRole=\"menu\" tabIndex=\"${tabIndex}\" dojoAttachEvent=\"onkeypress:_onKeyPress\">\r\n\t<tbody class=\"dijitReset\" dojoAttachPoint=\"containerNode\"></tbody>\r\n</table>\r\n"),

	// targetNodeIds: [const] String[]
	//		Array of dom node ids of nodes to attach to.
	//		Fill this with nodeIds upon widget creation and it becomes context menu for those nodes.
	targetNodeIds: [],

	// contextMenuForWindow: [const] Boolean
	//		If true, right clicking anywhere on the window will cause this context menu to open.
	//		If false, must specify targetNodeIds.
	contextMenuForWindow: false,

	// leftClickToOpen: [const] Boolean
	//		If true, menu will open on left click instead of right click, similiar to a file menu.
	leftClickToOpen: false,

	// refocus: Boolean
	// 		When this menu closes, re-focus the element which had focus before it was opened.
	refocus: true,

	// _contextMenuWithMouse: [private] Boolean
	//		Used to record mouse and keyboard events to determine if a context
	//		menu is being opened with the keyboard or the mouse.
	_contextMenuWithMouse: false,

	postCreate: function(){
		if(this.contextMenuForWindow){
			this.bindDomNode(dojo.body());
		}else{
			// TODO: should have _setTargetNodeIds() method to handle initialization and a possible
			// later attr('targetNodeIds', ...) call.   There's also a problem that targetNodeIds[]
			// gets stale after calls to bindDomNode()/unBindDomNode() as it still is just the original list (see #9610)
			dojo.forEach(this.targetNodeIds, this.bindDomNode, this);
		}
		var k = dojo.keys, l = this.isLeftToRight();
		this._openSubMenuKey = l ? k.RIGHT_ARROW : k.LEFT_ARROW;
		this._closeSubMenuKey = l ? k.LEFT_ARROW : k.RIGHT_ARROW;
		this.connectKeyNavHandlers([k.UP_ARROW], [k.DOWN_ARROW]);
	},

	_onKeyPress: function(/*Event*/ evt){
		// summary:
		//		Handle keyboard based menu navigation.
		// tags:
		//		protected

		if(evt.ctrlKey || evt.altKey){ return; }

		switch(evt.charOrCode){
			case this._openSubMenuKey:
				this._moveToPopup(evt);
				dojo.stopEvent(evt);
				break;
			case this._closeSubMenuKey:
				if(this.parentMenu){
					if(this.parentMenu._isMenuBar){
						this.parentMenu.focusPrev();
					}else{
						this.onCancel(false);
					}
				}else{
					dojo.stopEvent(evt);
				}
				break;
		}
	},

	// thanks burstlib!
	_iframeContentWindow: function(/* HTMLIFrameElement */iframe_el){
		// summary:
		//		Returns the window reference of the passed iframe
		// tags:
		//		private
		var win = dijit.getDocumentWindow(this._iframeContentDocument(iframe_el)) ||
			// Moz. TODO: is this available when defaultView isn't?
			this._iframeContentDocument(iframe_el)['__parent__'] ||
			(iframe_el.name && dojo.doc.frames[iframe_el.name]) || null;
		return win;	//	Window
	},

	_iframeContentDocument: function(/* HTMLIFrameElement */iframe_el){
		// summary:
		//		Returns a reference to the document object inside iframe_el
		// tags:
		//		protected
		var doc = iframe_el.contentDocument // W3
			|| (iframe_el.contentWindow && iframe_el.contentWindow.document) // IE
			|| (iframe_el.name && dojo.doc.frames[iframe_el.name] && dojo.doc.frames[iframe_el.name].document)
			|| null;
		return doc;	//	HTMLDocument
	},

	bindDomNode: function(/*String|DomNode*/ node){
		// summary:
		//		Attach menu to given node
		node = dojo.byId(node);

		var cn;	// Connect node

		// Support context menus on iframes.   Rather than binding to the iframe itself we need
		// to bind to the <body> node inside the iframe.
		if(node.tagName.toLowerCase() == "iframe"){
			var iframe = node,
				win = this._iframeContentWindow(iframe);
			cn = dojo.withGlobal(win, dojo.body);
		}else{
			
			// To capture these events at the top level, attach to <html>, not <body>.
			// Otherwise right-click context menu just doesn't work.
			cn = (node == dojo.body() ? dojo.doc.documentElement : node);
		}


		// "binding" is the object to track our connection to the node (ie, the parameter to bindDomNode())
		var binding = {
			node: node,
			iframe: iframe
		};

		// Save info about binding in _bindings[], and make node itself record index(+1) into
		// _bindings[] array.   Prefix w/_dijitMenu to avoid setting an attribute that may
		// start with a number, which fails on FF/safari.
		dojo.attr(node, "_dijitMenu" + this.id, this._bindings.push(binding));

		// Setup the connections to monitor click etc., unless we are connecting to an iframe which hasn't finished
		// loading yet, in which case we need to wait for the onload event first, and then connect
		var doConnects = dojo.hitch(this, function(cn){
			return [
				dojo.connect(cn, (this.leftClickToOpen)?"onclick":"oncontextmenu", this, function(evt){
					this._openMyself(evt, cn, iframe);
				}),
				dojo.connect(cn, "onkeydown", this, "_contextKey"),
				dojo.connect(cn, "onmousedown", this, "_contextMouse")
			];
		});
		binding.connects = cn ? doConnects(cn) : [];

		if(iframe){
			// Setup handler to [re]bind to the iframe when the contents are initially loaded,
			// and every time the contents change.
			// Need to do this b/c we are actually binding to the iframe's <body> node.
			// Note: can't use dojo.connect(), see #9609.

			binding.onloadHandler = dojo.hitch(this, function(){
				// want to remove old connections, but IE throws exceptions when trying to
				// access the <body> node because it's already gone, or at least in a state of limbo

				var win = this._iframeContentWindow(iframe);
					cn = dojo.withGlobal(win, dojo.body);
				binding.connects = doConnects(cn);
			});
			if(iframe.addEventListener){
				iframe.addEventListener("load", binding.onloadHandler, false);
			}else{
				iframe.attachEvent("onload", binding.onloadHandler);
			}
		}
	},

	unBindDomNode: function(/*String|DomNode*/ nodeName){
		// summary:
		//		Detach menu from given node

		var node;
		try{
			node = dojo.byId(nodeName);
		}catch(e){
			// On IE the dojo.byId() call will get an exception if the attach point was
			// the <body> node of an <iframe> that has since been reloaded (and thus the
			// <body> node is in a limbo state of destruction.
			return;
		}

		// node["_dijitMenu" + this.id] contains index(+1) into my _bindings[] array
		var attrName = "_dijitMenu" + this.id;
		if(node && dojo.hasAttr(node, attrName)){
			var bid = dojo.attr(node, attrName)-1, b = this._bindings[bid];
			dojo.forEach(b.connects, dojo.disconnect);

			// Remove listener for iframe onload events
			var iframe = b.iframe;
			if(iframe){
				if(iframe.removeEventListener){
					iframe.removeEventListener("load", b.onloadHandler, false);
				}else{
					iframe.detachEvent("onload", b.onloadHandler);
				}
			}

			dojo.removeAttr(node, attrName);
			delete this._bindings[bid];
		}
	},

	_contextKey: function(e){
		// summary:
		//		Code to handle popping up editor using F10 key rather than mouse
		// tags:
		//		private
		this._contextMenuWithMouse = false;
		if(e.keyCode == dojo.keys.F10){
			dojo.stopEvent(e);
			if(e.shiftKey && e.type == "keydown"){
				// FF: copying the wrong property from e will cause the system
				// context menu to appear in spite of stopEvent. Don't know
				// exactly which properties cause this effect.
				var _e = { target: e.target, pageX: e.pageX, pageY: e.pageY };
				_e.preventDefault = _e.stopPropagation = function(){};
				// IE: without the delay, focus work in "open" causes the system
				// context menu to appear in spite of stopEvent.
				window.setTimeout(dojo.hitch(this, function(){ this._openMyself(_e); }), 1);
			}
		}
	},

	_contextMouse: function(e){
		// summary:
		//		Helper to remember when we opened the context menu with the mouse instead
		//		of with the keyboard
		// tags:
		//		private
		this._contextMenuWithMouse = true;
	},

	_openMyself: function(/*Event*/ e, /*DomNode?*/ node, /*DomNode?*/ iframe){
		// summary:
		//		Internal function for opening myself when the user
		//		does a right-click or something similar.
		// node:
		//		The node that is being clicked
		// iframe:
		//		If an <iframe> is being clicked, iframe points to that iframe and node
		//		points to the iframe's body.
		// tags:
		//		private

		if(this.leftClickToOpen && e.button>0){
			return;
		}
		dojo.stopEvent(e);

		// Get coordinates.
		// If we are opening the menu with the mouse or on safari open
		// the menu at the mouse cursor
		// (Safari does not have a keyboard command to open the context menu
		// and we don't currently have a reliable way to determine
		// _contextMenuWithMouse on Safari)
		var x,y;
		if(dojo.isSafari || this._contextMenuWithMouse){
			x=e.pageX;
			y=e.pageY;

			if(iframe){
				// Event is on <body> node of an <iframe>, convert coordinates to match main document
				var od = e.target.ownerDocument,
					ifc = dojo.position(iframe, true),
					win = this._iframeContentWindow(iframe),
					scroll = dojo.withGlobal(win, "_docScroll", dojo);

				var cs = dojo.getComputedStyle(iframe),
					tp = dojo._toPixelValue,
					left = (dojo.isIE && dojo.isQuirks ? 0 : tp(iframe, cs.paddingLeft)) + (dojo.isIE && dojo.isQuirks ? tp(iframe, cs.borderLeftWidth) : 0),
					top = (dojo.isIE && dojo.isQuirks ? 0 : tp(iframe, cs.paddingTop)) + (dojo.isIE && dojo.isQuirks ? tp(iframe, cs.borderTopWidth) : 0);

				x += ifc.x + left - scroll.x;
				y += ifc.y + top - scroll.y;
			}
		}else{
			// otherwise open near e.target
			var coords = dojo.position(e.target, true);
			x = coords.x + 10;
			y = coords.y + 10;
		}

		var self=this;
		var savedFocus = dijit.getFocus(this);
		function closeAndRestoreFocus(){
			// user has clicked on a menu or popup
			if(self.refocus){
				dijit.focus(savedFocus);
			}
			dijit.popup.close(self);
		}
		dijit.popup.open({
			popup: this,
			x: x,
			y: y,
			onExecute: closeAndRestoreFocus,
			onCancel: closeAndRestoreFocus,
			orient: this.isLeftToRight() ? 'L' : 'R'
		});
		this.focus();

		this._onBlur = function(){
			this.inherited('_onBlur', arguments);
			// Usually the parent closes the child widget but if this is a context
			// menu then there is no parent
			dijit.popup.close(this);
			// don't try to restore focus; user has clicked another part of the screen
			// and set focus there
		};
	},

	uninitialize: function(){
 		dojo.forEach(this._bindings, function(b){ if(b){ this.unBindDomNode(b.node); } }, this);
 		this.inherited(arguments);
	}
}
);

// Back-compat (TODO: remove in 2.0)






}

if(!dojo._hasResource["dijit.layout.TabController"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.TabController"] = true;
dojo.provide("dijit.layout.TabController");



// Menu is used for an accessible close button, would be nice to have a lighter-weight solution





dojo.declare("dijit.layout.TabController",
	dijit.layout.StackController,
{
	// summary:
	// 		Set of tabs (the things with titles and a close button, that you click to show a tab panel).
	//		Used internally by `dijit.layout.TabContainer`.
	// description:
	//		Lets the user select the currently shown pane in a TabContainer or StackContainer.
	//		TabController also monitors the TabContainer, and whenever a pane is
	//		added or deleted updates itself accordingly.
	// tags:
	//		private

	templateString: "<div wairole='tablist' dojoAttachEvent='onkeypress:onkeypress'></div>",

	// tabPosition: String
	//		Defines where tabs go relative to the content.
	//		"top", "bottom", "left-h", "right-h"
	tabPosition: "top",

	// buttonWidget: String
	//		The name of the tab widget to create to correspond to each page
	buttonWidget: "dijit.layout._TabButton",

	_rectifyRtlTabList: function(){
		// summary:
		//		For left/right TabContainer when page is RTL mode, rectify the width of all tabs to be equal, otherwise the tab widths are different in IE

		if(0 >= this.tabPosition.indexOf('-h')){ return; }
		if(!this.pane2button){ return; }

		var maxWidth = 0;
		for(var pane in this.pane2button){
			var ow = this.pane2button[pane].innerDiv.scrollWidth;
			maxWidth = Math.max(maxWidth, ow);
		}
		//unify the length of all the tabs
		for(pane in this.pane2button){
			this.pane2button[pane].innerDiv.style.width = maxWidth + 'px';
		}
	}
});

dojo.declare("dijit.layout._TabButton",
	dijit.layout._StackButton,
	{
	// summary:
	//		A tab (the thing you click to select a pane).
	// description:
	//		Contains the title of the pane, and optionally a close-button to destroy the pane.
	//		This is an internal widget and should not be instantiated directly.
	// tags:
	//		private

	// baseClass: String
	//		The CSS class applied to the domNode.
	baseClass: "dijitTab",

	templateString: dojo.cache("dijit.layout", "templates/_TabButton.html", "<div waiRole=\"presentation\" dojoAttachPoint=\"titleNode\" dojoAttachEvent='onclick:onClick,onmouseenter:_onMouse,onmouseleave:_onMouse'>\r\n    <div waiRole=\"presentation\" class='dijitTabInnerDiv' dojoAttachPoint='innerDiv'>\r\n        <div waiRole=\"presentation\" class='dijitTabContent' dojoAttachPoint='tabContent,focusNode'>\r\n\t        <img src=\"${_blankGif}\" alt=\"\" dojoAttachPoint='iconNode' waiRole=\"presentation\"/>\r\n\t        <span dojoAttachPoint='containerNode' class='tabLabel'></span>\r\n\t        <span class=\"closeButton\" dojoAttachPoint='closeNode'\r\n\t        \t\tdojoAttachEvent='onclick: onClickCloseButton, onmouseenter: _onCloseButtonEnter, onmouseleave: _onCloseButtonLeave'>\r\n\t        \t<img src=\"${_blankGif}\" alt=\"\" dojoAttachPoint='closeIcon' class='closeImage' waiRole=\"presentation\"/>\r\n\t            <span dojoAttachPoint='closeText' class='closeText'>x</span>\r\n\t        </span>\r\n        </div>\r\n    </div>\r\n</div>\r\n"),

	// Override _FormWidget.scrollOnFocus.
	// Don't scroll the whole tab container into view when the button is focused.
	scrollOnFocus: false,

	postMixInProperties: function(){
		// Override blank iconClass from Button to do tab height adjustment on IE6,
		// to make sure that tabs with and w/out close icons are same height
		if(!this.iconClass){
			this.iconClass = "dijitTabButtonIcon";
		}
	},

	postCreate: function(){
		this.inherited(arguments);
		dojo.setSelectable(this.containerNode, false);

		// If a custom icon class has not been set for the
		// tab icon, set its width to one pixel. This ensures
		// that the height styling of the tab is maintained,
		// as it is based on the height of the icon.
		// TODO: I still think we can just set dijitTabButtonIcon to 1px in CSS <Bill>
		if(this.iconNode.className == "dijitTabButtonIcon"){
			dojo.style(this.iconNode, "width", "1px");
		}
	},

	startup: function(){
		this.inherited(arguments);
		var n = this.domNode;

		// Required to give IE6 a kick, as it initially hides the
		// tabs until they are focused on.
		setTimeout(function(){
			n.className = n.className;
		}, 1);
	},

	_setCloseButtonAttr: function(disp){
		this.closeButton = disp;
		dojo.toggleClass(this.innerDiv, "dijitClosable", disp);
		this.closeNode.style.display = disp ? "" : "none";
		if(disp){
			var _nlsResources = dojo.i18n.getLocalization("dijit", "common");
			if(this.closeNode){
				dojo.attr(this.closeNode,"title", _nlsResources.itemClose);
				if (dojo.isIE<8){
					// IE<8 needs title set directly on image.  Only set for IE since alt=""
					// for this node and WCAG 2.0 does not allow title when alt=""
					dojo.attr(this.closeIcon, "title", _nlsResources.itemClose);
				}
			}
			// add context menu onto title button
			var _nlsResources = dojo.i18n.getLocalization("dijit", "common");
			this._closeMenu = new dijit.Menu({
				id: this.id+"_Menu",
				targetNodeIds: [this.domNode]
			});

			this._closeMenu.addChild(new dijit.MenuItem({
				label: _nlsResources.itemClose,
				onClick: dojo.hitch(this, "onClickCloseButton")
			}));
		}else{
			if(this._closeMenu){
				this._closeMenu.destroyRecursive();
				delete this._closeMenu;
			}
		}
	},

	destroy: function(){
		if(this._closeMenu){
			this._closeMenu.destroyRecursive();
			delete this._closeMenu;
		}
		this.inherited(arguments);
	},

	_onCloseButtonEnter: function(){
		// summary:
		//		Handler when mouse is moved over the close icon (the X)
		dojo.addClass(this.closeNode, "closeButton-hover");
	},

	_onCloseButtonLeave: function(){
		// summary:
		//		Handler when mouse is moved off the close icon (the X)
		dojo.removeClass(this.closeNode, "closeButton-hover");
	}
});

}

if(!dojo._hasResource["dijit.layout.ScrollingTabController"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.ScrollingTabController"] = true;
dojo.provide("dijit.layout.ScrollingTabController");




dojo.declare("dijit.layout.ScrollingTabController",
	dijit.layout.TabController,
	{
	// summary:
	//		Set of tabs with left/right arrow keys and a menu to switch between tabs not
	//		all fitting on a single row.
	//		Works only for horizontal tabs (either above or below the content, not to the left
	//		or right).
	// tags:
	//		private

	templateString: dojo.cache("dijit.layout", "templates/ScrollingTabController.html", "<div class=\"dijitTabListContainer-${tabPosition}\" style=\"visibility:hidden\">\r\n\t<div dojoType=\"dijit.layout._ScrollingTabControllerButton\" buttonType=\"menuBtn\" buttonClass=\"tabStripMenuButton\"\r\n\t\t\ttabPosition=\"${tabPosition}\" dojoAttachPoint=\"_menuBtn\" showLabel=false>&darr;</div>\r\n\t<div dojoType=\"dijit.layout._ScrollingTabControllerButton\" buttonType=\"leftBtn\" buttonClass=\"tabStripSlideButtonLeft\"\r\n\t\t\ttabPosition=\"${tabPosition}\" dojoAttachPoint=\"_leftBtn\" dojoAttachEvent=\"onClick: doSlideLeft\" showLabel=false>&larr;</div>\r\n\t<div dojoType=\"dijit.layout._ScrollingTabControllerButton\" buttonType=\"rightBtn\" buttonClass=\"tabStripSlideButtonRight\"\r\n\t\t\ttabPosition=\"${tabPosition}\" dojoAttachPoint=\"_rightBtn\" dojoAttachEvent=\"onClick: doSlideRight\" showLabel=false>&rarr;</div>\r\n\t<div class='dijitTabListWrapper' dojoAttachPoint='tablistWrapper'>\r\n\t\t<div wairole='tablist' dojoAttachEvent='onkeypress:onkeypress'\r\n\t\t\t\tdojoAttachPoint='containerNode' class='nowrapTabStrip'>\r\n\t\t</div>\r\n\t</div>\r\n</div>\r\n"),

	// useMenu:[const] Boolean
	//		True if a menu should be used to select tabs when they are too
	//		wide to fit the TabContainer, false otherwise.
	useMenu: true,

	// useSlider: [const] Boolean
	//		True if a slider should be used to select tabs when they are too
	//		wide to fit the TabContainer, false otherwise.
	useSlider: true,

	// tabStripClass: String
	//		The css class to apply to the tab strip, if it is visible.
	tabStripClass: "",

	widgetsInTemplate: true,

	// _minScroll: Number
	//		The distance in pixels from the edge of the tab strip which,
	//		if a scroll animation is less than, forces the scroll to
	//		go all the way to the left/right.
	_minScroll: 5,

	attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
		"class": "containerNode"
	}),

	postCreate: function(){
		this.inherited(arguments);
		var n = this.domNode;

		this.scrollNode = this.tablistWrapper;
		this._initButtons();

		if(!this.tabStripClass){
			this.tabStripClass = "dijitTabContainer" +
				this.tabPosition.charAt(0).toUpperCase() +
				this.tabPosition.substr(1).replace(/-.*/, "") +
				"None";
			dojo.addClass(n, "tabStrip-disabled")
		}

		dojo.addClass(this.tablistWrapper, this.tabStripClass);
	},

	onStartup: function(){
		this.inherited(arguments);

		// Do not show the TabController until the related
		// StackController has added it's children.  This gives
		// a less visually jumpy instantiation.
		dojo.style(this.domNode, "visibility", "visible");
		this._postStartup = true;
	},

	onAddChild: function(page, insertIndex){
		this.inherited(arguments);
		var menuItem;
		if(this.useMenu){
			menuItem = new dijit.MenuItem({
				label: page.title,
				onClick: dojo.hitch(this, function(){
					this.onSelectChild(page);
				})
			});
			this._menuChildren[page.id] = menuItem;
			this._menu.addChild(menuItem, insertIndex);
		}

		// update the menuItem label when the button label is updated
		this.pane2handles[page.id].push(
			this.connect(this.pane2button[page.id], "attr", function(name, value){
				if(this._postStartup){
					if(arguments.length == 2 && name == "label"){
						if(menuItem){
							menuItem.attr(name, value);
						}
	
						// The changed label will have changed the width of the
						// buttons, so do a resize
						if(this._dim){
							this.resize(this._dim);
						}
					}
				}
			})
		);

		// Increment the width of the wrapper when a tab is added
		// This makes sure that the buttons never wrap.
		// The value 200 is chosen as it should be bigger than most
		// Tab button widths.
		dojo.style(this.containerNode, "width",
			(dojo.style(this.containerNode, "width") + 200) + "px");
	},

	onRemoveChild: function(page, insertIndex){
		// null out _selectedTab because we are about to delete that dom node
		var button = this.pane2button[page.id];
		if(this._selectedTab === button.domNode){
			this._selectedTab = null;
		}

		// delete menu entry corresponding to pane that was removed from TabContainer
		if(this.useMenu && page && page.id && this._menuChildren[page.id]){
			this._menu.removeChild(this._menuChildren[page.id]);
			this._menuChildren[page.id].destroy();
			delete this._menuChildren[page.id];
		}

		this.inherited(arguments);
	},

	_initButtons: function(){
		// summary:
		//		Creates the buttons used to scroll to view tabs that
		//		may not be visible if the TabContainer is too narrow.
		this._menuChildren = {};

		// Make a list of the buttons to display when the tab labels become
		// wider than the TabContainer, and hide the other buttons.
		// Also gets the total width of the displayed buttons.
		this._btnWidth = 0;
		this._buttons = dojo.query("> .tabStripButton", this.domNode).filter(function(btn){
			if((this.useMenu && btn == this._menuBtn.domNode) ||
				(this.useSlider && (btn == this._rightBtn.domNode || btn == this._leftBtn.domNode))){
				this._btnWidth += dojo.marginBox(btn).w;
				return true;
			}else{
				dojo.style(btn, "display", "none");
				return false;
			}
		}, this);

		if(this.useMenu){
			// Create the menu that is used to select tabs.
			this._menu = new dijit.Menu({
				id: this.id + "_menu",
				targetNodeIds: [this._menuBtn.domNode],
				leftClickToOpen: true,
				refocus: false	// selecting a menu item sets focus to a TabButton
			});
			this._supportingWidgets.push(this._menu);
		}
	},

	_getTabsWidth: function(){
		var children = this.getChildren();
		if(children.length){
			var leftTab = children[this.isLeftToRight() ? 0 : children.length - 1].domNode,
				rightTab = children[this.isLeftToRight() ? children.length - 1 : 0].domNode;
			return rightTab.offsetLeft + dojo.style(rightTab, "width") - leftTab.offsetLeft;
		}else{
			return 0;
		}
	},

	_enableBtn: function(width){
		// summary:
		//		Determines if the tabs are wider than the width of the TabContainer, and
		//		thus that we need to display left/right/menu navigation buttons.
		var tabsWidth = this._getTabsWidth();
		width = width || dojo.style(this.scrollNode, "width");
		return tabsWidth > 0 && width < tabsWidth;
	},

	resize: function(dim){
		// summary:
		//		Hides or displays the buttons used to scroll the tab list and launch the menu
		//		that selects tabs.

		if(this.domNode.offsetWidth == 0){
			return;
		}
		
		// Save the dimensions to be used when a child is renamed.
		this._dim = dim;

		// Set my height to be my natural height (tall enough for one row of tab labels),
		// and my content-box width based on margin-box width specified in dim parameter.
		// But first reset scrollNode.height in case it was set by layoutChildren() call
		// in a previous run of this method.
		this.scrollNode.style.height = "auto";
		this._contentBox = dijit.layout.marginBox2contentBox(this.domNode, {h: 0, w: dim.w});
		this._contentBox.h = this.scrollNode.offsetHeight;
		dojo.contentBox(this.domNode, this._contentBox);

		// Show/hide the left/right/menu navigation buttons depending on whether or not they
		// are needed.
		var enable = this._enableBtn(this._contentBox.w);
		this._buttons.style("display", enable ? "" : "none");

		// Position and size the navigation buttons and the tablist
		this._leftBtn.layoutAlign = "left";
		this._rightBtn.layoutAlign = "right";
		this._menuBtn.layoutAlign = this.isLeftToRight() ? "right" : "left";
		dijit.layout.layoutChildren(this.domNode, this._contentBox,
			[this._menuBtn, this._leftBtn, this._rightBtn, {domNode: this.scrollNode, layoutAlign: "client"}]);

		// set proper scroll so that selected tab is visible
		if(this._selectedTab){
			var w = this.scrollNode,
				sl = this._convertToScrollLeft(this._getScrollForSelectedTab());
			w.scrollLeft = sl;
		}

		// Enable/disabled left right buttons depending on whether or not user can scroll to left or right
		this._setButtonClass(this._getScroll());
	},

	_getScroll: function(){
		// summary:
		//		Returns the current scroll of the tabs where 0 means
		//		"scrolled all the way to the left" and some positive number, based on #
		//		of pixels of possible scroll (ex: 1000) means "scrolled all the way to the right"
		var sl = (this.isLeftToRight() || dojo.isIE < 8 || dojo.isQuirks || dojo.isWebKit) ? this.scrollNode.scrollLeft :
				dojo.style(this.containerNode, "width") - dojo.style(this.scrollNode, "width")
					 + (dojo.isIE == 8 ? -1 : 1) * this.scrollNode.scrollLeft;
		return sl;
	},

	_convertToScrollLeft: function(val){
		// summary:
		//		Given a scroll value where 0 means "scrolled all the way to the left"
		//		and some positive number, based on # of pixels of possible scroll (ex: 1000)
		//		means "scrolled all the way to the right", return value to set this.scrollNode.scrollLeft
		//		to achieve that scroll.
		//
		//		This method is to adjust for RTL funniness in various browsers and versions.
		if(this.isLeftToRight() || dojo.isIE < 8 || dojo.isQuirks || dojo.isWebKit){
			return val;
		}else{
			var maxScroll = dojo.style(this.containerNode, "width") - dojo.style(this.scrollNode, "width");
			return (dojo.isIE == 8 ? -1 : 1) * (val - maxScroll);
		}
	},

	onSelectChild: function(/*dijit._Widget*/ page){
		// summary:
		//		Smoothly scrolls to a tab when it is selected.

		var tab = this.pane2button[page.id];
		if(!tab || !page){return;}

		var node = tab.domNode;
		if(node != this._selectedTab){
			this._selectedTab = node;

			var sl = this._getScroll();

			if(sl > node.offsetLeft ||
					sl + dojo.style(this.scrollNode, "width") <
					node.offsetLeft + dojo.style(node, "width")){
				this.createSmoothScroll().play();
			}
		}

		this.inherited(arguments);
	},

	_getScrollBounds: function(){
		// summary:
		//		Returns the minimum and maximum scroll setting to show the leftmost and rightmost
		//		tabs (respectively)
		var children = this.getChildren(),
			scrollNodeWidth = dojo.style(this.scrollNode, "width"),		// about 500px
			containerWidth = dojo.style(this.containerNode, "width"),	// 50,000px
			maxPossibleScroll = containerWidth - scrollNodeWidth,	// scrolling until right edge of containerNode visible
			tabsWidth = this._getTabsWidth();

		if(children.length && tabsWidth > scrollNodeWidth){
			// Scrolling should happen
			return {
				min: this.isLeftToRight() ? 0 : children[children.length-1].domNode.offsetLeft,
				max: this.isLeftToRight() ?
					(children[children.length-1].domNode.offsetLeft + dojo.style(children[children.length-1].domNode, "width")) - scrollNodeWidth :
					maxPossibleScroll
			};
		}else{
			// No scrolling needed, all tabs visible, we stay either scrolled to far left or far right (depending on dir)
			var onlyScrollPosition = this.isLeftToRight() ? 0 : maxPossibleScroll;
			return {
				min: onlyScrollPosition,
				max: onlyScrollPosition
			};
		}
	},

	_getScrollForSelectedTab: function(){
		// summary:
		//		Returns the scroll value setting so that the selected tab
		//		will appear in the center
		var w = this.scrollNode,
			n = this._selectedTab,
			scrollNodeWidth = dojo.style(this.scrollNode, "width"),
			scrollBounds = this._getScrollBounds();

		// TODO: scroll minimal amount (to either right or left) so that
		// selected tab is fully visible, and just return if it's already visible?
		var pos = (n.offsetLeft + dojo.style(n, "width")/2) - scrollNodeWidth/2;
		pos = Math.min(Math.max(pos, scrollBounds.min), scrollBounds.max);

		// TODO:
		// If scrolling close to the left side or right side, scroll
		// all the way to the left or right.  See this._minScroll.
		// (But need to make sure that doesn't scroll the tab out of view...)
		return pos;
	},

	createSmoothScroll : function(x){
		// summary:
		//		Creates a dojo._Animation object that smoothly scrolls the tab list
		//		either to a fixed horizontal pixel value, or to the selected tab.
		// description:
		//		If an number argument is passed to the function, that horizontal
		//		pixel position is scrolled to.  Otherwise the currently selected
		//		tab is scrolled to.
		// x: Integer?
		//		An optional pixel value to scroll to, indicating distance from left.

		// Calculate position to scroll to
		if(arguments.length > 0){
			// position specified by caller, just make sure it's within bounds
			var scrollBounds = this._getScrollBounds();
			x = Math.min(Math.max(x, scrollBounds.min), scrollBounds.max);
		}else{
			// scroll to center the current tab
			x = this._getScrollForSelectedTab();
		}

		if(this._anim && this._anim.status() == "playing"){
			this._anim.stop();
		}

		var self = this,
			w = this.scrollNode,
			anim = new dojo._Animation({
				beforeBegin: function(){
					if(this.curve){ delete this.curve; }
					var oldS = w.scrollLeft,
						newS = self._convertToScrollLeft(x);
					anim.curve = new dojo._Line(oldS, newS);
				},
				onAnimate: function(val){
					w.scrollLeft = val;
				}
			});
		this._anim = anim;

		// Disable/enable left/right buttons according to new scroll position
		this._setButtonClass(x);

		return anim; // dojo._Animation
	},

	_getBtnNode: function(e){
		// summary:
		//		Gets a button DOM node from a mouse click event.
		// e:
		//		The mouse click event.
		var n = e.target;
		while(n && !dojo.hasClass(n, "tabStripButton")){
			n = n.parentNode;
		}
		return n;
	},

	doSlideRight: function(e){
		// summary:
		//		Scrolls the menu to the right.
		// e:
		//		The mouse click event.
		this.doSlide(1, this._getBtnNode(e));
	},

	doSlideLeft: function(e){
		// summary:
		//		Scrolls the menu to the left.
		// e:
		//		The mouse click event.
		this.doSlide(-1,this._getBtnNode(e));
	},

	doSlide: function(direction, node){
		// summary:
		//		Scrolls the tab list to the left or right by 75% of the widget width.
		// direction:
		//		If the direction is 1, the widget scrolls to the right, if it is
		//		-1, it scrolls to the left.

		if(node && dojo.hasClass(node, "dijitTabBtnDisabled")){return;}

		var sWidth = dojo.style(this.scrollNode, "width");
		var d = (sWidth * 0.75) * direction;

		var to = this._getScroll() + d;

		this._setButtonClass(to);

		this.createSmoothScroll(to).play();
	},

	_setButtonClass: function(scroll){
		// summary:
		//		Adds or removes a class to the left and right scroll buttons
		//		to indicate whether each one is enabled/disabled.
		// description:
		//		If the tabs are scrolled all the way to the left, the class
		//		'dijitTabBtnDisabled' is added to the left button.
		//		If the tabs are scrolled all the way to the right, the class
		//		'dijitTabBtnDisabled' is added to the right button.
		// scroll: Integer
		//		amount of horizontal scroll

		var cls = "dijitTabBtnDisabled",
			scrollBounds = this._getScrollBounds();
		dojo.toggleClass(this._leftBtn.domNode, cls, scroll <= scrollBounds.min);
		dojo.toggleClass(this._rightBtn.domNode, cls, scroll >= scrollBounds.max);
	}
});

dojo.declare("dijit.layout._ScrollingTabControllerButton",
	dijit.form.Button,
	{
		baseClass: "dijitTab",

		buttonType: "",

		buttonClass: "",

		tabPosition: "top",

		templateString: dojo.cache("dijit.layout", "templates/_ScrollingTabControllerButton.html", "<div id=\"${id}-${buttonType}\" class=\"tabStripButton dijitTab ${buttonClass} tabStripButton-${tabPosition}\"\r\n\t\tdojoAttachEvent=\"onclick:_onButtonClick,onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse\">\r\n\t<div role=\"presentation\" wairole=\"presentation\" class=\"dijitTabInnerDiv\" dojoattachpoint=\"innerDiv,focusNode\">\r\n\t\t<div role=\"presentation\" wairole=\"presentation\" class=\"dijitTabContent dijitButtonContents\" dojoattachpoint=\"tabContent\">\r\n\t\t\t<img src=\"${_blankGif}\"/>\r\n\t\t\t<span dojoAttachPoint=\"containerNode,titleNode\" class=\"dijitButtonText\"></span>\r\n\t\t</div>\r\n\t</div>\r\n</div>\r\n"),

		// Override inherited tabIndex: 0 from dijit.form.Button, because user shouldn't be
		// able to tab to the left/right/menu buttons
		tabIndex: ""
	}
);

}

if(!dojo._hasResource["dijit.layout.TabContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.TabContainer"] = true;
dojo.provide("dijit.layout.TabContainer");





dojo.declare("dijit.layout.TabContainer",
	dijit.layout._TabContainerBase,
	{
		// summary:
		//		A Container with tabs to select each child (only one of which is displayed at a time).
		// description:
		//		A TabContainer is a container that has multiple panes, but shows only
		//		one pane at a time.  There are a set of tabs corresponding to each pane,
		//		where each tab has the name (aka title) of the pane, and optionally a close button.

		// useMenu: [const] Boolean
		//		True if a menu should be used to select tabs when they are too
		//		wide to fit the TabContainer, false otherwise.
		useMenu: true,

		// useSlider: [const] Boolean
		//		True if a slider should be used to select tabs when they are too
		//		wide to fit the TabContainer, false otherwise.
		useSlider: true,

		// controllerWidget: String
		//		An optional parameter to override the widget used to display the tab labels
		controllerWidget: "",

		_makeController: function(/*DomNode*/ srcNode){
			// summary:
			//		Instantiate tablist controller widget and return reference to it.
			//		Callback from _TabContainerBase.postCreate().
			// tags:
			//		protected extension

			var cls = this.baseClass + "-tabs" + (this.doLayout ? "" : " dijitTabNoLayout"),
				TabController = dojo.getObject(this.controllerWidget);

			return new TabController({
				id: this.id + "_tablist",
				tabPosition: this.tabPosition,
				doLayout: this.doLayout,
				containerId: this.id,
				"class": cls,
				nested: this.nested,
				useMenu: this.useMenu,
				useSlider: this.useSlider,
				tabStripClass: this.tabStrip ? this.baseClass + (this.tabStrip ? "":"No") + "Strip": null
			}, srcNode);
		},

		postMixInProperties: function(){
			this.inherited(arguments);

			// Scrolling controller only works for horizontal non-nested tabs
			if(!this.controllerWidget){
				this.controllerWidget = (this.tabPosition == "top" || this.tabPosition == "bottom") && !this.nested ?
							"dijit.layout.ScrollingTabController" : "dijit.layout.TabController";
			}
		}
});


}

if(!dojo._hasResource["dojo.fx.Toggler"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.fx.Toggler"] = true;
dojo.provide("dojo.fx.Toggler");

dojo.declare("dojo.fx.Toggler", null, {
	// summary:
	//		A simple `dojo.Animation` toggler API.
	//
	// description:
	//		class constructor for an animation toggler. It accepts a packed
	//		set of arguments about what type of animation to use in each
	//		direction, duration, etc. All available members are mixed into 
	//		these animations from the constructor (for example, `node`, 
	//		`showDuration`, `hideDuration`). 
	//
	// example:
	//	|	var t = new dojo.fx.Toggler({
	//	|		node: "nodeId",
	//	|		showDuration: 500,
	//	|		// hideDuration will default to "200"
	//	|		showFunc: dojo.fx.wipeIn, 
	//	|		// hideFunc will default to "fadeOut"
	//	|	});
	//	|	t.show(100); // delay showing for 100ms
	//	|	// ...time passes...
	//	|	t.hide();

	// node: DomNode
	//		the node to target for the showing and hiding animations
	node: null,

	// showFunc: Function
	//		The function that returns the `dojo.Animation` to show the node
	showFunc: dojo.fadeIn,

	// hideFunc: Function	
	//		The function that returns the `dojo.Animation` to hide the node
	hideFunc: dojo.fadeOut,

	// showDuration:
	//		Time in milliseconds to run the show Animation
	showDuration: 200,

	// hideDuration:
	//		Time in milliseconds to run the hide Animation
	hideDuration: 200,

	// FIXME: need a policy for where the toggler should "be" the next
	// time show/hide are called if we're stopped somewhere in the
	// middle.
	// FIXME: also would be nice to specify individual showArgs/hideArgs mixed into
	// each animation individually. 
	// FIXME: also would be nice to have events from the animations exposed/bridged

	/*=====
	_showArgs: null,
	_showAnim: null,

	_hideArgs: null,
	_hideAnim: null,

	_isShowing: false,
	_isHiding: false,
	=====*/

	constructor: function(args){
		var _t = this;

		dojo.mixin(_t, args);
		_t.node = args.node;
		_t._showArgs = dojo.mixin({}, args);
		_t._showArgs.node = _t.node;
		_t._showArgs.duration = _t.showDuration;
		_t.showAnim = _t.showFunc(_t._showArgs);

		_t._hideArgs = dojo.mixin({}, args);
		_t._hideArgs.node = _t.node;
		_t._hideArgs.duration = _t.hideDuration;
		_t.hideAnim = _t.hideFunc(_t._hideArgs);

		dojo.connect(_t.showAnim, "beforeBegin", dojo.hitch(_t.hideAnim, "stop", true));
		dojo.connect(_t.hideAnim, "beforeBegin", dojo.hitch(_t.showAnim, "stop", true));
	},

	show: function(delay){
		// summary: Toggle the node to showing
		// delay: Integer?
		//		Ammount of time to stall playing the show animation
		return this.showAnim.play(delay || 0);
	},

	hide: function(delay){
		// summary: Toggle the node to hidden
		// delay: Integer?
		//		Ammount of time to stall playing the hide animation
		return this.hideAnim.play(delay || 0);
	}
});

}

if(!dojo._hasResource["dojo.fx"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.fx"] = true;
dojo.provide("dojo.fx");
 // FIXME: remove this back-compat require in 2.0 
/*=====
dojo.fx = {
	// summary: Effects library on top of Base animations
};
=====*/
(function(){
	
	var d = dojo, 
		_baseObj = {
			_fire: function(evt, args){
				if(this[evt]){
					this[evt].apply(this, args||[]);
				}
				return this;
			}
		};

	var _chain = function(animations){
		this._index = -1;
		this._animations = animations||[];
		this._current = this._onAnimateCtx = this._onEndCtx = null;

		this.duration = 0;
		d.forEach(this._animations, function(a){
			this.duration += a.duration;
			if(a.delay){ this.duration += a.delay; }
		}, this);
	};
	d.extend(_chain, {
		_onAnimate: function(){
			this._fire("onAnimate", arguments);
		},
		_onEnd: function(){
			d.disconnect(this._onAnimateCtx);
			d.disconnect(this._onEndCtx);
			this._onAnimateCtx = this._onEndCtx = null;
			if(this._index + 1 == this._animations.length){
				this._fire("onEnd");
			}else{
				// switch animations
				this._current = this._animations[++this._index];
				this._onAnimateCtx = d.connect(this._current, "onAnimate", this, "_onAnimate");
				this._onEndCtx = d.connect(this._current, "onEnd", this, "_onEnd");
				this._current.play(0, true);
			}
		},
		play: function(/*int?*/ delay, /*Boolean?*/ gotoStart){
			if(!this._current){ this._current = this._animations[this._index = 0]; }
			if(!gotoStart && this._current.status() == "playing"){ return this; }
			var beforeBegin = d.connect(this._current, "beforeBegin", this, function(){
					this._fire("beforeBegin");
				}),
				onBegin = d.connect(this._current, "onBegin", this, function(arg){
					this._fire("onBegin", arguments);
				}),
				onPlay = d.connect(this._current, "onPlay", this, function(arg){
					this._fire("onPlay", arguments);
					d.disconnect(beforeBegin);
					d.disconnect(onBegin);
					d.disconnect(onPlay);
				});
			if(this._onAnimateCtx){
				d.disconnect(this._onAnimateCtx);
			}
			this._onAnimateCtx = d.connect(this._current, "onAnimate", this, "_onAnimate");
			if(this._onEndCtx){
				d.disconnect(this._onEndCtx);
			}
			this._onEndCtx = d.connect(this._current, "onEnd", this, "_onEnd");
			this._current.play.apply(this._current, arguments);
			return this;
		},
		pause: function(){
			if(this._current){
				var e = d.connect(this._current, "onPause", this, function(arg){
						this._fire("onPause", arguments);
						d.disconnect(e);
					});
				this._current.pause();
			}
			return this;
		},
		gotoPercent: function(/*Decimal*/percent, /*Boolean?*/ andPlay){
			this.pause();
			var offset = this.duration * percent;
			this._current = null;
			d.some(this._animations, function(a){
				if(a.duration <= offset){
					this._current = a;
					return true;
				}
				offset -= a.duration;
				return false;
			});
			if(this._current){
				this._current.gotoPercent(offset / this._current.duration, andPlay);
			}
			return this;
		},
		stop: function(/*boolean?*/ gotoEnd){
			if(this._current){
				if(gotoEnd){
					for(; this._index + 1 < this._animations.length; ++this._index){
						this._animations[this._index].stop(true);
					}
					this._current = this._animations[this._index];
				}
				var e = d.connect(this._current, "onStop", this, function(arg){
						this._fire("onStop", arguments);
						d.disconnect(e);
					});
				this._current.stop();
			}
			return this;
		},
		status: function(){
			return this._current ? this._current.status() : "stopped";
		},
		destroy: function(){
			if(this._onAnimateCtx){ d.disconnect(this._onAnimateCtx); }
			if(this._onEndCtx){ d.disconnect(this._onEndCtx); }
		}
	});
	d.extend(_chain, _baseObj);

	dojo.fx.chain = function(/*dojo.Animation[]*/ animations){
		// summary: 
		//		Chain a list of `dojo.Animation`s to run in sequence
		//
		// description:
		//		Return a `dojo.Animation` which will play all passed
		//		`dojo.Animation` instances in sequence, firing its own
		//		synthesized events simulating a single animation. (eg:
		//		onEnd of this animation means the end of the chain, 
		//		not the individual animations within)
		//
		// example:
		//	Once `node` is faded out, fade in `otherNode`
		//	|	dojo.fx.chain([
		//	|		dojo.fadeIn({ node:node }),
		//	|		dojo.fadeOut({ node:otherNode })
		//	|	]).play();
		//
		return new _chain(animations) // dojo.Animation
	};

	var _combine = function(animations){
		this._animations = animations||[];
		this._connects = [];
		this._finished = 0;

		this.duration = 0;
		d.forEach(animations, function(a){
			var duration = a.duration;
			if(a.delay){ duration += a.delay; }
			if(this.duration < duration){ this.duration = duration; }
			this._connects.push(d.connect(a, "onEnd", this, "_onEnd"));
		}, this);
		
		this._pseudoAnimation = new d.Animation({curve: [0, 1], duration: this.duration});
		var self = this;
		d.forEach(["beforeBegin", "onBegin", "onPlay", "onAnimate", "onPause", "onStop", "onEnd"], 
			function(evt){
				self._connects.push(d.connect(self._pseudoAnimation, evt,
					function(){ self._fire(evt, arguments); }
				));
			}
		);
	};
	d.extend(_combine, {
		_doAction: function(action, args){
			d.forEach(this._animations, function(a){
				a[action].apply(a, args);
			});
			return this;
		},
		_onEnd: function(){
			if(++this._finished > this._animations.length){
				this._fire("onEnd");
			}
		},
		_call: function(action, args){
			var t = this._pseudoAnimation;
			t[action].apply(t, args);
		},
		play: function(/*int?*/ delay, /*Boolean?*/ gotoStart){
			this._finished = 0;
			this._doAction("play", arguments);
			this._call("play", arguments);
			return this;
		},
		pause: function(){
			this._doAction("pause", arguments);
			this._call("pause", arguments);
			return this;
		},
		gotoPercent: function(/*Decimal*/percent, /*Boolean?*/ andPlay){
			var ms = this.duration * percent;
			d.forEach(this._animations, function(a){
				a.gotoPercent(a.duration < ms ? 1 : (ms / a.duration), andPlay);
			});
			this._call("gotoPercent", arguments);
			return this;
		},
		stop: function(/*boolean?*/ gotoEnd){
			this._doAction("stop", arguments);
			this._call("stop", arguments);
			return this;
		},
		status: function(){
			return this._pseudoAnimation.status();
		},
		destroy: function(){
			d.forEach(this._connects, dojo.disconnect);
		}
	});
	d.extend(_combine, _baseObj);

	dojo.fx.combine = function(/*dojo.Animation[]*/ animations){
		// summary: 
		//		Combine a list of `dojo.Animation`s to run in parallel
		//
		// description:
		//		Combine an array of `dojo.Animation`s to run in parallel, 
		//		providing a new `dojo.Animation` instance encompasing each
		//		animation, firing standard animation events.
		//
		// example:
		//	Fade out `node` while fading in `otherNode` simultaneously
		//	|	dojo.fx.combine([
		//	|		dojo.fadeIn({ node:node }),
		//	|		dojo.fadeOut({ node:otherNode })
		//	|	]).play();
		//
		// example:
		//	When the longest animation ends, execute a function:
		//	|	var anim = dojo.fx.combine([
		//	|		dojo.fadeIn({ node: n, duration:700 }),
		//	|		dojo.fadeOut({ node: otherNode, duration: 300 })
		//	|	]);
		//	|	dojo.connect(anim, "onEnd", function(){
		//	|		// overall animation is done.
		//	|	});
		//	|	anim.play(); // play the animation
		//
		return new _combine(animations); // dojo.Animation
	};

	dojo.fx.wipeIn = function(/*Object*/ args){
		// summary:
		//		Expand a node to it's natural height.
		//
		// description:
		//		Returns an animation that will expand the
		//		node defined in 'args' object from it's current height to
		//		it's natural height (with no scrollbar).
		//		Node must have no margin/border/padding.
		//
		// args: Object
		//		A hash-map of standard `dojo.Animation` constructor properties
		//		(such as easing: node: duration: and so on)
		//
		// example:
		//	|	dojo.fx.wipeIn({
		//	|		node:"someId"
		//	|	}).play()
		var node = args.node = d.byId(args.node), s = node.style, o;

		var anim = d.animateProperty(d.mixin({
			properties: {
				height: {
					// wrapped in functions so we wait till the last second to query (in case value has changed)
					start: function(){
						// start at current [computed] height, but use 1px rather than 0
						// because 0 causes IE to display the whole panel
						o = s.overflow;
						s.overflow = "hidden";
						if(s.visibility == "hidden" || s.display == "none"){
							s.height = "1px";
							s.display = "";
							s.visibility = "";
							return 1;
						}else{
							var height = d.style(node, "height");
							return Math.max(height, 1);
						}
					},
					end: function(){
						return node.scrollHeight;
					}
				}
			}
		}, args));

		d.connect(anim, "onEnd", function(){ 
			s.height = "auto";
			s.overflow = o;
		});

		return anim; // dojo.Animation
	}

	dojo.fx.wipeOut = function(/*Object*/ args){
		// summary:
		//		Shrink a node to nothing and hide it. 
		//
		// description:
		//		Returns an animation that will shrink node defined in "args"
		//		from it's current height to 1px, and then hide it.
		//
		// args: Object
		//		A hash-map of standard `dojo.Animation` constructor properties
		//		(such as easing: node: duration: and so on)
		// 
		// example:
		//	|	dojo.fx.wipeOut({ node:"someId" }).play()
		
		var node = args.node = d.byId(args.node), s = node.style, o;
		
		var anim = d.animateProperty(d.mixin({
			properties: {
				height: {
					end: 1 // 0 causes IE to display the whole panel
				}
			}
		}, args));

		d.connect(anim, "beforeBegin", function(){
			o = s.overflow;
			s.overflow = "hidden";
			s.display = "";
		});
		d.connect(anim, "onEnd", function(){
			s.overflow = o;
			s.height = "auto";
			s.display = "none";
		});

		return anim; // dojo.Animation
	}

	dojo.fx.slideTo = function(/*Object*/ args){
		// summary:
		//		Slide a node to a new top/left position
		//
		// description:
		//		Returns an animation that will slide "node" 
		//		defined in args Object from its current position to
		//		the position defined by (args.left, args.top).
		//
		// args: Object
		//		A hash-map of standard `dojo.Animation` constructor properties
		//		(such as easing: node: duration: and so on). Special args members
		//		are `top` and `left`, which indicate the new position to slide to.
		//
		// example:
		//	|	dojo.fx.slideTo({ node: node, left:"40", top:"50", units:"px" }).play()

		var node = args.node = d.byId(args.node), 
			top = null, left = null;

		var init = (function(n){
			return function(){
				var cs = d.getComputedStyle(n);
				var pos = cs.position;
				top = (pos == 'absolute' ? n.offsetTop : parseInt(cs.top) || 0);
				left = (pos == 'absolute' ? n.offsetLeft : parseInt(cs.left) || 0);
				if(pos != 'absolute' && pos != 'relative'){
					var ret = d.position(n, true);
					top = ret.y;
					left = ret.x;
					n.style.position="absolute";
					n.style.top=top+"px";
					n.style.left=left+"px";
				}
			};
		})(node);
		init();

		var anim = d.animateProperty(d.mixin({
			properties: {
				top: args.top || 0,
				left: args.left || 0
			}
		}, args));
		d.connect(anim, "beforeBegin", anim, init);

		return anim; // dojo.Animation
	}

})();

}

if(!dojo._hasResource["dojo.date"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.date"] = true;
dojo.provide("dojo.date");

/*=====
dojo.date = {
	// summary: Date manipulation utilities
}
=====*/

dojo.date.getDaysInMonth = function(/*Date*/dateObject){
	//	summary:
	//		Returns the number of days in the month used by dateObject
	var month = dateObject.getMonth();
	var days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
	if(month == 1 && dojo.date.isLeapYear(dateObject)){ return 29; } // Number
	return days[month]; // Number
}

dojo.date.isLeapYear = function(/*Date*/dateObject){
	//	summary:
	//		Determines if the year of the dateObject is a leap year
	//	description:
	//		Leap years are years with an additional day YYYY-02-29, where the
	//		year number is a multiple of four with the following exception: If
	//		a year is a multiple of 100, then it is only a leap year if it is
	//		also a multiple of 400. For example, 1900 was not a leap year, but
	//		2000 is one.

	var year = dateObject.getFullYear();
	return !(year%400) || (!(year%4) && !!(year%100)); // Boolean
}

// FIXME: This is not localized
dojo.date.getTimezoneName = function(/*Date*/dateObject){
	//	summary:
	//		Get the user's time zone as provided by the browser
	// dateObject:
	//		Needed because the timezone may vary with time (daylight savings)
	//	description:
	//		Try to get time zone info from toString or toLocaleString method of
	//		the Date object -- UTC offset is not a time zone.  See
	//		http://www.twinsun.com/tz/tz-link.htm Note: results may be
	//		inconsistent across browsers.

	var str = dateObject.toString(); // Start looking in toString
	var tz = ''; // The result -- return empty string if nothing found
	var match;

	// First look for something in parentheses -- fast lookup, no regex
	var pos = str.indexOf('(');
	if(pos > -1){
		tz = str.substring(++pos, str.indexOf(')'));
	}else{
		// If at first you don't succeed ...
		// If IE knows about the TZ, it appears before the year
		// Capital letters or slash before a 4-digit year 
		// at the end of string
		var pat = /([A-Z\/]+) \d{4}$/;
		if((match = str.match(pat))){
			tz = match[1];
		}else{
		// Some browsers (e.g. Safari) glue the TZ on the end
		// of toLocaleString instead of putting it in toString
			str = dateObject.toLocaleString();
			// Capital letters or slash -- end of string, 
			// after space
			pat = / ([A-Z\/]+)$/;
			if((match = str.match(pat))){
				tz = match[1];
			}
		}
	}

	// Make sure it doesn't somehow end up return AM or PM
	return (tz == 'AM' || tz == 'PM') ? '' : tz; // String
}

// Utility methods to do arithmetic calculations with Dates

dojo.date.compare = function(/*Date*/date1, /*Date?*/date2, /*String?*/portion){
	//	summary:
	//		Compare two date objects by date, time, or both.
	//	description:
	//  	Returns 0 if equal, positive if a > b, else negative.
	//	date1:
	//		Date object
	//	date2:
	//		Date object.  If not specified, the current Date is used.
	//	portion:
	//		A string indicating the "date" or "time" portion of a Date object.
	//		Compares both "date" and "time" by default.  One of the following:
	//		"date", "time", "datetime"

	// Extra step required in copy for IE - see #3112
	date1 = new Date(+date1);
	date2 = new Date(+(date2 || new Date()));

	if(portion == "date"){
		// Ignore times and compare dates.
		date1.setHours(0, 0, 0, 0);
		date2.setHours(0, 0, 0, 0);
	}else if(portion == "time"){
		// Ignore dates and compare times.
		date1.setFullYear(0, 0, 0);
		date2.setFullYear(0, 0, 0);
	}
	
	if(date1 > date2){ return 1; } // int
	if(date1 < date2){ return -1; } // int
	return 0; // int
};

dojo.date.add = function(/*Date*/date, /*String*/interval, /*int*/amount){
	//	summary:
	//		Add to a Date in intervals of different size, from milliseconds to years
	//	date: Date
	//		Date object to start with
	//	interval:
	//		A string representing the interval.  One of the following:
	//			"year", "month", "day", "hour", "minute", "second",
	//			"millisecond", "quarter", "week", "weekday"
	//	amount:
	//		How much to add to the date.

	var sum = new Date(+date); // convert to Number before copying to accomodate IE (#3112)
	var fixOvershoot = false;
	var property = "Date";

	switch(interval){
		case "day":
			break;
		case "weekday":
			//i18n FIXME: assumes Saturday/Sunday weekend, but this is not always true.  see dojo.cldr.supplemental

			// Divide the increment time span into weekspans plus leftover days
			// e.g., 8 days is one 5-day weekspan / and two leftover days
			// Can't have zero leftover days, so numbers divisible by 5 get
			// a days value of 5, and the remaining days make up the number of weeks
			var days, weeks;
			var mod = amount % 5;
			if(!mod){
				days = (amount > 0) ? 5 : -5;
				weeks = (amount > 0) ? ((amount-5)/5) : ((amount+5)/5);
			}else{
				days = mod;
				weeks = parseInt(amount/5);
			}
			// Get weekday value for orig date param
			var strt = date.getDay();
			// Orig date is Sat / positive incrementer
			// Jump over Sun
			var adj = 0;
			if(strt == 6 && amount > 0){
				adj = 1;
			}else if(strt == 0 && amount < 0){
			// Orig date is Sun / negative incrementer
			// Jump back over Sat
				adj = -1;
			}
			// Get weekday val for the new date
			var trgt = strt + days;
			// New date is on Sat or Sun
			if(trgt == 0 || trgt == 6){
				adj = (amount > 0) ? 2 : -2;
			}
			// Increment by number of weeks plus leftover days plus
			// weekend adjustments
			amount = (7 * weeks) + days + adj;
			break;
		case "year":
			property = "FullYear";
			// Keep increment/decrement from 2/29 out of March
			fixOvershoot = true;
			break;
		case "week":
			amount *= 7;
			break;
		case "quarter":
			// Naive quarter is just three months
			amount *= 3;
			// fallthrough...
		case "month":
			// Reset to last day of month if you overshoot
			fixOvershoot = true;
			property = "Month";
			break;
//		case "hour":
//		case "minute":
//		case "second":
//		case "millisecond":
		default:
			property = "UTC"+interval.charAt(0).toUpperCase() + interval.substring(1) + "s";
	}

	if(property){
		sum["set"+property](sum["get"+property]()+amount);
	}

	if(fixOvershoot && (sum.getDate() < date.getDate())){
		sum.setDate(0);
	}

	return sum; // Date
};

dojo.date.difference = function(/*Date*/date1, /*Date?*/date2, /*String?*/interval){
	//	summary:
	//		Get the difference in a specific unit of time (e.g., number of
	//		months, weeks, days, etc.) between two dates, rounded to the
	//		nearest integer.
	//	date1:
	//		Date object
	//	date2:
	//		Date object.  If not specified, the current Date is used.
	//	interval:
	//		A string representing the interval.  One of the following:
	//			"year", "month", "day", "hour", "minute", "second",
	//			"millisecond", "quarter", "week", "weekday"
	//		Defaults to "day".

	date2 = date2 || new Date();
	interval = interval || "day";
	var yearDiff = date2.getFullYear() - date1.getFullYear();
	var delta = 1; // Integer return value

	switch(interval){
		case "quarter":
			var m1 = date1.getMonth();
			var m2 = date2.getMonth();
			// Figure out which quarter the months are in
			var q1 = Math.floor(m1/3) + 1;
			var q2 = Math.floor(m2/3) + 1;
			// Add quarters for any year difference between the dates
			q2 += (yearDiff * 4);
			delta = q2 - q1;
			break;
		case "weekday":
			var days = Math.round(dojo.date.difference(date1, date2, "day"));
			var weeks = parseInt(dojo.date.difference(date1, date2, "week"));
			var mod = days % 7;

			// Even number of weeks
			if(mod == 0){
				days = weeks*5;
			}else{
				// Weeks plus spare change (< 7 days)
				var adj = 0;
				var aDay = date1.getDay();
				var bDay = date2.getDay();

				weeks = parseInt(days/7);
				mod = days % 7;
				// Mark the date advanced by the number of
				// round weeks (may be zero)
				var dtMark = new Date(date1);
				dtMark.setDate(dtMark.getDate()+(weeks*7));
				var dayMark = dtMark.getDay();

				// Spare change days -- 6 or less
				if(days > 0){
					switch(true){
						// Range starts on Sat
						case aDay == 6:
							adj = -1;
							break;
						// Range starts on Sun
						case aDay == 0:
							adj = 0;
							break;
						// Range ends on Sat
						case bDay == 6:
							adj = -1;
							break;
						// Range ends on Sun
						case bDay == 0:
							adj = -2;
							break;
						// Range contains weekend
						case (dayMark + mod) > 5:
							adj = -2;
					}
				}else if(days < 0){
					switch(true){
						// Range starts on Sat
						case aDay == 6:
							adj = 0;
							break;
						// Range starts on Sun
						case aDay == 0:
							adj = 1;
							break;
						// Range ends on Sat
						case bDay == 6:
							adj = 2;
							break;
						// Range ends on Sun
						case bDay == 0:
							adj = 1;
							break;
						// Range contains weekend
						case (dayMark + mod) < 0:
							adj = 2;
					}
				}
				days += adj;
				days -= (weeks*2);
			}
			delta = days;
			break;
		case "year":
			delta = yearDiff;
			break;
		case "month":
			delta = (date2.getMonth() - date1.getMonth()) + (yearDiff * 12);
			break;
		case "week":
			// Truncate instead of rounding
			// Don't use Math.floor -- value may be negative
			delta = parseInt(dojo.date.difference(date1, date2, "day")/7);
			break;
		case "day":
			delta /= 24;
			// fallthrough
		case "hour":
			delta /= 60;
			// fallthrough
		case "minute":
			delta /= 60;
			// fallthrough
		case "second":
			delta /= 1000;
			// fallthrough
		case "millisecond":
			delta *= date2.getTime() - date1.getTime();
	}

	// Round for fractional values and DST leaps
	return Math.round(delta); // Number (integer)
};

}

if(!dojo._hasResource["dojox.collections._base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.collections._base"] = true;
dojo.provide("dojox.collections._base");

dojox.collections.DictionaryEntry=function(/* string */k, /* object */v){
	//	summary
	//	return an object of type dojox.collections.DictionaryEntry
	this.key=k;
	this.value=v;
	this.valueOf=function(){ 
		return this.value; 	//	object
	};
	this.toString=function(){ 
		return String(this.value);	//	string 
	};
}

/*	Iterators
 *	The collections.Iterators (Iterator and DictionaryIterator) are built to
 *	work with the Collections included in this module.  However, they *can*
 *	be used with arrays and objects, respectively, should one choose to do so.
 */
dojox.collections.Iterator=function(/* array */arr){
	//	summary
	//	return an object of type dojox.collections.Iterator
	var a=arr;
	var position=0;
	this.element=a[position]||null;
	this.atEnd=function(){
		//	summary
		//	Test to see if the internal cursor has reached the end of the internal collection.
		return (position>=a.length);	//	bool
	};
	this.get=function(){
		//	summary
		//	Get the next member in the collection.
		if(this.atEnd()){
			return null;		//	object
		}
		this.element=a[position++];
		return this.element;	//	object
	};
	this.map=function(/* function */fn, /* object? */scope){
		//	summary
		//	Functional iteration with optional scope.
		return dojo.map(a, fn, scope);
	};
	this.reset=function(){
		//	summary
		//	reset the internal cursor.
		position=0;
		this.element=a[position];
	};
}

/*	Notes:
 *	The DictionaryIterator no longer supports a key and value property;
 *	the reality is that you can use this to iterate over a JS object
 *	being used as a hashtable.
 */
dojox.collections.DictionaryIterator=function(/* object */obj){
	//	summary
	//	return an object of type dojox.collections.DictionaryIterator
	var a=[];	//	Create an indexing array
	var testObject={};
	for(var p in obj){
		if(!testObject[p]){
			a.push(obj[p]);	//	fill it up
		}
	}
	var position=0;
	this.element=a[position]||null;
	this.atEnd=function(){
		//	summary
		//	Test to see if the internal cursor has reached the end of the internal collection.
		return (position>=a.length);	//	bool
	};
	this.get=function(){
		//	summary
		//	Get the next member in the collection.
		if(this.atEnd()){
			return null;		//	object
		}
		this.element=a[position++];
		return this.element;	//	object
	};
	this.map=function(/* function */fn, /* object? */scope){
		//	summary
		//	Functional iteration with optional scope.
		return dojo.map(a, fn, scope);
	};
	this.reset=function() { 
		//	summary
		//	reset the internal cursor.
		position=0; 
		this.element=a[position];
	};
};

}

if(!dojo._hasResource["dojox.collections.Dictionary"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.collections.Dictionary"] = true;
dojo.provide("dojox.collections.Dictionary");


dojox.collections.Dictionary=function(/* dojox.collections.Dictionary? */dictionary){
	//	summary
	//	Returns an object of type dojox.collections.Dictionary
	var items={};
	this.count=0;

	//	comparator for property addition and access.
	var testObject={};

	this.add=function(/* string */k, /* object */v){
		//	summary
		//	Add a new item to the Dictionary.
		var b=(k in items);
		items[k]=new dojox.collections.DictionaryEntry(k,v);
		if(!b){
			this.count++;
		}
	};
	this.clear=function(){
		//	summary
		//	Clears the internal dictionary.
		items={};
		this.count=0;
	};
	this.clone=function(){
		//	summary
		//	Returns a new instance of dojox.collections.Dictionary; note the the dictionary is a clone but items might not be.
		return new dojox.collections.Dictionary(this);	//	dojox.collections.Dictionary
	};
	this.contains=this.containsKey=function(/* string */k){
		//	summary
		//	Check to see if the dictionary has an entry at key "k".
		if(testObject[k]){
			return false;			// bool
		}
		return (items[k]!=null);	//	bool
	};
	this.containsValue=function(/* object */v){
		//	summary
		//	Check to see if the dictionary has an entry with value "v".
		var e=this.getIterator();
		while(e.get()){
			if(e.element.value==v){
				return true;	//	bool
			}
		}
		return false;	//	bool
	};
	this.entry=function(/* string */k){
		//	summary
		//	Accessor method; similar to dojox.collections.Dictionary.item but returns the actual Entry object.
		return items[k];	//	dojox.collections.DictionaryEntry
	};
	this.forEach=function(/* function */ fn, /* object? */ scope){
		//	summary
		//	functional iterator, following the mozilla spec.
		var a=[];	//	Create an indexing array
		for(var p in items) {
			if(!testObject[p]){
				a.push(items[p]);	//	fill it up
			}
		}
		dojo.forEach(a, fn, scope);
	};
	this.getKeyList=function(){
		//	summary
		//	Returns an array of the keys in the dictionary.
		return (this.getIterator()).map(function(entry){ 
			return entry.key; 
		});	//	array
	};
	this.getValueList=function(){
		//	summary
		//	Returns an array of the values in the dictionary.
		return (this.getIterator()).map(function(entry){ 
			return entry.value; 
		});	//	array
	};
	this.item=function(/* string */k){
		//	summary
		//	Accessor method.
		if(k in items){
			return items[k].valueOf();	//	object
		}
		return undefined;	//	object
	};
	this.getIterator=function(){
		//	summary
		//	Gets a dojox.collections.DictionaryIterator for iteration purposes.
		return new dojox.collections.DictionaryIterator(items);	//	dojox.collections.DictionaryIterator
	};
	this.remove=function(/* string */k){
		//	summary
		//	Removes the item at k from the internal collection.
		if(k in items && !testObject[k]){
			delete items[k];
			this.count--;
			return true;	//	bool
		}
		return false;	//	bool
	};

	if (dictionary){
		var e=dictionary.getIterator();
		while(e.get()) {
			 this.add(e.element.key, e.element.value);
		}
	}
};

}

if(!dojo._hasResource["xwt.widget.CommonUtilities"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.CommonUtilities"] = true;
/*******************************************************************   
 *        Copyright (c) 2009-2011 Cisco Systems, Inc.       
 *        All rights reserved.     
 * @fileoverview 
 * The Common Utilities  
 * 
 * @author Harjeet Singh harjeesi@cisco.com
 *
 ********************************************************************/
dojo.provide("xwt.widget.CommonUtilities");





//dojo.require("xwt.widget.dictionary");


// Common JS utilities go here.


	 
xwt.version= function(){
   
    var build_date=" 20110509-1117  ".replace(/^\s+|\s+$/g,"");
    var build_version =" 1.6.4 ".replace(/^\s+|\s+$/g,"");
    var build_number =" 84  ".replace(/^\s+|\s+$/g,"");
   
    if(build_version.search("Revision") !=-1) return null; 
    var d = new Date(build_date.substring(0,4), parseInt(build_date.substring(4, 6)) - 1, build_date.substring(6, 8), build_date.substring(9, 11), build_date.substring(11, 13));
    return {'Build_Version': build_version, 'Build_Date': d,'Build_number':build_number};
}();

	 
xwt.CommonUtilities = new function(){

	this.regExIPAddress = "";	
	
	this._dateFormat = "yyyy-MMM-dd, HH:mm:ss.nnn ZZZ";
	//_MONTH_NAMES : Array
	// Constant values of months
	this._MONTH_NAMES = new Array("January","February","March","April","May","June","July","August","September","October","November","December","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec");
	this._zone = new Object();
	this._zone["0"] = "GMT"; //	Greenwich Mean Time
	this._zone["1"] = "ECT"; // European Central Time
	this._zone["2"] = "EET"; //	Eastern European Time
	this._zone["3"] = "EAT"; // Eastern African Time
	this._zone["3.5"] = "MET"; // Middle East Time
	this._zone["4"] = "NET"; // Near East Time
	this._zone["5"] = "PLT"; // Pakistan Lahore Time
	this._zone["5.5"] = "IST"; // India Standard Time
	this._zone["6"] = "BST"; // Bangladesh Standard Time
	this._zone["7"] = "VST"; // Vietnam Standard Time
	this._zone["8"] = "CTT"; // China Taiwan Time
	this._zone["9"] = "JST"; // Japan Standard Time
	this._zone["9.5"] = "ACT"; // Australia Central Time
	this._zone["10"] = "AET"; // Australia Eastern Time
	this._zone["11"] = "SST"; // Solomon Standard Time
	this._zone["12"] = "NST"; // New Zealand Standard Time
	this._zone["-11"] = "MIT"; // Midway Islands Time
	this._zone["-10"] = "HST"; // Hawaii Standard Time
	this._zone["-9"] = "AST"; // Alaska Standard Time
	this._zone["-8"] = "PST"; // Pacific Standard Time
	this._zone["-7"] = "PNT"; // Phoenix Standard Time
	this._zone["-6"] = "CST"; // Central Standard Time
	this._zone["-5"] = "EST"; // Eastern Standard Time
	this._zone["-4"] = "PRT"; // Puerto Rico and US Virgin Islands Time
	this._zone["-3"] = "AGT"; // Argentina Standard Time
	this._zone["-1"] = "CAT"; // Central African Time
	
	this.getMouseCoordinates = function(e){
		// summary: returns the mouse coordinates in a reliable way.
		// e : browser event.
		// return: {x: xcoords, y: ycoords}
		var result = null;
		var xcoord, ycoord;
		if( !e ) { return; }
		if( typeof( e.pageX ) == 'number' ) {
			xcoord = e.pageX;
		    ycoord = e.pageY;
		} else if( typeof( e.clientX ) == 'number' ) {
		    xcoord = e.clientX;
		    ycoord = e.clientY;
		    if( document.body && ( document.body.scrollLeft || document.body.scrollTop ) ) {
		      xcoord += document.body.scrollLeft;
		      ycoord += document.body.scrollTop;
		    } else if( document.documentElement && ( document.documentElement.scrollLeft || document.documentElement.scrollTop ) ) {
		      xcoord += document.documentElement.scrollLeft;
		      ycoord += document.documentElement.scrollTop;
		    }
		} else { return; }
		
		result = {x: xcoord, y:ycoord};
		//console.log('Mouse coordinates are ('+xcoord+','+ycoord+')');

		return result;
	};

	this.getMouseCoordinatesOldBrowsers = function(e){
		
		// summary: returns the mouse coordinates in a reliable way for old browsers like IE4/IE5
		// e : browser event.
		// return: {x: xcoords, y: ycoords}
		var result = null;
		var xcoord, ycoord;
		if( !e ) {
			return;
		}
		if( typeof( e.pageX ) == 'number' ) {
			//most browsers
			xcoord = e.pageX;
			ycoord = e.pageY;
		} else if( typeof( e.clientX ) == 'number' ) {
			//Internet Explorer and older browsers
			//other browsers provide this, but follow the pageX/Y branch
			xcoord = e.clientX;
			ycoord = e.clientY;
			var badOldBrowser = ( window.navigator.userAgent.indexOf( 'Opera' ) + 1 ) || ( window.ScriptEngine && ScriptEngine().indexOf( 'InScript' ) + 1 ) || ( navigator.vendor == 'KDE' );
			if( !badOldBrowser ) {
				if( document.body && ( document.body.scrollLeft || document.body.scrollTop ) ) {
					//IE 4, 5 & 6 (in non-standards compliant mode)
					xcoord += document.body.scrollLeft;
					ycoord += document.body.scrollTop;
				} else if( document.documentElement && ( document.documentElement.scrollLeft || document.documentElement.scrollTop ) ) {
					//IE 6 (in standards compliant mode)
					xcoord += document.documentElement.scrollLeft;
					ycoord += document.documentElement.scrollTop;
				}
			}
		} else {
			//total failure, we have no way of obtaining the mouse coordinates
			return;
		}
		result = {x: xcoord, y:ycoord};
		console.log('Mouse coordinates are ('+xcoord+','+ycoord+')');
		return result;
	};


	this.openUrl = function(/*String*/ url, /*String*/ target, /*String Tokens*/ features){
		
		// summary : opens a given url in a given target with supplied features.
		// features are: (must be supplied like "status=1,toolbar=1" etc.)
		// status  	The status bar at the bottom of the window.
		// toolbar 	The standard browser toolbar, with buttons such as Back and Forward.
		// location 	The Location entry field where you enter the URL.
		// menubar 	The menu bar of the window
		// directories 	The standard browser directory buttons, such as What's New and What's Cool
		// resizable 	Allow/Disallow the user to resize the window.
		// scrollbars 	Enable the scrollbars if the document is bigger than the window
		// height 		Specifies the height of the window in pixels. (example: height='350')
		// width 		Specifies the width of the window in pixels.
		
		if(url && target){
			if(features){
				window.open(url, target, features);
			} else {
				window.open(url, target);
			}
		}
	};
	
	
	this.getScrollBarInfo = function(/*domeNode*/ node){
		
		// summary : gets the width of the scrollbar if present on a node.
		// checks the domnode for width of its scrollbar, if no node is supplied will add a node
		// get the width and then delete the same. If node is given with h and v corresponding sroll flags will be checke dand returned.
		// node : dom node to check
		// return : Object  { hasVScrollBar : t-f, hasHScrollBar : t-f }
		
		var sBarWidth = 0;
		var inner = null;
		var wScroll = 0;
		var wNoScroll = 0;
		var hasVScrollBar;
		var hasHScrollBar;
		
		if(node){
			//add logic here to figure out if we have a scrollbar.
			
			var style = dojo.style(node, "overflow");
			
			if (style == "hidden") {
				hasVScrollBar = false;
				hasHScrollBar = false;
			} else if (style == "scroll") {
				hasVScrollBar = true;
				hasHScrollBar = true;
			} else {
				hasVScrollBar = (node.scrollHeight > node.clientHeight);
				hasHScrollBar = (node.scrollWidth > node.clientWidth);
			}
			
			var result = {
				hasVScrollBar : hasVScrollBar,
				hasHScrollBar : hasHScrollBar
			};
			
			return result;
			
			
		} else {
			
			if (dojo.isIE) {

			} else {

			}
			var nodeL = document.createElement("DIV");
			dojo.style(nodeL, {
				position : "absolute",
				top : "-1000px",
				left : "-1000px",
				overflow : "hidden",
				height : "100px",
				width : "100px"
			});
			inner = document.createElement("DIV");
			dojo.style(inner, {
				height : "200px",
				width : "200px"
			});
			nodeL.appendChild(inner);
			dojo.body().appendChild(nodeL);
			//wNoScroll = inner.offsetWidth;
			dojo.style(nodeL, {
				overflow : "auto"
			});
			//wScroll = inner.offsetWidth;
			//sBarWidth = (wNoScroll - wScroll);
			sBarWidth = nodeL.offsetWidth - nodeL.clientWidth;
			
			dojo.destroy(nodeL);
			
			return sBarWidth;
		}
		
		
		
	};
	
	this.getFormattedTimeDate = function(/*Date*/ _date, /*boolean*/ _hasSeconds, /*boolean*/ _hasMilliseconds){
		// summary:
		//
		//
		//return Formatted Date / time string. see http://sjc-filer20b-web/wg-n/nmtg-ue/Published/nmtg_ux_standards/v1/data_format.html
			
		// summary:
		//		return the formatted date string
		// Description:
		// 		This method will return the formatted date string specified in the constructor.
		if(typeof _date == "string")
			_date = new Date(_date);
		
		if(!_hasSeconds)
			_hasMilliseconds = false;
			
		var format = "";
		/*if (!_hasMilliseconds && !_hasSeconds){
			format = this._dateFormat.replace(":ss.nnn","");				
			}
		else if(!_hasMilliseconds && _hasSeconds){
			format = this._dateFormat.replace(".nnn","");				
			}
		else if(!_hasSeconds && _hasMilliseconds){
			format = this._dateFormat.replace(":ss","");
			}
		else{
			format = this._dateFormat+"";
		}*/
		if (!_hasSeconds){
			format = this._dateFormat.replace(":ss.nnn","");				
			}
		else if(!_hasMilliseconds){
			format = this._dateFormat.replace(".nnn","");				
			}
		else{
			format = this._dateFormat+"";
		}
		var result = "";
		var i_format = 0;
		var c = "";
		var token="";
		var y=_date.getFullYear()+"";
		var M=_date.getMonth()+1;
		var d=_date.getDate();
		var E=_date.getDay();
		var H=_date.getHours();
		var m=_date.getMinutes();
		var s=_date.getSeconds();
		var n =_date.getMilliseconds();
		var z =-_date.getTimezoneOffset()/60;
		
		z  = ""+z;
		var yyyy,yy,MMM,MM,dd,hh,h,mm,ss,ampm,HH,KK,K,kk,k;
		var nnn,nn;
		// Convert real date parts into formatted versions
		var value=new Object();
		
		if (y.length < 4) {
			y=""+(y-0+1900);
		}
		value["y"]=""+y;
		
		value["yyyy"]=y;
		
		value["yy"]=y.substring(2,4);
		
		value["M"]=M;
		
		value["MM"]=this._getZeroPrefixedNo(M);
		
		value["MMM"]=this._MONTH_NAMES[M+11];
		
		value["d"]=d;
		
		value["dd"]=this._getZeroPrefixedNo(d);
		
		value["H"]=H;
		value["HH"]=this._getZeroPrefixedNo(H);
		if (H==0){
			value["h"]=12;
		}
		else if (H>12){
			value["h"]=H-12;
		}
		else {
			value["h"]=H;
		}
		value["hh"] = this._getZeroPrefixedNo(value["h"]);
		
		if (H > 11) { 
			value["a"]="PM"; 
		}
		else {
			value["a"]="AM"; 
		}
		value["m"]=m;
		
		value["mm"]=this._getZeroPrefixedNo(m);
		
		value["s"]=this._getZeroPrefixedNo(s);
		
		value["ss"]=this._getZeroPrefixedNo(s);
		
		value["n"]=this._formatMilliSecs(n);
		value["nn"]=this._formatMilliSecs(n);;
		value["nnn"]=this._formatMilliSecs(n);
		
		value["Z"] =  this._zone[z];
		value["ZZ"] =  this._zone[z];
		value["ZZZ"] =  this._zone[z];				
		
		
		while (i_format < format.length) {
			c=format.charAt(i_format);
			token="";
			while ((format.charAt(i_format)==c) && (i_format < format.length)) {
				token += format.charAt(i_format++);
				}
			if (value[token] != null) {
				result=result + value[token]; 
				}
			else {
				result=result + token; 
				}
			}
		return result;
				
	};  
	 
	this._getZeroPrefixedNo = function(x) {
			// summary:
			//		returns zero prefixed number if x is less than 10
			// Description:
			// 		This method will return zero prefixed number if x is less than 10
			return(x<0||x>9?"":"0")+x;
			
	};
	
	this._formatMilliSecs = function(milliseconds){
		// summary:
		//		returns zero prefixed number if x is less than 10
		// Description:
		// 		This method will return zero prefixed number if x is less than 10
		
		return ( (milliseconds < 10 ? "00" : ((milliseconds > 9 && milliseconds < 100)?"0":""))+milliseconds);  
		
		
	};
	
	
	this.stringToBoolean = function(/*string*/ string){
		// summary converts a string to a boolean. "true", "yes", 1 are returned as true, "false", "no" and 0 are false
        switch(string.toLowerCase()){
                case "true": case "yes": case "1": return true;
                case "false": case "no": case "0": case null: return false;
                default: return Boolean(string);
        }
	};	

	this.jsonToWidget = function(json, dictionary){
	//Summary:
	//Instantiate object using json
	/*
		var widgets = [];
	    if(!dictionary){
	    	dictionary= new dojox.collections.Dictionary();
	    	//console.log("create dictionary");
	    }
		for (var i = 0; i< json.objects.length ; i++ ){
			var obj = json.objects[i];
			try{
				if (!obj.type){
					throw("[type] atrribute is not specified in " + obj + " at index " + i + " " + dojo.toJson(obj));
				}
				var aWidgetName =null;
				if (dictionary.containsKey(obj.type)){
					//console.log("key in dictionary");
					aWidgetName = dictionary.item(obj.type);
				}else{
					//console.log("key NOT in dictionary");
					dojo.require(obj.type);		        
			      	// Don't parse till the module				
			        aWidgetName = dojo.getObject(obj.type);
			        dictionary.add(obj.type, aWidgetName);
				}
		        // Create the widget
		        var aWidgetObj = new aWidgetName(obj.properties);
		        widgets.push(aWidgetObj);
		        if (obj.children ){
		        		var childObj = obj.children;
		        		var childrenWidgets = this.jsonToWidget(childObj, dictionary);
		        		if (eval('typeof ' + obj.childrenHandler) == 'function'){
		        			var resutlt = obj.childrenHandler(aWidgetObj, childrenWidgets);
		        		}else{
		        			console.error("Miss [childrenHandler] function in  " + obj +  " " + dojo.toJson(obj));
		        			throw("Miss [childrenHandler] function in  " + obj +  " " + dojo.toJson(obj));
		        		}
		        }
			}catch(e){
				console.error("xwt.widget.CommonUtilities.jsonToWidget() " + e );
			
			}
		}
		return widgets;
		*/
	};

}();


}

if(!dojo._hasResource["xwt.widget.layout.TitlePane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.layout.TitlePane"] = true;
/*******************************************************************   
 *        Copyright (c) 2010-2011 Cisco Systems, Inc.   
 *        All rights reserved.   
 *        
 *        @author Harjeet Singh harjeesi@cisco.com
 *        @version 0.1 
 *******************************************************************/

dojo.provide("xwt.widget.layout.TitlePane");








dojo.declare("xwt.widget.layout.TitlePane", [dojox.layout.ContentPane, dijit._Templated], {
	// summary:
		//	The Title Pane is a layout widget with a title on top that can be expanded or collapsed.
		//	Actions can be added on the left side of the Title Pane. Default actions available are: 
		//	|		Close  				Close Icon
		//	|		Edit 				Major status icon
		//	|		Collapse/Expand 	Minor status icon
		//	|		Maximize/Restore 	Stopped status icon
		//	|		Detach 				Unknown status icon
		//	|		Refresh 			Unmanaged status icon
		//	|		Help
		//
		// description:
		//		Title Pane is an accessible layout container with a title heading, actions, and a content
		//		section that slides open and closed. Title Pane is an extension to
		//		`dijit.layout.ContentPane`, which provides useful content-control aspects. For more details, see the
		//		Title Pane specification at http://sjc5-netapp03a-web/projects/nmtg-ue-svn/nmtg-ux/Published/nmtg_ux_standards/v1_5/title_panes.html.
		//	
		//	
		// warning: 
		//			Do not set a fixed or hardcoded height on the domNode of the Title Pane. Doing so will affect how the 
		//			Title Pane closes. Height should be set to auto so that it takes the height that is needed 
		//			to display the content. If you must have a fixed-height Title Pane, introduce a fixed-height DOM 
		//			node or widget inside the Title Pane.
		//
		//			Here is an example of an incorrect attempt to get a fixed-height Title Pane: 
		//		|		<div dojoType="xwt.widget.layout.TitlePane" href="foobar.html" style="height: 400px" title="Title"></div>
		//
		//			Here is an example of correct use when you need a fixed-height Title Pane:
		//		|		<div dojoType="xwt.widget.layout.TitlePane" href="foobar.html" title="Title">
		//		|			<div style="height: 400px; overflow: auto;"></div>
		//		|		</div>
		//
		//
		// example:
		// | 	// load a TitlePane from remote file:
		// |	var foo = new xwt.widget.layout.TitlePane({ href: "foobar.html", title:"Title", actions:"" });
		// |	foo.startup();
		//
		// example:
		// |	<!-- markup href example: -->
		// |	<div dojoType="xwt.widget.layout.TitlePane"
		// |  		style="margin: 0; auto; width: 500px;"
		// |		title="Some Title" 
		// |		titlePaneActions = 'titleBarActions' 
		// |		needTitleBar="true">
		// |	  		<p style="margin:0; padding: 0;">---Title Pane Content Goes Here----. 
		// |			 <p>>---Title Pane Content Goes Here----
		// |	</div>
		//
		//		The titlePaneActions JSON structure is as follows:
		//
		//	|		var titleBarActions =
		//	|		{
		//  |	  		items:[
		//  |	      	{
		//  |	          actionId:'history', 
		//  |	          label:'History',
		//  |	          handler: actionHandler,
		//  |	          iconClass: 'actionHistory'
		//  |	      	},
		//  |	      	{
		//  |	          actionId:'clone',
		//  |	          label:'Clone',
		//  |	          handler: actionHandler,
		//  |	          iconClass: 'actionClone'
		//  |	      	},
		//  |	      	{
		//  |	          actionId:'create',
		//  |	          label:'Create',
		//  |	          handler: actionHandler,
		//  |	          iconClass: 'actionCreate'
		//  |	      	}
		//  |	  	]
		//	|		};
		//		actionId - The action ID that pertains to that icon.
		//		label - The label that pertains to that icon.
		//		handler - The action handler that handles the event for that icon.
		//		iconClass - The style element for that icon.
		//
		// example:
		// |	<!-- markup with inline data -->
		// | 	<div dojoType="xwt.widget.layout.TitlePane" title="Title">
		// |		<p>I am content</p>
		// |	</div>
	
	//title: String
	// Title of the pane
	title: "",

	//open: Boolean
	//	Whether pane is opened or closed.
	open: true,

	//toggleable: Boolean
	// Whether pane can be opened or closed by clicking the title bar.
	toggleable: true,

	//tabIndex: String
	//	Tabindex setting for the title (so users can tab to the title then
	//	use space/enter to open/close the title pane)
	tabIndex: "0",

	//duration: Integer
	// Time in milliseconds to fade in/fade out
	duration: dijit.defaultDuration,

	//baseClass: [protected] String
	// The root className to be placed on this widget's domNode.
	baseClass: "xwtTitlePane",

	templateString: dojo.cache("xwt", "widget/layout/templates/TitlePane.html", "<div class=\"${baseClass}\">\r\n<div dojoAttachEvent=\"onfocus:_handleFocus, onblur:_handleFocus, onkeypress:_onTitleKey, onmouseenter:_onTitleEnter, onmouseleave:_onTitleLeave\"\r\n\tclass=\"xwtTitlePaneTitle\" dojoAttachPoint=\"titleBarNode,focusNode\">\r\n<div id=\"${id}_arrowNodeInner\" dojoAttachEvent=\"onkeypress:_onTitleKey,onclick:_onTitleClick\"  dojoAttachPoint=\"arrowNodeInner\" class=\"xwtArrowNodeInner\"></div>\r\n<div dojoAttachPoint=\"titleNode\" dojoAttachEvent=\"onkeypress:_onTitleKey,onclick:_onTitleClick\" class=\"xwtTitlePaneTextNode\"></div>\r\n<div class=\"xwtTitlePaneActions\" dojoAttachPoint=\"titlePaneActionsAP\"></div>\r\n</div>\r\n<div class=\"xwtTitlePaneContentOuter\" dojoAttachPoint=\"hideNode\"\r\n\twaiRole=\"presentation\">\r\n<div class=\"dijitReset\" dojoAttachPoint=\"wipeNode\"\r\n\twaiRole=\"presentation\">\r\n<table dojoAttachPoint=\"rcTableAP\" style=\"border-spacing: 0;border: none;width: 100%\">\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td class=\"tp_tl\"></td>\r\n\t\t\t<td class=\"tp_tm\"></td>\r\n\t\t\t<td class=\"tp_tr\"></td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td class=\"tp_ml\"></td>\r\n\t\t\t<td class=\"tp_mm\">\r\n\t\t\t<div class=\"xwtTitlePaneContentInner\" dojoAttachPoint=\"containerNode\"\r\n\t\t\t\twaiRole=\"region\" tabindex=\"-1\" id=\"${id}_pane\"><!-- dojo1.4 nested divs because wipeIn()/wipeOut() doesn't work right on node w/padding etc.  Put padding on inner div. -->\r\n\t\t\t</div>\r\n\t\t\t</td>\r\n\t\t\t<td class=\"tp_mr\"></td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td class=\"tp_bl\"></td>\r\n\t\t\t<td class=\"tp_bm\"></td>\r\n\t\t\t<td class=\"tp_br\"></td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n</div>\r\n</div>\r\n</div>\r\n"),

	// if set to false will not show the title bar area.
	// by default it is set to true.
	needTitleBar: true,
	
	titlePaneActionsArray: null,
	//titlePaneActions: JSON 
	// A JSON of Actions that pertains to all of the content 
	// in a title pane. These actions are represented as a set of right-aligned icons 
    // in the title bar of the title pane. 
	titlePaneActions : null,
	
	//for correcting extra width other then contentNode
	heightC : 47,
	//for correcting extra height other then contentNode
	widthC: 17,
	//arrowNodeInner: null,
	
	openedFirstTime: false,
	
	// true is a title pane is nested under a parent title pane, false otherwise
	isNested: false,

	// if true is nested at odd level, even otherwise.
	isNestedAtOdd : false,
	
	attributeMap: dojo.delegate(dijit.layout.ContentPane.prototype.attributeMap, {
		title: { node: "titleNode", type: "innerHTML" },
		tooltip: {node: "focusNode", type: "attribute", attribute: "title"},	// focusNode spans the entire width, titleNode doesn't
		id:""
	}),
	
	needAnimation:true,
	  
    constructor: function(args, node) {
    	//args: JSON
		//		the JSON object having input data for constructing action items.
		//node: DOM
		//		the DOM node where teh wipe in and wipe out of titlepane happens.
		//		i.e. node where title pane is hooked.
		this.titlePaneActionsArray = [];
		if (args) {
    		dojo.mixin(this, args);
    	}
		
		// WebKit and Chrome have issues with animation so we always disable it for these browsers.
		if(dojo.isWebKit || dojo.isChrome){
			this.needAnimation = false;
		}
	},

	postCreate: function(){

		if(!this.open){
			this.openedFirstTime = true;
			this.hideNode.style.display = this.wipeNode.style.display = "none";
		}
		
		this._setCss();
		dojo.setSelectable(this.titleNode, false);
		dijit.setWaiState(this.containerNode,"hidden", this.open ? "false" : "true");
		dijit.setWaiState(this.focusNode, "pressed", this.open ? "true" : "false");

		// setup open/close animations
		var hideNode = this.hideNode, wipeNode = this.wipeNode;
		var _self = this;
		this._wipeIn = dojo.fx.wipeIn({
			node: this.wipeNode,
			duration: this.duration,
			beforeBegin: function(){
				hideNode.style.display="";
			}
		});
		this.connect(this._wipeIn, 'onEnd', function(){
			_self.resize();
		});
		
		this._wipeOut = dojo.fx.wipeOut({
			node: this.wipeNode,
			duration: this.duration,
			onEnd: function(){
				hideNode.style.display="none";
			}
		});
		
		this.inherited(arguments);
	
		// hide titlebar if not needed.
		if(!this.needTitleBar){
			dojo.style(this.titleBarNode, {
				"display" : "none"
			});
		}
		// if toggleable is set to false hide it.
		if(!this.toggleable){
			dojo.style(this.arrowNodeInner, {
				"display" : "none"
			});
			dojo.style(this.titleNode, {
				"cursor" : "default"
			});
		}
		
		// Add the action to the title pane.
		if(this.titlePaneActions){
			this.addActionItems(this.titlePaneActions.items);
		}
	  
	},
	
	startup: function(){
        // summary:
        //    Widget's life-cycle method.
        this.inherited(arguments);
        
        
        /*
         * There is no meaningful way to determine if the parent is a widget of type Titlepane
         * because in the HTML markup the innermost title pane will start first and this order
         * cannot be determined for progmatic way. For now the users will have to figure out and add these 
         * flags isNested and IsNestedAtOdd manually.
         */ 
        
         // fix the odd or even level
//        this._fixOddEvenLevelFlag();
        
        // set the CSS class indicator to style odd and even level nested title panes.
	   	if(this.isNested && this.isNestedAtOdd){
	   		dojo.addClass(this.domNode,"oddLevelTitlePane");
	   	} else {
	   		dojo.addClass(this.domNode,"evenLevelTitlePane");
		}
	   	//console.log("Nested-->" + this.isNested + "Nested at Odd -->" + this.isNestedAtOdd);
	   	
	   	
	},
	
	destroy: function(){
		dojo.forEach(this.titlePaneActionsArray, function(item){
			item.destroy();
		});
		this.inherited(arguments);
	},
	
	_fixOddEvenLevelFlag : function() {
		// summary : Sets the isNested and isNestedAtOdd flags if applicable.
		var parent = this.domNode.parentNode;
		var parentWidget = (parent) ? dijit.getEnclosingWidget(parent) : null;

		// parent is a widget and type is xwt.widget.layout.TitlePane
		if(parentWidget && parentWidget.declaredClass && parentWidget.declaredClass == "xwt.widget.layout.TitlePane"){
			if(parentWidget.isNestedAtOdd){
				this.isNestedAtOdd = false;
				this.isNested = true;
			} else {
				this.isNestedAtOdd = true;
				this.isNested = true;
			}
		} else {
			this.isNested = false;
			this.isNestedAtOdd = false;
		}
		
	},
	
	addActionItems: function(/*Object*/ items){
		// summary : adds the action items to the title bar
		// items : 
		// 		An JSON object which is as follows:
		// {
	    //     actionId:'history',
	    //     label:'History',
	    //     handler: actionHandler, (handler to be invoked or href and target)
	    //     iconClass: 'actionHistory' (icon to be displayed, is a CSS class name)
	    //  }
		if(items && items.length>0){
			
			for(var i=0; i<items.length; i++){
				var item  = items[i];
				this.addActionItem(item);
			}
			
		}
		
	},
	
	addActionItem: function(/*Object*/ item){
		// summary : Adds an action item
		// item : 
		// 		An JSON object which has just single item as follows:
		// {
	    //     actionId:'history',
	    //     label:'History',
	    //     handler: actionHandler, (handler to be invoked or href and target)
	    //     iconClass: 'actionHistory' (icon to be displayed, is a CSS class name)
	    //  }
		
		var localId = (item.id)? this.id+"_"+item.id : item.id;
		var args = {
				id: localId,
				title: item.label,
				showLabel:false,
				iconClass: "titlePaneActionIcon " + item.iconClass
			};
		var actionItem = new dijit.form.Button(args);
		
		if(item.actionId){
			dojo.mixin(actionItem, {actionId: item.actionId});
		}
		if(item.href){
			args = {
				href: item.href,
				target: item.target
			};
			dojo.mixin(actionItem, args);
		} 
		
		if(item.handler){
			args = {handler: item.handler};
			dojo.mixin(actionItem, args);
		}
		this.connect(actionItem, "onClick", dojo.hitch(this, "_onActionItemClick"));
		actionItem.startup();
		
		this.titlePaneActionsAP.appendChild(actionItem.domNode);
		// add the new item to array for future reference.
		this.titlePaneActionsArray.push(actionItem);

		//console.log("Added -->" + item.actionId + item.iconClass + item.label);
		
	},
	
	_setOpenAttr: function(/* Boolean */ open){
		// summary:
		//		Hook to make attr("open", boolean) control the open/closed state of the pane.
		// open: Boolean
		//		True if you want to open the pane, false if you want to close it.
		if(this.open !== open){ this.toggle(); }
	},

	_setToggleableAttr: function(/* Boolean */ canToggle){
		// summary:
		//		Hook to make attr("canToggle", boolean) work.
		// canToggle: Boolean
		//		True to allow user to open/close pane by clicking title bar.
		this.toggleable = canToggle;
		dijit.setWaiRole(this.focusNode, canToggle ? "button" : "heading");
		dojo.attr(this.focusNode, "tabIndex", canToggle ? this.tabIndex : "-1");
		if(canToggle){
			// TODO: if canToggle is switched from true false shouldn't we remove this setting?
			dijit.setWaiState(this.focusNode, "controls", this.id+"_pane");
		}
		this._setCss();
	},

	_setContentAttr: function(content){
		// summary:
		//		Hook to make attr("content", ...) work.
		// 		Typically called when an href is loaded.  Our job is to make the animation smooth.

		if(!this.open || !this._wipeOut || this._wipeOut.status() == "playing"){
			// we are currently *closing* the pane (or the pane is closed), so just let that continue
			this.inherited(arguments);
		}else{
			if(this._wipeIn && this._wipeIn.status() == "playing"){
				this._wipeIn.stop();
			}

			// freeze container at current height so that adding new content doesn't make it jump
			dojo.marginBox(this.wipeNode, { h: dojo.marginBox(this.wipeNode).h });

			// add the new content (erasing the old content, if any)
			this.inherited(arguments);

			// call _wipeIn.play() to animate from current height to new height
			if(this._wipeIn){
				this._wipeIn.play();
			}else{
				this.hideNode.style.display = "";
			}
		}
	},

	toggle: function(){
		// summary:
		//		Switches between the opened and closed state.
		// description:
		//		Switches between the opened and closed state.
		// tags:
		//		private

		dojo.forEach([this._wipeIn, this._wipeOut], function(animation){
			if(animation && animation.status() == "playing"){
				animation.stop();
			}
		});

		var anim = this[this.open ? "_wipeOut" : "_wipeIn"];
		
		if(anim && this.needAnimation){
			anim.play();
		}else{			
			this.hideNode.style.display = this.open ? "none" : "";
			this.wipeNode.style.display = this.open ? "none" : "";
		}
		this.open =! this.open;
		dijit.setWaiState(this.containerNode, "hidden", this.open ? "false" : "true");
		dijit.setWaiState(this.focusNode, "pressed", this.open ? "true" : "false");

		// load content (if this is the first time we are opening the TitlePane
		// and content is specified as an href, or href was set when hidden)
		if(this.open){
			this._onShow();
			this.onShow();
		}else{
			this.onHide();
		}

		this._setCss();
		
		if(this.openedFirstTime){
			if(this.href){
				this.refresh();
			} else {
				//var mb = dojo.marginBox(this.containerNode);
				//var size = {w:(mb.w + this.widthC), h: (mb.h + this.heightC)};
				//this.resize(size);
			}
			this.openedFirstTime = false;
		}
		
	},
	
	onHide: function(){
		// summary:
		// callback called after titlepane is hidden/closed.
		
	},

	onShow: function(){
		// summary:
		// callback called after titlepane is shown/opened.
		
	},
	_setCss: function(){
		// summary:
		//		Set the open/close css state for the TitlePane.
		// tags:
		//		private

		var node = this.titleBarNode || this.focusNode;

		if(this._titleBarClass){
			dojo.removeClass(node, this._titleBarClass);
		}
		this._titleBarClass = "dijit" + (this.toggleable ? "" : "Fixed") + (this.open ? "Open" : "Closed");
		dojo.addClass(node, this._titleBarClass);
		
		//this.arrowNodeInner.innerHTML = this.open ? "-" : "+";
		
		if(this.open){
			if(this.arrowNodeInner){
				dojo.removeClass(this.arrowNodeInner, "closed");
			}
			
			dojo.removeClass(this.domNode, "xwtTitlePaneBorderBottom");
		} else {
			if(this.arrowNodeInner){
				dojo.addClass(this.arrowNodeInner, "closed");
			}
			dojo.addClass(this.domNode, "xwtTitlePaneBorderBottom");
		}
		
		
	},

	_onTitleKey: function(/*Event*/ e){
		// summary:
		//		Handler for when user hits a key.
		// e: Event
		//		the event that gets fired.
		// tags:
		//		private

		if(e.charOrCode == dojo.keys.ENTER || e.charOrCode == ' '){
			if(this.toggleable){
				this.toggle();
			}
			dojo.stopEvent(e);
		}else if(e.charOrCode == dojo.keys.DOWN_ARROW && this.open){
			this.containerNode.focus();
			e.preventDefault();
	 	}
	},

	_onTitleEnter: function(){
		// summary:
		//		Handler for when someone hovers over my title.
		// tags:
		//		private
		if(this.toggleable){
			dojo.addClass(this.focusNode, "xwtTitlePaneTitle-hover");
		}
	},

	_onTitleLeave: function(){
		// summary:
		//		Handler when someone stops hovering over my title.
		// tags:
		//		private
		if(this.toggleable){
			dojo.removeClass(this.focusNode, "xwtTitlePaneTitle-hover");
		}
	},

	_onTitleClick: function(){
		// summary:
		//		Handler when user clicks the title bar.
		// tags:
		//		private
		if(this.toggleable){
			this.toggle();
		}
	},

	_handleFocus: function(/*Event*/ e){
		// summary:
		//		Handle blur and focus events on title bar.
		// e: Event
		//		the event that gets fired when the handle gets focused.
		// tags:
		//		private

		dojo.toggleClass(this.focusNode, this.baseClass + "Focused", e.type == "focus");
	},

	setTitle: function(/*String*/ title){
		// summary:
		//		This method will be invoked to set the title of titlepane.
		// title:
		//		the String holding value of Title.	
		// description:
		//		This method will be invoked to set the title of titlepane.
		// tags:
		//		deprecated
		dojo.deprecated("xwt.widget.layout.TitlePane.setTitle() is deprecated.  Use attr('title', ...) instead.", "", "2.0");
		this.attr("title", title);
	},
	
	_onActionItemClick: function(evt){
		// summary: invoked when an action item is clicked.
		// evt: Event
		//		the event that gets fired when the action item is clicked.
		// item : dijit.form.Button
		var item  = dijit.byNode(evt.currentTarget);
		
		// invoke call back.
		this.onActionItemClick(evt, item);
		
		if(item.href && item.href.length>3){
        	var target = (item.target) ? item.target : "_self";
        	xwt.CommonUtilities.openUrl(item.href, target);
        }
        // Invoke the action handler.
        if (item.handler) {
            item.handler(item);
        }
		
	},
	
	onActionItemClick: function(evt, item){
		// summary: callback for listening to actions just in case.
		// evt: Event
		//		the event that gets fired when the action item is clicked.
		// item: JSON
		//		the JSON object which consists of details of action item.
		console.log("TitlePane/Dashlet clicked actionId is --> " +  item.actionId);
	}
	
//	resize: function(changeSize, resultSize){
//		// summary:
//		//		See `dijit.layout._LayoutWidget.resize` for description.
//		//		Although ContentPane doesn't extend _LayoutWidget, it does implement
//		//		the same API.
//		this.inherited(arguments);
//
//		var children = this.getChildren();
//		if(children){
//			dojo.forEach(children, function(widget){
//				var mb = dojo.marginBox(widget.domNode);
//				console.log("XXXXX --> "+ mb.h + "   " + mb.w);
//			});
//			
//			return;
//		}
//		
//		var mb = dojo.contentBox(this.domNode);
//		// make corrections for the rounded corners.
//		mb = this._adjustSize(mb);
//		dojo.marginBox(this.containerNode, mb);
//		
//		// propagate the same to children
//		dojo.forEach(this.getChildren(), function(widget){
//			if(widget.resize){
//				var wmb = dojo.marginBox(widget.domNode);
//				if(wmb.h > mb.h || wmb.w > mb.w){
//					widget.resize(mb);
//				}
//			}
//		});
//		
//	},
//	
//	_adjustSize: function(/*object*/ marginBox){
//		// summary: adjust the height to take care of rounded corners.
//		if(marginBox){
//			if("h" in marginBox){
//				marginBox.h = marginBox.h - (this.heightC);
//			}
//			if("w" in marginBox){
//				marginBox.w = marginBox.w - (this.widthC);
//			}
//
//		}
//		
//		return marginBox;
//		
//	}
});

}

if(!dojo._hasResource["xwt.widget.layout.Dashlet"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.layout.Dashlet"] = true;
/* ************************************************** */
/* Copyright (c) 2009-2011 Cisco Systems, Inc.       */
/* All rights reserved.                               */
/* ************************************************** */
dojo.provide("xwt.widget.layout.Dashlet");



dojo.declare("xwt.widget.layout.Dashlet", [xwt.widget.layout.TitlePane],{
	
	//summary :  
	//	The Dashlet is a Title Pane with drag-and-drop functionality that allows the title pane to be moved within the UI.
  	//	This provides a dashlet panel that can be placed inside a dojox.layout.GridContainer.
	//	The dashlet panel supports drag and drop of individual dashlets in the layout. 
	//description:
	//	The Dashlet is a Title Pane with drag-and-drop functionality that allows the title pane to be moved within the UI.
  	//	This provides a dashlet panel that can be placed inside a dojox.layout.GridContainer.
	//	The dashlet panel supports drag and drop of individual dashlets in the layout.
	//
	// 	Dashlet supports the following actions:
	//
	//	|	Action			ActionId (on DOM) 	flagToPass		Description
	//	|	------			---------------		----------		-----------------------------------------------------------------
	//	|	edit			edit				requireEdit		Allows user to edit the dashlet preferences in implementation.
	//	|	help			help				requireHelp		Displays a help icon.
	//	|	refresh			refresh				requireRefresh	Icon to indicate refresh capability if implemented.
	//	|	detach			detach				requireDetach	The dashlet can be cloned and detached from the dashboard.
	//	|	collapseExpand	collapseExpand		requireCollapse	The dashlet can be collapsed/expanded as needed.
	//	|	maximizeRestore	maximizeRestore		requireMaxinize	The dashlet can maximize to available space and then collapsed to regular real estate (NOT YET IMPLEMENTED)
	//  |	close			close				requireClose	The dashlet can be closed (hence removed) from the dashboard layout.
	//	|	-------			----------------	----------		-------------------------------------------------------------------
	//   
	//	These actions can be added by supplying the following arguments :
	//  
	//	To add some of the actions supported:
	//	requiredActions : ['edit','help','refresh','detach','maximizeRestore','collapseExpand','close'];
	//	
	//	To add all the supported actions:
	//	requireAllActions : true 
	//	
	//	To add each action by passing a flag, 
	//	set the appropriate flags as listed in table above as "true".
	//
	// 	After the actions are added the user can connect to a callback to see what action has been invoked.
	//	The callback is called with evt and item as arguments.	For example:
	//
	//	|	var dashlet = dijit.byId("someDashlet");
	//	|	dojo.connect(dashlet,"onActionItemClick", function(evt, item){
	//	|		if(item.actionId=="help"){
	//	|			console.log("Launch HELP");	
	//	|		}
	//	|		if(item.actionId=="detach") {
	//	|			console.log("Code to detach godes here.");
	//	|		}
	//	|	});
	//
	//
	// Bucket List:
	//	* Add i18n to dashlet actions so that labels are shown in appropriate language. (harjeesi TO be done in hardening.)
	//  * How the dashlet preferences will be saved. Design a format, etc., for this.
	//	* Maximize is not implemented.
	
	
	
	//template
	templateString: dojo.cache("xwt", "widget/layout/templates/Dashlet.html", "<div class=\"${baseClass}\">\r\n<table dojoAttachPoint=\"rcTableAP\" class=\"dashletContainerTable\">\r\n\t<tbody>\r\n\t\t<tr class=\"topRow\">\r\n\t\t\t<td class=\"tl\"></td>\r\n\t\t\t<td class=\"tm\"></td>\r\n\t\t\t<td class=\"tr\"></td>\r\n\t\t</tr>\r\n\t\t<tr class=\"middleRow\">\r\n\t\t\t<td class=\"ml\"></td>\r\n\t\t\t<td class=\"mm\">\r\n\t\t\t<div id=\"${id}_titleBarNode\" dojoAttachEvent=\"onkeypress:_onTitleKey, onfocus:_handleFocus, onblur:_handleFocus, onmouseenter:_onTitleEnter, onmouseleave:_onTitleLeave\"\r\n\t\t\t\tclass=\"xwtTitlePaneTitle xwtDashletPaneTitle\" dojoAttachPoint=\"titleBarNode,focusNode\">\r\n\t\t\t<div id=\"${id}_xwtTitlePaneTextNode\" dojoAttachPoint=\"titleNode\" class=\"xwtTitlePaneTextNode\"></div>\r\n\t\t\t<div id=\"${id}_titlePaneActionsAP\" class=\"xwtTitlePaneActions\" dojoAttachPoint=\"titlePaneActionsAP\">\r\n\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t\t<div class=\"xwtTitlePaneContentOuter\" dojoAttachPoint=\"hideNode\"\r\n\t\t\t\twaiRole=\"presentation\">\r\n\t\t\t<div class=\"dijitReset\" dojoAttachPoint=\"wipeNode\"\r\n\t\t\t\twaiRole=\"presentation\">\r\n\t\t\t<div class=\"xwtTitlePaneContentInner\" dojoAttachPoint=\"containerNode\"\r\n\t\t\t\twaiRole=\"region\" tabindex=\"-1\" id=\"${id}_pane\"><!-- dojo1.4 nested divs because wipeIn()/wipeOut() doesn't work right on node w/padding etc.  Put padding on inner div. -->\r\n\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t\t</td>\r\n\t\t\t<td class=\"mr\"></td>\r\n\t\t</tr>\r\n\t\t<tr class=\"bottomRow\">\r\n\t\t\t<td class=\"bl\"></td>\r\n\t\t\t<td class=\"bm\"></td>\r\n\t\t\t<td class=\"br\"></td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n</div>\r\n"),

	widgetsInTemplate: true,
	
	// CSS class that adds rounded corners.
	_roundedCornersClass: "xwtRoundedPanel",
	// CSS class for dashlet behavior.
	_dashletClass: "xwtDashlet",
	
	// corrections for rounded corners.
	topC: 8,
	bottomC: 8,
	leftC: 9,
	rightC: 10,
	
	// time in ms to wait before firing _updateSize.
	// we do not want to do that on every event.
	_timerForUpdateSize: 300,

	// Array of all the sandard supported actions.
	_standardActions: ['edit','help','refresh','detach','maximizeRestore','collapseExpand','close'],
	
	// default dashlet actions.
	dashletActions : {
		edit : {
			id: 'edit',
			actionId : 'edit',
			label : 'Edit',
			iconClass : 'd_titleicon_edit'
		},
		help : {
			id: 'help',
			actionId : 'help',
			label : 'Help',
			iconClass : 'd_titleicon_help'
		},
		refresh : {
			id: 'refresh',
			actionId : 'refresh',
			label : 'Refresh',
			iconClass : 'd_titleicon_refresh'
		},
		detach : {
			id: 'detach',
			actionId : 'detach',
			label : 'Detach',
			iconClass : 'd_titleicon_detach'
		},
		collapseExpand : {
			id: 'collapseExpand',
			actionId : 'collapseExpand',
			label : 'Collapse/Expand',
			iconClass : 'd_titleicon_collapse'
		},
		maximizeRestore : {
			id: 'maximizeRestore',
			actionId : 'maximizeRestore',
			label : 'Maximize/Restore',
			iconClass : 'd_titleicon_maximize'
		},
		close : {
			id: 'close',
			actionId : 'close',
			label : 'Close',
			iconClass : 'd_titleicon_close'
		}
	},
	
	// requiredActions:Object
	//	 An  array of required Actions for the title bar in a Dashlet:	
	//	['edit','refresh','collapseExpand','maximizeRestore','close','help']
	requiredActions: null,
	
	// default refresh interval in ms
	refreshIntervel: 30000,
	
	// help url for the dashlet if help is loaded from an external location.
	// TODO harjeesi UE to clarify how help may originate.
	helpUrl: '',
	
	// resizeChildren: Boolean
	//		If true, when the dashlet is resized, any child widgets
	//		with a 'resize' method have that method called.
	resizeChildren: true,
	
	// _parents: Array
	//		An array of all the StackContainer widgets that this dashlet
	//		is contained in. These are used to determine if the dashlet
	//		is visible or not.
	_parents: null,
	
	// _size: Object
	//		Cache of the previous size of the dashlet, used to determine
	//		if the size has changed and if the child widgets should be
	//		resized.
	_size: null,
	
	
	
	// requireEdit: boolean
	// Indicates if the dashlet needs to edit its preferences.
	requireEdit: false,
	
	// requireHelp: boolean
	// Indicates if the dashlet needs to display a help icon.
	requireHelp: false,
	
	// requireRefresh: boolean
	// Indicates if the dashlet needs to display a refresh icon. 
	requireRefresh: false,
	
	
	//requireDetach: boolean
	// Indicates if the dashlet can be detached from the dashboard.
	requireDetach: false,
	
	// requireCollapse: boolean
	// Indicates if the dashlet can collapse and expand.
	requireCollapse: true,
	
	// requireMaximize: boolean
	// Indicates if the dashlet can be maximized and restored.
	requireMaximize: false,
	
	// requireClose: boolean
	// Indicates if the dashlet can close.
	requireClose: false,
	
	// requireAllActions: boolean
	// If set to true, will add all the standard actions available.
	// These are [ edit, help, refresh, detach, collapseExpand, maximizeRestore, close], in this order.
	requireAllActions: false,

	// dragRestriction: Boolean
	//	Indicates if the dashlet has its drag and drop capability enabled. The default is "false".
	dragRestriction : false,
	
	// internal pointer to subscriptions.
	_subscriptions: null,
	
	buildRendering: function(){
		this.inherited(arguments);
		// Hide the dashlet until it is fully constructed.
		dojo.style(this.domNode, "visibility", "hidden");
	},
	
	postCreate: function(){
		
		this.inherited(arguments);
		
		var _this = this;
		// Add the portlet classes
		dojo.addClass(this.domNode, this._roundedCornersClass);
		dojo.addClass(this.domNode, this._dashletClass);
	

		// add the dashlet actions from user supplied list.
		if( this.requiredActions || this.requireAllActions || this.requireEdit || this.requireHelp || this.requireRefresh || this.requireDetach || this.requireCollapse || this.requireMaximize || this.requireClose){
			this._addDashletActions();
		}

		// Choose the class to add depending on if the portlet is draggable or not.
		dojo.addClass(this.domNode,  this._dashletClass + "-" + (!this.dragRestriction ? "movable" : "nonmovable"));
		
		if(this.resizeChildren){
			// If children should be resized when the dashlet size changes,
			
			// listen for items being dropped
			this.subscribe("/dnd/drop", function(){_this._updateSize();});

			// listen when the window is resized,
			this.connect(window, "onresize", function(){_this._updateSize();});

			// listen when another dashlet's size changes.
			this.subscribe("/Dashlet/sizechange", function(widget){_this.onSizeChange(widget);});

			// Subscribe to all possible child-selection events that could affect this dashtlet
			var doSelectSubscribe = dojo.hitch(this, function(id, lastId){
				var widget = dijit.byId(id);
				if(widget.selectChild){
					_this._subscriptions = this.subscribe(id + "-selectChild", function(child){
						var n = _this.domNode.parentNode;
						while(n){
							if(n == child.domNode){
								// Only fire this once, as the widget is now visible
								// at least once, so child measurements should be accurate.
								_this.unsubscribe(_this._subscriptions);
								_this._updateSize();
								break;
							}
							n = n.parentNode;
						}
					});

					// Record the StackContainer and child widget that this dashlet
					// is in, so it can figure out whether or not it is visible.
					// If it is not visible, it will not update it's size dynamically.
					var child = dijit.byId(lastId);
					if(widget && child){
						_this._parents.push({parent: widget, child: child});
					}
				}
			});
			var lastId;
			this._parents = [];

			// Find all parent widgets, and if they are StackContainers,
			// subscribe to their selectChild method calls.
			for(var p = this.domNode.parentNode; p !== null; p = p.parentNode){
				var id = p.getAttribute ? p.getAttribute("widgetId") : null;
				if(id){
					doSelectSubscribe(id, lastId);
					lastId = id;
				}
			}
			
			var xx="";
		}

		//TODO resize login will go here.
		
		//  TODO we may not need it. Prevent clicks on icons from causing a drag to start.
//		this.connect(this.titlePaneActionsAP, "onmousedown", function(evt){
//			dojo.stopevent(evt);
//			return false;
//		});
		
		// Inform all dashlets that the size of this one has changed,
		// and therefore perhaps they have too.
		this.connect(this._wipeOut, "onEnd", dojo.hitch(this, "_publish"));
		this.connect(this._wipeIn, "onEnd", dojo.hitch(this,"_publish"));
		
	},
	
	
	startup: function(){
		//summary: 
		//	Life-cycle method. Starts up the widget.
		if(this._started){return;}
		
		this._placeSettingsWidgets();
		
		this.inherited(arguments);

		// show the dashlet after it has started.
		dojo.style(this.domNode, "visibility", "visible");
		
	},
	
	_placeSettingsWidgets: function(){
		// summary: 
		//		Checks all the children to see if they are instances
		//		of xwt.widget.layout.DashletSettings. If they are, 
		//		creates an icon for them in the title bar which, when clicked,
		//		calls their toggle() method.

		//var children = this.getChildren();
		var children = dijit.findWidgets(this.hideNode);
		var dashletSettings = null;
		dojo.forEach(children, function(child){
			if(dojo.hasClass(child.domNode, "xwtDashletSettingsContainer")) {
				dashletSettings = child;
				console.log("Found xwtDashletSettingsContainer -->" + child.id);
			}
		});
		if(dashletSettings){
			// found an instance of xwt.widget.layout.DashletSettings
			// TODO try #child instanceof "xwt.widget.layout.DashletSettings"# instead more reliable.
			var _this = this;
			this.connect(this, "onActionItemClick", function(evt, item){
				if(item && item.actionId=="edit"){
					console.log("xwt.widget.layout.dashlet --> Show/Hide DashletSettings!");
					dojo.hitch(dashletSettings, "toggle");
				}
			});
			dojo.place(dashletSettings.domNode, this.containerNode, "before");
			dashletSettings.attr("portlet", this);
		}

	},
	
	_addDashletActions : function() {
		// summary : 
		//	Add the dashlet's actions based on what is requested by the user
		// 	by setting requiredAction array (such as: ['edit','refresh','collapseExpand','maximizeRestore','close','help']).
	
		if(this.requireAllActions){
			for ( var i = 0; i < this._standardActions.length; i++) {
				var action = this._standardActions[i];
				if(this.dashletActions[action]){
					this.addDashletAction(this.dashletActions[action]);
				}
			}
			
		} else if(this.requiredActions && this.requiredActions.length>0){
			for ( var j = 0; j < this.requiredActions.length; j++) {
				var action = this.requiredActions[j];
				if(this.dashletActions[action]){
					this.addDashletAction(this.dashletActions[action]);
				}
			}
		} else {
			if(this.requireEdit){
				this.addDashletAction(this.dashletActions["edit"]);
			}
			if(this.requireHelp){
				this.addDashletAction(this.dashletActions["help"]);
			}
			if(this.requireRefresh){
				this.addDashletAction(this.dashletActions["refresh"]);
			}
			if(this.requireDetach){
				this.addDashletAction(this.dashletActions["detach"]);
			}
			if(this.requireMaximize){
				this.addDashletAction(this.dashletActions["maximizeRestore"]);
			}
			if(this.requireCollapse){
				this.addDashletAction(this.dashletActions["collapseExpand"]);
			}
			if(this.requireClose){
				this.addDashletAction(this.dashletActions["close"]);
			}
		}

	},
	
	addDashletAction: function(/*Object*/ item){
		//summary : 
		//	Adds an action to the dashlet
		//item : Object
		//	A JSON object that specifies the dashlet action item. For example:
		//
		// 	{
	    //     actionId:'history',
	    //     label:'History',
	    //     handler: actionHandler, (handler to be invoked or href and target)
	    //     iconClass: 'actionHistory' (icon to be displayed, is a CSS class name)
	    //  }
		
		var localId = (item.id)? this.id+"_"+item.id : item.id;
		var args = {
				id: localId,
				title: item.label,
				showLabel:false,
				iconClass: "titlePaneActionIcon " + item.iconClass
			};
		var actionItem = new dijit.form.Button(args);
		
		if(item.actionId){
			dojo.mixin(actionItem, {actionId: item.actionId});
		}
		if(item.href){
			var args = {
				href: item.href,
				target: item.target
			};
			dojo.mixin(actionItem, args);
		} 
		
		if(item.handler){
			var args = {handler: item.handler};
			dojo.mixin(actionItem, args);
		}


		this.connect(actionItem, "onClick", dojo.hitch(this, "_onActionItemClick"));
		
		if(item.actionId && item.actionId=='collapseExpand'){
			this.arrowNodeInner = actionItem;
			this.connect(actionItem, "onClick", dojo.hitch(this, "_onTitleClick"));
			this.connect(this, "onActionItemClick", dojo.hitch(this, "_handleToggleStyle"));
		}

		this.titlePaneActionsArray.push(actionItem);

		actionItem.startup();
		
//		if(item.actionId == 'close'){
//			dojo.place(actionItem.domNode, this.arrowNodeInner, "after");
//		} else {
//			dojo.place(actionItem.domNode, this.arrowNodeInner, "before");
//		}
		
		this.titlePaneActionsAP.appendChild(actionItem.domNode);
		// add the new item to array for future reference.

		//console.log("Added -->" + item.actionId + item.iconClass + item.label);
		
	},

	_handleToggleStyle: function(evt, item){
		if(item && item.actionId=='collapseExpand') {
			var toggled = false;
			if(this.open){
				toggled = false;
				dojo.addClass(this.domNode, "xwtDashletCollapsed");
			} else {
				toggled = true;
				dojo.removeClass(this.domNode, "xwtDashletCollapsed");

			}
			item.attr("iconClass", toggled ? "titlePaneActionIcon d_titleicon_collapse" : "titlePaneActionIcon d_titleicon_expand");
		}
		//console.log("DO TOGGLE STYLES" + item.actionId);
	},
	
	_publish: function(){
		//summary: 
		//	Publishes an event that all other dashlets listen to.
		//	This causes them to update their child widgets if their
		//	size has changed.
		console.log("Published.");
		dojo.publish("/Dashlet/sizechange",[this]);
	},
	
	addChild: function(child){
		// summary: 
		//	Adds a child widget to the dashlet.
		this._size = null;
		this.inherited(arguments);
		
		if(this._started){
			this._placeSettingsWidgets(); //TODO check if we need to call this.
			this._updateSize();
		}
		if(this._started && !child.started && !child._started){
			child.startup();
		}
	},
	
	onSizeChange: function(widget){
		// summary:
		//		Updates the dashlet size if any other dashlet
		//		changes its size.
		if(widget == this){
			return;
		}
		this._updateSize();
	},
	
	_updateSize: function(){
		// summary: 
		//		Updates the size of all child widgets.
		if(!this.open || !this._started || !this.resizeChildren){
			return;
		}
		
		if(this._timer){
			clearTimeout(this._timer);
		}
		// Delay applying the size change in case the size 
		// changes very frequently, for performance reasons.
		this._timer = setTimeout(dojo.hitch(this, function(){

			if(!this.domNode){
				console.log("Error::xwt.widget.layout.Dashlet._updateSize() -- The domNode is null as it has been destroyed for dashlet -- " + this.id);
				return;
			}
			//TODO harjeesi use dojo.marginBox here
			var size = {
				w: dojo.style(this.domNode, "width"),
				h: dojo.style(this.domNode, "height")
			};
	
			// If the Dashlet is in a StackWidget, and it is not
			// visible, do not update the size, as it could
			// make child widgets miscalculate.
			for(var i = 0; i < this._parents.length; i++){
				var p = this._parents[i];
				var sel = p.parent.selectedChildWidget;
				if(sel && sel != p.child){
					return;
				}
			}
	
			if(this._size){
				// If the size of the dashlet hasn't changed, don't
				// resize the children, as this can be expensive

				//TODO harjeesi use dojo.marginBox here
				if(this._size.w == size.w && this._size.h == size.h){
					return;
				}
			}
			
			this._size = size;
	
			// check if each child of children has a resize or layout , if so invoke those.

			var callBacks = ["resize", "layout"]; // call backs intrested in.
			this._timer = null;
			
			var children = this.getChildren();

			dojo.forEach(children, function(child){
				for(var i = 0; i < callBacks.length; i++){
					if(dojo.isFunction(child[callBacks[i]])){
						try{
							child[callBacks[i]]();
						} catch(e){
							console.log("Error::xwt.widget.layout.Dashlet._updateSize (failed calling child["+ callBacks[i] +"]) -->" + e);
						}
						break;
					} 
				}
			});	
			
			//invoke the callback.
			this.onUpdateSize();
			
		}), this._timerForUpdateSize);
	},

	onUpdateSize: function(){
		// summary:
		//		Callback needed just in case.
	},
	_setCss: function(){
		// summary:
		//		Set the open/close CSS state for the TitlePane.
		// tags:
		//		private
		this.inherited(arguments);
		dojo.removeClass(this.domNode, "xwtTitlePaneBorderBottom");
	},
	
	
	onClose: function(){
		// summary: 
		//		Hides the dashlet. Note that it does not
		//		persist this for now (subject to change), so it is up to the client to
		//		listen to this method and persist the closed state
		//		in their own way.
		dojo.addClass(this.domNode, "hide");
	},
	
	onShow: function(){
		// summary : 
		//		Shows the dashlet.
		dojo.removeClass(this.domNode, "hide");
	},
	
	resize: function(changeSize, resultSize){
		// summary:
		//		See `dijit.layout._LayoutWidget.resize` for description.
		//		Although ContentPane doesn't extend _LayoutWidget, it does implement
		//		the same API.
		this.inherited(arguments);
		var mb = dojo.contentBox(this.domNode);
		mb.w = changeSize ? changeSize.w : mb.w;
		// make corrections for the rounded corners.
		mb = this._adjustSize(mb);
		dojo.marginBox(this.containerNode, mb);
		// propagate the same to children
		var changeSizeChild = {h: mb.h, w: mb.w};
		dojo.forEach(this.getChildren(), function(widget){
			if(widget.resize){
				widget.resize(changeSizeChild);
			}
		});
		
	},
	
	_adjustSize: function(/*object*/ marginBox){
		// summary: 
		//	Adjust the widget height to take care of rounded corners.
		if(marginBox){
			if("h" in marginBox){
				marginBox.h = marginBox.h - (this.topC + this.bottomC);
			}
			if("w" in marginBox){
				marginBox.w = marginBox.w - (this.leftC + this.rightC);
			}

		}
		
		return marginBox;
		
	},
	
	displayChildren: function(children){
		// summary: for debugging remove it later.
		dojo.forEach(children, function(widget){
			var i = 0;
			console.log( i + " widget is -->" + widget.id);
			if(widget.resize){
				console.log( i + " widget has resize");
			}
		});
	}
});



dojo.declare("xwt.widget.layout.DashletSettings", [dijit._Container, dijit.layout.ContentPane],{
	// summary: 
	//		A settings widget to be used with a dojox.widget.Portlet.
	// description: 
	//		This widget should be placed inside a dojox.widget.Portlet widget.
	//		It is used to set some preferences for that Portlet. It is essentially
	//		a ContentPane, and should contain other widgets and DOM nodes that
	//		do the real work of setting preferences for the portlet.

	postCreate: function(){
		// summary:
		//		Sets the require CSS classes on the widget.

		// Start the PortletSettings widget hidden, always.
		dojo.style(this.domNode, "display", "none");
		dojo.addClass(this.domNode, "xwtDashletSettingsContainer");

		// Remove the unwanted content pane class.
		dojo.removeClass(this.domNode, "dijitContentPane");
	},

	_setPortletAttr: function(portlet){
		// summary: 
		//		Sets the portlet that encloses this widget.
		this.portlet = portlet;
	},

	toggle: function(){
		// summary: 
		//		Toggles the visibility of this widget.
		var n = this.domNode;
		if(dojo.style(n, "display") == "none"){
			dojo.style(n,{
				"display": "block",
				"height": "1px",
				"width": "auto"
			});
			dojo.fx.wipeIn({
				node: n
			}).play();
		}else{
			dojo.fx.wipeOut({
				node: n,
				onEnd: dojo.hitch(this, function(){
					dojo.style(n,{"display": "none", "height": "", "width":""});
				}
			)}).play();
		}
	},
	
	destroy: function(){
		
	}
	
});

dojo.declare("xwt.widget.layout.DashletDialogSettings", 
	xwt.widget.layout.DashletSettings,{
	// summary: 
	//		A settings widget to be used with a xwt.widget.layout.Dashlet. It displays
	//		the contents of this widget in a dijit.Dialog box.

	// dimensions: Array
	//		The size of the dialog to display.	This defaults to [300, 300]
	dimensions: null,

	constructor: function(props, node){
		this.dimensions = props.dimensions || [300, 100];
	},

	toggle: function(){
		// summary: 
		//		Toggles the visibility of the Dialog box.
		if(!this.dialog){
			dojo["require"]("dijit.Dialog");
			this.dialog = new dijit.Dialog({title: this.title});
			
			dojo.body().appendChild(this.dialog.domNode);

			// Move this widget inside the dialog
			this.dialog.containerNode.appendChild(this.domNode);

			dojo.style(this.dialog.domNode,{
				"width" : this.dimensions[0] + "px",
				"height" : this.dimensions[1] + "px"
			});
			dojo.style(this.domNode, "display", "");
		}
		if(this.dialog.open){
			this.dialog.hide();
		}else{
			this.dialog.show(this.domNode);
		}
	}
});

}

if(!dojo._hasResource["dijit.Tooltip"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Tooltip"] = true;
dojo.provide("dijit.Tooltip");




dojo.declare(
	"dijit._MasterTooltip",
	[dijit._Widget, dijit._Templated],
	{
		// summary:
		//		Internal widget that holds the actual tooltip markup,
		//		which occurs once per page.
		//		Called by Tooltip widgets which are just containers to hold
		//		the markup
		// tags:
		//		protected

		// duration: Integer
		//		Milliseconds to fade in/fade out
		duration: dijit.defaultDuration,

		templateString: dojo.cache("dijit", "templates/Tooltip.html", "<div class=\"dijitTooltip dijitTooltipLeft\" id=\"dojoTooltip\">\r\n\t<div class=\"dijitTooltipContainer dijitTooltipContents\" dojoAttachPoint=\"containerNode\" waiRole='alert'></div>\r\n\t<div class=\"dijitTooltipConnector\"></div>\r\n</div>\r\n"),

		postCreate: function(){
			dojo.body().appendChild(this.domNode);

			this.bgIframe = new dijit.BackgroundIframe(this.domNode);

			// Setup fade-in and fade-out functions.
			this.fadeIn = dojo.fadeIn({ node: this.domNode, duration: this.duration, onEnd: dojo.hitch(this, "_onShow") });
			this.fadeOut = dojo.fadeOut({ node: this.domNode, duration: this.duration, onEnd: dojo.hitch(this, "_onHide") });

		},

		show: function(/*String*/ innerHTML, /*DomNode*/ aroundNode, /*String[]?*/ position){
			// summary:
			//		Display tooltip w/specified contents to right of specified node
			//		(To left if there's no space on the right, or if LTR==right)

			if(this.aroundNode && this.aroundNode === aroundNode){
				return;
			}

			if(this.fadeOut.status() == "playing"){
				// previous tooltip is being hidden; wait until the hide completes then show new one
				this._onDeck=arguments;
				return;
			}
			this.containerNode.innerHTML=innerHTML;

			// Firefox bug. when innerHTML changes to be shorter than previous
			// one, the node size will not be updated until it moves.
			this.domNode.style.top = (this.domNode.offsetTop + 1) + "px";

			var pos = dijit.placeOnScreenAroundElement(this.domNode, aroundNode, dijit.getPopupAroundAlignment((position && position.length) ? position : dijit.Tooltip.defaultPosition, this.isLeftToRight()), dojo.hitch(this, "orient"));

			// show it
			dojo.style(this.domNode, "opacity", 0);
			this.fadeIn.play();
			this.isShowingNow = true;
			this.aroundNode = aroundNode;
		},

		orient: function(/* DomNode */ node, /* String */ aroundCorner, /* String */ tooltipCorner){
			// summary:
			//		Private function to set CSS for tooltip node based on which position it's in.
			//		This is called by the dijit popup code.
			// tags:
			//		protected

			node.className = "dijitTooltip " +
				{
					"BL-TL": "dijitTooltipBelow dijitTooltipABLeft",
					"TL-BL": "dijitTooltipAbove dijitTooltipABLeft",
					"BR-TR": "dijitTooltipBelow dijitTooltipABRight",
					"TR-BR": "dijitTooltipAbove dijitTooltipABRight",
					"BR-BL": "dijitTooltipRight",
					"BL-BR": "dijitTooltipLeft"
				}[aroundCorner + "-" + tooltipCorner];
		},

		_onShow: function(){
			// summary:
			//		Called at end of fade-in operation
			// tags:
			//		protected
			if(dojo.isIE){
				// the arrow won't show up on a node w/an opacity filter
				this.domNode.style.filter="";
			}
		},

		hide: function(aroundNode){
			// summary:
			//		Hide the tooltip
			if(this._onDeck && this._onDeck[1] == aroundNode){
				// this hide request is for a show() that hasn't even started yet;
				// just cancel the pending show()
				this._onDeck=null;
			}else if(this.aroundNode === aroundNode){
				// this hide request is for the currently displayed tooltip
				this.fadeIn.stop();
				this.isShowingNow = false;
				this.aroundNode = null;
				this.fadeOut.play();
			}else{
				// just ignore the call, it's for a tooltip that has already been erased
			}
		},

		_onHide: function(){
			// summary:
			//		Called at end of fade-out operation
			// tags:
			//		protected

			this.domNode.style.cssText="";	// to position offscreen again
			if(this._onDeck){
				// a show request has been queued up; do it now
				this.show.apply(this, this._onDeck);
				this._onDeck=null;
			}
		}

	}
);

dijit.showTooltip = function(/*String*/ innerHTML, /*DomNode*/ aroundNode, /*String[]?*/ position){
	// summary:
	//		Display tooltip w/specified contents in specified position.
	//		See description of dijit.Tooltip.defaultPosition for details on position parameter.
	//		If position is not specified then dijit.Tooltip.defaultPosition is used.
	if(!dijit._masterTT){ dijit._masterTT = new dijit._MasterTooltip(); }
	return dijit._masterTT.show(innerHTML, aroundNode, position);
};

dijit.hideTooltip = function(aroundNode){
	// summary:
	//		Hide the tooltip
	if(!dijit._masterTT){ dijit._masterTT = new dijit._MasterTooltip(); }
	return dijit._masterTT.hide(aroundNode);
};

dojo.declare(
	"dijit.Tooltip",
	dijit._Widget,
	{
		// summary:
		//		Pops up a tooltip (a help message) when you hover over a node.

		// label: String
		//		Text to display in the tooltip.
		//		Specified as innerHTML when creating the widget from markup.
		label: "",

		// showDelay: Integer
		//		Number of milliseconds to wait after hovering over/focusing on the object, before
		//		the tooltip is displayed.
		showDelay: 400,

		// connectId: [const] String[]
		//		Id's of domNodes to attach the tooltip to.
		//		When user hovers over any of the specified dom nodes, the tooltip will appear.
		//
		//		Note: Currently connectId can only be specified on initialization, it cannot
		//		be changed via attr('connectId', ...)
		//
		//		Note: in 2.0 this will be renamed to connectIds for less confusion.
		connectId: [],

		// position: String[]
		//		See description of `dijit.Tooltip.defaultPosition` for details on position parameter.
		position: [],

		constructor: function(){
			// Map id's of nodes I'm connected to to a list of the this.connect() handles
			this._nodeConnectionsById = {};
		},

		_setConnectIdAttr: function(newIds){
			for(var oldId in this._nodeConnectionsById){
				this.removeTarget(oldId);
			}
			dojo.forEach(dojo.isArrayLike(newIds) ? newIds : [newIds], this.addTarget, this);
		},

		_getConnectIdAttr: function(){
			var ary = [];
			for(var id in this._nodeConnectionsById){
				ary.push(id);
			}
			return ary;
		},

		addTarget: function(/*DOMNODE || String*/ id){
			// summary:
			//		Attach tooltip to specified node, if it's not already connected
			var node = dojo.byId(id);
			if(!node){ return; }
			if(node.id in this._nodeConnectionsById){ return; }//Already connected

			this._nodeConnectionsById[node.id] = [
				this.connect(node, "onmouseenter", "_onTargetMouseEnter"),
				this.connect(node, "onmouseleave", "_onTargetMouseLeave"),
				this.connect(node, "onfocus", "_onTargetFocus"),
				this.connect(node, "onblur", "_onTargetBlur")
			];
			if(dojo.isIE && !node.style.zoom){//preserve zoom
				// BiDi workaround
				node.style.zoom = 1;
			}
		},

		removeTarget: function(/*DOMNODE || String*/ node){
			// summary:
			//		Detach tooltip from specified node

			// map from DOMNode back to plain id string
			var id = node.id || node;

			if(id in this._nodeConnectionsById){
				dojo.forEach(this._nodeConnectionsById[id], this.disconnect, this);
				delete this._nodeConnectionsById[id];
			}
		},

		postCreate: function(){
			dojo.addClass(this.domNode,"dijitTooltipData");
		},

		startup: function(){
			this.inherited(arguments);

			// If this tooltip was created in a template, or for some other reason the specified connectId[s]
			// didn't exist during the widget's initialization, then connect now.
			var ids = this.connectId;
			dojo.forEach(dojo.isArrayLike(ids) ? ids : [ids], this.addTarget, this);
		},

		_onTargetMouseEnter: function(/*Event*/ e){
			// summary:
			//		Handler for mouseenter event on the target node
			// tags:
			//		private
			this._onHover(e);
		},

		_onTargetMouseLeave: function(/*Event*/ e){
			// summary:
			//		Handler for mouseleave event on the target node
			// tags:
			//		private
			this._onUnHover(e);
		},

		_onTargetFocus: function(/*Event*/ e){
			// summary:
			//		Handler for focus event on the target node
			// tags:
			//		private

			this._focus = true;
			this._onHover(e);
		},

		_onTargetBlur: function(/*Event*/ e){
			// summary:
			//		Handler for blur event on the target node
			// tags:
			//		private

			this._focus = false;
			this._onUnHover(e);
		},

		_onHover: function(/*Event*/ e){
			// summary:
			//		Despite the name of this method, it actually handles both hover and focus
			//		events on the target node, setting a timer to show the tooltip.
			// tags:
			//		private
			if(!this._showTimer){
				var target = e.target;
				this._showTimer = setTimeout(dojo.hitch(this, function(){this.open(target)}), this.showDelay);
			}
		},

		_onUnHover: function(/*Event*/ e){
			// summary:
			//		Despite the name of this method, it actually handles both mouseleave and blur
			//		events on the target node, hiding the tooltip.
			// tags:
			//		private

			// keep a tooltip open if the associated element still has focus (even though the
			// mouse moved away)
			if(this._focus){ return; }

			if(this._showTimer){
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
			this.close();
		},

		open: function(/*DomNode*/ target){
 			// summary:
			//		Display the tooltip; usually not called directly.
			// tags:
			//		private

			if(this._showTimer){
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
			dijit.showTooltip(this.label || this.domNode.innerHTML, target, this.position);

			this._connectNode = target;
			this.onShow(target, this.position);
		},

		close: function(){
			// summary:
			//		Hide the tooltip or cancel timer for show of tooltip
			// tags:
			//		private

			if(this._connectNode){
				// if tooltip is currently shown
				dijit.hideTooltip(this._connectNode);
				delete this._connectNode;
				this.onHide();
			}
			if(this._showTimer){
				// if tooltip is scheduled to be shown (after a brief delay)
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
		},

		onShow: function(target, position){
			// summary:
			//		Called when the tooltip is shown
			// tags:
			//		callback
		},

		onHide: function(){
			// summary:
			//		Called when the tooltip is hidden
			// tags:
			//		callback
		},

		uninitialize: function(){
			this.close();
			this.inherited(arguments);
		}
	}
);

// dijit.Tooltip.defaultPosition: String[]
//		This variable controls the position of tooltips, if the position is not specified to
//		the Tooltip widget or *TextBox widget itself.  It's an array of strings with the following values:
//
//			* before: places tooltip to the left of the target node/widget, or to the right in
//			  the case of RTL scripts like Hebrew and Arabic
//			* after: places tooltip to the right of the target node/widget, or to the left in
//			  the case of RTL scripts like Hebrew and Arabic
//			* above: tooltip goes above target node
//			* below: tooltip goes below target node
//
//		The list is positions is tried, in order, until a position is found where the tooltip fits
//		within the viewport.
//
//		Be careful setting this parameter.  A value of "above" may work fine until the user scrolls
//		the screen so that there's no room above the target node.   Nodes with drop downs, like
//		DropDownButton or FilteringSelect, are especially problematic, in that you need to be sure
//		that the drop down and tooltip don't overlap, even when the viewport is scrolled so that there
//		is only room below (or above) the target node, but not both.
dijit.Tooltip.defaultPosition = ["after", "before"];

}

if(!dojo._hasResource["xwt.widget.layout.Breadcrumb"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.layout.Breadcrumb"] = true;
/*******************************************************************   
 *        Copyright (c) 2009-2011 Cisco Systems, Inc.   
 *        All rights reserved.   
 *        
 *   	  @author vijagraw
 * 		  @author Dennis Park denpark@cisco.com
 *        @author Mohammed Ashik Maricar mmaricar@cisco.com
 *        @version 0.3 
 *******************************************************************/
/**
 * @fileoverview 
 * xwt.widget.layout.Breadcrumb allows users to add the navigation page in the breadcrumbs.
 * For more details, see the specification at http://sjc5-netapp03a-web/projects/nmtg-ue-svn/nmtg-ux/Published/nmtg_ux_standards/v1/breadcrumb.html.
 */  
dojo.provide("xwt.widget.layout.Breadcrumb");






dojo.declare("xwt.widget.layout.Breadcrumb", [dijit._Widget, dijit._Templated],
{
	// summary:
	//		Breadcrumb is a navigation tool.
	// 
	// description:
	//		 Breadcrumbs are navigation tools that:
    //		 * Allow a user to see where the current page or object is in relation to the application's navigation hierarchy and flow.
	//		 * Provide links back to each previous page or object through which a user has navigated. 
	//
	// example:
	// Using HTML markup:
	//	|	<div
	//	|		id="breadcrumbExample"
	//	|		dojoType="xwt.widget.layout.Breadcrumb" 
	//	|		breadcrumbItems='{items:[{label:'Home',htmlText:'Home'},
	//	|		{label:'Level 1',htmlText:'Level 1'},
	//	|		{label:'Level 1.1',destination:"#"},
	//	|		{label:'Level 1.1.1'},
	//	|		{label:'Level 1.1.1.1',destination:"#"}]}'>	
	//	|	</div>
	//	If the breadcrumbs are nested within an application context and not in the global context, set the
	//	"nested" attribute to true.  Doing so will achieve the breadcrumb item color to be #0088C2. 
	//	|	<div
	//	|		nested="true"
	//	|		id="breadcrumbExample"
	//	|		dojoType="xwt.widget.layout.Breadcrumb" 
	//	|		breadcrumbItems='{items:[{label:'Home',htmlText:'Home'},
	//	|		{label:'Level 1',htmlText:'Level 1'},
	//	|		{label:'Level 1.1',destination:"#"},
	//	|		{label:'Level 1.1.1'},
	//	|		{label:'Level 1.1.1.1',destination:"#"}]}'>	
	//	|	</div>
	//
	// example: 
	// Programatically:
	// |	new xwt.widget.layout.Breadcrumb({breadcrumbItems:"{items:[{label:'Home'},{label:'Level 1.1',destination:'http://wwwin.cisco.com'},{label:'Level 1.1.1',htmlText:'Level 1.1.1'}]}"});
    // 
	// breadcrumbItems: Object
	// format: { items : [ { label : <required, String>, htmlText: <optional, String>, destination: <optional, String>}...]}
	
    breadcrumbItems: "",
    templateString:"<span dojoAttachPoint=\"breadcrumb_span\"></span>\r\n",
    ellipsesNotation: "...",
    ellipsesFlag: false,
    // store all the missing elements
    ellipsesStr: "",
    // input to enable or disable ellipses. By default it's enabled
    showEllipsesFlag: true,
    // input to set the ellipses counter  
    _ellipsesCounter: "3",
    spacerString: "&nbsp;>&nbsp;",
    nested: false,
    
	startup: function(){
		this.inherited(arguments);
		if(this.nested){
			this._nested(this.breadcrumb_span);
		}
	},
	
	_nested: function(_breadSpan){
			 dojo.addClass(_breadSpan, "nested");
	},
    
    //
    // addItems: Function
    // parameters: [{name: 'param1'
    // format: addItems({ items : [ { label : <required, String>, htmlText: <optional, String>, destination: <optional, String>}...]}
    // returnType: 
    addItems: function(breadcrumbString){
		//Summary: Adds the elements (page name) in the breadcrumbs.
		//Description: This method adds the specified elements (such as the current page) into the breadcrumbs. 
		// If showEllipses is set to true and the ellipses counter is set, and the number of existing pages is greater than
		// the number of pages in the ellipses counter, then the breadcrumbs will display ellipses for some of the 
		// pages, except for the root node and the current and previous page. If showEllipses is set to false 
		// then no ellipses will be shown; instead, 
		// all the elements will appear in the breadcrumbs. By default, showEllipses is set to 'true', with 
		// the counter set to 3.
		//Example: dijit.byId('breadcrumbExample').addItems('{label:'Level 2.1',destination:"#"}');
		var node = "";
		// check if input is array of items or items in the array
		if (dojo.isArray(breadcrumbString)) {
			node = breadcrumbString;
        }
		else{
			var newnode = eval('(' + breadcrumbString + ')');
			this.breadcrumbItems.items[this.breadcrumbItems.items.length] = newnode;
			node = this.breadcrumbItems.items;
		}
        
        var bread_span = this.breadcrumb_span;
        bread_span.innerHTML = "";        
        this.ellipsesFlag = false;
        this.ellipsesStr="";
       
        // check if no of pages exceeds the ellipses counter
        if(node.length>parseInt(this.getCounter(), 10)){
        	for (var i = 0; i < node.length; i++) { 
        		// check if showEllipses flag set to true
        		if(this.showEllipses()){
        			// shows current page, parent of current page and root
	        		if(i===0 || i=== node.length-2 || i === node.length-1){ 
	        			// add the page element in the breadcrumbs
	        			this._addData(node[i],bread_span,i);
	        		}
	        		// show rest of the page in ellipses
	        		else{  
	        			// show the ellipses 
	        			this._addEllipses(node[i],bread_span);
	        			
	        		}
        		}        		
        		else{
        			// all the elements shown in the breadcrumbs
        			this._addData(node[i],bread_span,i);
        		}
        	}
        }
        // show all the pages without ellipses
        else{
        	for (i = 0; i < node.length; i++) {
        		// all the elements shown in the bread-crumb
    	        this._addData(node[i],bread_span,i); 
            }
        }     
        
        // --------------- CSCti92082 ------------------------------------------
        if(this.showEllipses()){
    		var ellipsesTag = dojo.byId("ellipsesId");
    		if(this.ellipsesEvent){
    			dojo.disconnect(this.ellipsesEvent);
    			this.ellipsesEvent = null;
    		}
    		this.ellipsesEvent = dojo.connect(ellipsesTag, "onclick", this, "expandEllipses");
        }
        // ------------------------------------------
    },
    showEllipses: function(){
    	//Summary: Checks the number of pages.
		//Description: Developers use this method to check the number of pages. Based on that, the decision has to 
    	//			be made to show the ellipses and also set the counter to show the ellipses. Set 
    	//			the showEllipses flag to true to display ellipses, or false to turn them off. 
    	// 			You must also set ellipsesCounter; ellipses are shown only when the number of pages 
    	//			exceeds the ellipsesCounter
    	 return this.showEllipsesFlag; 	
    },
    setCounter: function(counterParam){
    	//Summary: Sets the ellipses counter to show ellipses.
    	//Description:  Sets the counter controlling whether ellipses are shown or not. 
    	//			If the number of breadcrumbItems exceeds the value of the counter, 
    	//			ellipses are shown. The minimum counter value should be 3. If you set 
    	//			the counter less then 3, you will not be able to  
    	//			 maintain display of the current or previous page and the navigation history root, 
    	//			 which are critical for effective user navigation via breadcrumbs.
    	this._ellipsesCounter = counterParam;
    },
    getCounter: function(){
    	//Summary: Retrieve the ellipses counter setting.
    	//Description: Returns the number of breadcrumb items to show before compressing to ellipses.
    	return this._ellipsesCounter;
    },
    _addData : function (node,breadSpan,counter){
    	//Summary: Checks the page size.
		//Description: Developers use this method to check the page size. Based on that, decision has to 
    	//			be made to show the ellipses and also set the counter to show the ellipses. 
    	//			Set the showEllipses flag to true to show ellipses, false to turn them off. 
    	//			The ellipsesCounter is set to check if the page elements are hyper-linked.
    	var _doc = document;
    	if (node.destination) {
            var destinationSpan ;
            if(counter == this.breadcrumbItems.items.length-1){
            	destinationSpan = _doc.createElement("span");
                 dojo.addClass(destinationSpan, "xwtBreadcrumbText");                 
            }else{
            	destinationSpan= _doc.createElement("a");
            	destinationSpan.setAttribute("href", node.destination);
            	dojo.addClass(breadSpan, "xwtBreadcrumb");
            }
    		if(this.nested){
    			this._nested(breadSpan);
    		}
            destinationSpan.innerHTML = node.label;
            if(counter > 0){
    			breadSpan.appendChild(this.getSeperator());      	
    			breadSpan.appendChild(destinationSpan);
    		}
    		else{
    			breadSpan.appendChild(destinationSpan);
    		}          
        }
        else{ 
        	// check if it's plain html text
            if (node.htmlText) {   
        		//console.log(node.htmlText);
        		var htmlTextSpan = _doc.createElement("span");
        		dojo.addClass(htmlTextSpan, "xwtBreadcrumbText");
        		htmlTextSpan.innerHTML =  node.htmlText;
        		if(counter > 0){
        			breadSpan.appendChild(this.getSeperator());      	
        			breadSpan.appendChild(htmlTextSpan);
        		}
        		else{
        			breadSpan.appendChild(htmlTextSpan);
        		}
            }
            else {
            	// check it's plain label
                var labelSpan = _doc.createElement("span");
                dojo.addClass(labelSpan, "xwtBreadcrumbText");
                labelSpan.innerHTML = node.label;
                if(counter > 0){
                	breadSpan.appendChild(this.getSeperator());      	
                	breadSpan.appendChild(labelSpan);
                }
                else{
                	breadSpan.appendChild(labelSpan);
                }                
            }
        }
    },
    _addEllipses : function (node,breadSpan){
    	//Summary: Add ellipses for the missing element(s)
		//Description: Use this method to add the missing element in the ellipses and show the 
    	//		missing element in the tooltip. Ellipses should add only once  
    	// 		condition to create the ellipses tag.
    	if(!this.ellipsesFlag){
    		var ellipsesTag = document.createElement("span");
    		ellipsesTag.innerHTML = this.ellipsesNotation;
    		ellipsesTag.setAttribute("id", "ellipsesId");
    		dojo.addClass(ellipsesTag, "xwtEllipses");
    		
    		this.ellipsesFlag = true;
    		// append all the missing element
    		if(node.destination){
    			this.ellipsesStr += node.label + this.spacerString;
    		}
    		else if(node.htmlText){
    			this.ellipsesStr += node.htmlText + this.spacerString;
    		}
    		else{ 
    			this.ellipsesStr += node.label + this.spacerString;
    		}
    		
    		// connect onmouseover event to ellipses to show the missing element in the tooltip
    		//dojo.connect(dojo.byId("ellipsesId"),"onmouseover",this,"showBCTooltip");
//    		ellipsesTag.title = this.ellipsesStr;
    		
        	// fix for CSCti74947
        	ellipsesTag.title = this._convertBreadcrumbTxtToPresentableString();
    		breadSpan.appendChild(this.getSeperator());
    		breadSpan.appendChild(ellipsesTag);
    		
    	}
    	else{    
    		// append all the missing element in the tool-tip
    		if(node.destination){
    			this.ellipsesStr += node.label + this.spacerString;
    		}
    		else if(node.htmlText){
    			this.ellipsesStr += node.htmlText + this.spacerString;
    		}
    		else{ 
    			this.ellipsesStr += node.label + this.spacerString;
    		}
    		var ellipsesTag = dojo.byId("ellipsesId");
    		
//    		ellipsesTag.title = this.ellipsesStr;
    		
        	// fix for CSCti74947
    		ellipsesTag.title = this._convertBreadcrumbTxtToPresentableString();
    	}
    },
    
    
    // --------------- CSCti92082 ------------------------------------------
    expandEllipses :function(){
    	if(this.ellipsesEvent){
    		dojo.disconnect(this.ellipsesEvent);
    		this.ellipsesEvent = null;
    	}
    		
        var bread_span = this.breadcrumb_span;
		bread_span.innerHTML = "";
        var node = this.breadcrumbItems.items;
        
        
     	for (i = 0; i < node.length; i++) {
    		// all the elements shown in the bread-crumb
	        this._addData(node[i],bread_span,i); 
        }
    },
    // ---------------------------------------------------------------------
    
    _convertBreadcrumbTxtToPresentableString: function(){
    	// fix for CSCti74947
    	var _bcString = this.ellipsesStr;
    	var _bcStringPresentable = _bcString.replace(/&nbsp;/g," ");
    	return _bcStringPresentable;
    },
    
    showBCTooltip: function(){
    	//Summary: Show the compressed elements in the tooltip.
		//Description: Shows in a tooltip dialog the elements that are compressed in the ellipses.
    	
    	var _bcStringPresentable = this._convertBreadcrumbTxtToPresentableString();
    	this.tooltip = new dijit.Tooltip({label:_bcStringPresentable,position:top});
    	this.tooltip.open(dojo.byId("ellipsesId"));
    	dojo.connect(dojo.byId("ellipsesId"),"onmouseout",this,"_closeBCTooltip");
    },  
    _closeBCTooltip: function(){
     	this.tooltip.close();
    },
    removeItems: function(){
    	//Summary: Remove an element from the breadcrumbs.
		//Description: Use this method to remove the current page element from the breadcrumbs
    	//				when navigating to the previous page.
    	//Example: dijit.byId('breadcrumbExample').removeItems() - remove the last index from the breadcrumb items.
        var bread_span = this.breadcrumb_span;
		bread_span.innerHTML = "";
        var node = this.breadcrumbItems.items;
        // to ensure not to delete the first element
        if(node.length>=2){
        	
        	var _removedItem = node.pop();
        	//console.dir(_removedItem);
        	this.addItems(this.breadcrumbItems.items);
        	
        }
        else{
        	this.addItems(this.breadcrumbItems.items);
        }                
    },

    setBreadcrumbItems: function(breadcrumbString){
    	//Summary: Set the page elements in the breadcrumbs.
		//Description: Use this method to set the page elements in the breadcrumbs
    	//				when navigating to the previous page.

        if (dojo.isString(breadcrumbString)) {
			this.breadcrumbItems = eval('(' + breadcrumbString + ')');
        }
        var _doc = document; 
        var bread_span = this.breadcrumb_span;
		bread_span.innerHTML = "";
        var node = this.breadcrumbItems.items;
        for (var i = 0; i < node.length; i++) {
            if (node[i].destination) {
            	 var a ;
            	 if(i==node.length-1){
                 	a = _doc.createElement("span");
                 	a.setAttribute("href", node[i].destination);
  	                dojo.addClass(a, "xwtBreadcrumbText");
                 }else{
                	 a = _doc.createElement("a");
                	 a.setAttribute("href", node[i].destination);
                	 dojo.addClass(bread_span, "xwtBreadcrumb");
                 }
                 a.innerHTML = node[i].label;
                 bread_span.appendChild(a);                
                 if (i != node.length - 1){ 
     				bread_span.appendChild(this.getSeperator());
     			}
            }
            else 
                if (node[i].htmlText) {                	
                	var span = _doc.createElement("span");
            		dojo.addClass(span,"xwtBreadcrumbText");
            		span.innerHTML =  node[i].htmlText;
        			bread_span.appendChild(span);        			 
        			if (i != node.length - 1){ 
        				bread_span.appendChild(this.getSeperator());
        			}  
                }
                else {
                    var span = _doc.createElement("span");
	                dojo.addClass(span, "xwtBreadcrumbText");
                    span.innerHTML = node[i].label;
                    bread_span.appendChild(span);                 
                    if (i != node.length - 1){ 
        				bread_span.appendChild(this.getSeperator());
        			}
                }
           
        }
        
    },
    getSeperator : function(){
    	//Summary: Retrieves the separator used in the breadcrumbs.
		//Description: Returns the separator token that acts as a delimiter between breadcrumb items.
    	var eSpan = document.createElement("span");
		dojo.addClass(eSpan, "xwtBreadcrumbSeparator");
		eSpan.innerHTML = this.spacerString;
    	return eSpan;
    },

    postCreate: function(){
    	//Summary: Sets the default page elements in the breadcrumb array.
		//Description: Use this method to set the page elements in the breadcrumb array when the page is loaded.
        if (dojo.isString(this.breadcrumbItems)) {
            this.breadcrumbItems = eval('(' + this.breadcrumbItems + ')');            
        }
        var bread_span = this.breadcrumb_span;
        var node = this.breadcrumbItems.items;
        var _doc = document; 
        for (var i = 0; i < node.length; i++) {        	
            if (node[i].destination) {
                var a ;
                if(i==node.length-1){
                	a = _doc.createElement("span");
                	a.setAttribute("href", node[i].destination);
 	                dojo.addClass(a, "xwtBreadcrumbText");
                }else{
                	a = _doc.createElement("a");
                	a.setAttribute("href", node[i].destination);
                	dojo.addClass(bread_span, "xwtBreadcrumb");
                }
                a.innerHTML = node[i].label;
                bread_span.appendChild(a);                
                if (i != node.length - 1){ 
    				bread_span.appendChild(this.getSeperator());
    			}
            }
            else{
                if (node[i].htmlText) {
                	var span = _doc.createElement("span");
            		dojo.addClass(span, "xwtBreadcrumbText");
            		span.innerHTML =  node[i].htmlText;
        			bread_span.appendChild(span);        			
        			if (i != node.length - 1){ 
        				bread_span.appendChild(this.getSeperator());
        			}            			
                }
                else {
                    var span = _doc.createElement("span");
	                dojo.addClass(span, "xwtBreadcrumbText");
                    span.innerHTML = node[i].label;
                    bread_span.appendChild(span);                    
                    if (i != node.length - 1){ 
        				bread_span.appendChild(this.getSeperator());
        			}
                }
            }          
        }
     }
});

}

if(!dojo._hasResource["xwt.widget.form.ListBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.form.ListBox"] = true;
/*******************************************************************   
 *        Copyright (c) 2010-2011 Cisco Systems, Inc.   
 *        All rights reserved.   
 *        
 *        @author Mohammed Ashik Maricar mmaricar@cisco.com
 *        @version 0.1 
 *******************************************************************/
dojo.provide("xwt.widget.form.ListBox");






dojo.declare("xwt.widget.form.ListBox",[dijit._Widget, dijit._Templated, dijit.form._FormWidget],{
	
	// summary:
	//		The List Box allows users to select items from a list.
	// 
	// description:
	//		The List Box widget lets users select one or more items from a list. A fixed number of 
	//		list items is always visible, and a scrollbar lets users scroll through the 
	//		entire list. A list box may have one column or multiple columns.
	//
	// example:
	//
	//	To instantiate the List Box using HTML markup:
	//
	//	|	<div dojoType="dojo.data.ItemFileReadStore" 
	//	|		jsId="listStore" 
	//	|		url="../data/data_listbox.json">
	//	|  	</div>
	//	|	<select 
	//	|		id="listbox" 
	//	|		name="listbox" 
	//	|		dojoType="xwt.widget.form.ListBox" 
	//	|		store="listStore">
	//	|	</select>
	//
	//	To instantiate the List Box programatically:
	//
	//	|	var store = new dojo.data.ItemFileReadStore({
	//	|		url:"../data/data_listbox.json"
	//	|	});
	//	|	var listbox = new xwt.widget.form.ListBox({
	//	|		id:"programaticListBox", 
	//	|		store: store, searchAttr: "id"
	//	|	}, dojo.byId("test"));		
	
	//templatePath: String
	//		Template file for the list box widget
	templateString:"<select multiple=\"true\" class=\"${baseClass}\" size=\"${size}\" dojoAttachPoint=\"containerNode,focusNode\" dojoType=\"dijit.form.MultiSelect\">\r\n</select>\r\n\t\t\r\n",
	
	baseClass: "xwtlistbox",
	
	//size: Number
	//	The number of elements to display on a page.
	size: 8,

	//store: Object
	//	Reference to a data provider object used by this ListBox.
	store: null,
	
	//searchAttr: String
	//	Keyword based on which options are populated.
	searchAttr: "",

	//disabled: String
	//	Disable the widget.
	disabled: false,		
	
	postCreate: function() {	
	
		this.inherited(arguments);
		this._createOptions();	      
		 
    	if(this.disabled == true) 			
			dojo.attr(this.focusNode, 'disabled', this.disabled);			
    },
	
	_createOptions: function() {		
		if(this.store) {    					
        	if(this.containerNode !=null)
           		this.store.fetch({onItem: dojo.hitch(this, '_addOption')});         
       	}
	},
	
	_addOption : function(item) {			
        var option = dojo.doc.createElement('option');
		if(this.searchAttr) {
			option.innerHTML = this.store.getValue(item, this.searchAttr);
		} else {
			option.innerHTML = this.store.getLabel(item);
		}
        option.value = this.store.getIdentity(item);
		if(this.store.getValue(item, "selected") == "true")
			option.selected = "selected";
		this.containerNode.appendChild(option);		
    },		
    
	getSelectedItemsValue : function() {
    	// summary:
        //    Returns the value of the selected items or options.
        // description:
        //    This method returns the value of the selected items or options.
    	// returns:
    	// 	Returns an array of values for the selected items/options value in the List Box.  
       if(this.containerNode ==null) { return; }       
       
        var selectedItems = new Array();			
		dojo.query("option",this.containerNode).filter(function(n){			
			return n.selected;
		}).forEach(function(n) {				
			selectedItems.push(n.value);
		});	
		
		if(selectedItems.length > 0)
			return selectedItems;
		else 
			return null;
    },

	getSelectedItemsText : function(){
       	// summary:
        //     Returns the displayed text for all of the selected items or options in the List Box.
        // description:
        //    This method returns the displayed text for all of the selected items or options in the List Box.
    	// returns:
    	// 	Returns an array containing the displayed text for all selected items/options displayed in the List Box.       	
       if(this.containerNode ==null) { return; }

        var selectedItems = new Array();      
		dojo.query("option",this.containerNode).filter(function(n){		
			return n.selected;
		}).forEach(function(n) {			
			selectedItems.push(n.text);
		});		
		
		if(selectedItems.length > 0)
			return selectedItems;
		else 
			return null;
    },	    
	
	resize: function(/* Object */size){
    	// summary:
        //    Resizes the List Box widget to show a specified number of visible items or options.
        // description:
        //    Resizes the List Box widget to show a specified number of visible items or options.
    	// size: Number
    	// 	The number of items/options to be visible in the List Box.
		if(size){
			dojo.marginBox(this, size);
		}
	},
	
	setStore: function(/*store*/ store) {	
	   	// summary:
        //     Sets the new data object (containing items or options) to the List Box.  	
        // description:
        //    Sets the new data object (containing items or options) to the List Box.
        // store: Object
        //    The data object (containing items or options) to be set to the List Box.  	
		
		this.store = store;
	},
	
	refresh: function() {
	   	// summary:
        //     Removes all the items or options and adds the newly created data object 
	   	//	   containing List Box items or options.    	
        // description:
        //     Removes all the items or options and adds the newly created data object 
	   	//	   containing List Box items or options.    			
		this.clearOptions();
		this._createOptions();
	},
	
	clearOptions: function() {	
		// summary:
        //     Removes all the items or options from the List Box.  
        // description:
        //    Removes all the items or options from the List Box.  
    	dojo.query("option", this.containerNode).orphan();		
	}
});

}

if(!dojo._hasResource["xwt.widget.form.TextButton"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.form.TextButton"] = true;
/* ************************************************** */
/* Copyright (c) 2009-2011 Cisco Systems, Inc.       */
/* All rights reserved.                               */
/* ************************************************** */ 

/**
 * @fileoverview 
 * The xwt.widget.form.TextButton 
 * This widget extends dijit.form.Button with a new template file and CSS.
 * 
 * The purpose of this widget is to allow TextButton and dijit.form.Button to coexist on one HTML page.
 * For example, a page might contain both a toolbar and text buttons. The toolbar uses dijit.form.Button. 
 * There will be a CSS conflict if we do not create a new text button widget.  
 * 
 * @author Jeff Hu jefhu@cisco.com
 */

dojo.provide("xwt.widget.form.TextButton");



dojo.declare("xwt.widget.form.TextButton",  [dijit.form.Button], {
	// Summary:
	// 		xwt.widget.TextButton is an extension of the dijit.form.Button that has the Kubrick styling.
	
	// description:
	// 		xwt.widget.TextButton extends from dijit.form.Button with new template and CSS file. 
	//		There is no new API.
	// 		A new template is needed to avoid CSS conflict so that dijit.form.Button and 
	//		xwt.widget.TextButton can co-exist on one page.
	
	//	example:
		//	Using HTML markup:
		//	|	<button baseClass="defaultButton" id="createDevice" dojoType="xwt.widget.form.TextButton">Edit..</button>
		//  |   <button id="createDevice2" dojoType="xwt.widget.form.TextButton">Advanced..</button>
	//
	//	example:
		//	Programmatically:
		//	|	var button = new xwt.widget.form.TextButto({ label:"hello",
	    //  |                                                 baseClase = "defautltButton", //if set to default button 
	    //  |                                                 onClick :function(event){alert("you click Hello"},
		//  |                                               });
	    //  |  button.startup(); //optional 
	    //  |  button.attr(..); // this is the api to change button instance properties. Refer to dojo api doc
	
	
	// baseClass: String
	//		Base CSS style class. Overrides the Dojo-defined class.
	baseClass: "xwt-TextButton",

	// templateString: String
	//		Widget markup as a String.
	templateString: null,
	
	// templatePath: String
	//		URL to retrieve the widget template.
	templateString:"<span class=\"dijit dijitReset dijitLeft dijitInline xwtButtonBorder\"\r\n\tdojoAttachEvent=\"ondijitclick:_onButtonClick,onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse \"\r\n\tdojoAttachPoint=\"styleEventNode\"\r\n\t><span class=\"dijitReset xwt-TextRight dijitInline\"\r\n\t\t><span class=\"dijitReset dijitInline xwt-TextButtonNode\"\r\n\t\t\t><button class=\"dijitReset dijitStretch xwt-TextButtonContents\"\r\n\t\t\t\tdojoAttachPoint=\"titleNode,focusNode\" \r\n\t\t\t\t${nameAttrSetting} type=\"${type}\" value=\"${value}\" waiRole=\"button\" waiState=\"labelledby-${id}_label\"\r\n\t\t\t\t><span class=\"dijitReset dijitInline xwt-TextButtonIconNode\" dojoAttachPoint=\"iconNode\"\r\n\t\t\t\t\t><span class=\"dijitReset dijitToggleButtonIconChar\">&#10003;</span\r\n\t\t\t\t></span\r\n\t\t\t\t><span class=\"dijitReset dijitInline xwt-TextButtonText\" \r\n\t\t\t\t\tid=\"${id}_label\"  \r\n\t\t\t\t\tdojoAttachPoint=\"containerNode\"\r\n\t\t\t\t></span\r\n\t\t\t></button\r\n\t\t></span\r\n\t></span\r\n></span>\r\n",
	
	/*
	_onMouse :function(event){		
		console.log(event.type);
		if (!this.disabled){
			switch(event.type){
			case "mouseout":
			case "mouseleave":
				//dojo.addClass(this.textButtonNode, "xwtTextButtonMouseOut");
				dojo.addClass(this.domNode, "xwtTextButtonMouseOut");
				break;
			default:
				dojo.removeClass(this.domNode, "xwtTextButtonMouseOut");
			}
		}
		this.inherited(arguments);
	},
	*/
	

	
	focus: function(){
	// summary:
	// overwrite focus() for accessibilty compliance
		this.inherited(arguments);
		if (this===undefined || this.styleEventNode===undefined) return;
		if(this.baseClass ==="defaultButton"){
			dojo.addClass(this.styleEventNode,"defaultButton");
			dojo.addClass(this.styleEventNode,"defaultButtonHover");
		}else{
			dojo.addClass(this.styleEventNode,"xwt-TextButton");
			dojo.addClass(this.styleEventNode,"xwt-TextButtonHover");
		}
		dojo.addClass(this.styleEventNode,"dijitHover");
		/*
		if (this.attr("baseClass")==="defaultButton"){
			dojo.addClass(this.domNode, "defaultButtonActive");
		}else{
			dojo.addClass(this.domNode, "xwt-TextButtonActive");
		}
		*/
	},
	
	onBlur: function(){
	// summary:
	// overwrite onBlur() for accessibilty compliance
		this.inherited(arguments);
		if (this===undefined || this.styleEventNode===undefined) return;
		if(this.baseClass ==="defaultButton"){
			dojo.removeClass(this.styleEventNode,"defaultButton");
			dojo.removeClass(this.styleEventNode,"defaultButtonHover");
		}else{
			dojo.removeClass(this.styleEventNode,"xwt-TextButtonHover");
		}
		dojo.removeClass(this.styleEventNode,"dijitHover");
		/*if (btn.attr("baseClass")==="defaultButton"){
			dojo.removeClass(btn.domNode, "defaultButtonActive");
		}else{
			dojo.removeClass(btn.domNode, "xwt-TextButtonActive");
		}*/
	}
});

}

if(!dojo._hasResource["dijit.form.ValidationTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.ValidationTextBox"] = true;
dojo.provide("dijit.form.ValidationTextBox");








/*=====
	dijit.form.ValidationTextBox.__Constraints = function(){
		// locale: String
		//		locale used for validation, picks up value from this widget's lang attribute
		// _flags_: anything
		//		various flags passed to regExpGen function
		this.locale = "";
		this._flags_ = "";
	}
=====*/

dojo.declare(
	"dijit.form.ValidationTextBox",
	dijit.form.TextBox,
	{
		// summary:
		//		Base class for textbox widgets with the ability to validate content of various types and provide user feedback.
		// tags:
		//		protected

		templateString: dojo.cache("dijit.form", "templates/ValidationTextBox.html", "<div class=\"dijit dijitReset dijitInlineTable dijitLeft\"\r\n\tid=\"widget_${id}\"\r\n\tdojoAttachEvent=\"onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse\" waiRole=\"presentation\"\r\n\t><div style=\"overflow:hidden;\"\r\n\t\t><div class=\"dijitReset dijitValidationIcon\"><br></div\r\n\t\t><div class=\"dijitReset dijitValidationIconText\">&Chi;</div\r\n\t\t><div class=\"dijitReset dijitInputField\"\r\n\t\t\t><input class=\"dijitReset\" dojoAttachPoint='textbox,focusNode' autocomplete=\"off\"\r\n\t\t\t${nameAttrSetting} type='${type}'\r\n\t\t/></div\r\n\t></div\r\n></div>\r\n"),
		baseClass: "dijitTextBox",

		// required: Boolean
		//		User is required to enter data into this field.
		required: false,

		// promptMessage: String
		//		If defined, display this hint string immediately on focus to the textbox, if empty.
		//		Think of this like a tooltip that tells the user what to do, not an error message
		//		that tells the user what they've done wrong.
		//
		//		Message disappears when user starts typing.
		promptMessage: "",

		// invalidMessage: String
		// 		The message to display if value is invalid.
		invalidMessage: "$_unset_$", // read from the message file if not overridden

		// constraints: dijit.form.ValidationTextBox.__Constraints
		//		user-defined object needed to pass parameters to the validator functions
		constraints: {},

		// regExp: [extension protected] String
		//		regular expression string used to validate the input
		//		Do not specify both regExp and regExpGen
		regExp: ".*",

		regExpGen: function(/*dijit.form.ValidationTextBox.__Constraints*/constraints){
			// summary:
			//		Overridable function used to generate regExp when dependent on constraints.
			//		Do not specify both regExp and regExpGen.
			// tags:
			//		extension protected
			return this.regExp; // String
		},

		// state: [readonly] String
		//		Shows current state (ie, validation result) of input (Normal, Warning, or Error)
		state: "",

		// tooltipPosition: String[]
		//		See description of `dijit.Tooltip.defaultPosition` for details on this parameter.
		tooltipPosition: [],

		_setValueAttr: function(){
			// summary:
			//		Hook so attr('value', ...) works.
			this.inherited(arguments);
			this.validate(this._focused);
		},

		validator: function(/*anything*/value, /*dijit.form.ValidationTextBox.__Constraints*/constraints){
			// summary:
			//		Overridable function used to validate the text input against the regular expression.
			// tags:
			//		protected
			return (new RegExp("^(?:" + this.regExpGen(constraints) + ")"+(this.required?"":"?")+"$")).test(value) &&
				(!this.required || !this._isEmpty(value)) &&
				(this._isEmpty(value) || this.parse(value, constraints) !== undefined); // Boolean
		},

		_isValidSubset: function(){
			// summary:
			//		Returns true if the value is either already valid or could be made valid by appending characters.
			//		This is used for validation while the user [may be] still typing.
			return this.textbox.value.search(this._partialre) == 0;
		},

		isValid: function(/*Boolean*/ isFocused){
			// summary:
			//		Tests if value is valid.
			//		Can override with your own routine in a subclass.
			// tags:
			//		protected
			return this.validator(this.textbox.value, this.constraints);
		},

		_isEmpty: function(value){
			// summary:
			//		Checks for whitespace
			return /^\s*$/.test(value); // Boolean
		},

		getErrorMessage: function(/*Boolean*/ isFocused){
			// summary:
			//		Return an error message to show if appropriate
			// tags:
			//		protected
			return this.invalidMessage; // String
		},

		getPromptMessage: function(/*Boolean*/ isFocused){
			// summary:
			//		Return a hint message to show when widget is first focused
			// tags:
			//		protected
			return this.promptMessage; // String
		},

		_maskValidSubsetError: true,
		validate: function(/*Boolean*/ isFocused){
			// summary:
			//		Called by oninit, onblur, and onkeypress.
			// description:
			//		Show missing or invalid messages if appropriate, and highlight textbox field.
			// tags:
			//		protected
			var message = "";
			var isValid = this.disabled || this.isValid(isFocused);
			if(isValid){ this._maskValidSubsetError = true; }
			var isValidSubset = !isValid && isFocused && this._isValidSubset();
			var isEmpty = this._isEmpty(this.textbox.value);
			if(isEmpty){ this._maskValidSubsetError = true; }
			this.state = (isValid || (!this._hasBeenBlurred && isEmpty) || isValidSubset) ? "" : "Error";
			if(this.state == "Error"){ this._maskValidSubsetError = false; }
			this._setStateClass();
			dijit.setWaiState(this.focusNode, "invalid", isValid ? "false" : "true");
			if(isFocused){
				if(isEmpty){
					message = this.getPromptMessage(true);
				}
				if(!message && (this.state == "Error" || (isValidSubset && !this._maskValidSubsetError))){
					message = this.getErrorMessage(true);
				}
			}
			this.displayMessage(message);
			return isValid;
		},

		// _message: String
		//		Currently displayed message
		_message: "",

		displayMessage: function(/*String*/ message){
			// summary:
			//		Overridable method to display validation errors/hints.
			//		By default uses a tooltip.
			// tags:
			//		extension
			if(this._message == message){ return; }
			this._message = message;
			dijit.hideTooltip(this.domNode);
			if(message){
				dijit.showTooltip(message, this.domNode, this.tooltipPosition);
			}
		},

		_refreshState: function(){
			// Overrides TextBox._refreshState()
			this.validate(this._focused);
			this.inherited(arguments);
		},

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		constructor: function(){
			this.constraints = {};
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			this.constraints.locale = this.lang;
			this.messages = dojo.i18n.getLocalization("dijit.form", "validate", this.lang);
			if(this.invalidMessage == "$_unset_$"){ this.invalidMessage = this.messages.invalidMessage; }
			var p = this.regExpGen(this.constraints);
			this.regExp = p;
			var partialre = "";
			// parse the regexp and produce a new regexp that matches valid subsets
			// if the regexp is .* then there's no use in matching subsets since everything is valid
			if(p != ".*"){ this.regExp.replace(/\\.|\[\]|\[.*?[^\\]{1}\]|\{.*?\}|\(\?[=:!]|./g,
				function (re){
					switch(re.charAt(0)){
						case '{':
						case '+':
						case '?':
						case '*':
						case '^':
						case '$':
						case '|':
						case '(':
							partialre += re;
							break;
						case ")":
							partialre += "|$)";
							break;
						 default:
							partialre += "(?:"+re+"|$)";
							break;
					}
				}
			);}
			try{ // this is needed for now since the above regexp parsing needs more test verification
				"".search(partialre);
			}catch(e){ // should never be here unless the original RE is bad or the parsing is bad
				partialre = this.regExp;
				console.warn('RegExp error in ' + this.declaredClass + ': ' + this.regExp);
			} // should never be here unless the original RE is bad or the parsing is bad
			this._partialre = "^(?:" + partialre + ")$";
		},

		_setDisabledAttr: function(/*Boolean*/ value){
			this.inherited(arguments);	// call FormValueWidget._setDisabledAttr()
			this._refreshState();
		},

		_setRequiredAttr: function(/*Boolean*/ value){
			this.required = value;
			dijit.setWaiState(this.focusNode,"required", value);
			this._refreshState();
		},

		postCreate: function(){
			if(dojo.isIE){ // IE INPUT tag fontFamily has to be set directly using STYLE
				var s = dojo.getComputedStyle(this.focusNode);
				if(s){
					var ff = s.fontFamily;
					if(ff){
						this.focusNode.style.fontFamily = ff;
					}
				}
			}
			this.inherited(arguments);
		},

		reset:function(){
			// Overrides dijit.form.TextBox.reset() by also
			// hiding errors about partial matches
			this._maskValidSubsetError = true;
			this.inherited(arguments);
		},

		_onBlur: function(){
			this.displayMessage('');
			this.inherited(arguments);
		}
	}
);

dojo.declare(
	"dijit.form.MappedTextBox",
	dijit.form.ValidationTextBox,
	{
		// summary:
		//		A dijit.form.ValidationTextBox subclass which provides a base class for widgets that have
		//		a visible formatted display value, and a serializable
		//		value in a hidden input field which is actually sent to the server.
		// description:
		//		The visible display may
		//		be locale-dependent and interactive.  The value sent to the server is stored in a hidden
		//		input field which uses the `name` attribute declared by the original widget.  That value sent
		//		to the server is defined by the dijit.form.MappedTextBox.serialize method and is typically
		//		locale-neutral.
		// tags:
		//		protected

		postMixInProperties: function(){
			this.inherited(arguments);

			// we want the name attribute to go to the hidden <input>, not the displayed <input>,
			// so override _FormWidget.postMixInProperties() setting of nameAttrSetting
			this.nameAttrSetting = "";
		},

		serialize: function(/*anything*/val, /*Object?*/options){
			// summary:
			//		Overridable function used to convert the attr('value') result to a canonical
			//		(non-localized) string.  For example, will print dates in ISO format, and
			//		numbers the same way as they are represented in javascript.
			// tags:
			//		protected extension
			return val.toString ? val.toString() : ""; // String
		},

		toString: function(){
			// summary:
			//		Returns widget as a printable string using the widget's value
			// tags:
			//		protected
			var val = this.filter(this.attr('value')); // call filter in case value is nonstring and filter has been customized
			return val != null ? (typeof val == "string" ? val : this.serialize(val, this.constraints)) : ""; // String
		},

		validate: function(){
			// Overrides `dijit.form.TextBox.validate`
			this.valueNode.value = this.toString();
			return this.inherited(arguments);
		},

		buildRendering: function(){
			// Overrides `dijit._Templated.buildRendering`

			this.inherited(arguments);

			// Create a hidden <input> node with the serialized value used for submit
			// (as opposed to the displayed value).
			// Passing in name as markup rather than calling dojo.create() with an attrs argument
			// to make dojo.query(input[name=...]) work on IE. (see #8660)
			this.valueNode = dojo.place("<input type='hidden'" + (this.name ? " name='" + this.name + "'" : "") + ">", this.textbox, "after");
		},

		reset:function(){
			// Overrides `dijit.form.ValidationTextBox.reset` to
			// reset the hidden textbox value to ''
			this.valueNode.value = '';
			this.inherited(arguments);
		}
	}
);

/*=====
	dijit.form.RangeBoundTextBox.__Constraints = function(){
		// min: Number
		//		Minimum signed value.  Default is -Infinity
		// max: Number
		//		Maximum signed value.  Default is +Infinity
		this.min = min;
		this.max = max;
	}
=====*/

dojo.declare(
	"dijit.form.RangeBoundTextBox",
	dijit.form.MappedTextBox,
	{
		// summary:
		//		Base class for textbox form widgets which defines a range of valid values.

		// rangeMessage: String
		//		The message to display if value is out-of-range
		rangeMessage: "",

		/*=====
		// constraints: dijit.form.RangeBoundTextBox.__Constraints
		constraints: {},
		======*/

		rangeCheck: function(/*Number*/ primitive, /*dijit.form.RangeBoundTextBox.__Constraints*/ constraints){
			// summary:
			//		Overridable function used to validate the range of the numeric input value.
			// tags:
			//		protected
			return	("min" in constraints? (this.compare(primitive,constraints.min) >= 0) : true) &&
				("max" in constraints? (this.compare(primitive,constraints.max) <= 0) : true); // Boolean
		},

		isInRange: function(/*Boolean*/ isFocused){
			// summary:
			//		Tests if the value is in the min/max range specified in constraints
			// tags:
			//		protected
			return this.rangeCheck(this.attr('value'), this.constraints);
		},

		_isDefinitelyOutOfRange: function(){
			// summary:
			//		Returns true if the value is out of range and will remain
			//		out of range even if the user types more characters
			var val = this.attr('value');
			var isTooLittle = false;
			var isTooMuch = false;
			if("min" in this.constraints){
				var min = this.constraints.min;
				min = this.compare(val, ((typeof min == "number") && min >= 0 && val !=0) ? 0 : min);
				isTooLittle = (typeof min == "number") && min < 0;
			}
			if("max" in this.constraints){
				var max = this.constraints.max;
				max = this.compare(val, ((typeof max != "number") || max > 0) ? max : 0);
				isTooMuch = (typeof max == "number") && max > 0;
			}
			return isTooLittle || isTooMuch;
		},

		_isValidSubset: function(){
			// summary:
			//		Overrides `dijit.form.ValidationTextBox._isValidSubset`.
			//		Returns true if the input is syntactically valid, and either within
			//		range or could be made in range by more typing.
			return this.inherited(arguments) && !this._isDefinitelyOutOfRange();
		},

		isValid: function(/*Boolean*/ isFocused){
			// Overrides dijit.form.ValidationTextBox.isValid to check that the value is also in range.
			return this.inherited(arguments) &&
				((this._isEmpty(this.textbox.value) && !this.required) || this.isInRange(isFocused)); // Boolean
		},

		getErrorMessage: function(/*Boolean*/ isFocused){
			// Overrides dijit.form.ValidationTextBox.getErrorMessage to print "out of range" message if appropriate
			var v = this.attr('value');
			if(v !== null && v !== '' && v !== undefined && !this.isInRange(isFocused)){ // don't check isInRange w/o a real value
				return this.rangeMessage; // String
			}
			return this.inherited(arguments);
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			if(!this.rangeMessage){
				this.messages = dojo.i18n.getLocalization("dijit.form", "validate", this.lang);
				this.rangeMessage = this.messages.rangeMessage;
			}
		},

		postCreate: function(){
			this.inherited(arguments);
			if(this.constraints.min !== undefined){
				dijit.setWaiState(this.focusNode, "valuemin", this.constraints.min);
			}
			if(this.constraints.max !== undefined){
				dijit.setWaiState(this.focusNode, "valuemax", this.constraints.max);
			}
		},

		_setValueAttr: function(/*Number*/ value, /*Boolean?*/ priorityChange){
			// summary:
			//		Hook so attr('value', ...) works.

			dijit.setWaiState(this.focusNode, "valuenow", value);
			this.inherited(arguments);
		}
	}
);

}

if(!dojo._hasResource["dijit.form.ComboBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.ComboBox"] = true;
dojo.provide("dijit.form.ComboBox");









dojo.declare(
	"dijit.form.ComboBoxMixin",
	null,
	{
		// summary:
		//		Implements the base functionality for `dijit.form.ComboBox`/`dijit.form.FilteringSelect`
		// description:
		//		All widgets that mix in dijit.form.ComboBoxMixin must extend `dijit.form._FormValueWidget`.
		// tags:
		//		protected

		// item: Object
		//		This is the item returned by the dojo.data.store implementation that
		//		provides the data for this ComboBox, it's the currently selected item.
		item: null,

		// pageSize: Integer
		//		Argument to data provider.
		//		Specifies number of search results per page (before hitting "next" button)
		pageSize: Infinity,

		// store: Object
		//		Reference to data provider object used by this ComboBox
		store: null,

		// fetchProperties: Object
		//		Mixin to the dojo.data store's fetch.
		//		For example, to set the sort order of the ComboBox menu, pass:
		//	|	{ sort: {attribute:"name",descending: true} }
		//		To override the default queryOptions so that deep=false, do:
		//	|	{ queryOptions: {ignoreCase: true, deep: false} }
		fetchProperties:{},

		// query: Object
		//		A query that can be passed to 'store' to initially filter the items,
		//		before doing further filtering based on `searchAttr` and the key.
		//		Any reference to the `searchAttr` is ignored.
		query: {},

		// autoComplete: Boolean
		//		If user types in a partial string, and then tab out of the `<input>` box,
		//		automatically copy the first entry displayed in the drop down list to
		//		the `<input>` field
		autoComplete: true,

		// highlightMatch: String
		// 		One of: "first", "all" or "none".
		//
		//		If the ComboBox/FilteringSelect opens with the search results and the searched
		//		string can be found, it will be highlighted.  If set to "all"
		//		then will probably want to change `queryExpr` parameter to '*${0}*'
		//
		//		Highlighting is only performed when `labelType` is "text", so as to not
		//		interfere with any HTML markup an HTML label might contain.
		highlightMatch: "first",

		// searchDelay: Integer
		//		Delay in milliseconds between when user types something and we start
		//		searching based on that value
		searchDelay: 100,

		// searchAttr: String
		//		Search for items in the data store where this attribute (in the item)
		//		matches what the user typed
		searchAttr: "name",

		// labelAttr: String?
		//		The entries in the drop down list come from this attribute in the
		//		dojo.data items.
		//		If not specified, the searchAttr attribute is used instead.
		labelAttr: "",

		// labelType: String
		//		Specifies how to interpret the labelAttr in the data store items.
		//		Can be "html" or "text".
		labelType: "text",

		// queryExpr: String
		//		This specifies what query ComboBox/FilteringSelect sends to the data store,
		//		based on what the user has typed.  Changing this expression will modify
		//		whether the drop down shows only exact matches, a "starting with" match,
		//		etc.   Use it in conjunction with highlightMatch.
		//		dojo.data query expression pattern.
		//		`${0}` will be substituted for the user text.
		//		`*` is used for wildcards.
		//		`${0}*` means "starts with", `*${0}*` means "contains", `${0}` means "is"
		queryExpr: "${0}*",

		// ignoreCase: Boolean
		//		Set true if the ComboBox/FilteringSelect should ignore case when matching possible items
		ignoreCase: true,

		// hasDownArrow: [const] Boolean
		//		Set this textbox to have a down arrow button, to display the drop down list.
		//		Defaults to true.
		hasDownArrow: true,

		templateString: dojo.cache("dijit.form", "templates/ComboBox.html", "<div class=\"dijit dijitReset dijitInlineTable dijitLeft\"\r\n\tid=\"widget_${id}\"\r\n\tdojoAttachEvent=\"onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse\" dojoAttachPoint=\"comboNode\" waiRole=\"combobox\" tabIndex=\"-1\"\r\n\t><div style=\"overflow:hidden;\"\r\n\t\t><div class='dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton'\r\n\t\t\tdojoAttachPoint=\"downArrowNode\" waiRole=\"presentation\"\r\n\t\t\tdojoAttachEvent=\"onmousedown:_onArrowMouseDown,onmouseup:_onMouse,onmouseenter:_onMouse,onmouseleave:_onMouse\"\r\n\t\t\t><div class=\"dijitArrowButtonInner\">&thinsp;</div\r\n\t\t\t><div class=\"dijitArrowButtonChar\">&#9660;</div\r\n\t\t></div\r\n\t\t><div class=\"dijitReset dijitValidationIcon\"><br></div\r\n\t\t><div class=\"dijitReset dijitValidationIconText\">&Chi;</div\r\n\t\t><div class=\"dijitReset dijitInputField\"\r\n\t\t\t><input ${nameAttrSetting} type=\"text\" autocomplete=\"off\" class='dijitReset'\r\n\t\t\tdojoAttachEvent=\"onkeypress:_onKeyPress,compositionend\"\r\n\t\t\tdojoAttachPoint=\"textbox,focusNode\" waiRole=\"textbox\" waiState=\"haspopup-true,autocomplete-list\"\r\n\t\t/></div\r\n\t></div\r\n></div>\r\n"),

		baseClass:"dijitComboBox",

		_getCaretPos: function(/*DomNode*/ element){
			// khtml 3.5.2 has selection* methods as does webkit nightlies from 2005-06-22
			var pos = 0;
			if(typeof(element.selectionStart) == "number"){
				// FIXME: this is totally borked on Moz < 1.3. Any recourse?
				pos = element.selectionStart;
			}else if(dojo.isIE){
				// in the case of a mouse click in a popup being handled,
				// then the dojo.doc.selection is not the textarea, but the popup
				// var r = dojo.doc.selection.createRange();
				// hack to get IE 6 to play nice. What a POS browser.
				var tr = dojo.doc.selection.createRange().duplicate();
				var ntr = element.createTextRange();
				tr.move("character",0);
				ntr.move("character",0);
				try{
					// If control doesnt have focus, you get an exception.
					// Seems to happen on reverse-tab, but can also happen on tab (seems to be a race condition - only happens sometimes).
					// There appears to be no workaround for this - googled for quite a while.
					ntr.setEndPoint("EndToEnd", tr);
					pos = String(ntr.text).replace(/\r/g,"").length;
				}catch(e){
					// If focus has shifted, 0 is fine for caret pos.
				}
			}
			return pos;
		},

		_setCaretPos: function(/*DomNode*/ element, /*Number*/ location){
			location = parseInt(location);
			dijit.selectInputText(element, location, location);
		},

		_setDisabledAttr: function(/*Boolean*/ value){
			// Additional code to set disabled state of ComboBox node.
			// Overrides _FormValueWidget._setDisabledAttr() or ValidationTextBox._setDisabledAttr().
			this.inherited(arguments);
			dijit.setWaiState(this.comboNode, "disabled", value);
		},

		_abortQuery: function(){
			// stop in-progress query
			if(this.searchTimer){
				clearTimeout(this.searchTimer);
				this.searchTimer = null;
			}
			if(this._fetchHandle){
				if(this._fetchHandle.abort){ this._fetchHandle.abort(); }
				this._fetchHandle = null;
			}
		},

		_onKeyPress: function(/*Event*/ evt){
			// summary:
			//		Handles keyboard events
			var key = evt.charOrCode;
			// except for cutting/pasting case - ctrl + x/v
			if(evt.altKey || ((evt.ctrlKey || evt.metaKey) && (key != 'x' && key != 'v')) || key == dojo.keys.SHIFT){
				return; // throw out weird key combinations and spurious events
			}
			var doSearch = false;
			var searchFunction = "_startSearchFromInput";
			var pw = this._popupWidget;
			var dk = dojo.keys;
			var highlighted = null;
			this._prev_key_backspace = false;
			this._abortQuery();
			if(this._isShowingNow){
				pw.handleKey(key);
				highlighted = pw.getHighlightedOption();
			}
			switch(key){
				case dk.PAGE_DOWN:
				case dk.DOWN_ARROW:
				case dk.PAGE_UP:
				case dk.UP_ARROW:
					if(!this._isShowingNow){
						this._arrowPressed();
						doSearch = true;
						searchFunction = "_startSearchAll";
					}else{
						this._announceOption(highlighted);
					}
					dojo.stopEvent(evt);
					break;

				case dk.ENTER:
					// prevent submitting form if user presses enter. Also
					// prevent accepting the value if either Next or Previous
					// are selected
					if(highlighted){
						// only stop event on prev/next
						if(highlighted == pw.nextButton){
							this._nextSearch(1);
							dojo.stopEvent(evt);
							break;
						}else if(highlighted == pw.previousButton){
							this._nextSearch(-1);
							dojo.stopEvent(evt);
							break;
						}
					}else{
						// Update 'value' (ex: KY) according to currently displayed text
						this._setBlurValue(); // set value if needed
						this._setCaretPos(this.focusNode, this.focusNode.value.length); // move cursor to end and cancel highlighting
					}
					// default case:
					// prevent submit, but allow event to bubble
					evt.preventDefault();
					// fall through

				case dk.TAB:
					var newvalue = this.attr('displayedValue');
					//	if the user had More Choices selected fall into the
					//	_onBlur handler
					if(pw && (
						newvalue == pw._messages["previousMessage"] ||
						newvalue == pw._messages["nextMessage"])
					){
						break;
					}
					if(highlighted){
						this._selectOption();
					}
					if(this._isShowingNow){
						this._lastQuery = null; // in case results come back later
						this._hideResultList();
					}
					break;

				case ' ':
					if(highlighted){
						dojo.stopEvent(evt);
						this._selectOption();
						this._hideResultList();
					}else{
						doSearch = true;
					}
					break;

				case dk.ESCAPE:
					if(this._isShowingNow){
						dojo.stopEvent(evt);
						this._hideResultList();
					}
					break;

				case dk.DELETE:
				case dk.BACKSPACE:
					this._prev_key_backspace = true;
					doSearch = true;
					break;

				default:
					// Non char keys (F1-F12 etc..)  shouldn't open list.
					// Ascii characters and IME input (Chinese, Japanese etc.) should.
					// On IE and safari, IME input produces keycode == 229, and we simulate
					// it on firefox by attaching to compositionend event (see compositionend method)
					doSearch = typeof key == 'string' || key == 229;
			}
			if(doSearch){
				// need to wait a tad before start search so that the event
				// bubbles through DOM and we have value visible
				this.item = undefined; // undefined means item needs to be set
				this.searchTimer = setTimeout(dojo.hitch(this, searchFunction),1);
			}
		},

		_autoCompleteText: function(/*String*/ text){
			// summary:
			// 		Fill in the textbox with the first item from the drop down
			// 		list, and highlight the characters that were
			// 		auto-completed. For example, if user typed "CA" and the
			// 		drop down list appeared, the textbox would be changed to
			// 		"California" and "ifornia" would be highlighted.

			var fn = this.focusNode;

			// IE7: clear selection so next highlight works all the time
			dijit.selectInputText(fn, fn.value.length);
			// does text autoComplete the value in the textbox?
			var caseFilter = this.ignoreCase? 'toLowerCase' : 'substr';
			if(text[caseFilter](0).indexOf(this.focusNode.value[caseFilter](0)) == 0){
				var cpos = this._getCaretPos(fn);
				// only try to extend if we added the last character at the end of the input
				if((cpos+1) > fn.value.length){
					// only add to input node as we would overwrite Capitalisation of chars
					// actually, that is ok
					fn.value = text;//.substr(cpos);
					// visually highlight the autocompleted characters
					dijit.selectInputText(fn, cpos);
				}
			}else{
				// text does not autoComplete; replace the whole value and highlight
				fn.value = text;
				dijit.selectInputText(fn);
			}
		},

		_openResultList: function(/*Object*/ results, /*Object*/ dataObject){
			this._fetchHandle = null;
			if(	this.disabled ||
				this.readOnly ||
				(dataObject.query[this.searchAttr] != this._lastQuery)
			){
				return;
			}
			this._popupWidget.clearResultList();
			if(!results.length){
				this._hideResultList();
				return;
			}


			// Fill in the textbox with the first item from the drop down list,
			// and highlight the characters that were auto-completed. For
			// example, if user typed "CA" and the drop down list appeared, the
			// textbox would be changed to "California" and "ifornia" would be
			// highlighted.

			dataObject._maxOptions = this._maxOptions;
			var nodes = this._popupWidget.createOptions(
				results,
				dataObject,
				dojo.hitch(this, "_getMenuLabelFromItem")
			);

			// show our list (only if we have content, else nothing)
			this._showResultList();

			// #4091:
			//		tell the screen reader that the paging callback finished by
			//		shouting the next choice
			if(dataObject.direction){
				if(1 == dataObject.direction){
					this._popupWidget.highlightFirstOption();
				}else if(-1 == dataObject.direction){
					this._popupWidget.highlightLastOption();
				}
				this._announceOption(this._popupWidget.getHighlightedOption());
			}else if(this.autoComplete && !this._prev_key_backspace /*&& !dataObject.direction*/
				// when the user clicks the arrow button to show the full list,
				// startSearch looks for "*".
				// it does not make sense to autocomplete
				// if they are just previewing the options available.
				&& !/^[*]+$/.test(dataObject.query[this.searchAttr])){
					this._announceOption(nodes[1]); // 1st real item
			}
		},

		_showResultList: function(){
			this._hideResultList();
			this._arrowPressed();
			// hide the tooltip
			this.displayMessage("");

			// Position the list and if it's too big to fit on the screen then
			// size it to the maximum possible height
			// Our dear friend IE doesnt take max-height so we need to
			// calculate that on our own every time

			// TODO: want to redo this, see
			//		http://trac.dojotoolkit.org/ticket/3272
			//	and
			//		http://trac.dojotoolkit.org/ticket/4108


			// natural size of the list has changed, so erase old
			// width/height settings, which were hardcoded in a previous
			// call to this function (via dojo.marginBox() call)
			dojo.style(this._popupWidget.domNode, {width: "", height: ""});

			var best = this.open();
			// #3212:
			//		only set auto scroll bars if necessary prevents issues with
			//		scroll bars appearing when they shouldn't when node is made
			//		wider (fractional pixels cause this)
			var popupbox = dojo.marginBox(this._popupWidget.domNode);
			this._popupWidget.domNode.style.overflow =
				((best.h == popupbox.h) && (best.w == popupbox.w)) ? "hidden" : "auto";
			// #4134:
			//		borrow TextArea scrollbar test so content isn't covered by
			//		scrollbar and horizontal scrollbar doesn't appear
			var newwidth = best.w;
			if(best.h < this._popupWidget.domNode.scrollHeight){
				newwidth += 16;
			}
			dojo.marginBox(this._popupWidget.domNode, {
				h: best.h,
				w: Math.max(newwidth, this.domNode.offsetWidth)
			});
			
			// If we increased the width of drop down to match the width of ComboBox.domNode,
			// then need to reposition the drop down (wrapper) so (all of) the drop down still
			// appears underneath the ComboBox.domNode
			if(newwidth < this.domNode.offsetWidth){
				this._popupWidget.domNode.parentNode.style.left = dojo.position(this.domNode).x + "px";
			}

			dijit.setWaiState(this.comboNode, "expanded", "true");
		},

		_hideResultList: function(){
			this._abortQuery();
			if(this._isShowingNow){
				dijit.popup.close(this._popupWidget);
				this._arrowIdle();
				this._isShowingNow=false;
				dijit.setWaiState(this.comboNode, "expanded", "false");
				dijit.removeWaiState(this.focusNode,"activedescendant");
			}
		},

		_setBlurValue: function(){
			// if the user clicks away from the textbox OR tabs away, set the
			// value to the textbox value
			// #4617:
			//		if value is now more choices or previous choices, revert
			//		the value
			var newvalue=this.attr('displayedValue');
			var pw = this._popupWidget;
			if(pw && (
				newvalue == pw._messages["previousMessage"] ||
				newvalue == pw._messages["nextMessage"]
				)
			){
				this._setValueAttr(this._lastValueReported, true);
			}else if(typeof this.item == "undefined"){
				// Update 'value' (ex: KY) according to currently displayed text
				this.item = null;
				this.attr('displayedValue', newvalue);
			}else{
				if(this.value != this._lastValueReported){
					dijit.form._FormValueWidget.prototype._setValueAttr.call(this, this.value, true);
				}
				this._refreshState();
			}
		},

		_onBlur: function(){
			// summary:
			//		Called magically when focus has shifted away from this widget and it's drop down
			this._hideResultList();
			this._arrowIdle();
			this.inherited(arguments);
		},

		_setItemAttr: function(/*item*/ item, /*Boolean?*/ priorityChange, /*String?*/ displayedValue){
			// summary:
			//              Set the displayed valued in the input box, and the hidden value
			//              that gets submitted, based on a dojo.data store item.
			// description:
			//              Users shouldn't call this function; they should be calling
			//              attr('item', value)
			// tags:
			//              private
			if(!displayedValue){ displayedValue = this.labelFunc(item, this.store); }
			this.value = this._getValueField() != this.searchAttr? this.store.getIdentity(item) : displayedValue;
			this.item = item;
			dijit.form.ComboBox.superclass._setValueAttr.call(this, this.value, priorityChange, displayedValue);
		},

		_announceOption: function(/*Node*/ node){
			// summary:
			//		a11y code that puts the highlighted option in the textbox.
			//		This way screen readers will know what is happening in the
			//		menu.

			if(!node){
				return;
			}
			// pull the text value from the item attached to the DOM node
			var newValue;
			if( node == this._popupWidget.nextButton ||
				node == this._popupWidget.previousButton){
				newValue = node.innerHTML;
				this.item = undefined;
				this.value = '';
			}else{
				newValue = this.labelFunc(node.item, this.store);
				this.attr('item', node.item, false, newValue);
			}
			// get the text that the user manually entered (cut off autocompleted text)
			this.focusNode.value = this.focusNode.value.substring(0, this._lastInput.length);
			// set up ARIA activedescendant
			dijit.setWaiState(this.focusNode, "activedescendant", dojo.attr(node, "id"));
			// autocomplete the rest of the option to announce change
			this._autoCompleteText(newValue);
		},

		_selectOption: function(/*Event*/ evt){
			// summary:
			//		Menu callback function, called when an item in the menu is selected.
			if(evt){
				this._announceOption(evt.target);
			}
			this._hideResultList();
			this._setCaretPos(this.focusNode, this.focusNode.value.length);
			dijit.form._FormValueWidget.prototype._setValueAttr.call(this, this.value, true); // set this.value and fire onChange
		},

		_onArrowMouseDown: function(evt){
			// summary:
			//		Callback when arrow is clicked
			if(this.disabled || this.readOnly){
				return;
			}
			dojo.stopEvent(evt);
			this.focus();
			if(this._isShowingNow){
				this._hideResultList();
			}else{
				// forces full population of results, if they click
				// on the arrow it means they want to see more options
				this._startSearchAll();
			}
		},

		_startSearchAll: function(){
			this._startSearch('');
		},

		_startSearchFromInput: function(){
			this._startSearch(this.focusNode.value.replace(/([\\\*\?])/g, "\\$1"));
		},

		_getQueryString: function(/*String*/ text){
			return dojo.string.substitute(this.queryExpr, [text]);
		},

		_startSearch: function(/*String*/ key){
			if(!this._popupWidget){
				var popupId = this.id + "_popup";
				this._popupWidget = new dijit.form._ComboBoxMenu({
					onChange: dojo.hitch(this, this._selectOption),
					id: popupId
				});
				dijit.removeWaiState(this.focusNode,"activedescendant");
				dijit.setWaiState(this.textbox,"owns",popupId); // associate popup with textbox
			}
			// create a new query to prevent accidentally querying for a hidden
			// value from FilteringSelect's keyField
			var query = dojo.clone(this.query); // #5970
			this._lastInput = key; // Store exactly what was entered by the user.
			this._lastQuery = query[this.searchAttr] = this._getQueryString(key);
			// #5970: set _lastQuery, *then* start the timeout
			// otherwise, if the user types and the last query returns before the timeout,
			// _lastQuery won't be set and their input gets rewritten
			this.searchTimer=setTimeout(dojo.hitch(this, function(query, _this){
				this.searchTimer = null;
				var fetch = {
					queryOptions: {
						ignoreCase: this.ignoreCase,
						deep: true
					},
					query: query,
					onBegin: dojo.hitch(this, "_setMaxOptions"),
					onComplete: dojo.hitch(this, "_openResultList"),
					onError: function(errText){
						_this._fetchHandle = null;
						console.error('dijit.form.ComboBox: ' + errText);
						dojo.hitch(_this, "_hideResultList")();
					},
					start: 0,
					count: this.pageSize
				};
				dojo.mixin(fetch, _this.fetchProperties);
				this._fetchHandle = _this.store.fetch(fetch);

				var nextSearch = function(dataObject, direction){
					dataObject.start += dataObject.count*direction;
					// #4091:
					//		tell callback the direction of the paging so the screen
					//		reader knows which menu option to shout
					dataObject.direction = direction;
					this._fetchHandle = this.store.fetch(dataObject);
				};
				this._nextSearch = this._popupWidget.onPage = dojo.hitch(this, nextSearch, this._fetchHandle);
			}, query, this), this.searchDelay);
		},

		_setMaxOptions: function(size, request){
			 this._maxOptions = size;
		},

		_getValueField: function(){
			// summmary:
			//		Helper for postMixInProperties() to set this.value based on data inlined into the markup.
			//		Returns the attribute name in the item (in dijit.form._ComboBoxDataStore) to use as the value.
			return this.searchAttr;
		},

		/////////////// Event handlers /////////////////////

		_arrowPressed: function(){
			if(!this.disabled && !this.readOnly && this.hasDownArrow){
				dojo.addClass(this.downArrowNode, "dijitArrowButtonActive");
			}
		},

		_arrowIdle: function(){
			if(!this.disabled && !this.readOnly && this.hasDownArrow){
				dojo.removeClass(this.downArrowNode, "dojoArrowButtonPushed");
			}
		},

		// FIXME: For 2.0, rename to "_compositionEnd"
		compositionend: function(/*Event*/ evt){
			// summary:
			//		When inputting characters using an input method, such as
			//		Asian languages, it will generate this event instead of
			//		onKeyDown event.
			//		Note: this event is only triggered in FF (not in IE/safari)
			// tags:
			//		private

			// 229 is the code produced by IE and safari while pressing keys during
			// IME input mode
			this._onKeyPress({charOrCode: 229});
		},

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		constructor: function(){
			this.query={};
			this.fetchProperties={};
		},

		postMixInProperties: function(){
			if(!this.hasDownArrow){
				this.baseClass = "dijitTextBox";
			}
			if(!this.store){
				var srcNodeRef = this.srcNodeRef;

				// if user didn't specify store, then assume there are option tags
				this.store = new dijit.form._ComboBoxDataStore(srcNodeRef);

				// if there is no value set and there is an option list, set
				// the value to the first value to be consistent with native
				// Select

				// Firefox and Safari set value
				// IE6 and Opera set selectedIndex, which is automatically set
				// by the selected attribute of an option tag
				// IE6 does not set value, Opera sets value = selectedIndex
				if(	!this.value || (
						(typeof srcNodeRef.selectedIndex == "number") &&
						srcNodeRef.selectedIndex.toString() === this.value)
				){
					var item = this.store.fetchSelectedItem();
					if(item){
						var valueField = this._getValueField();
						this.value = valueField != this.searchAttr? this.store.getValue(item, valueField) : this.labelFunc(item, this.store);
					}
				}
			}
			this.inherited(arguments);
		},

		postCreate: function(){
			// summary:
			//		Subclasses must call this method from their postCreate() methods
			// tags:
			//		protected

			// find any associated label element and add to ComboBox node.
			var label=dojo.query('label[for="'+this.id+'"]');
			if(label.length){
				label[0].id = (this.id+"_label");
				var cn=this.comboNode;
				dijit.setWaiState(cn, "labelledby", label[0].id);

			}
			this.inherited(arguments);
		},

		uninitialize: function(){
			if(this._popupWidget && !this._popupWidget._destroyed){
				this._hideResultList();
				this._popupWidget.destroy();
			}
			this.inherited(arguments);
		},

		_getMenuLabelFromItem: function(/*Item*/ item){
			var label = this.labelAttr? this.store.getValue(item, this.labelAttr) : this.labelFunc(item, this.store);
			var labelType = this.labelType;
			// If labelType is not "text" we don't want to screw any markup ot whatever.
			if(this.highlightMatch != "none" && this.labelType == "text" && this._lastInput){
				label = this.doHighlight(label, this._escapeHtml(this._lastInput));
				labelType = "html";
			}
			return {html: labelType == "html", label: label};
		},

		doHighlight: function(/*String*/label, /*String*/find){
			// summary:
			//		Highlights the string entered by the user in the menu.  By default this
			//		highlights the first occurence found. Override this method
			//		to implement your custom highlighing.
			// tags:
			//		protected

			// Add greedy when this.highlightMatch == "all"
			var modifiers = "i"+(this.highlightMatch == "all"?"g":"");
			var escapedLabel = this._escapeHtml(label);
			find = dojo.regexp.escapeString(find); // escape regexp special chars
			var ret = escapedLabel.replace(new RegExp("(^|\\s)("+ find +")", modifiers),
					'$1<span class="dijitComboBoxHighlightMatch">$2</span>');
			return ret;// returns String, (almost) valid HTML (entities encoded)
		},

		_escapeHtml: function(/*string*/str){
			// TODO Should become dojo.html.entities(), when exists use instead
			// summary:
			//		Adds escape sequences for special characters in XML: &<>"'
			str = String(str).replace(/&/gm, "&amp;").replace(/</gm, "&lt;")
				.replace(/>/gm, "&gt;").replace(/"/gm, "&quot;");
			return str; // string
		},

		open: function(){
			// summary:
			//		Opens the drop down menu.  TODO: rename to _open.
			// tags:
			//		private
			this._isShowingNow=true;
			return dijit.popup.open({
				popup: this._popupWidget,
				around: this.domNode,
				parent: this
			});
		},

		reset: function(){
			// Overrides the _FormWidget.reset().
			// Additionally reset the .item (to clean up).
			this.item = null;
			this.inherited(arguments);
		},

		labelFunc: function(/*item*/ item, /*dojo.data.store*/ store){
			// summary:
			//              Computes the label to display based on the dojo.data store item.
			// returns:
			//              The label that the ComboBox should display
			// tags:
			//              private

			// Use toString() because XMLStore returns an XMLItem whereas this
			// method is expected to return a String (#9354)
			return store.getValue(item, this.searchAttr).toString(); // String
		}
	}
);

dojo.declare(
	"dijit.form._ComboBoxMenu",
	[dijit._Widget, dijit._Templated],
	{
		// summary:
		//		Focus-less menu for internal use in `dijit.form.ComboBox`
		// tags:
		//		private

		templateString: "<ul class='dijitReset dijitMenu' dojoAttachEvent='onmousedown:_onMouseDown,onmouseup:_onMouseUp,onmouseover:_onMouseOver,onmouseout:_onMouseOut' tabIndex='-1' style='overflow: \"auto\"; overflow-x: \"hidden\";'>"
				+"<li class='dijitMenuItem dijitMenuPreviousButton' dojoAttachPoint='previousButton' waiRole='option'></li>"
				+"<li class='dijitMenuItem dijitMenuNextButton' dojoAttachPoint='nextButton' waiRole='option'></li>"
			+"</ul>",

		// _messages: Object
		//		Holds "next" and "previous" text for paging buttons on drop down
		_messages: null,

		postMixInProperties: function(){
			this._messages = dojo.i18n.getLocalization("dijit.form", "ComboBox", this.lang);
			this.inherited(arguments);
		},

		_setValueAttr: function(/*Object*/ value){
			this.value = value;
			this.onChange(value);
		},

		// stubs
		onChange: function(/*Object*/ value){
			// summary:
			//		Notifies ComboBox/FilteringSelect that user clicked an option in the drop down menu.
			//		Probably should be called onSelect.
			// tags:
			//		callback
		},
		onPage: function(/*Number*/ direction){
			// summary:
			//		Notifies ComboBox/FilteringSelect that user clicked to advance to next/previous page.
			// tags:
			//		callback
		},

		postCreate: function(){
			// fill in template with i18n messages
			this.previousButton.innerHTML = this._messages["previousMessage"];
			this.nextButton.innerHTML = this._messages["nextMessage"];
			this.inherited(arguments);
		},

		onClose: function(){
			// summary:
			//		Callback from dijit.popup code to this widget, notifying it that it closed
			// tags:
			//		private
			this._blurOptionNode();
		},

		_createOption: function(/*Object*/ item, labelFunc){
			// summary:
			//		Creates an option to appear on the popup menu subclassed by
			//		`dijit.form.FilteringSelect`.

			var labelObject = labelFunc(item);
			var menuitem = dojo.doc.createElement("li");
			dijit.setWaiRole(menuitem, "option");
			if(labelObject.html){
				menuitem.innerHTML = labelObject.label;
			}else{
				menuitem.appendChild(
					dojo.doc.createTextNode(labelObject.label)
				);
			}
			// #3250: in blank options, assign a normal height
			if(menuitem.innerHTML == ""){
				menuitem.innerHTML = "&nbsp;";
			}
			menuitem.item=item;
			return menuitem;
		},

		createOptions: function(results, dataObject, labelFunc){
			// summary:
			//		Fills in the items in the drop down list
			// results:
			//		Array of dojo.data items
			// dataObject:
			//		dojo.data store
			// labelFunc:
			//		Function to produce a label in the drop down list from a dojo.data item

			//this._dataObject=dataObject;
			//this._dataObject.onComplete=dojo.hitch(comboBox, comboBox._openResultList);
			// display "Previous . . ." button
			this.previousButton.style.display = (dataObject.start == 0) ? "none" : "";
			dojo.attr(this.previousButton, "id", this.id + "_prev");
			// create options using _createOption function defined by parent
			// ComboBox (or FilteringSelect) class
			// #2309:
			//		iterate over cache nondestructively
			dojo.forEach(results, function(item, i){
				var menuitem = this._createOption(item, labelFunc);
				menuitem.className = "dijitReset dijitMenuItem";
				dojo.attr(menuitem, "id", this.id + i);
				this.domNode.insertBefore(menuitem, this.nextButton);
			}, this);
			// display "Next . . ." button
			var displayMore = false;
			//Try to determine if we should show 'more'...
			if(dataObject._maxOptions && dataObject._maxOptions != -1){
				if((dataObject.start + dataObject.count) < dataObject._maxOptions){
					displayMore = true;
				}else if((dataObject.start + dataObject.count) > (dataObject._maxOptions - 1)){
					//Weird return from a datastore, where a start + count > maxOptions
					// implies maxOptions isn't really valid and we have to go into faking it.
					//And more or less assume more if count == results.length
					if(dataObject.count == results.length){
						displayMore = true;
					}
				}
			}else if(dataObject.count == results.length){
				//Don't know the size, so we do the best we can based off count alone.
				//So, if we have an exact match to count, assume more.
				displayMore = true;
			}

			this.nextButton.style.display = displayMore ? "" : "none";
			dojo.attr(this.nextButton,"id", this.id + "_next");
			return this.domNode.childNodes;
		},

		clearResultList: function(){
			// summary:
			//		Clears the entries in the drop down list, but of course keeps the previous and next buttons.
			while(this.domNode.childNodes.length>2){
				this.domNode.removeChild(this.domNode.childNodes[this.domNode.childNodes.length-2]);
			}
		},

		_onMouseDown: function(/*Event*/ evt){
			dojo.stopEvent(evt);
		},

		_onMouseUp: function(/*Event*/ evt){
			if(evt.target === this.domNode){
				return;
			}else if(evt.target == this.previousButton){
				this.onPage(-1);
			}else if(evt.target == this.nextButton){
				this.onPage(1);
			}else{
				var tgt = evt.target;
				// while the clicked node is inside the div
				while(!tgt.item){
					// recurse to the top
					tgt = tgt.parentNode;
				}
				this._setValueAttr({ target: tgt }, true);
			}
		},

		_onMouseOver: function(/*Event*/ evt){
			if(evt.target === this.domNode){ return; }
			var tgt = evt.target;
			if(!(tgt == this.previousButton || tgt == this.nextButton)){
				// while the clicked node is inside the div
				while(!tgt.item){
					// recurse to the top
					tgt = tgt.parentNode;
				}
			}
			this._focusOptionNode(tgt);
		},

		_onMouseOut: function(/*Event*/ evt){
			if(evt.target === this.domNode){ return; }
			this._blurOptionNode();
		},

		_focusOptionNode: function(/*DomNode*/ node){
			// summary:
			//		Does the actual highlight.
			if(this._highlighted_option != node){
				this._blurOptionNode();
				this._highlighted_option = node;
				dojo.addClass(this._highlighted_option, "dijitMenuItemSelected");
			}
		},

		_blurOptionNode: function(){
			// summary:
			//		Removes highlight on highlighted option.
			if(this._highlighted_option){
				dojo.removeClass(this._highlighted_option, "dijitMenuItemSelected");
				this._highlighted_option = null;
			}
		},

		_highlightNextOption: function(){
			// summary:
			// 		Highlight the item just below the current selection.
			// 		If nothing selected, highlight first option.

			// because each press of a button clears the menu,
			// the highlighted option sometimes becomes detached from the menu!
			// test to see if the option has a parent to see if this is the case.
			var fc = this.domNode.firstChild;
			if(!this.getHighlightedOption()){
				this._focusOptionNode(fc.style.display == "none" ? fc.nextSibling : fc);
			}else{
				var ns = this._highlighted_option.nextSibling;
				if(ns && ns.style.display != "none"){
					this._focusOptionNode(ns);
				}
			}
			// scrollIntoView is called outside of _focusOptionNode because in IE putting it inside causes the menu to scroll up on mouseover
			dijit.scrollIntoView(this._highlighted_option);
		},

		highlightFirstOption: function(){
			// summary:
			// 		Highlight the first real item in the list (not Previous Choices).
			this._focusOptionNode(this.domNode.firstChild.nextSibling);
			dijit.scrollIntoView(this._highlighted_option);
		},

		highlightLastOption: function(){
			// summary:
			// 		Highlight the last real item in the list (not More Choices).
			this._focusOptionNode(this.domNode.lastChild.previousSibling);
			dijit.scrollIntoView(this._highlighted_option);
		},

		_highlightPrevOption: function(){
			// summary:
			// 		Highlight the item just above the current selection.
			// 		If nothing selected, highlight last option (if
			// 		you select Previous and try to keep scrolling up the list).
			var lc = this.domNode.lastChild;
			if(!this.getHighlightedOption()){
				this._focusOptionNode(lc.style.display == "none" ? lc.previousSibling : lc);
			}else{
				var ps = this._highlighted_option.previousSibling;
				if(ps && ps.style.display != "none"){
					this._focusOptionNode(ps);
				}
			}
			dijit.scrollIntoView(this._highlighted_option);
		},

		_page: function(/*Boolean*/ up){
			// summary:
			//		Handles page-up and page-down keypresses

			var scrollamount = 0;
			var oldscroll = this.domNode.scrollTop;
			var height = dojo.style(this.domNode, "height");
			// if no item is highlighted, highlight the first option
			if(!this.getHighlightedOption()){
				this._highlightNextOption();
			}
			while(scrollamount<height){
				if(up){
					// stop at option 1
					if(!this.getHighlightedOption().previousSibling ||
						this._highlighted_option.previousSibling.style.display == "none"){
						break;
					}
					this._highlightPrevOption();
				}else{
					// stop at last option
					if(!this.getHighlightedOption().nextSibling ||
						this._highlighted_option.nextSibling.style.display == "none"){
						break;
					}
					this._highlightNextOption();
				}
				// going backwards
				var newscroll=this.domNode.scrollTop;
				scrollamount+=(newscroll-oldscroll)*(up ? -1:1);
				oldscroll=newscroll;
			}
		},

		pageUp: function(){
			// summary:
			//		Handles pageup keypress.
			//		TODO: just call _page directly from handleKey().
			// tags:
			//		private
			this._page(true);
		},

		pageDown: function(){
			// summary:
			//		Handles pagedown keypress.
			//		TODO: just call _page directly from handleKey().
			// tags:
			//		private
			this._page(false);
		},

		getHighlightedOption: function(){
			// summary:
			//		Returns the highlighted option.
			var ho = this._highlighted_option;
			return (ho && ho.parentNode) ? ho : null;
		},

		handleKey: function(key){
			switch(key){
				case dojo.keys.DOWN_ARROW:
					this._highlightNextOption();
					break;
				case dojo.keys.PAGE_DOWN:
					this.pageDown();
					break;
				case dojo.keys.UP_ARROW:
					this._highlightPrevOption();
					break;
				case dojo.keys.PAGE_UP:
					this.pageUp();
					break;
			}
		}
	}
);

dojo.declare(
	"dijit.form.ComboBox",
	[dijit.form.ValidationTextBox, dijit.form.ComboBoxMixin],
	{
		// summary:
		//		Auto-completing text box, and base class for dijit.form.FilteringSelect.
		//
		// description:
		//		The drop down box's values are populated from an class called
		//		a data provider, which returns a list of values based on the characters
		//		that the user has typed into the input box.
		//		If OPTION tags are used as the data provider via markup,
		//		then the OPTION tag's child text node is used as the widget value
		//		when selected.  The OPTION tag's value attribute is ignored.
		//		To set the default value when using OPTION tags, specify the selected
		//		attribute on 1 of the child OPTION tags.
		//
		//		Some of the options to the ComboBox are actually arguments to the data
		//		provider.

		_setValueAttr: function(/*String*/ value, /*Boolean?*/ priorityChange, /*String?*/ displayedValue){
			// summary:
			//		Hook so attr('value', value) works.
			// description:
			//		Sets the value of the select.
			this.item = null; // value not looked up in store
			if(!value){ value = ''; } // null translates to blank
			dijit.form.ValidationTextBox.prototype._setValueAttr.call(this, value, priorityChange, displayedValue);
		}
	}
);

dojo.declare("dijit.form._ComboBoxDataStore", null, {
	// summary:
	//		Inefficient but small data store specialized for inlined `dijit.form.ComboBox` data
	//
	// description:
	//		Provides a store for inlined data like:
	//
	//	|	<select>
	//	|		<option value="AL">Alabama</option>
	//	|		...
	//
	//		Actually. just implements the subset of dojo.data.Read/Notification
	//		needed for ComboBox and FilteringSelect to work.
	//
	//		Note that an item is just a pointer to the <option> DomNode.

	constructor: function( /*DomNode*/ root){
		this.root = root;

		dojo.query("> option", root).forEach(function(node){
			//	TODO: this was added in #3858 but unclear why/if it's needed;  doesn't seem to be.
			//	If it is needed then can we just hide the select itself instead?
			//node.style.display="none";
			node.innerHTML = dojo.trim(node.innerHTML);
		});

	},

	getValue: function(	/* item */ item,
						/* attribute-name-string */ attribute,
						/* value? */ defaultValue){
		return (attribute == "value") ? item.value : (item.innerText || item.textContent || '');
	},

	isItemLoaded: function(/* anything */ something){
		return true;
	},

	getFeatures: function(){
		return {"dojo.data.api.Read": true, "dojo.data.api.Identity": true};
	},

	_fetchItems: function(	/* Object */ args,
							/* Function */ findCallback,
							/* Function */ errorCallback){
		// summary:
		//		See dojo.data.util.simpleFetch.fetch()
		if(!args.query){ args.query = {}; }
		if(!args.query.name){ args.query.name = ""; }
		if(!args.queryOptions){ args.queryOptions = {}; }
		var matcher = dojo.data.util.filter.patternToRegExp(args.query.name, args.queryOptions.ignoreCase),
			items = dojo.query("> option", this.root).filter(function(option){
				return (option.innerText || option.textContent || '').match(matcher);
			} );
		if(args.sort){
			items.sort(dojo.data.util.sorter.createSortFunction(args.sort, this));
		}
		findCallback(items, args);
	},

	close: function(/*dojo.data.api.Request || args || null */ request){
		return;
	},

	getLabel: function(/* item */ item){
		return item.innerHTML;
	},

	getIdentity: function(/* item */ item){
		return dojo.attr(item, "value");
	},

	fetchItemByIdentity: function(/* Object */ args){
		// summary:
		//		Given the identity of an item, this method returns the item that has
		//		that identity through the onItem callback.
		//		Refer to dojo.data.api.Identity.fetchItemByIdentity() for more details.
		//
		// description:
		//		Given arguments like:
		//
		//	|		{identity: "CA", onItem: function(item){...}
		//
		//		Call `onItem()` with the DOM node `<option value="CA">California</option>`
		var item = dojo.query("option[value='" + args.identity + "']", this.root)[0];
		args.onItem(item);
	},

	fetchSelectedItem: function(){
		// summary:
		//		Get the option marked as selected, like `<option selected>`.
		//		Not part of dojo.data API.
		var root = this.root,
			si = root.selectedIndex;
		return dojo.query("> option:nth-child(" +
			(si != -1 ? si+1 : 1) + ")",
			root)[0];	// dojo.data.Item
	}
});
//Mix in the simple fetch implementation to this class.
dojo.extend(dijit.form._ComboBoxDataStore,dojo.data.util.simpleFetch);

}

if(!dojo._hasResource["dijit.form.FilteringSelect"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.FilteringSelect"] = true;
dojo.provide("dijit.form.FilteringSelect");



dojo.declare(
	"dijit.form.FilteringSelect",
	[dijit.form.MappedTextBox, dijit.form.ComboBoxMixin],
	{
		// summary:
		//		An enhanced version of the HTML SELECT tag, populated dynamically
		//
		// description:
		//		An enhanced version of the HTML SELECT tag, populated dynamically. It works
		//		very nicely with very large data sets because it can load and page data as needed.
		//		It also resembles ComboBox, but does not allow values outside of the provided ones.
		//		If OPTION tags are used as the data provider via markup, then the
		//		OPTION tag's child text node is used as the displayed value when selected
		//		while the OPTION tag's value attribute is used as the widget value on form submit.
		//		To set the default value when using OPTION tags, specify the selected
		//		attribute on 1 of the child OPTION tags.
		//
		//		Similar features:
		//			- There is a drop down list of possible values.
		//			- You can only enter a value from the drop down list.  (You can't
		//				enter an arbitrary value.)
		//			- The value submitted with the form is the hidden value (ex: CA),
		//				not the displayed value a.k.a. label (ex: California)
		//
		//		Enhancements over plain HTML version:
		//			- If you type in some text then it will filter down the list of
		//				possible values in the drop down list.
		//			- List can be specified either as a static list or via a javascript
		//				function (that can get the list from a server)

		_isvalid: true,

		// required: Boolean
		//		True (default) if user is required to enter a value into this field.
		required: true,

		_lastDisplayedValue: "",

		isValid: function(){
			// Overrides ValidationTextBox.isValid()
			return this._isvalid || (!this.required && this.attr('displayedValue') == ""); // #5974
		},

		_callbackSetLabel: function(	/*Array*/ result,
						/*Object*/ dataObject,
						/*Boolean?*/ priorityChange){
			// summary:
			//		Callback function that dynamically sets the label of the
			//		ComboBox

			// setValue does a synchronous lookup,
			// so it calls _callbackSetLabel directly,
			// and so does not pass dataObject
			// still need to test against _lastQuery in case it came too late
			if((dataObject && dataObject.query[this.searchAttr] != this._lastQuery) || (!dataObject && result.length && this.store.getIdentity(result[0]) != this._lastQuery)){
				return;
			}
			if(!result.length){
				//#3268: do nothing on bad input
				//#3285: change CSS to indicate error
				this.valueNode.value = "";
				dijit.form.TextBox.superclass._setValueAttr.call(this, "", priorityChange || (priorityChange === undefined && !this._focused));
				this._isvalid = false;
				this.validate(this._focused);
				this.item = null;
			}else{
				this.attr('item', result[0], priorityChange);
			}
		},

		_openResultList: function(/*Object*/ results, /*Object*/ dataObject){
			// Overrides ComboBox._openResultList()

			// #3285: tap into search callback to see if user's query resembles a match
			if(dataObject.query[this.searchAttr] != this._lastQuery){
				return;
			}
			this._isvalid = results.length != 0; // FIXME: should this be greater-than?
			this.validate(true);
			dijit.form.ComboBoxMixin.prototype._openResultList.apply(this, arguments);
		},

		_getValueAttr: function(){
			// summary:
			//		Hook for attr('value') to work.

			// don't get the textbox value but rather the previously set hidden value.
			// Use this.valueNode.value which isn't always set for other MappedTextBox widgets until blur
			return this.valueNode.value;
		},

		_getValueField: function(){
			// Overrides ComboBox._getValueField()
			return "value";
		},

		_setValueAttr: function(/*String*/ value, /*Boolean?*/ priorityChange){
			// summary:
			//		Hook so attr('value', value) works.
			// description:
			//		Sets the value of the select.
			//		Also sets the label to the corresponding value by reverse lookup.
			if(!this._onChangeActive){ priorityChange = null; }
			this._lastQuery = value;

			if(value === null || value === ''){
				this._setDisplayedValueAttr('', priorityChange);
				return;
			}

			//#3347: fetchItemByIdentity if no keyAttr specified
			var self = this;
			this.store.fetchItemByIdentity({
				identity: value,
				onItem: function(item){
					self._callbackSetLabel([item], undefined, priorityChange);
				}
			});
		},

		_setItemAttr: function(/*item*/ item, /*Boolean?*/ priorityChange, /*String?*/ displayedValue){
			// summary:
			//		Set the displayed valued in the input box, and the hidden value
			//		that gets submitted, based on a dojo.data store item.
			// description:
			//		Users shouldn't call this function; they should be calling
			//		attr('item', value)
			// tags:
			//		private
			this._isvalid = true;
			this.inherited(arguments);
			this.valueNode.value = this.value;
			this._lastDisplayedValue = this.textbox.value;
		},

		_getDisplayQueryString: function(/*String*/ text){
			return text.replace(/([\\\*\?])/g, "\\$1");
		},

		_setDisplayedValueAttr: function(/*String*/ label, /*Boolean?*/ priorityChange){
			// summary:
			//		Hook so attr('displayedValue', label) works.
			// description:
			//		Sets textbox to display label. Also performs reverse lookup
			//		to set the hidden value.

			// When this is called during initialization it'll ping the datastore
			// for reverse lookup, and when that completes (after an XHR request)
			// will call setValueAttr()... but that shouldn't trigger an onChange()
			// event, even when it happens after creation has finished
			if(!this._created){
				priorityChange = false;
			}

			if(this.store){
				this._hideResultList();
				var query = dojo.clone(this.query); // #6196: populate query with user-specifics
				// escape meta characters of dojo.data.util.filter.patternToRegExp().
				this._lastQuery = query[this.searchAttr] = this._getDisplayQueryString(label);
				// if the label is not valid, the callback will never set it,
				// so the last valid value will get the warning textbox set the
				// textbox value now so that the impending warning will make
				// sense to the user
				this.textbox.value = label;
				this._lastDisplayedValue = label;
				var _this = this;
				var fetch = {
					query: query,
					queryOptions: {
						ignoreCase: this.ignoreCase,
						deep: true
					},
					onComplete: function(result, dataObject){
						_this._fetchHandle = null;
						dojo.hitch(_this, "_callbackSetLabel")(result, dataObject, priorityChange);
					},
					onError: function(errText){
						_this._fetchHandle = null;
						console.error('dijit.form.FilteringSelect: ' + errText);
						dojo.hitch(_this, "_callbackSetLabel")([], undefined, false);
					}
				};
				dojo.mixin(fetch, this.fetchProperties);
				this._fetchHandle = this.store.fetch(fetch);
			}
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			this._isvalid = !this.required;
		},

		undo: function(){
			this.attr('displayedValue', this._lastDisplayedValue);
		}
	}
);

}

if(!dojo._hasResource["xwt.widget.form.FilteringSelect"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.form.FilteringSelect"] = true;
/*******************************************************************************
 * Copyright (c) 2009-2011 Cisco Systems, Inc. All rights reserved.
 * 
 * @fileoverview The XWT FilteringSelect widget complies with Kubrick guidelines
 *               and incorporates XMP UE Specifications.
 * 
 * @author Dennis Park denpark@cisco.com
 * 
 * @version 0.1
 ******************************************************************************/
dojo.provide("xwt.widget.form.FilteringSelect");



dojo.declare("xwt.widget.form.FilteringSelect", dijit.form.FilteringSelect,
{
		// summary:
		//		The Dropdown List widget is a combination of a dropdown list or list box and a single-line text input field.
	
		// description:
		//		The Dropdown List widget is a combination of a dropdown list or list box and a single-line text input field. 
		//		A dropdown list requires users to select a single value from a list of predefined 
		//		values. It differs from a combo box in that users are constrained to a value from 
		//		the list. Users cannot specify values that do not already exist in the list.
		//
		// example:
		//	To create FilteringSelect using HTML markup:
		//	|  <div dojoType="dojo.data.ItemFileReadStore" url="data/states.json" jsId="comboStore"></div>
		//	|  <input dojoType="xwt.widget.form.FilteringSelect"
		//	|    value="California"
		//	|    store="comboStore"
		//	|    searchAttr="name"
		//	|    name="state"
		//	|    id="stateInput" />
	
		baseClass : "xwtComboBox dijitComboBox",

		// autoComplete: Boolean
		// Set to false because the UX specifications do not ask for auto-complete.
		autoComplete: false,
		
		// highlightMatch: String
		//		This parameter determines the highlighting behavior of
		//		matching items in the result list.  The possible values are: "first", "all",
		//		or "none".	Default value: "first".
		highlightMatch: "first",
		
		// queryExpr: String
		//		This parameter specifies a regular expression that will be matched when text is 
		//		typed into the text field of the Dropdown List/FilteringSelect.  The default pattern 
		//		will match starting from the beginning of the item text. 
		//		To match text contained anywhere in the text, use `*$\{0}*`.
		//		queryExpr: '$\{0}*' is the default query expression which, again,
		//		is the 'starts with' match. Default value: "$\{0}*".
		queryExpr: "${0}*",     // "starts with" match
		
		_isvalidsubset: true,
		
		_isValidSubset: function(){
			return this._isvalidsubset;	
		},
		// when user click textinput
		onTextboxClickEvent: function (/*Event*/e){
			//Summary:
			//	Event generated on clicking the textbox.
			// e: Event
			//	The event triggered when the textbox is clicked.
			e.target.blur();
			this._onArrowMouseDown(e);
			e.preventDefault();
		},

		// not implemented yet
		onItemSelectedEvent: function (/*Event*/e){
			//Summary:
			//	Event generated on selection of an item.
			// e: Event
			//	The Event that  triggered when Item gets selected.
			// e.target.blur();
		},
		
		
		_arrowIdle: function(){
			if(!this.disabled && !this.readOnly && this.hasDownArrow){
				dojo.removeClass(this.downArrowNode, "dojoArrowButtonPushed");
				dojo.removeClass(this.downArrowNode, "downArrowPressed");
			}
		},
		
		_arrowPressed: function(){
			if(!this.disabled && !this.readOnly && this.hasDownArrow){
				dojo.addClass(this.downArrowNode, "dijitArrowButtonActive");
				dojo.addClass(this.downArrowNode, "downArrowPressed");
			}
		},
		
		
		
	_openResultList: function(/* Object */ results, /* Object */ dataObject){
			// summary:
			// 	Implement "scroll into view": The first selected item in the
			//	dropdown part of the list will be selected and if not visible, scrolled
			//	into the visible area.
			// tags:
			// 	protected extension
			
			
			/**
			 * SP#20598: Because the standard combobox does not keep track of
			 * which items match the user's input, this version will track the
			 * matched Items in the matchedItems array. Every time
			 * _openResultList we need to reset it as the contents of the menu
			 * are about to be re-built.
			 */
			this.matchedItems = [];
			
			/**
			 * SP#20598: _matchedFocusIndex keeps track of which item the user
			 * has selected using the arrow keys. This value is later
			 * manipulated in _onKeyPress.
			 */
			this._matchedFocusIndex = -1;
			
			/**
			 * SP#20598: We need to change _createOption to keep track of the
			 * menu items that match the user's input string. If we find a match
			 * then we place the DOM node for the item in the
			 * comboBox.matchedItems array.
			 */
			if(!this._createOptionOrig) {
				this._createOptionOrig = this._popupWidget._createOption;
				var createOptionOrig = this._createOptionOrig;
				var comboBox = this;
				this._popupWidget._createOption = function(/* Object */ item, labelFunc) {
						var labelObject = labelFunc(item);
						var menuitem = dojo.doc.createElement("li");
						dijit.setWaiRole(menuitem, "option");
						if(labelObject.html){
							menuitem.innerHTML = labelObject.label;
						}else{
							menuitem.appendChild(
								dojo.doc.createTextNode(labelObject.label)
							);
						}
						// #3250: in blank options, assign a normal height
						if(menuitem.innerHTML === ""){
							menuitem.innerHTML = "&nbsp;";
						}
						menuitem.item=item;
						if(labelObject.matchQuery) {
							comboBox.matchedItems.push(menuitem);
						}
						return menuitem;
				};
			}
		
			this.inherited(arguments);	

			try{
				// this throws an error for some reason
				var _selectedItem = this._getSelectedItem();			
				this._isvalidsubset = this._isvalid;
				this._isvalid = !!_selectedItem;
	
	
				if(_selectedItem){
					if(this._isShowingNow){
						this._popupWidget.domNode.scrollTop = this._popupWidget.domNode.scrollHeight;
						dijit.scrollIntoView(_selectedItem);
						this._popupWidget._focusOptionNode(_selectedItem);
	
					}
				}else {
					var _highlightedNodes = dojo.query(".dijitComboBoxHighlightMatch",this._popupWidget.domNode);
					if(_highlightedNodes.length > 0){
						this._popupWidget.domNode.scrollTop = this._popupWidget.domNode.scrollHeight;
						dijit.scrollIntoView(_highlightedNodes[0]);
						this._focusScrollOptionNode(_highlightedNodes[0]);
					}
				}
			}catch(e){
				console.error(e);
			}
		},
	
	doHighlight: function(/* String */label, /* String */find){
		// summary:
		// 	Implement custom highlighting.
		// tags:
		// 	protected extension
		// label: String
		//	The label that gets highlighted
		// find : String
		// 	The string that needs to be searched.

		// Add "greedy" if this.highlightMatch=="all".
		var modifiers = "i"+(this.highlightMatch=="all"?"g":"");
		var escapedLabel = this._escapeHtml(label);
		find = dojo.regexp.escapeString(find); // escape regexp special chars

		var ret;
		if (this.highlightMatch=="all") {
			// console.debug('all')
			ret = escapedLabel.replace(new RegExp("(|\\s)("+ find +")", modifiers),
				'$1<span class="dijitComboBoxHighlightMatch">$2</span>');
		}else{
			// console.debug('highlightMatch: ' + this.highlightMatch);
			// ret = escapedLabel.replace(new RegExp("(^|\\s)("+ find +")",
			// modifiers),
			ret = escapedLabel.replace(new RegExp("(^)("+ find +")", modifiers),
			'$1<span class="dijitComboBoxHighlightMatch">$2</span>');
		}
		return ret;// returns String, (almost) valid HTML (entities encoded)
	},
	
	_focusScrollOptionNode: function(/* DomNode */ node){
			// summary:
			//	Does the actual highlighting.
			if(this.scrollToHighlightedOption != node){
				this._blurScrollOptionNode();
				this.scrollToHighlightedOption = node;
				dojo.addClass(this.scrollToHighlightedOption.parentNode, "dijitMenuItemSelected");
			}
		},

		_blurScrollOptionNode: function(){
			// summary:
			//	Removes the highlight on a highlighted option.
			if(this.scrollToHighlightedOption != null && this.scrollToHighlightedOption.parentNode != null){
				dojo.removeClass(this.scrollToHighlightedOption.parentNode, "dijitMenuItemSelected");
				this.scrollToHighlightedOption = null;
			}
		},
		_getSelectedItem: function(){
			// summary:
			//	Returns the selected item.
			var _pw = this._popupWidget;
			var _selectionLabel = this.attr('displayedValue');
			var _items = _pw.domNode.children;
			
			var _nItems = _items.length;
			// this.store.getValue()
			for(var i = 1; i < _nItems-1; i++){
				var _labelAttr = ""; 
				if(this.labelAttr && this.labelAttr !== ""){
					_labelAttr = this.labelAttr;	
				}else{
					_labelAttr = this.searchAttr; 
				}
				
				var _itemName = "";

				// -----------------------------------------------------------------
				//http://nmtg-jira.cisco.com/jira/browse/XMPGUI-217
				//http://nmtg-jira.cisco.com/jira/browse/XMPGUI-218
	
	//			if(typeof(_items[i].item[_labelAttr]) == "string"){
	//				_itemName = _items[i].item[_labelAttr];
	//			}else{
	//				_itemName = _items[i].item[_labelAttr][0];
	//			}
				
				if(dojo.isIE){
					_itemName = _items[i].innerHTML;
				}
				else{
					_itemName = _items[i].textContent;
				}
	
				// -----------------------------------------------------------------
					
				if(_itemName == _selectionLabel){
					return _items[i];
				}
			}
			return null;
		},
		
		startup: function(){
			// summary:
			// 	Override the default Dojo Widget startup method. See
			// 	the Dojo docs for a complete description.
			// tags:
			// 	extension
			this.inherited(arguments);	
			
//			
//			var _mb = dojo.marginBox(this.domNode);
//			var _leftRightBorders = 2;
//			var _leftRightMargins = 16;			
//			var _offset = _leftRightBorders + _leftRightMargins;
//			
//			var _rightPadding;
//			if(_mb.w > 160){
//				_rightPadding = 4;	
//			}else{
//				_rightPadding = 9;
//			}
//			var _width = _mb.w - _offset;			
//			var _width = _width + _rightPadding;
//			
//			if(_width > 0){
//				dojo.style(this.domNode, {"width":  _width+ "px"});
//			}
			
//			console.log("width:  " + _width);
			
			//var _width = parseInt(node.w);
			
			// 160 px seems to be the width where the combo box's scroll bar
			// is rendered properly. After that point, the combo box's drop
			// down is not inline with the down arrow.
//			if(width > 160){		
//				var _scrollBarConstant = 0;
//				var newWidth =  width + _scrollBarConstant;
//				dojo.style(this.domNode, {"width":  newWidth+ "px"});
//			}
			// this._hideResultList= function(){};
		},	
		
		
		
		_startSearch: function(/* String */ key){
			this.inherited(arguments);
			//dojo.addClass(this._popupWidget.domNode,"xwtComboBoxPopup");
			dojo.addClass(this._popupWidget.domNode,this.getPopupClass());			
			
		},
	
	getPopupClass : function(){
			//Summary:
			//	Returns the combo box popup
			//Description:
			//	This API is used to get the instance of a
			//	combobox popup widget.
			//return: Instance
			
			return "xwtComboBoxPopup";
		},
	
	
	/**
	 * SP#20598 adding funcitonality to _onKeyPress to scroll through matched
	 * items when the user used the up and down arrow keys they will scroll
	 * through only those items that match the user's input.
	 */
	
	_onKeyPress: function(/* Event */ evt) {
			var key = evt.charOrCode;
			var dk = dojo.keys;
		
			if(this._popupWidget && this.matchedItems && this.matchedItems.length > 0) {
				var oldIndex = this._matchedFocusIndex;
				switch(key) {
					case dk.DOWN_ARROW:
						this._matchedFocusIndex++;
					break;
					case dk.UP_ARROW:
						this._matchedFocusIndex--;
					break;

				}
				if(oldIndex != this._matchedFocusIndex) {
					
					/*
					 * Check to see if the _matchedFocusIndex been moved beyond
					 * the confines of the array and, if so, loop it back around.
					 * if looping is not desired, then change the logic to keep
					 * the index at the beginning or end of the array.
					 */
					if(this._matchedFocusIndex >= this.matchedItems.length) {
						this._matchedFocusIndex  = 0;
					} else if(this._matchedFocusIndex < 0) {
						this._matchedFocusIndex = this.matchedItems.length -1;
					}
					var toFocus = this.matchedItems[this._matchedFocusIndex];
					this._announceOption(toFocus);
					this._popupWidget._focusOptionNode(toFocus);
					dijit.scrollIntoView(toFocus);
					dojo.stopEvent(evt);
					return;	
				}
			}
			this.inherited(arguments);
	},
	
	/**
	 * SP#20598: Re-implementing functionality to _getMenuLabelFromItem. The
	 * existing version did not keep track of the menu items that matched the
	 * user's input. This version adds a matchQuery boolean to the return
	 * object. This value will later be used by _createOption; we modify
	 * its behavior in _openResultList (see below).
	 */
	_getMenuLabelFromItem: function(/* Item */ item){
		var label = this.labelAttr? this.store.getValue(item, this.labelAttr) : this.labelFunc(item, this.store);
		var labelType = this.labelType;
		var matchedQuery = false;
		// If labelType is not "text" we don't want to screw any markup to
		// whatever.
		if(this.highlightMatch != "none" && this.labelType == "text" && this._lastInput){
			var temp = this.doHighlight(label, this._escapeHtml(this._lastInput));
			if(label != temp) {
				/**
				 * We have a match for the user's input
				 */
				matchedQuery = true;
			// this.matchedItems.push(item);
			}
			label = temp;
			
			labelType = "html";
		}
		
		
		return {html: labelType == "html", label: label, matchQuery: matchedQuery};
	},
	getValue:function(){
		//Summary:
		//	Implement the getValue() API.
		return this.textbox.value;
	},		
	

	/*I dont know why we have 2 startups. There's one above too, so commenting this out - Alka 
	startup: function(){
		// summary:
        //    Widget's life-cycle method.
		// description:
        //   This API is called once the widget is constructed.   
        // tags:
        //      extension
		this.inherited(arguments);
		//this._de1192_CSCth29102_hack();
	},
	*/
	
	_de1192_CSCth29102_hack:function(){
		// de1192/CSCCSCth29102 workaround.  Not a bug-a hack for UX's mistake. 
		var _position = dojo.position(this.domNode);
		var _w = _position.w;
		_w = _w + 6;
		dojo.style(this.domNode, "width", _w + "px");
	} 
	
});

}

if(!dojo._hasResource["xwt.widget.form.ComboBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.form.ComboBox"] = true;
/*******************************************************************   
 *        Copyright (c) 2009-2011 Cisco Systems, Inc.   
 *        All rights reserved.   
 * 
 * @fileoverview 
 * The combobox is an extension of the existing Dojo Combobox with some UE enhancements. 
 * @author Anuradha Bhat anbhat@cisco.com
 * @author Dennis Park denpark@cisco.com
 * @autor Priston psesumic@cisco.com (changed the package structure)
 ********************************************************************/
dojo.provide("xwt.widget.form.ComboBox");



dojo.declare("xwt.widget.form.ComboBox", dijit.form.ComboBox, {	
	// summary:
	// 		The ComboBox widget has the standard combobox behavior.
	// description:
	//		The ComboBox provides an input control that lets users either to enter a value directly into the text box 
	//		or choose one item from a list of mutually-exclusive predefined values.
	//		Filtering and scrolling to the closest match provides a dropdown in the combobox that shows a limited set of choices, 
	//		based on the user input, from a long list of choices.
	//	
	//		For more details, see the specification at http://sjc5-netapp03a-web/projects/nmtg-ue-svn/nmtg-ux/Published/nmtg_ux_standards/v1_5/combobox.html.
	//
	// example:
	// To create the widget using HTML markup:
	//		 |	<div dojoType="dojo.data.ItemFileReadStore" url="data/states.json" jsId="comboStore"></div>
	//		 |	<input dojoType="xwt.widget.form.ComboBox" value="California"  store="comboStore"
	//		 |  searchAttr="name" name="state" id="stateInput" />
	//
	// To create the widget programmatically:
	//		 |	_comboBox = new xwt.widget.form.ComboBox({ value : "California",
	//		 |					rootTitle : "San Jose Equipment", store : "comboStore", searchAttr:"name",
	//		 |  				name:"state", id:"stateInput" });
	//		 |	_comboBox.startup(); need to call the startup once 
	
	baseClass : "xwtComboBox dijitComboBox",
	
	// autoComplete: Boolean
	//		Set to false because the UX specs do not ask for auto-complete.
	autoComplete: true,
	
	// highlightMatch: String
	// 		One of: "first", "all" or "none".
	//		Default is "first" - first matched item containing the filtered text will be highlighted.
	highlightMatch: "first",
	
	//	queryExpr: String
	//		Specifies a regular expression that will be matched when text is 
	//		typed into the text field of the ComboBox/FilteringSelect.
	//		
	//		The default pattern will match starting from the beginning of the item
	//		text. To match text which is contained anywhere in the text, use `*${0}*`.
	//queryExpr: "*",		// "contains" match
	queryExpr: "${0}*",     // "starts with" match
	
	
	_openResultList: function(/*Object*/ results, /*Object*/ dataObject){
		// summary:
		//		Implement "scroll into view" - the first selected item in the drop down
		//		part of the list will be selected and if not visible, scrolled into the visible 
		//		area.
		// tags:
		//		protected extension
		
		this.inherited(arguments);	
		
		var _selectedItem = this._getSelectedItem();
		if(_selectedItem){
			if(this._isShowingNow){
				this._popupWidget.domNode.scrollTop = this._popupWidget.domNode.scrollHeight;
				dijit.scrollIntoView(_selectedItem);
				this._popupWidget._focusOptionNode(_selectedItem);

			}
		}else {
			var _highlightedNodes = dojo.query(".dijitComboBoxHighlightMatch",this._popupWidget.domNode);
			if(_highlightedNodes.length > 0){
				this._popupWidget.domNode.scrollTop = this._popupWidget.domNode.scrollHeight;
				dijit.scrollIntoView(_highlightedNodes[0]);
				//this._focusScrollOptionNode(_highlightedNodes[0]);
			}
		}
	},
	
	_onArrowMouseDown: function(evt){
		// summary:
		//		Callback when arrow is clicked
		if(this.disabled || this.readOnly){
			return;
		}
		dojo.stopEvent(evt);
		this.focus();
		if(this._isShowingNow){
			this._hideResultList();
		}else{
			// forces full population of results, if they click
			// on the arrow it means they want to see more options
			this._startSearchFromInput();
		}
	},
	
	doHighlight: function(/*String*/label, /*String*/find){
		//	summary:
		//		Implement custom highlighting.
		//	tags:
		//		protected extension

		// Add "greedy" if this.highlightMatch=="all".
		var modifiers = "i"+(this.highlightMatch=="all"?"g":"");
		var escapedLabel = this._escapeHtml(label);
		find = dojo.regexp.escapeString(find); // escape regexp special chars		
		
		//console.debug('find in do highlight:  '+find);

		var ret;
		if (this.highlightMatch=="all") {
			//console.debug('all')
			ret = escapedLabel.replace(new RegExp("(|\\s)("+ find +")", modifiers),
				'$1<span class="dijitComboBoxHighlightMatch">$2</span>');
		}else{
			//console.debug('highlightMatch: ' + this.highlightMatch);
			//ret = escapedLabel.replace(new RegExp("(^|\\s)("+ find +")", modifiers),
			ret = escapedLabel.replace(new RegExp("(^)("+ find +")", modifiers),
			'$1<span class="dijitComboBoxHighlightMatch">$2</span>');
		}
		return ret;// returns String, (almost) valid HTML (entities encoded)
	},
	
	_focusScrollOptionNode: function(/*DomNode*/ node){
		//	summary:
		//		Does the actual highlight.		
		if(this.scrollToHighlightedOption != node){
			this._blurScrollOptionNode();
			this.scrollToHighlightedOption = node;
			dojo.addClass(this.scrollToHighlightedOption.parentNode, "dijitMenuItemSelected");
		}
	},

	_blurScrollOptionNode: function(){
		//	summary:
		//		Removes highlight on highlighted option.
		if(this.scrollToHighlightedOption !== null && this.scrollToHighlightedOption.parentNode !== null){
			dojo.removeClass(this.scrollToHighlightedOption.parentNode, "dijitMenuItemSelected");
			this.scrollToHighlightedOption = null;
		}
	},
	
	_getSelectedItem: function(){
		//	summary:
		//		Returns the selected item
		var _pw = this._popupWidget;
		var _selectionLabel = this.getValue();
		
		var _items = _pw.domNode.children;
		
		var _nItems = _items.length;
		// this.store.getValue()
		for(var i = 1; i < _nItems-1; i++){
			var _labelAttr = ""; 
			if(this.labelAttr && this.labelAttr !== ""){
				_labelAttr = this.labelAttr;	
			}else{
				_labelAttr = this.searchAttr; 
			}
			
			var _itemName = "";
			
			// -----------------------------------------------------------------
			//http://nmtg-jira.cisco.com/jira/browse/XMPGUI-217
			//http://nmtg-jira.cisco.com/jira/browse/XMPGUI-218

//			if(typeof(_items[i].item[_labelAttr]) == "string"){
//				_itemName = _items[i].item[_labelAttr];
//			}else{
//				_itemName = _items[i].item[_labelAttr][0];
//			}
			
			_itemName = _items[i].textContent;

			// -----------------------------------------------------------------
			
			if(_itemName == _selectionLabel){
				return _items[i];
			}
		}
		return null;
		
		
	},

	_arrowIdle: function(){
		//	summary:
		//		Remove new class
		//	tags:
		//		extension
		if(!this.disabled && !this.readOnly && this.hasDownArrow){
			dojo.removeClass(this.downArrowNode, "dojoArrowButtonPushed");
			dojo.removeClass(this.downArrowNode, "downArrowPressed");
		}
	},
	
	_arrowPressed: function(){
		//	summary:
		//		Add new class
		//	tags:
		//		extension
		if(!this.disabled && !this.readOnly && this.hasDownArrow){
			dojo.addClass(this.downArrowNode, "dijitArrowButtonActive");
			dojo.addClass(this.downArrowNode, "downArrowPressed");
		}
	},
	
//	_onBlur:function(){},
	
	startup: function(){
		//	summary:
		//		Override the default Dojo Widget startup method. See
		//		Dojo docs for complete description.
		//	tags:
		//		extension
		this.inherited(arguments);	
//		var node = dojo.coords(this.domNode);
//		var width = parseInt(node.w);
//		// 160 px seems to be the width where the combo box's scroll bar
//		//	is rendered properly.  After that point, the combo box's drop
//		//	down is not inline with the down arrow.
//		if(width > 160){		
//			var _scrollBarConstant = 0;
//			var newWidth =  width + _scrollBarConstant;
//			dojo.style(this.domNode, {"width":  newWidth+ "px"});
//		}
		
		//this._hideResultList= function(){};
		
//		this._de1192_CSCth29102_hack();
		// fix for CDETS: CSCth95445
		if(dojo.isIE){
			dojo.style(this.focusNode, "fontFamily", "inherit");
		}
		if(this.textbox){
			// Disable spell checker: CSCtn87438
			dojo.attr(this.textbox, "spellcheck", "false");
		}
	},
	
//	_de1192_CSCth29102_hack:function(){
//		// de1192/CSCth29102 workaround.  Not a bug-a hack for UX's mistake. 
//		var _position = dojo.position(this.domNode);
//		var _w = _position.w;
//		_w = _w + 6;
//		dojo.style(this.domNode, "width", _w + "px");
//	}, 
	
	
	
	_startSearch: function(/*String*/ key){
		this.inherited(arguments);
		dojo.addClass(this._popupWidget.domNode,"xwtComboBoxPopup");	
	},
	
	/**
	*  SP#20598 Re-implementing funcitonality to _getMenuLabelFromItem 
	*  the existing version did not keep track of the menu items
	*  that matched the user's input.  This version adds a matchQuery
	*  boolean to the return object.  This value will later be used
	*  by _createOption which we modify its behavior in _openResultList (see below)
	*/
	_getMenuLabelFromItem: function(/*Item*/ item){
		var label = this.labelAttr? this.store.getValue(item, this.labelAttr) : this.labelFunc(item, this.store);
		var labelType = this.labelType;
		var matchedQuery = false;
		// If labelType is not "text" we don't want to screw any markup ot whatever.
		if(this.highlightMatch != "none" && this.labelType == "text" && this._lastInput){
			var temp = this.doHighlight(label, this._escapeHtml(this._lastInput));
			if(label != temp) {
				/**
				* We have a match for the user's input
				*/
				matchedQuery = true;
			//	this.matchedItems.push(item);
			}
			label = temp;
			
			labelType = "html";
		}
		
		
		return {html: labelType == "html", label: label, matchQuery: matchedQuery};
	},
	

	_openResultList: function(/*Object*/ results, /*Object*/ dataObject){
		// summary:
		//		Implement "scroll into view" - the first selected item in the drop down
		//		part of the list will be selected and if not visible, scrolled into visible 
		//		area.
		// tags:
		//		protected extension
		
		
		/**
		*  SP#20598 Because the standard combobox does not keep track of 
		*  which items match the user's input this version will
		*  track the matched Items in the matchedItems array.
		*  Every time _openResultList we need ot reset is as the 
		*  contents of the menu are about to be re-built.
		*/
		this.matchedItems = [];
		
		/**
		* SP#20598 _matchedFocusIndex keeps track of which item the user
		* has selected using the arrow keys.  This value is later
		* manipulated in _onKeyPress
		*/
		this._matchedFocusIndex = -1;
		
		/**
		*  SP#20598 we need to change _createOption to keep track of the 
		*  menu items that match the user's input string.
		*  if we find a match then we place the dom node for the item
		*  in the comboBox.matchedItems array.
		*/
		if(!this._createOptionOrig) {
			this._createOptionOrig = this._popupWidget._createOption;
			var createOptionOrig = this._createOptionOrig;
			var comboBox = this;
			var _doc = dojo.doc;
			this._popupWidget._createOption = function(/*Object*/ item, labelFunc) {
					var labelObject = labelFunc(item);
					var menuitem = _doc.createElement("li");
					dijit.setWaiRole(menuitem, "option");
					if(labelObject.html){
						menuitem.innerHTML = labelObject.label;
					}else{
						menuitem.appendChild(
							_doc.createTextNode(labelObject.label)
						);
					}
					// #3250: in blank options, assign a normal height
					if(menuitem.innerHTML === ""){
						menuitem.innerHTML = "&nbsp;";
					}
					menuitem.item=item;
					if(labelObject.matchQuery) {
						comboBox.matchedItems.push(menuitem);
					}
					return menuitem;
			};
		}
	
		this.inherited(arguments);	
		

		var _selectedItem = this._getSelectedItem();
		if(_selectedItem){
			if(this._isShowingNow){
				this._popupWidget.domNode.scrollTop = this._popupWidget.domNode.scrollHeight;
				dijit.scrollIntoView(_selectedItem);
				this._popupWidget._focusOptionNode(_selectedItem);

			}
		}else {
			var _highlightedNodes = dojo.query(".dijitComboBoxHighlightMatch",this._popupWidget.domNode);
			if(_highlightedNodes.length > 0){
				this._popupWidget.domNode.scrollTop = this._popupWidget.domNode.scrollHeight;
				dijit.scrollIntoView(_highlightedNodes[0]);
				//this._focusScrollOptionNode(_highlightedNodes[0]);
			}
		}
	},

	
	/**
	*  SP#20598 adding functionality to _onKeyPress to scroll through matched items
	*  when the user used the up and down arrow keys they will scroll 
	*  through only those items that match the user's input.
	*/
	
	_onKeyPress: function(/*Event*/ evt) {
			var key = evt.charOrCode;
			var dk = dojo.keys;
		
			if(this._popupWidget && this.matchedItems && this.matchedItems.length > 0) {
				var oldIndex = this._matchedFocusIndex;
				switch(key) {
					case dk.DOWN_ARROW:
						this._matchedFocusIndex++;
					break;
					case dk.UP_ARROW:
						this._matchedFocusIndex--;
					break;

				}
				if(oldIndex != this._matchedFocusIndex) {
					
					/*
					* Check to see if the _matchedFocusIndex has been moved beyond
					* the confines of the array and if so loop it back around.
					* if looping is not desired then change the logic to keep 
					* the index at the beginning or end of the array.
					*/
					if(this._matchedFocusIndex >= this.matchedItems.length) {
						this._matchedFocusIndex  = 0;
					} else if(this._matchedFocusIndex < 0) {
						this._matchedFocusIndex = this.matchedItems.length -1;
					}
					var toFocus = this.matchedItems[this._matchedFocusIndex];
					this._announceOption(toFocus);
					this._popupWidget._focusOptionNode(toFocus);
					dijit.scrollIntoView(toFocus);
					dojo.stopEvent(evt);
					return;	
				}
			}
			this.inherited(arguments);
	}
	
});

}

if(!dojo._hasResource["xwt.widget.form.Label"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.form.Label"] = true;
/* ************************************************** */
/* Copyright (c) 2009-2011 Cisco Systems, Inc.        */
/* All rights reserved.                               */
/* ************************************************** */ 

// xwt.widget.form.Label

dojo.provide("xwt.widget.form.Label");




dojo.declare( "xwt.widget.form.Label", [dijit._Widget,dijit._Templated], {
	
	// summary:
	// Wrap text as widget.  
	//	
	//description:
	// Wrap text as widget.  
    // 
	//example:
	//
	// | var repeater1 = new xwt.widget.form.Label({label:"repeater1" , value:"Test"]);
	
	//template
    templateString: '<span dojoAttachPoint="labelNode" class = "xwtLabel"></span>',
    
    //templatePath 
    templatePath:null,
    
    //default value
     value : "",
     
     //property
     style:null,
     
     
        
     postCreate:function() {		  
		// summary:
        //    Widget's life-cycle method. Called after the widget instance has
        //    been created.
        // description:
        //      This method creates the contents 
        // tags:
        //      extension  
		this.inherited(arguments);
		   //console.log("postCreate");
    	   this.domNode.appendChild(document.createTextNode(this.value));	  
     },
     
    getValue: function(){
    	// summary:
 		//		Retrieve label.
 		// description:
 		//		Retrieve the value of the widget (i.e., the label).
		return this.value;
	},

	setValue: function(/*String*/newValue){
	// summary:
	//		Set the value of this widget.
	// description:
 	//		Set the value of the widget (i.e., the label).
	// newValue: String
	// 		The input String that sets the value for the label.
		this.value = newValue;
		this.labelNode.innerHTML = newValue;
		this.onChange(newValue);
	},
	
	onChange:function(/*String*/newValue){
	// summary:
	//		onChange method. This method has to exist to permit data saving back to store.
	//newValue: String
	//		The input String that is changed.
	}	
     
 });

}

if(!dojo._hasResource["dojox.form.Rating"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.form.Rating"] = true;
dojo.provide("dojox.form.Rating");



dojo.declare("dojox.form.Rating",
	dijit.form._FormWidget,{
	// summary:
	//		A widget for rating using stars.
	//
	// required: Boolean
	//		TODO: Can be true or false, default is false.
	// required: false,

	templateString: null,
	
	// numStars: Integer/Float
	//		The number of stars to show, default is 3.
	numStars: 3,
	// value: Integer/Float
	//		The current value of the Rating
	value: 0,

	constructor:function(/*Object*/params){
		// Build the templateString. The number of stars is given by this.numStars,
		// which is normally an attribute to the widget node.
		dojo.mixin(this, params);
		
		// TODO actually "dijitInline" should be applied to the surrounding div, but FF2
		// screws up when we dojo.query() for the star nodes, it orders them randomly, because of the use
		// of display:--moz-inline-box ... very strange bug
		// Since using ul and li in combintaion with dijitInline this problem doesnt exist anymore.
		
		// The focusNode is normally used to store the value, i dont know if that is right here, but seems standard for _FormWidgets
		var tpl = '<div dojoAttachPoint="domNode" class="dojoxRating dijitInline">' +
					'<input type="hidden" value="0" dojoAttachPoint="focusNode" /><ul>${stars}</ul>' +
				'</div>';
		// The value-attribute is used to "read" the value for processing in the widget class
		var starTpl = '<li class="dojoxRatingStar dijitInline" dojoAttachEvent="onclick:onStarClick,onmouseover:_onMouse,onmouseout:_onMouse" value="${value}"></li>';
		var rendered = "";
		for(var i = 0; i < this.numStars; i++){
			rendered += dojo.string.substitute(starTpl, {value:i+1});
		}
		this.templateString = dojo.string.substitute(tpl, {stars:rendered});
	},

	postCreate: function(){
		this.inherited(arguments);
		this._renderStars(this.value);
	},

	_onMouse: function(evt){
		this.inherited(arguments);
		if(this._hovering){
			var hoverValue = +dojo.attr(evt.target, "value");
			this.onMouseOver(evt, hoverValue);
			this._renderStars(hoverValue, true);
		}else{
			this._renderStars(this.value);
		}
	},

	_renderStars: function(value, hover){
		// summary: Render the stars depending on the value.
		dojo.query(".dojoxRatingStar", this.domNode).forEach(function(star, i){
			if(i + 1 > value){
				dojo.removeClass(star, "dojoxRatingStarHover");
				dojo.removeClass(star, "dojoxRatingStarChecked");
			}else{
				dojo.removeClass(star, "dojoxRatingStar" + (hover ? "Checked" : "Hover"));
				dojo.addClass(star, "dojoxRatingStar" + (hover ? "Hover" : "Checked"));
			}
		});
	},

	onStarClick:function(/* Event */evt){
		// summary: Connect on this method to get noticed when a star was clicked.
		// example: dojo.connect(widget, "onStarClick", function(event){ ... })
		var newVal = +dojo.attr(evt.target, "value");
		this.setAttribute("value", newVal == this.value ? 0 : newVal);
		this._renderStars(this.value);
		this.onChange(this.value); // Do I have to call this by hand?
	},
	
	onMouseOver: function(/*evt, value*/){
		// summary: Connect here, the value is passed to this function as the second parameter!
	},
	
	setAttribute: function(/*String*/key, /**/value){
		// summary: When calling setAttribute("value", 4), set the value and render the stars accordingly.
		this.inherited("setAttribute", arguments);
		if (key=="value"){
			this._renderStars(this.value);
			this.onChange(this.value); // Do I really have to call this by hand? :-(
		}
	}
});

}

if(!dojo._hasResource["xwt.widget.form.Rating"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.form.Rating"] = true;
/*******************************************************************   
 *        Copyright (c) 2010-2011 Cisco Systems, Inc.   
 *        All rights reserved.   
 * 
 *  
 * @author Prathiban Mohanasundaram pmohanas@cisco.com
 * 
 ********************************************************************/
dojo.provide("xwt.widget.form.Rating");




dojo.declare("xwt.widget.form.Rating",dojox.form.Rating,{
	// summary:
	//		A widget for rating, using stars.
	//
	// required: Boolean
	//		TODO: Can be true or false, default is false.
	// required: false,

	templateString: null,
	
	totalRatings: 0,
	
	ratingsLabel: "Ratings",
	
	constructor:function(/*Object*/params){
	    // summary: 
	    // 	Modify the template classes for XWT CSS to be applied.
		// 	TODO actually "dijitInline" should be applied to the surrounding div, but FF2
		// 	screws up when we dojo.query() for the star nodes, it orders them randomly, because of the use
		// 	of display:--moz-inline-box ... very strange bug
		// 	Since using ul and li in combintaion with dijitInline this problem doesnt exist anymore.
		// 	The focusNode is normally used to store the value, i dont know if that is right here, but seems standard for _FormWidgets
		var tpl = '<div class="xwtRating dijitInline">' +
					'<input type="hidden" value="0" dojoAttachPoint="focusNode" /><ul>${stars}</ul>' +
				'</div>';
		// The value-attribute is used to "read" the value for processing in the widget class
		var starTpl = '<li class="xwtRatingStar dijitInline" dojoAttachEvent="onclick:onStarClick,onmouseover:_onMouse,onmouseout:_onMouse" value="${value}"></li>';
		var rendered = "";
		for(var i = 0; i < this.numStars; i++){
			rendered += dojo.string.substitute(starTpl, {value : (i+1)});
		}
		this.templateString = dojo.string.substitute(tpl, {stars : rendered});
    },
	
    postCreate: function(){
    	// summary:
        //    Widget's life-cycle method. Called after the widget instance has
        //    been created.
        // description:
        //      This method creates the contents.
        // tags:
        //      extension 
    	this.inherited(arguments);
		this.totalRatingsSpan = dojo.create("span", {innerHTML: this._formatTotalRatings(this.totalRatings), "class":"totalRatings"}, this.domNode);
	},
	_renderStars: function(value, hover){
	// summary: 
	// 	Render the stars depending on the value.
		var decVal=false;
		if(String(value).indexOf('.') != -1){
		       	decVal = true;
		}	
		dojo.query(".xwtRatingStar", this.domNode).forEach(function(star, i){
			if(i + 1 > Math.floor(value)){
				tempVal= Math.floor(value) +1;
				if(decVal && (tempVal == i+1)){
				     console.log(i+1);
				     // Display Half Star if average is not a whole number
				     dojo.removeClass(star, "xwtRatingStarHover");
				     dojo.removeClass(star, "xwtRatingStarChecked");
				     dojo.addClass(star, "xwtRatingStarHalfChecked");
				} else {
					dojo.removeClass(star, "xwtRatingStarHover");
					dojo.removeClass(star, "xwtRatingStarHalfChecked");
					dojo.removeClass(star, "xwtRatingStarChecked");
				} 
			} else {
				dojo.removeClass(star, "xwtRatingStarHalfChecked");
				dojo.removeClass(star, "xwtRatingStar" + (hover ? "Checked" : "Hover"));
				dojo.addClass(star, "xwtRatingStar" + (hover ? "Hover" : "Checked"));
			}
		});
     },
     
 	_onMouse: function(/* Event */evt){
    	 if(this.disabled){
    		 return;
    	 }
 		this.inherited(arguments);
 	},

 	onStarClick:function(/* Event */evt){
 		// Summary:
 		//		Executed when a start is clicked.
 		// Description:
 		//		Callback function executed when a star is clicked.
 		// evt: Event
 		//		The event fired when a star is clicked.
 		if(this.disabled){
 			return;
 		}
		this.inherited(arguments);
 	},
	
    updateTotalRatings: function(/*Integer*/count){
    	 // summary :
    	 //			Update the total rating count.
    	 // count : Integer.
    	 //			The rating count.
    	 this.totalRatingsSpan.innerHTML = this._formatTotalRatings(count);
    },
    
    _formatTotalRatings: function(/*Integer*/count){
    	 this.totalRatings = count;
    	 return "("+this.totalRatings + this.ratingsLabel + ")"; 
    }
	
});

}

if(!dojo._hasResource["dijit.form._FormSelectWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form._FormSelectWidget"] = true;
dojo.provide("dijit.form._FormSelectWidget");




/*=====
dijit.form.__SelectOption = function(){
	// value: String
	//		The value of the option.  Setting to empty (or missing) will
	//		place a separator at that location
	// label: String
	//		The label for our option.  It can contain html tags.
	//  selected: Boolean
	//		Whether or not we are a selected option
	// disabled: Boolean
	//		Whether or not this specific option is disabled
	this.value = value;
	this.label = label;
	this.selected = selected;
	this.disabled = disabled;
}
=====*/

dojo.declare("dijit.form._FormSelectWidget", dijit.form._FormValueWidget, {
	// summary:
	//		Extends _FormValueWidget in order to provide "select-specific"
	//		values - i.e., those values that are unique to <select> elements.
	//		This also provides the mechanism for reading the elements from
	//		a store, if desired.

	// multiple: Boolean
	//		Whether or not we are multi-valued
	multiple: false,

	// options: dijit.form.__SelectOption[]
	//		The set of options for our select item.  Roughly corresponds to
	//      the html <option> tag.
	options: null,

	// store: dojo.data.api.Identity
	//		A store which, at the very least impelements dojo.data.api.Identity
	//		to use for getting our list of options - rather than reading them
	//		from the <option> html tags.
	store: null,

	// query: object
	//		A query to use when fetching items from our store
	query: null,

	// queryOptions: object
	//		Query options to use when fetching from the store
	queryOptions: null,

	// onFetch: Function
	//		A callback to do with an onFetch - but before any items are actually
	//		iterated over (i.e. to filter even futher what you want to add)
	onFetch: null,

	// sortByLabel: boolean
	//		Flag to sort the options returned from a store by the label of
	//		the store.
	sortByLabel: true,


	// loadChildrenOnOpen: boolean
	//		By default loadChildren is called when the items are fetched from the
	//		store.  This property allows delaying loadChildren (and the creation
	//		of the options/menuitems) until the user opens the click the button.
	//		dropdown
	loadChildrenOnOpen: false,

	getOptions: function(/* anything */ valueOrIdx){
		// summary:
		//		Returns a given option (or options).
		// valueOrIdx:
		//		If passed in as a string, that string is used to look up the option
		//		in the array of options - based on the value property.
		//		(See dijit.form.__SelectOption).
		//
		//		If passed in a number, then the option with the given index (0-based)
		//		within this select will be returned.
		//
		//		If passed in a dijit.form.__SelectOption, the same option will be
		//		returned if and only if it exists within this select.
		//
		//		If passed an array, then an array will be returned with each element
		//		in the array being looked up.
		//
		//		If not passed a value, then all options will be returned
		//
		// returns:
		//		The option corresponding with the given value or index.  null
		//		is returned if any of the following are true:
		//			- A string value is passed in which doesn't exist
		//			- An index is passed in which is outside the bounds of the array of options
		//			- A dijit.form.__SelectOption is passed in which is not a part of the select

		// NOTE: the compare for passing in a dijit.form.__SelectOption checks
		//		if the value property matches - NOT if the exact option exists
		// NOTE: if passing in an array, null elements will be placed in the returned
		//		array when a value is not found.
		var lookupValue = valueOrIdx, opts = this.options || [], l = opts.length;

		if(lookupValue === undefined){
			return opts; // dijit.form.__SelectOption[]
		}
		if(dojo.isArray(lookupValue)){
			return dojo.map(lookupValue, "return this.getOptions(item);", this); // dijit.form.__SelectOption[]
		}
		if(dojo.isObject(valueOrIdx)){
			// We were passed an option - so see if it's in our array (directly),
			// and if it's not, try and find it by value.
			if(!dojo.some(this.options, function(o, idx){
				if(o === lookupValue ||
					(o.value && o.value === lookupValue.value)){
					lookupValue = idx;
					return true;
				}
				return false;
			})){
				lookupValue = -1;
			}
		}
		if(typeof lookupValue == "string"){
			for(var i=0; i<l; i++){
				if(opts[i].value === lookupValue){
					lookupValue = i;
					break;
				}
			}
		}
		if(typeof lookupValue == "number" && lookupValue >= 0 && lookupValue < l){
			return this.options[lookupValue] // dijit.form.__SelectOption
		}
		return null; // null
	},

	addOption: function(/* dijit.form.__SelectOption, dijit.form.__SelectOption[] */ option){
		// summary:
		//		Adds an option or options to the end of the select.  If value
		//		of the option is empty or missing, a separator is created instead.
		//		Passing in an array of options will yield slightly better performance
		//		since the children are only loaded once.
		if(!dojo.isArray(option)){ option = [option]; }
		dojo.forEach(option, function(i){
			if(i && dojo.isObject(i)){
				this.options.push(i);
			}
		}, this);
		this._loadChildren();
	},

	removeOption: function(/* string, dijit.form.__SelectOption, number, or array */ valueOrIdx){
		// summary:
		//		Removes the given option or options.  You can remove by string
		//		(in which case the value is removed), number (in which case the
		//		index in the options array is removed), or select option (in
		//		which case, the select option with a matching value is removed).
		//		You can also pass in an array of those values for a slightly
		//		better performance since the children are only loaded once.
		if(!dojo.isArray(valueOrIdx)){ valueOrIdx = [valueOrIdx]; }
		var oldOpts = this.getOptions(valueOrIdx);
		dojo.forEach(oldOpts, function(i){
			// We can get null back in our array - if our option was not found.  In
			// that case, we don't want to blow up...
			if(i){
				this.options = dojo.filter(this.options, function(node, idx){
					return (node.value !== i.value);
				});
				this._removeOptionItem(i);
			}
		}, this);
		this._loadChildren();
	},

	updateOption: function(/* dijit.form.__SelectOption, dijit.form.__SelectOption[] */ newOption){
		// summary:
		//		Updates the values of the given option.  The option to update
		//		is matched based on the value of the entered option.  Passing
		//		in an array of new options will yeild better performance since
		//		the children will only be loaded once.
		if(!dojo.isArray(newOption)){ newOption = [newOption]; }
		dojo.forEach(newOption, function(i){
			var oldOpt = this.getOptions(i), k;
			if(oldOpt){
				for(k in i){ oldOpt[k] = i[k]; }
			}
		}, this);
		this._loadChildren();
	},

	setStore: function(/* dojo.data.api.Identity */ store,
						/* anything? */ selectedValue,
						/* Object? */ fetchArgs){
		// summary:
		//		Sets the store you would like to use with this select widget.
		//		The selected value is the value of the new store to set.  This
		//		function returns the original store, in case you want to reuse
		//		it or something.
		// store: dojo.data.api.Identity
		//		The store you would like to use - it MUST implement Identity,
		//		and MAY implement Notification.
		// selectedValue: anything?
		//		The value that this widget should set itself to *after* the store
		//		has been loaded
		// fetchArgs: Object?
		//		The arguments that will be passed to the store's fetch() function
		var oStore = this.store;
		fetchArgs = fetchArgs || {};
		if(oStore !== store){
			// Our store has changed, so update our notifications
			dojo.forEach(this._notifyConnections || [], dojo.disconnect);
			delete this._notifyConnections;
			if(store && store.getFeatures()["dojo.data.api.Notification"]){
				this._notifyConnections = [
					dojo.connect(store, "onNew", this, "_onNewItem"),
					dojo.connect(store, "onDelete", this, "_onDeleteItem"),
					dojo.connect(store, "onSet", this, "_onSetItem")
				];
			}
			this.store = store;
		}

		// Turn off change notifications while we make all these changes
		this._onChangeActive = false;

		// Remove existing options (if there are any)
		if(this.options && this.options.length){
			this.removeOption(this.options);
		}

		// Add our new options
		if(store){
			var cb = function(items){
				if(this.sortByLabel && !fetchArgs.sort && items.length){
					items.sort(dojo.data.util.sorter.createSortFunction([{
						attribute: store.getLabelAttributes(items[0])[0]
					}], store));
				}

				if(fetchArgs.onFetch){
					items = fetchArgs.onFetch(items);
				}
				// TODO: Add these guys as a batch, instead of separately
				dojo.forEach(items, function(i){
					this._addOptionForItem(i);
				}, this);

				// Set our value (which might be undefined), and then tweak
				// it to send a change event with the real value
				this._loadingStore = false;
				this.attr("value", (("_pendingValue" in this) ? this._pendingValue : selectedValue));
				delete this._pendingValue;

				if(!this.loadChildrenOnOpen){
					this._loadChildren();
				}else{
					this._pseudoLoadChildren(items);
				}
				this._fetchedWith = opts;
				this._lastValueReported = this.multiple ? [] : null;
				this._onChangeActive = true;
				this.onSetStore();
				this._handleOnChange(this.value);
			};
			var opts = dojo.mixin({onComplete:cb, scope: this}, fetchArgs);
			this._loadingStore = true;
			store.fetch(opts);
		}else{
			delete this._fetchedWith;
		}
		return oStore;	// dojo.data.api.Identity
	},

	_setValueAttr: function(/*anything*/ newValue, /*Boolean, optional*/ priorityChange){
		// summary:
		//		set the value of the widget.
		//		If a string is passed, then we set our value from looking it up.
		if(this._loadingStore){
			// Our store is loading - so save our value, and we'll set it when
			// we're done
			this._pendingValue = newValue;
			return;
		}
		var opts = this.getOptions() || [];
		if(!dojo.isArray(newValue)){
			newValue = [newValue];
		}
		dojo.forEach(newValue, function(i, idx){
			if(!dojo.isObject(i)){
				i = i + "";
			}
			if(typeof i === "string"){
				newValue[idx] = dojo.filter(opts, function(node){
					return node.value === i;
				})[0] || {value: "", label: ""};
			}
		}, this);

		// Make sure some sane default is set
		newValue = dojo.filter(newValue, function(i){ return i && i.value; });
		if(!this.multiple && (!newValue[0] || !newValue[0].value) && opts.length){
			newValue[0] = opts[0];
		}
		dojo.forEach(opts, function(i){
			i.selected = dojo.some(newValue, function(v){ return v.value === i.value; });
		});
		var val = dojo.map(newValue, function(i){ return i.value; }),
			disp = dojo.map(newValue, function(i){ return i.label; });

		this.value = this.multiple ? val : val[0];
		this._setDisplay(this.multiple ? disp : disp[0]);
		this._updateSelection();
		this._handleOnChange(this.value, priorityChange);
	},

	_getDisplayedValueAttr: function(){
		// summary:
		//		returns the displayed value of the widget
		var val = this.attr("value");
		if(!dojo.isArray(val)){
			val = [val];
		}
		var ret = dojo.map(this.getOptions(val), function(v){
			if(v && "label" in v){
				return v.label;
			}else if(v){
				return v.value;
			}
			return null;
		}, this);
		return this.multiple ? ret : ret[0];
	},

	_getValueDeprecated: false, // remove when _FormWidget:getValue is removed
	getValue: function(){
		// summary:
		//		get the value of the widget.
		return this._lastValue;
	},

	undo: function(){
		// summary:
		//		restore the value to the last value passed to onChange
		this._setValueAttr(this._lastValueReported, false);
	},

	_loadChildren: function(){
		// summary:
		//		Loads the children represented by this widget's options.
		//		reset the menu to make it "populatable on the next click
		if(this._loadingStore){ return; }
		dojo.forEach(this._getChildren(), function(child){
			child.destroyRecursive();
		});
		// Add each menu item
		dojo.forEach(this.options, this._addOptionItem, this);

		// Update states
		this._updateSelection();
	},

	_updateSelection: function(){
		// summary:
		//		Sets the "selected" class on the item for styling purposes
		this.value = this._getValueFromOpts();
		var val = this.value;
		if(!dojo.isArray(val)){
			val = [val];
		}
		if(val && val[0]){
			dojo.forEach(this._getChildren(), function(child){
				var isSelected = dojo.some(val, function(v){
					return child.option && (v === child.option.value);
				});
				dojo.toggleClass(child.domNode, this.baseClass + "SelectedOption", isSelected);
				dijit.setWaiState(child.domNode, "selected", isSelected);
			}, this);
		}
		this._handleOnChange(this.value);
	},

	_getValueFromOpts: function(){
		// summary:
		//		Returns the value of the widget by reading the options for
		//		the selected flag
		var opts = this.getOptions() || [];
		if(!this.multiple && opts.length){
			// Mirror what a select does - choose the first one
			var opt = dojo.filter(opts, function(i){
				return i.selected;
			})[0];
			if(opt && opt.value){
				return opt.value
			}else{
				opts[0].selected = true;
				return opts[0].value;
			}
		}else if(this.multiple){
			// Set value to be the sum of all selected
			return dojo.map(dojo.filter(opts, function(i){
				return i.selected;
			}), function(i){
				return i.value;
			}) || [];
		}
		return "";
	},

	// Internal functions to call when we have store notifications come in
	_onNewItem: function(/* item */ item, /* Object? */ parentInfo){
		if(!parentInfo || !parentInfo.parent){
			// Only add it if we are top-level
			this._addOptionForItem(item);
		}
	},
	_onDeleteItem: function(/* item */ item){
		var store = this.store;
		this.removeOption(store.getIdentity(item));
	},
	_onSetItem: function(/* item */ item){
		this.updateOption(this._getOptionObjForItem(item));
	},

	_getOptionObjForItem: function(item){
		// summary:
		//		Returns an option object based off the given item.  The "value"
		//		of the option item will be the identity of the item, the "label"
		//		of the option will be the label of the item.  If the item contains
		//		children, the children value of the item will be set
		var store = this.store, label = store.getLabel(item),
			value = (label ? store.getIdentity(item) : null);
		return {value: value, label: label, item:item}; // dijit.form.__SelectOption
	},

	_addOptionForItem: function(/* item */ item){
		// summary:
		//		Creates (and adds) the option for the given item
		var store = this.store;
		if(!store.isItemLoaded(item)){
			// We are not loaded - so let's load it and add later
			store.loadItem({item: item, onComplete: function(i){
				this._addOptionForItem(item);
			},
			scope: this});
			return;
		}
		var newOpt = this._getOptionObjForItem(item);
		this.addOption(newOpt);
	},

	constructor: function(/* Object */ keywordArgs){
		// summary:
		//		Saves off our value, if we have an initial one set so we
		//		can use it if we have a store as well (see startup())
		this._oValue = (keywordArgs || {}).value || null;
	},

	_fillContent: function(){
		// summary:
		//		Loads our options and sets up our dropdown correctly.  We
		//		don't want any content, so we don't call any inherit chain
		//		function.
		var opts = this.options;
		if(!opts){
			opts = this.options = this.srcNodeRef ? dojo.query(">",
						this.srcNodeRef).map(function(node){
							if(node.getAttribute("type") === "separator"){
								return { value: "", label: "", selected: false, disabled: false };
							}
							return { value: node.getAttribute("value"),
										label: String(node.innerHTML),
										selected: node.getAttribute("selected") || false,
										disabled: node.getAttribute("disabled") || false };
						}, this) : [];
		}
		if(!this.value){
			this.value = this._getValueFromOpts();
		}else if(this.multiple && typeof this.value == "string"){
			this.value = this.value.split(",");
		}
	},

	postCreate: function(){
		// summary:
		//		sets up our event handling that we need for functioning
		//		as a select
		dojo.setSelectable(this.focusNode, false);
		this.inherited(arguments);

		// Make our event connections for updating state
		this.connect(this, "onChange", "_updateSelection");
		this.connect(this, "startup", "_loadChildren");

		this._setValueAttr(this.value, null);
	},

	startup: function(){
		// summary:
		//		Connects in our store, if we have one defined
		this.inherited(arguments);
		var store = this.store, fetchArgs = {};
		dojo.forEach(["query", "queryOptions", "onFetch"], function(i){
			if(this[i]){
				fetchArgs[i] = this[i];
			}
			delete this[i];
		}, this);
		if(store && store.getFeatures()["dojo.data.api.Identity"]){
			// Temporarily set our store to null so that it will get set
			// and connected appropriately
			this.store = null;
			this.setStore(store, this._oValue, fetchArgs);
		}
	},

	destroy: function(){
		// summary:
		//		Clean up our connections
		dojo.forEach(this._notifyConnections || [], dojo.disconnect);
		this.inherited(arguments);
	},

	_addOptionItem: function(/* dijit.form.__SelectOption */ option){
		// summary:
		//		User-overridable function which, for the given option, adds an
		//		item to the select.  If the option doesn't have a value, then a
		//		separator is added in that place.  Make sure to store the option
		//		in the created option widget.
	},

	_removeOptionItem: function(/* dijit.form.__SelectOption */ option){
		// summary:
		//		User-overridable function which, for the given option, removes
		//		its item from the select.
	},

	_setDisplay: function(/*String or String[]*/ newDisplay){
		// summary:
		//		Overridable function which will set the display for the
		//		widget.  newDisplay is either a string (in the case of
		//		single selects) or array of strings (in the case of multi-selects)
	},

	_getChildren: function(){
		// summary:
		//		Overridable function to return the children that this widget contains.
		return [];
	},

	_getSelectedOptionsAttr: function(){
		// summary:
		//		hooks into this.attr to provide a mechanism for getting the
		//		option items for the current value of the widget.
		return this.getOptions(this.attr("value"));
	},

	_pseudoLoadChildren: function(/* item[] */ items){
		// summary:
		//		a function that will "fake" loading children, if needed, and
		//		if we have set to not load children until the widget opens.
		// items:
		//		An array of items that will be loaded, when needed
	},

	onSetStore: function(){
		// summary:
		//		a function that can be connected to in order to receive a
		//		notification that the store has finished loading and all options
		//		from that store are available
	}
});

}

if(!dojo._hasResource["dijit.form.Select"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.Select"] = true;
dojo.provide("dijit.form.Select");







dojo.declare("dijit.form._SelectMenu", dijit.Menu, {
	// summary:
	//		An internally-used menu for dropdown that allows us to more
	//		gracefully overflow our menu
	buildRendering: function(){
		// summary:
		//		Stub in our own changes, so that our domNode is not a table
		//		otherwise, we won't respond correctly to heights/overflows
		this.inherited(arguments);
		var o = (this.menuTableNode = this.domNode);
		var n = (this.domNode = dojo.doc.createElement("div"));
		if(o.parentNode){
			o.parentNode.replaceChild(n, o);
		}
		dojo.removeClass(o, "dijitMenuTable");
		n.className = o.className + " dijitSelectMenu";
		o.className = "dijitReset dijitMenuTable";
		dijit.setWaiRole(o,"listbox");
		dijit.setWaiRole(n,"presentation");
		n.appendChild(o);
		this.tabIndex=null; // so tabindex=0 does not get set on domNode (role="presentation" AND tabindex is invalid)
	},
	resize: function(/*Object*/ mb){
		// summary:
		//		Overridden so that we are able to handle resizing our
		//		internal widget.  Note that this is not a "full" resize
		//		implementation - it only works correctly if you pass it a
		//		marginBox.
		//
		// mb: Object
		//		The margin box to set this dropdown to.
		if(mb){
			dojo.marginBox(this.domNode, mb);
			var w = dojo.contentBox(this.domNode).w;
			if(dojo.isMoz && this.domNode.scrollHeight > this.domNode.clientHeight){
				w--;
			}else if(dojo.isIE < 8 || (dojo.isIE && dojo.isQuirks)){
				// IE < 8 and IE8 in quirks mode doesn't need this additional
				// width of the scrollbar...it causes a horizontal scroll bar
				// (as well as continually expanding the dropdown each time
				// it is opened)
				w -= 16;
			}
			dojo.marginBox(this.menuTableNode, {w: w});
		}
	}
});

dojo.declare("dijit.form.Select", [dijit.form._FormSelectWidget, dijit._HasDropDown], {
	// summary:
	//		This is a "styleable" select box - it is basically a DropDownButton which
	//		can take a <select> as its input.

	baseClass: "dijitSelect",

	templateString: dojo.cache("dijit.form", "templates/Select.html", "<table class='dijit dijitReset dijitInline dijitLeft'\r\n\tdojoAttachPoint=\"_buttonNode,tableNode\" cellspacing='0' cellpadding='0' waiRole=\"presentation\"\r\n\tdojoAttachEvent=\"onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse\"\r\n\t><tbody waiRole=\"presentation\"><tr waiRole=\"presentation\"\r\n\t\t><td class=\"dijitReset dijitStretch dijitButtonContents dijitButtonNode\" dojoAttachPoint=\"focusNode\"\r\n\t\t\twaiRole=\"combobox\" waiState=\"haspopup-true\"\r\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"  dojoAttachPoint=\"containerNode,_popupStateNode\"></span\r\n\t\t\t><input type=\"hidden\" ${nameAttrSetting} dojoAttachPoint=\"valueNode\" value=\"${value}\" waiState=\"hidden-true\" />\r\n\t\t</td><td class=\"dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton\"\r\n\t\t\t\tdojoAttachPoint=\"titleNode\" waiRole=\"presentation\"\r\n\t\t\t><div class=\"dijitReset dijitArrowButtonInner\" waiRole=\"presentation\">&thinsp;</div\r\n\t\t\t><div class=\"dijitReset dijitArrowButtonChar\" waiRole=\"presentation\">&#9660;</div\r\n\t\t></td\r\n\t></tr></tbody\r\n></table>\r\n"),

	// attributeMap: Object
	//		Add in our style to be applied to the focus node
	attributeMap: dojo.mixin(dojo.clone(dijit.form._FormSelectWidget.prototype.attributeMap),{style:"tableNode"}),

	// required: Boolean
	//		Can be true or false, default is false.
	required: false,

	// state: String
	//		Shows current state (ie, validation result) of input (Normal, Warning, or Error)
	state: "",

	//	tooltipPosition: String[]
	//		See description of dijit.Tooltip.defaultPosition for details on this parameter.
	tooltipPosition: [],

	// emptyLabel: string
	//		What to display in an "empty" dropdown
	emptyLabel: "",

	// _isLoaded: Boolean
	//		Whether or not we have been loaded
	_isLoaded: false,

	// _childrenLoaded: Boolean
	//		Whether or not our children have been loaded
	_childrenLoaded: false,

	_fillContent: function(){
		// summary:
		//		Set the value to be the first, or the selected index
		this.inherited(arguments);
		if(this.options.length && !this.value && this.srcNodeRef){
			var si = this.srcNodeRef.selectedIndex;
			this.value = this.options[si != -1 ? si : 0].value;
		}

		// Create the dropDown widget
		this.dropDown = new dijit.form._SelectMenu();
		dojo.addClass(this.dropDown.domNode, this.baseClass + "Menu");
	},

	_getMenuItemForOption: function(/*dijit.form.__SelectOption*/ option){
		// summary:
		//		For the given option, return the menu item that should be
		//		used to display it.  This can be overridden as needed
		if(!option.value){
			// We are a separator (no label set for it)
			return new dijit.MenuSeparator();
		}else{
			// Just a regular menu option
			var click = dojo.hitch(this, "_setValueAttr", option);
			var item = new dijit.MenuItem({
				option: option,
				label: option.label,
				onClick: click,
				disabled: option.disabled || false
			});
			dijit.setWaiRole(item.focusNode, "listitem");
			return item;
		}
	},

	_addOptionItem: function(/*dijit.form.__SelectOption*/ option){
		// summary:
		//		For the given option, add an option to our dropdown.
		//		If the option doesn't have a value, then a separator is added
		//		in that place.
		if(this.dropDown){
			this.dropDown.addChild(this._getMenuItemForOption(option));
		}
	},

	_getChildren: function(){
		if(!this.dropDown){
			return [];
		}
		return this.dropDown.getChildren();
	},

	_loadChildren: function(/*Boolean*/ loadMenuItems){
		// summary:
		//		Resets the menu and the length attribute of the button - and
		//		ensures that the label is appropriately set.
		//	loadMenuItems: Boolean
		//		actually loads the child menu items - we only do this when we are
		//		populating for showing the dropdown.

		if(loadMenuItems === true){
			// this.inherited destroys this.dropDown's child widgets (MenuItems).
			// Avoid this.dropDown (Menu widget) having a pointer to a destroyed widget (which will cause
			// issues later in _setSelected). (see #10296)
			if(this.dropDown){
				delete this.dropDown.focusedChild;
			}
			if(this.options.length){
				this.inherited(arguments);
			}else{
				// Drop down menu is blank but add one blank entry just so something appears on the screen
				// to let users know that they are no choices (mimicing native select behavior)
				dojo.forEach(this._getChildren(), function(child){ child.destroyRecursive(); });
				var item = new dijit.MenuItem({label: "&nbsp;"});
				this.dropDown.addChild(item);
			}
		}else{
			this._updateSelection();
		}

		var len = this.options.length;
		this._isLoaded = false;
		this._childrenLoaded = true;

		if(!this._loadingStore){
			// Don't call this if we are loading - since we will handle it later
			this._setValueAttr(this.value);
		}
	},

	_setValueAttr: function(value){
		this.inherited(arguments);
		dojo.attr(this.valueNode, "value", this.attr("value"));
	},

	_setDisplay: function(/*String*/ newDisplay){
		// summary:
		//		sets the display for the given value (or values)
		this.containerNode.innerHTML = '<span class="dijitReset dijitInline ' + this.baseClass + 'Label">' +
					(newDisplay || this.emptyLabel || "&nbsp;") +
					'</span>';
		dijit.setWaiState(this.focusNode, "valuenow", (newDisplay || this.emptyLabel || "&nbsp;") );
	},

	validate: function(/*Boolean*/ isFocused){
		// summary:
		//		Called by oninit, onblur, and onkeypress.
		// description:
		//		Show missing or invalid messages if appropriate, and highlight textbox field.
		//		Used when a select is initially set to no value and the user is required to
		//		set the value.
		
		var isValid = this.isValid(isFocused);
		this.state = isValid ? "" : "Error";
		this._setStateClass();
		dijit.setWaiState(this.focusNode, "invalid", isValid ? "false" : "true");
		var message = isValid ? "" : this._missingMsg;
		if(this._message !== message){
			this._message = message;
			dijit.hideTooltip(this.domNode);
			if(message){
				dijit.showTooltip(message, this.domNode, this.tooltipPosition);
			}
		}
		return isValid;
	},

	isValid: function(/*Boolean*/ isFocused){
		// summary:
		//		Whether or not this is a valid value.   The only way a Select
		//		can be invalid is when it's required but nothing is selected.
		return (!this.required || !(/^\s*$/.test(this.value)));
	},

	reset: function(){
		// summary:
		//		Overridden so that the state will be cleared.
		this.inherited(arguments);
		dijit.hideTooltip(this.domNode);
		this.state = "";
		this._setStateClass();
		delete this._message;
	},

	postMixInProperties: function(){
		// summary:
		//		set the missing message
		this.inherited(arguments);
		this._missingMsg = dojo.i18n.getLocalization("dijit.form", "validate",
									this.lang).missingMessage;
	},

	postCreate: function(){
		this.inherited(arguments);
		if(this.tableNode.style.width){
			dojo.addClass(this.domNode, this.baseClass + "FixedWidth");
		}
	},

	isLoaded: function(){
		return this._isLoaded;
	},

	loadDropDown: function(/*Function*/ loadCallback){
		// summary:
		//		populates the menu
		this._loadChildren(true);
		this._isLoaded = true;
		loadCallback();
	},

	uninitialize: function(preserveDom){
		if(this.dropDown && !this.dropDown._destroyed){
			this.dropDown.destroyRecursive(preserveDom);
			delete this.dropDown;
		}
		this.inherited(arguments);
	}
});

}

if(!dojo._hasResource["xwt.widget.form.DropDown"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.form.DropDown"] = true;
/*******************************************************************   
 *        Copyright (c) 2009-2011 Cisco Systems, Inc.   
 *        All rights reserved.   
 * 
 * @fileoverview 
 * The dropdown is an extension of the existing dijit select with some UE enhancements. 
 * @author Dennis Park denpark@cisco.com
 * @author Priston Sesumichael psesumic@cisco.com
 ********************************************************************/
dojo.provide("xwt.widget.form.DropDown");

dojo.declare("xwt.widget.form.DropDown", dijit.form.Select, {

	// summary:
	//	The Dropdown List widget is a combination of a dropdown list or list box and a single-line text input field. 
	//	Unlike the ComboBox, which lets users select or enter values, a Dropdown List requires users to select a 
	//	single value from the list of predefined values.The text input field permits narrowing down the choices, but users
	//	cannot enter a value that is not in the list.
	// description:
	//	The Dropdown List widget is a combination of a dropdown list or list box and a single-line text input field. 
	//	A dropdown list requires users to select a single value from a list of predefined values. 
	//
	// example:
	//	To create the widget using HTML markup:
	//		|	<div dojoType="dojo.data.ItemFileReadStore" url="data/states.json" jsId="comboStore"></div>
	//		|	<input dojoType="xwt.widget.form.DropDown" value="California" store="comboStore" searchAttr="name"
	//		|	name="state"  id="stateInput" />
	//	
	//	To create the widget programmatically:
	//		|	_dropDown = new xwt.widget.form.DropDowm( { value : "California", store : "comboStore",
	//		|												searchAttr:"name", name:"state", id:"stateInput"});
	//		|	_dropDown.startup(); need to call startup once

		
	baseClass: "xwtDropDown dijitSelect",
	

	closeDropDown: function(/*Boolean*/ focus){
		//	summary:
		//		Remove the new class.
		//	tags:
		//		extension
		//	focus: Boolean
		//		Indicates whether the Dropdown needs to be focused or not.
		this.inherited(arguments);
		dojo.removeClass(this.titleNode, "dojoArrowButtonPushed");
		dojo.removeClass(this.titleNode, "downArrowPressed");
	},

	openDropDown: function(){
		this.inherited(arguments);
		dojo.addClass(this.titleNode, "dijitArrowButtonActive");
		dojo.addClass(this.titleNode, "downArrowPressed");		
	},
	
	startup: function(){
		//	summary:
		//		Overrides the default Dojo Widget startup method. See
		//		Dojo docs for a complete description.
		//	tags:
		//		extension
		this.inherited(arguments);	
		
		/**
		 * Calling toggleDropDown will force the loading of the 
		 * menu data and create the DOM node. 
		 * We have to connect to the openDropDown method
		 * because the loading of the data can be async and 
		 * the menu won't be loaded when we call the margin box. 
		 *  
		 * Also:  Note that the focus controls are temporarily disabled. 
		 * This is to avoid bad focus changes during DOM render, which 
		 * can cause serious browser issues, like inadvertant 
		 * destruction of DOM nodes. 
		 */  
		this.tempDropdownConnect = dojo.connect(this, "openDropDown", this, "_sizeWidget");
		if(this.focus){
			this._oldFocus = this.focus;
			this.focus = function() {}; // Do nothing, ignore focus changes.  
		}
		if(this.dropDown){
			if(this.dropDown.focus){
				this.dropDown._oldFocus = this.dropDown.focus;
				this.dropDown.focus = function() {};
			}
			if(this.dropDown.domNode){
				// 'Hide' it from view, but keep size for size calc in sizeWidget
				// Cosmetic change to make it not 'blip'
				this._oldVisibility = dojo.style(this.dropDown.domNode, "visibility");
				dojo.style(this.dropDown.domNode, "visibility", "hidden");
			}
		}
		this.toggleDropDown();
	},
	
	_sizeWidget: function(){
		// summary:
		//		Sets the width of the focus node to
		//		the width of the dropdown menu.  The dropdown must be loaded for it to work.
		//
		//		Note: It must be called any time that the menu changes.  If
		//		desired, it can be connected to the _addOptionItem method or
		//		the like.
		var dropDownMb = dojo.marginBox(this.dropDown.domNode);
		var _rightMarginOffset = 20;
		var _width = dropDownMb.w - _rightMarginOffset;
		if(_width > 0){
			this.focusNode.style.width = _width + "px";
			this.toggleDropDown();
			if(this.tempDropdownConnect){
				dojo.disconnect(this.tempDropdownConnect);
				delete this.tempDropdownConnect;
			}
			this._sizeWidgetCalled = true;

			// Restore the focus handlers, if necessary, 
			// from disable in startup code.
			if(this._oldFocus){
				this.focus = this._oldFocus;
				delete this._oldFocus;
			}
			if(this.dropDown){
				if(this.dropDown._oldFocus){
					this.dropDown.focus = this.dropDown._oldFocus;
					delete this.dropDown._oldFocus;
				}
				if(this.dropDown.domNode && this._oldVisibility){
					dojo.style(this.dropDown.domNode, "visibility", this._oldVisibility);
					delete this._oldVisibility;
				}
			}
		}
	},

	_setDisplay: function(/*String*/ newDisplay){
		  // summary:
		  //  sets the display for the given value (or values)
		  var dropDownMb = null;
		  var _rightMarginOffset = 25;
		  
		  if(dojo.hasClass(dojo.body(),"kubricklite"))
		  {
			  if(dojo.isIE){
			   dropDownMb = dojo.contentBox(this.domNode);
			   _rightMarginOffset = 32;
			  }else{
			   dropDownMb = dojo.marginBox(this.domNode);
			   _rightMarginOffset = 37;
			  } 
		  }
		  else
		  {
			  if(dojo.isIE){
			   dropDownMb = dojo.contentBox(this.domNode);
			   _rightMarginOffset = 25;
			  }else{
			   dropDownMb = dojo.marginBox(this.domNode);
			   _rightMarginOffset = 30;
			  }
		  }
		  
		  var _width =null;
		  if(dropDownMb.w>_rightMarginOffset)
		  {
		   _width = dropDownMb.w - _rightMarginOffset;
		  }
		  else if(dropDownMb.w<=0)
		  {
			  _width=100;
		  }
		  else
		  {
			  _width = dropDownMb.w;
		  }
		  
		  this.containerNode.style.width =  _width+"px";
		 
		  this.containerNode.innerHTML = '<span style = "width:'+_width+'px;" class="dijitReset dijitInline ' + this.baseClass + 'Label">' +
		     (newDisplay || this.emptyLabel || "&nbsp;")+'</span>';
		  dijit.setWaiState(this.focusNode, "valuenow", (newDisplay || this.emptyLabel || "&nbsp;") );
		  
		 },

	setStore: function(store){
		// summary:
		//		Handles setting the store on the widget.
		// store: String
		//		The store to set.
		if(this.tempDropdownConnect){
			dojo.disconnect(this.tempDropdownConnect);
			delete this.tempDropdownConnect;
		}
		this.tempDropdownConnect = dojo.connect(this, "onSetStore", this, "_sizeWidget");
		this.inherited(arguments);
		this.toggleDropDown();
	}
});

}

if(!dojo._hasResource["dojo.dnd.common"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.common"] = true;
dojo.provide("dojo.dnd.common");

dojo.dnd.getCopyKeyState = dojo.isCopyKeyPressed;

dojo.dnd._uniqueId = 0;
dojo.dnd.getUniqueId = function(){
	// summary:
	//		returns a unique string for use with any DOM element
	var id;
	do{
		id = dojo._scopeName + "Unique" + (++dojo.dnd._uniqueId);
	}while(dojo.byId(id));
	return id;
};

dojo.dnd._empty = {};

dojo.dnd.isFormElement = function(/*Event*/ e){
	// summary:
	//		returns true if user clicked on a form element
	var t = e.target;
	if(t.nodeType == 3 /*TEXT_NODE*/){
		t = t.parentNode;
	}
	return " button textarea input select option ".indexOf(" " + t.tagName.toLowerCase() + " ") >= 0;	// Boolean
};

}

if(!dojo._hasResource["dojo.dnd.Container"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Container"] = true;
dojo.provide("dojo.dnd.Container");




/*
	Container states:
		""		- normal state
		"Over"	- mouse over a container
	Container item states:
		""		- normal state
		"Over"	- mouse over a container item
*/

/*=====
dojo.declare("dojo.dnd.__ContainerArgs", [], {
	creator: function(){
		// summary:
		//		a creator function, which takes a data item, and returns an object like that:
		//		{node: newNode, data: usedData, type: arrayOfStrings}
	},

	// skipForm: Boolean
	//		don't start the drag operation, if clicked on form elements
	skipForm: false,

	// dropParent: Node||String
	//		node or node's id to use as the parent node for dropped items
	//		(must be underneath the 'node' parameter in the DOM)
	dropParent: null,

	// _skipStartup: Boolean
	//		skip startup(), which collects children, for deferred initialization
	//		(this is used in the markup mode)
	_skipStartup: false
});

dojo.dnd.Item = function(){
	// summary:
	//		Represents (one of) the source node(s) being dragged.
	//		Contains (at least) the "type" and "data" attributes.
	// type: String[]
	//		Type(s) of this item, by default this is ["text"]
	// data: Object
	//		Logical representation of the object being dragged.
	//		If the drag object's type is "text" then data is a String,
	//		if it's another type then data could be a different Object,
	//		perhaps a name/value hash.
	
	this.type = type;
	this.data = data;
}
=====*/

dojo.declare("dojo.dnd.Container", null, {
	// summary:
	//		a Container object, which knows when mouse hovers over it, 
	//		and over which element it hovers
	
	// object attributes (for markup)
	skipForm: false,
	
	/*=====
	// current: DomNode
	//		The DOM node the mouse is currently hovered over
	current: null,
	
	// map: Hash<String, dojo.dnd.Item>
	//		Map from an item's id (which is also the DOMNode's id) to
	//		the dojo.dnd.Item itself.
	map: {},
	=====*/
	
	constructor: function(node, params){
		// summary:
		//		a constructor of the Container
		// node: Node
		//		node or node's id to build the container on
		// params: dojo.dnd.__ContainerArgs
		//		a dictionary of parameters
		this.node = dojo.byId(node);
		if(!params){ params = {}; }
		this.creator = params.creator || null;
		this.skipForm = params.skipForm;
		this.parent = params.dropParent && dojo.byId(params.dropParent);
		
		// class-specific variables
		this.map = {};
		this.current = null;

		// states
		this.containerState = "";
		dojo.addClass(this.node, "dojoDndContainer");
		
		// mark up children
		if(!(params && params._skipStartup)){
			this.startup();
		}

		// set up events
		this.events = [
			dojo.connect(this.node, "onmouseover", this, "onMouseOver"),
			dojo.connect(this.node, "onmouseout",  this, "onMouseOut"),
			// cancel text selection and text dragging
			dojo.connect(this.node, "ondragstart",   this, "onSelectStart"),
			dojo.connect(this.node, "onselectstart", this, "onSelectStart")
		];
	},
	
	// object attributes (for markup)
	creator: function(){
		// summary:
		//		creator function, dummy at the moment
	},
	
	// abstract access to the map
	getItem: function(/*String*/ key){
		// summary:
		//		returns a data item by its key (id)
		return this.map[key];	// dojo.dnd.Item
	},
	setItem: function(/*String*/ key, /*dojo.dnd.Item*/ data){
		// summary:
		//		associates a data item with its key (id)
		this.map[key] = data;
	},
	delItem: function(/*String*/ key){
		// summary:
		//		removes a data item from the map by its key (id)
		delete this.map[key];
	},
	forInItems: function(/*Function*/ f, /*Object?*/ o){
		// summary:
		//		iterates over a data map skipping members that 
		//		are present in the empty object (IE and/or 3rd-party libraries).
		o = o || dojo.global;
		var m = this.map, e = dojo.dnd._empty;
		for(var i in m){
			if(i in e){ continue; }
			f.call(o, m[i], i, this);
		}
		return o;	// Object
	},
	clearItems: function(){
		// summary:
		//		removes all data items from the map
		this.map = {};
	},
	
	// methods
	getAllNodes: function(){
		// summary:
		//		returns a list (an array) of all valid child nodes
		return dojo.query("> .dojoDndItem", this.parent);	// NodeList
	},
	sync: function(){
		// summary:
		//		sync up the node list with the data map
		var map = {};
		this.getAllNodes().forEach(function(node){
			if(node.id){
				var item = this.getItem(node.id);
				if(item){
					map[node.id] = item;
					return;
				}
			}else{
				node.id = dojo.dnd.getUniqueId();
			}
			var type = node.getAttribute("dndType"),
				data = node.getAttribute("dndData");
			map[node.id] = {
				data: data || node.innerHTML,
				type: type ? type.split(/\s*,\s*/) : ["text"]
			};
		}, this);
		this.map = map;
		return this;	// self
	},
	insertNodes: function(data, before, anchor){
		// summary:
		//		inserts an array of new nodes before/after an anchor node
		// data: Array
		//		a list of data items, which should be processed by the creator function
		// before: Boolean
		//		insert before the anchor, if true, and after the anchor otherwise
		// anchor: Node
		//		the anchor node to be used as a point of insertion
		if(!this.parent.firstChild){
			anchor = null;
		}else if(before){
			if(!anchor){
				anchor = this.parent.firstChild;
			}
		}else{
			if(anchor){
				anchor = anchor.nextSibling;
			}
		}
		if(anchor){
			for(var i = 0; i < data.length; ++i){
				var t = this._normalizedCreator(data[i]);
				this.setItem(t.node.id, {data: t.data, type: t.type});
				this.parent.insertBefore(t.node, anchor);
			}
		}else{
			for(var i = 0; i < data.length; ++i){
				var t = this._normalizedCreator(data[i]);
				this.setItem(t.node.id, {data: t.data, type: t.type});
				this.parent.appendChild(t.node);
			}
		}
		return this;	// self
	},
	destroy: function(){
		// summary:
		//		prepares this object to be garbage-collected
		dojo.forEach(this.events, dojo.disconnect);
		this.clearItems();
		this.node = this.parent = this.current = null;
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.Container(node, params);
	},
	startup: function(){
		// summary:
		//		collects valid child items and populate the map
		
		// set up the real parent node
		if(!this.parent){
			// use the standard algorithm, if not assigned
			this.parent = this.node;
			if(this.parent.tagName.toLowerCase() == "table"){
				var c = this.parent.getElementsByTagName("tbody");
				if(c && c.length){ this.parent = c[0]; }
			}
		}
		this.defaultCreator = dojo.dnd._defaultCreator(this.parent);

		// process specially marked children
		this.sync();
	},

	// mouse events
	onMouseOver: function(e){
		// summary:
		//		event processor for onmouseover
		// e: Event
		//		mouse event
		var n = e.relatedTarget;
		while(n){
			if(n == this.node){ break; }
			try{
				n = n.parentNode;
			}catch(x){
				n = null;
			}
		}
		if(!n){
			this._changeState("Container", "Over");
			this.onOverEvent();
		}
		n = this._getChildByEvent(e);
		if(this.current == n){ return; }
		if(this.current){ this._removeItemClass(this.current, "Over"); }
		if(n){ this._addItemClass(n, "Over"); }
		this.current = n;
	},
	onMouseOut: function(e){
		// summary:
		//		event processor for onmouseout
		// e: Event
		//		mouse event
		for(var n = e.relatedTarget; n;){
			if(n == this.node){ return; }
			try{
				n = n.parentNode;
			}catch(x){
				n = null;
			}
		}
		if(this.current){
			this._removeItemClass(this.current, "Over");
			this.current = null;
		}
		this._changeState("Container", "");
		this.onOutEvent();
	},
	onSelectStart: function(e){
		// summary:
		//		event processor for onselectevent and ondragevent
		// e: Event
		//		mouse event
		if(!this.skipForm || !dojo.dnd.isFormElement(e)){
			dojo.stopEvent(e);
		}
	},
	
	// utilities
	onOverEvent: function(){
		// summary:
		//		this function is called once, when mouse is over our container
	},
	onOutEvent: function(){
		// summary:
		//		this function is called once, when mouse is out of our container
	},
	_changeState: function(type, newState){
		// summary:
		//		changes a named state to new state value
		// type: String
		//		a name of the state to change
		// newState: String
		//		new state
		var prefix = "dojoDnd" + type;
		var state  = type.toLowerCase() + "State";
		//dojo.replaceClass(this.node, prefix + newState, prefix + this[state]);
		dojo.removeClass(this.node, prefix + this[state]);
		dojo.addClass(this.node, prefix + newState);
		this[state] = newState;
	},
	_addItemClass: function(node, type){
		// summary:
		//		adds a class with prefix "dojoDndItem"
		// node: Node
		//		a node
		// type: String
		//		a variable suffix for a class name
		dojo.addClass(node, "dojoDndItem" + type);
	},
	_removeItemClass: function(node, type){
		// summary:
		//		removes a class with prefix "dojoDndItem"
		// node: Node
		//		a node
		// type: String
		//		a variable suffix for a class name
		dojo.removeClass(node, "dojoDndItem" + type);
	},
	_getChildByEvent: function(e){
		// summary:
		//		gets a child, which is under the mouse at the moment, or null
		// e: Event
		//		a mouse event
		var node = e.target;
		if(node){
			for(var parent = node.parentNode; parent; node = parent, parent = node.parentNode){
				if(parent == this.parent && dojo.hasClass(node, "dojoDndItem")){ return node; }
			}
		}
		return null;
	},
	_normalizedCreator: function(/*dojo.dnd.Item*/ item, /*String*/ hint){
		// summary:
		//		adds all necessary data to the output of the user-supplied creator function
		var t = (this.creator || this.defaultCreator).call(this, item, hint);
		if(!dojo.isArray(t.type)){ t.type = ["text"]; }
		if(!t.node.id){ t.node.id = dojo.dnd.getUniqueId(); }
		dojo.addClass(t.node, "dojoDndItem");
		return t;
	}
});

dojo.dnd._createNode = function(tag){
	// summary:
	//		returns a function, which creates an element of given tag 
	//		(SPAN by default) and sets its innerHTML to given text
	// tag: String
	//		a tag name or empty for SPAN
	if(!tag){ return dojo.dnd._createSpan; }
	return function(text){	// Function
		return dojo.create(tag, {innerHTML: text});	// Node
	};
};

dojo.dnd._createTrTd = function(text){
	// summary:
	//		creates a TR/TD structure with given text as an innerHTML of TD
	// text: String
	//		a text for TD
	var tr = dojo.create("tr");
	dojo.create("td", {innerHTML: text}, tr);
	return tr;	// Node
};

dojo.dnd._createSpan = function(text){
	// summary:
	//		creates a SPAN element with given text as its innerHTML
	// text: String
	//		a text for SPAN
	return dojo.create("span", {innerHTML: text});	// Node
};

// dojo.dnd._defaultCreatorNodes: Object
//		a dictionary that maps container tag names to child tag names
dojo.dnd._defaultCreatorNodes = {ul: "li", ol: "li", div: "div", p: "div"};

dojo.dnd._defaultCreator = function(node){
	// summary:
	//		takes a parent node, and returns an appropriate creator function
	// node: Node
	//		a container node
	var tag = node.tagName.toLowerCase();
	var c = tag == "tbody" || tag == "thead" ? dojo.dnd._createTrTd :
			dojo.dnd._createNode(dojo.dnd._defaultCreatorNodes[tag]);
	return function(item, hint){	// Function
		var isObj = item && dojo.isObject(item), data, type, n;
		if(isObj && item.tagName && item.nodeType && item.getAttribute){
			// process a DOM node
			data = item.getAttribute("dndData") || item.innerHTML;
			type = item.getAttribute("dndType");
			type = type ? type.split(/\s*,\s*/) : ["text"];
			n = item;	// this node is going to be moved rather than copied
		}else{
			// process a DnD item object or a string
			data = (isObj && item.data) ? item.data : item;
			type = (isObj && item.type) ? item.type : ["text"];
			n = (hint == "avatar" ? dojo.dnd._createSpan : c)(String(data));
		}
		n.id = dojo.dnd.getUniqueId();
		return {node: n, data: data, type: type};
	};
};

}

if(!dojo._hasResource["dojo.dnd.Selector"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Selector"] = true;
dojo.provide("dojo.dnd.Selector");




/*
	Container item states:
		""			- an item is not selected
		"Selected"	- an item is selected
		"Anchor"	- an item is selected, and is an anchor for a "shift" selection
*/

/*=====
dojo.declare("dojo.dnd.__SelectorArgs", [dojo.dnd.__ContainerArgs], {
	//	singular: Boolean
	//		allows selection of only one element, if true
	singular: false,

	//	autoSync: Boolean
	//		autosynchronizes the source with its list of DnD nodes,
	autoSync: false
});
=====*/

dojo.declare("dojo.dnd.Selector", dojo.dnd.Container, {
	// summary:
	//		a Selector object, which knows how to select its children
	
	/*=====
	// selection: Set<String>
	//		The set of id's that are currently selected, such that this.selection[id] == 1
	//		if the node w/that id is selected.  Can iterate over selected node's id's like:
	//	|		for(var id in this.selection)
	selection: {},
	=====*/

	constructor: function(node, params){
		// summary:
		//		constructor of the Selector
		// node: Node||String
		//		node or node's id to build the selector on
		// params: dojo.dnd.__SelectorArgs?
		//		a dictionary of parameters
		if(!params){ params = {}; }
		this.singular = params.singular;
		this.autoSync = params.autoSync;
		// class-specific variables
		this.selection = {};
		this.anchor = null;
		this.simpleSelection = false;
		// set up events
		this.events.push(
			dojo.connect(this.node, "onmousedown", this, "onMouseDown"),
			dojo.connect(this.node, "onmouseup",   this, "onMouseUp"));
	},
	
	// object attributes (for markup)
	singular: false,	// is singular property
	
	// methods
	getSelectedNodes: function(){
		// summary:
		//		returns a list (an array) of selected nodes
		var t = new dojo.NodeList();
		var e = dojo.dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			t.push(dojo.byId(i));
		}
		return t;	// NodeList
	},
	selectNone: function(){
		// summary:
		//		unselects all items
		return this._removeSelection()._removeAnchor();	// self
	},
	selectAll: function(){
		// summary:
		//		selects all items
		this.forInItems(function(data, id){
			this._addItemClass(dojo.byId(id), "Selected");
			this.selection[id] = 1;
		}, this);
		return this._removeAnchor();	// self
	},
	deleteSelectedNodes: function(){
		// summary:
		//		deletes all selected items
		var e = dojo.dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			var n = dojo.byId(i);
			this.delItem(i);
			dojo.destroy(n);
		}
		this.anchor = null;
		this.selection = {};
		return this;	// self
	},
	forInSelectedItems: function(/*Function*/ f, /*Object?*/ o){
		// summary:
		//		iterates over selected items;
		//		see `dojo.dnd.Container.forInItems()` for details
		o = o || dojo.global;
		var s = this.selection, e = dojo.dnd._empty;
		for(var i in s){
			if(i in e){ continue; }
			f.call(o, this.getItem(i), i, this);
		}
	},
	sync: function(){
		// summary:
		//		sync up the node list with the data map
		
		dojo.dnd.Selector.superclass.sync.call(this);
		
		// fix the anchor
		if(this.anchor){
			if(!this.getItem(this.anchor.id)){
				this.anchor = null;
			}
		}
		
		// fix the selection
		var t = [], e = dojo.dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			if(!this.getItem(i)){
				t.push(i);
			}
		}
		dojo.forEach(t, function(i){
			delete this.selection[i];
		}, this);
		
		return this;	// self
	},
	insertNodes: function(addSelected, data, before, anchor){
		// summary:
		//		inserts new data items (see `dojo.dnd.Container.insertNodes()` method for details)
		// addSelected: Boolean
		//		all new nodes will be added to selected items, if true, no selection change otherwise
		// data: Array
		//		a list of data items, which should be processed by the creator function
		// before: Boolean
		//		insert before the anchor, if true, and after the anchor otherwise
		// anchor: Node
		//		the anchor node to be used as a point of insertion
		var oldCreator = this._normalizedCreator;
		this._normalizedCreator = function(item, hint){
			var t = oldCreator.call(this, item, hint);
			if(addSelected){
				if(!this.anchor){
					this.anchor = t.node;
					this._removeItemClass(t.node, "Selected");
					this._addItemClass(this.anchor, "Anchor");
				}else if(this.anchor != t.node){
					this._removeItemClass(t.node, "Anchor");
					this._addItemClass(t.node, "Selected");
				}
				this.selection[t.node.id] = 1;
			}else{
				this._removeItemClass(t.node, "Selected");
				this._removeItemClass(t.node, "Anchor");
			}
			return t;
		};
		dojo.dnd.Selector.superclass.insertNodes.call(this, data, before, anchor);
		this._normalizedCreator = oldCreator;
		return this;	// self
	},
	destroy: function(){
		// summary:
		//		prepares the object to be garbage-collected
		dojo.dnd.Selector.superclass.destroy.call(this);
		this.selection = this.anchor = null;
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.Selector(node, params);
	},

	// mouse events
	onMouseDown: function(e){
		// summary:
		//		event processor for onmousedown
		// e: Event
		//		mouse event
		if(this.autoSync){ this.sync(); }
		if(!this.current){ return; }
		if(!this.singular && !dojo.isCopyKey(e) && !e.shiftKey && (this.current.id in this.selection)){
			this.simpleSelection = true;
			if(e.button === dojo.mouseButtons.LEFT){
				// accept the left button and stop the event
				// for IE we don't stop event when multiple buttons are pressed
				dojo.stopEvent(e);
			}
			return;
		}
		if(!this.singular && e.shiftKey){
			if(!dojo.isCopyKey(e)){
				this._removeSelection();
			}
			var c = this.getAllNodes();
			if(c.length){
				if(!this.anchor){
					this.anchor = c[0];
					this._addItemClass(this.anchor, "Anchor");
				}
				this.selection[this.anchor.id] = 1;
				if(this.anchor != this.current){
					var i = 0;
					for(; i < c.length; ++i){
						var node = c[i];
						if(node == this.anchor || node == this.current){ break; }
					}
					for(++i; i < c.length; ++i){
						var node = c[i];
						if(node == this.anchor || node == this.current){ break; }
						this._addItemClass(node, "Selected");
						this.selection[node.id] = 1;
					}
					this._addItemClass(this.current, "Selected");
					this.selection[this.current.id] = 1;
				}
			}
		}else{
			if(this.singular){
				if(this.anchor == this.current){
					if(dojo.isCopyKey(e)){
						this.selectNone();
					}
				}else{
					this.selectNone();
					this.anchor = this.current;
					this._addItemClass(this.anchor, "Anchor");
					this.selection[this.current.id] = 1;
				}
			}else{
				if(dojo.isCopyKey(e)){
					if(this.anchor == this.current){
						delete this.selection[this.anchor.id];
						this._removeAnchor();
					}else{
						if(this.current.id in this.selection){
							this._removeItemClass(this.current, "Selected");
							delete this.selection[this.current.id];
						}else{
							if(this.anchor){
								this._removeItemClass(this.anchor, "Anchor");
								this._addItemClass(this.anchor, "Selected");
							}
							this.anchor = this.current;
							this._addItemClass(this.current, "Anchor");
							this.selection[this.current.id] = 1;
						}
					}
				}else{
					if(!(this.current.id in this.selection)){
						this.selectNone();
						this.anchor = this.current;
						this._addItemClass(this.current, "Anchor");
						this.selection[this.current.id] = 1;
					}
				}
			}
		}
		dojo.stopEvent(e);
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup
		// e: Event
		//		mouse event
		if(!this.simpleSelection){ return; }
		this.simpleSelection = false;
		this.selectNone();
		if(this.current){
			this.anchor = this.current;
			this._addItemClass(this.anchor, "Anchor");
			this.selection[this.current.id] = 1;
		}
	},
	onMouseMove: function(e){
		// summary
		//		event processor for onmousemove
		// e: Event
		//		mouse event
		this.simpleSelection = false;
	},
	
	// utilities
	onOverEvent: function(){
		// summary:
		//		this function is called once, when mouse is over our container
		this.onmousemoveEvent = dojo.connect(this.node, "onmousemove", this, "onMouseMove");
	},
	onOutEvent: function(){
		// summary:
		//		this function is called once, when mouse is out of our container
		dojo.disconnect(this.onmousemoveEvent);
		delete this.onmousemoveEvent;
	},
	_removeSelection: function(){
		// summary:
		//		unselects all items
		var e = dojo.dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			var node = dojo.byId(i);
			if(node){ this._removeItemClass(node, "Selected"); }
		}
		this.selection = {};
		return this;	// self
	},
	_removeAnchor: function(){
		if(this.anchor){
			this._removeItemClass(this.anchor, "Anchor");
			this.anchor = null;
		}
		return this;	// self
	}
});

}

if(!dojo._hasResource["dojo.dnd.autoscroll"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.autoscroll"] = true;
dojo.provide("dojo.dnd.autoscroll");

dojo.dnd.getViewport = function(){
	// summary:
	//		Returns a viewport size (visible part of the window)

	// TODO: remove this when getViewport() moved to dojo core, see #7028

	// FIXME: need more docs!!
	var d = dojo.doc, dd = d.documentElement, w = window, b = dojo.body();
	if(dojo.isMozilla){
		return {w: dd.clientWidth, h: w.innerHeight};	// Object
	}else if(!dojo.isOpera && w.innerWidth){
		return {w: w.innerWidth, h: w.innerHeight};		// Object
	}else if (!dojo.isOpera && dd && dd.clientWidth){
		return {w: dd.clientWidth, h: dd.clientHeight};	// Object
	}else if (b.clientWidth){
		return {w: b.clientWidth, h: b.clientHeight};	// Object
	}
	return null;	// Object
};

dojo.dnd.V_TRIGGER_AUTOSCROLL = 32;
dojo.dnd.H_TRIGGER_AUTOSCROLL = 32;

dojo.dnd.V_AUTOSCROLL_VALUE = 16;
dojo.dnd.H_AUTOSCROLL_VALUE = 16;

dojo.dnd.autoScroll = function(e){
	// summary:
	//		a handler for onmousemove event, which scrolls the window, if
	//		necesary
	// e: Event
	//		onmousemove event

	// FIXME: needs more docs!
	var v = dojo.dnd.getViewport(), dx = 0, dy = 0;
	if(e.clientX < dojo.dnd.H_TRIGGER_AUTOSCROLL){
		dx = -dojo.dnd.H_AUTOSCROLL_VALUE;
	}else if(e.clientX > v.w - dojo.dnd.H_TRIGGER_AUTOSCROLL){
		dx = dojo.dnd.H_AUTOSCROLL_VALUE;
	}
	if(e.clientY < dojo.dnd.V_TRIGGER_AUTOSCROLL){
		dy = -dojo.dnd.V_AUTOSCROLL_VALUE;
	}else if(e.clientY > v.h - dojo.dnd.V_TRIGGER_AUTOSCROLL){
		dy = dojo.dnd.V_AUTOSCROLL_VALUE;
	}
	window.scrollBy(dx, dy);
};

dojo.dnd._validNodes = {"div": 1, "p": 1, "td": 1};
dojo.dnd._validOverflow = {"auto": 1, "scroll": 1};

dojo.dnd.autoScrollNodes = function(e){
	// summary:
	//		a handler for onmousemove event, which scrolls the first avaialble
	//		Dom element, it falls back to dojo.dnd.autoScroll()
	// e: Event
	//		onmousemove event

	// FIXME: needs more docs!
	for(var n = e.target; n;){
		if(n.nodeType == 1 && (n.tagName.toLowerCase() in dojo.dnd._validNodes)){
			var s = dojo.getComputedStyle(n);
			if(s.overflow.toLowerCase() in dojo.dnd._validOverflow){
				var b = dojo._getContentBox(n, s), t = dojo.position(n, true);
				//console.log(b.l, b.t, t.x, t.y, n.scrollLeft, n.scrollTop);
				var w = Math.min(dojo.dnd.H_TRIGGER_AUTOSCROLL, b.w / 2), 
					h = Math.min(dojo.dnd.V_TRIGGER_AUTOSCROLL, b.h / 2),
					rx = e.pageX - t.x, ry = e.pageY - t.y, dx = 0, dy = 0;
				if(dojo.isWebKit || dojo.isOpera){
					// FIXME: this code should not be here, it should be taken into account 
					// either by the event fixing code, or the dojo.position()
					// FIXME: this code doesn't work on Opera 9.5 Beta
					rx += dojo.body().scrollLeft, ry += dojo.body().scrollTop;
				}
				if(rx > 0 && rx < b.w){
					if(rx < w){
						dx = -w;
					}else if(rx > b.w - w){
						dx = w;
					}
				}
				//console.log("ry =", ry, "b.h =", b.h, "h =", h);
				if(ry > 0 && ry < b.h){
					if(ry < h){
						dy = -h;
					}else if(ry > b.h - h){
						dy = h;
					}
				}
				var oldLeft = n.scrollLeft, oldTop = n.scrollTop;
				n.scrollLeft = n.scrollLeft + dx;
				n.scrollTop  = n.scrollTop  + dy;
				if(oldLeft != n.scrollLeft || oldTop != n.scrollTop){ return; }
			}
		}
		try{
			n = n.parentNode;
		}catch(x){
			n = null;
		}
	}
	dojo.dnd.autoScroll(e);
};

}

if(!dojo._hasResource["dojo.dnd.Avatar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Avatar"] = true;
dojo.provide("dojo.dnd.Avatar");



dojo.declare("dojo.dnd.Avatar", null, {
	// summary:
	//		Object that represents transferred DnD items visually
	// manager: Object
	//		a DnD manager object

	constructor: function(manager){
		this.manager = manager;
		this.construct();
	},

	// methods
	construct: function(){
		// summary:
		//		constructor function;
		//		it is separate so it can be (dynamically) overwritten in case of need
		this.isA11y = dojo.hasClass(dojo.body(),"dijit_a11y");
		var a = dojo.create("table", {
				"class": "dojoDndAvatar",
				style: {
					position: "absolute",
					zIndex:   "1999",
					margin:   "0px"
				}
			}),
			source = this.manager.source, node,
			b = dojo.create("tbody", null, a),
			tr = dojo.create("tr", null, b),
			td = dojo.create("td", null, tr),
			icon = this.isA11y ? dojo.create("span", {
						id : "a11yIcon",
						innerHTML : this.manager.copy ? '+' : "<"
					}, td) : null,
			span = dojo.create("span", {
				innerHTML: source.generateText ? this._generateText() : ""
			}, td),
			k = Math.min(5, this.manager.nodes.length), i = 0;
		// we have to set the opacity on IE only after the node is live
		dojo.attr(tr, {
			"class": "dojoDndAvatarHeader",
			style: {opacity: 0.9}
		});
		for(; i < k; ++i){
			if(source.creator){
				// create an avatar representation of the node
				node = source._normalizedCreator(source.getItem(this.manager.nodes[i].id).data, "avatar").node;
			}else{
				// or just clone the node and hope it works
				node = this.manager.nodes[i].cloneNode(true);
				if(node.tagName.toLowerCase() == "tr"){
					// insert extra table nodes
					var table = dojo.create("table"),
						tbody = dojo.create("tbody", null, table);
					tbody.appendChild(node);
					node = table;
				}
			}
			node.id = "";
			tr = dojo.create("tr", null, b);
			td = dojo.create("td", null, tr);
			td.appendChild(node);
			dojo.attr(tr, {
				"class": "dojoDndAvatarItem",
				style: {opacity: (9 - i) / 10}
			});
		}
		this.node = a;
	},
	destroy: function(){
		// summary:
		//		destructor for the avatar; called to remove all references so it can be garbage-collected
		dojo.destroy(this.node);
		this.node = false;
	},
	update: function(){
		// summary:
		//		updates the avatar to reflect the current DnD state
		dojo[(this.manager.canDropFlag ? "add" : "remove") + "Class"](this.node, "dojoDndAvatarCanDrop");
		if (this.isA11y){
			var icon = dojo.byId("a11yIcon");
			var text = '+';   // assume canDrop && copy
			if (this.manager.canDropFlag && !this.manager.copy) {
				text = '< '; // canDrop && move 
			}else if (!this.manager.canDropFlag && !this.manager.copy) {
				text = "o"; //!canDrop && move
			}else if(!this.manager.canDropFlag){
				text = 'x';  // !canDrop && copy
			}
			icon.innerHTML=text;
		}
		// replace text
		dojo.query(("tr.dojoDndAvatarHeader td span" +(this.isA11y ? " span" : "")), this.node).forEach(
			function(node){
				node.innerHTML = this._generateText();
			}, this);
	},
	_generateText: function(){
		// summary: generates a proper text to reflect copying or moving of items
		return this.manager.nodes.length.toString();
	}
});

}

if(!dojo._hasResource["dojo.dnd.Manager"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Manager"] = true;
dojo.provide("dojo.dnd.Manager");





dojo.declare("dojo.dnd.Manager", null, {
	// summary:
	//		the manager of DnD operations (usually a singleton)
	constructor: function(){
		this.avatar  = null;
		this.source = null;
		this.nodes = [];
		this.copy  = true;
		this.target = null;
		this.canDropFlag = false;
		this.events = [];
	},

	// avatar's offset from the mouse
	OFFSET_X: 16,
	OFFSET_Y: 16,
	
	// methods
	overSource: function(source){
		// summary:
		//		called when a source detected a mouse-over condition
		// source: Object
		//		the reporter
		if(this.avatar){
			this.target = (source && source.targetState != "Disabled") ? source : null;
			this.canDropFlag = Boolean(this.target);
			this.avatar.update();
		}
		dojo.publish("/dnd/source/over", [source]);
	},
	outSource: function(source){
		// summary:
		//		called when a source detected a mouse-out condition
		// source: Object
		//		the reporter
		if(this.avatar){
			if(this.target == source){
				this.target = null;
				this.canDropFlag = false;
				this.avatar.update();
				dojo.publish("/dnd/source/over", [null]);
			}
		}else{
			dojo.publish("/dnd/source/over", [null]);
		}
	},
	startDrag: function(source, nodes, copy){
		// summary:
		//		called to initiate the DnD operation
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		this.source = source;
		this.nodes  = nodes;
		this.copy   = Boolean(copy); // normalizing to true boolean
		this.avatar = this.makeAvatar();
		dojo.body().appendChild(this.avatar.node);
		dojo.publish("/dnd/start", [source, nodes, this.copy]);
		this.events = [
			dojo.connect(dojo.doc, "onmousemove", this, "onMouseMove"),
			dojo.connect(dojo.doc, "onmouseup",   this, "onMouseUp"),
			dojo.connect(dojo.doc, "onkeydown",   this, "onKeyDown"),
			dojo.connect(dojo.doc, "onkeyup",     this, "onKeyUp"),
			// cancel text selection and text dragging
			dojo.connect(dojo.doc, "ondragstart",   dojo.stopEvent),
			dojo.connect(dojo.body(), "onselectstart", dojo.stopEvent)
		];
		var c = "dojoDnd" + (copy ? "Copy" : "Move");
		dojo.addClass(dojo.body(), c); 
	},
	canDrop: function(flag){
		// summary:
		//		called to notify if the current target can accept items
		var canDropFlag = Boolean(this.target && flag);
		if(this.canDropFlag != canDropFlag){
			this.canDropFlag = canDropFlag;
			this.avatar.update();
		}
	},
	stopDrag: function(){
		// summary:
		//		stop the DnD in progress
		dojo.removeClass(dojo.body(), "dojoDndCopy");
		dojo.removeClass(dojo.body(), "dojoDndMove");
		dojo.forEach(this.events, dojo.disconnect);
		this.events = [];
		this.avatar.destroy();
		this.avatar = null;
		this.source = this.target = null;
		this.nodes = [];
	},
	makeAvatar: function(){
		// summary:
		//		makes the avatar; it is separate to be overwritten dynamically, if needed
		return new dojo.dnd.Avatar(this);
	},
	updateAvatar: function(){
		// summary:
		//		updates the avatar; it is separate to be overwritten dynamically, if needed
		this.avatar.update();
	},
	
	// mouse event processors
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove
		// e: Event
		//		mouse event
		var a = this.avatar;
		if(a){
			dojo.dnd.autoScrollNodes(e);
			//dojo.dnd.autoScroll(e);
			var s = a.node.style;
			s.left = (e.pageX + this.OFFSET_X) + "px";
			s.top  = (e.pageY + this.OFFSET_Y) + "px";
			var copy = Boolean(this.source.copyState(dojo.isCopyKey(e)));
			if(this.copy != copy){ 
				this._setCopyStatus(copy);
			}
		}
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup
		// e: Event
		//		mouse event
		if(this.avatar){
			if(this.target && this.canDropFlag){
				var copy = Boolean(this.source.copyState(dojo.isCopyKey(e))),
				params = [this.source, this.nodes, copy, this.target];
				dojo.publish("/dnd/drop/before", params);
				dojo.publish("/dnd/drop", params);
			}else{
				dojo.publish("/dnd/cancel");
			}
			this.stopDrag();
		}
	},
	
	// keyboard event processors
	onKeyDown: function(e){
		// summary:
		//		event processor for onkeydown:
		//		watching for CTRL for copy/move status, watching for ESCAPE to cancel the drag
		// e: Event
		//		keyboard event
		if(this.avatar){
			switch(e.keyCode){
				case dojo.keys.CTRL:
					var copy = Boolean(this.source.copyState(true));
					if(this.copy != copy){ 
						this._setCopyStatus(copy);
					}
					break;
				case dojo.keys.ESCAPE:
					dojo.publish("/dnd/cancel");
					this.stopDrag();
					break;
			}
		}
	},
	onKeyUp: function(e){
		// summary:
		//		event processor for onkeyup, watching for CTRL for copy/move status
		// e: Event
		//		keyboard event
		if(this.avatar && e.keyCode == dojo.keys.CTRL){
			var copy = Boolean(this.source.copyState(false));
			if(this.copy != copy){ 
				this._setCopyStatus(copy);
			}
		}
	},
	
	// utilities
	_setCopyStatus: function(copy){
		// summary:
		//		changes the copy status
		// copy: Boolean
		//		the copy status
		this.copy = copy;
		this.source._markDndStatus(this.copy);
		this.updateAvatar();
		dojo.removeClass(dojo.body(), "dojoDnd" + (this.copy ? "Move" : "Copy"));
		dojo.addClass(dojo.body(), "dojoDnd" + (this.copy ? "Copy" : "Move"));
	}
});

// dojo.dnd._manager:
//		The manager singleton variable. Can be overwritten if needed.
dojo.dnd._manager = null;

dojo.dnd.manager = function(){
	// summary:
	//		Returns the current DnD manager.  Creates one if it is not created yet.
	if(!dojo.dnd._manager){
		dojo.dnd._manager = new dojo.dnd.Manager();
	}
	return dojo.dnd._manager;	// Object
};

}

if(!dojo._hasResource["dojo.dnd.Source"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Source"] = true;
dojo.provide("dojo.dnd.Source");




/*
	Container property:
		"Horizontal"- if this is the horizontal container
	Source states:
		""			- normal state
		"Moved"		- this source is being moved
		"Copied"	- this source is being copied
	Target states:
		""			- normal state
		"Disabled"	- the target cannot accept an avatar
	Target anchor state:
		""			- item is not selected
		"Before"	- insert point is before the anchor
		"After"		- insert point is after the anchor
*/

/*=====
dojo.dnd.__SourceArgs = function(){
	//	summary:
	//		a dict of parameters for DnD Source configuration. Note that any
	//		property on Source elements may be configured, but this is the
	//		short-list
	//	isSource: Boolean?
	//		can be used as a DnD source. Defaults to true.
	//	accept: Array?
	//		list of accepted types (text strings) for a target; defaults to
	//		["text"]
	//	autoSync: Boolean
	//		if true refreshes the node list on every operation; false by default
	//	copyOnly: Boolean?
	//		copy items, if true, use a state of Ctrl key otherwise,
	//		see selfCopy and selfAccept for more details
	//	delay: Number
	//		the move delay in pixels before detecting a drag; 0 by default
	//	horizontal: Boolean?
	//		a horizontal container, if true, vertical otherwise or when omitted
	//	selfCopy: Boolean?
	//		copy items by default when dropping on itself,
	//		false by default, works only if copyOnly is true
	//	selfAccept: Boolean?
	//		accept its own items when copyOnly is true,
	//		true by default, works only if copyOnly is true
	//	withHandles: Boolean?
	//		allows dragging only by handles, false by default
	//  generateText: Boolean?
	//		generate text node for drag and drop, true by default
	this.isSource = isSource;
	this.accept = accept;
	this.autoSync = autoSync;
	this.copyOnly = copyOnly;
	this.delay = delay;
	this.horizontal = horizontal;
	this.selfCopy = selfCopy;
	this.selfAccept = selfAccept;
	this.withHandles = withHandles;
	this.generateText = true;
}
=====*/

dojo.declare("dojo.dnd.Source", dojo.dnd.Selector, {
	// summary:
	//		a Source object, which can be used as a DnD source, or a DnD target
	
	// object attributes (for markup)
	isSource: true,
	horizontal: false,
	copyOnly: false,
	selfCopy: false,
	selfAccept: true,
	skipForm: false,
	withHandles: false,
	autoSync: false,
	delay: 0, // pixels
	accept: ["text"],
	generateText: true,
	
	constructor: function(/*DOMNode|String*/node, /*dojo.dnd.__SourceArgs?*/params){
		// summary: 
		//		a constructor of the Source
		// node:
		//		node or node's id to build the source on
		// params: 
		//		any property of this class may be configured via the params
		//		object which is mixed-in to the `dojo.dnd.Source` instance
		dojo.mixin(this, dojo.mixin({}, params));
		var type = this.accept;
		if(type.length){
			this.accept = {};
			for(var i = 0; i < type.length; ++i){
				this.accept[type[i]] = 1;
			}
		}
		// class-specific variables
		this.isDragging = false;
		this.mouseDown = false;
		this.targetAnchor = null;
		this.targetBox = null;
		this.before = true;
		this._lastX = 0;
		this._lastY = 0;
		// states
		this.sourceState  = "";
		if(this.isSource){
			dojo.addClass(this.node, "dojoDndSource");
		}
		this.targetState  = "";
		if(this.accept){
			dojo.addClass(this.node, "dojoDndTarget");
		}
		if(this.horizontal){
			dojo.addClass(this.node, "dojoDndHorizontal");
		}
		// set up events
		this.topics = [
			dojo.subscribe("/dnd/source/over", this, "onDndSourceOver"),
			dojo.subscribe("/dnd/start",  this, "onDndStart"),
			dojo.subscribe("/dnd/drop",   this, "onDndDrop"),
			dojo.subscribe("/dnd/cancel", this, "onDndCancel")
		];
	},
	
	// methods
	checkAcceptance: function(source, nodes){
		// summary:
		//		checks if the target can accept nodes from this source
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		if(this == source){
			return !this.copyOnly || this.selfAccept;
		}
		for(var i = 0; i < nodes.length; ++i){
			var type = source.getItem(nodes[i].id).type;
			// type instanceof Array
			var flag = false;
			for(var j = 0; j < type.length; ++j){
				if(type[j] in this.accept){
					flag = true;
					break;
				}
			}
			if(!flag){
				return false;	// Boolean
			}
		}
		return true;	// Boolean
	},
	copyState: function(keyPressed, self){
		// summary:
		//		Returns true if we need to copy items, false to move.
		//		It is separated to be overwritten dynamically, if needed.
		// keyPressed: Boolean
		//		the "copy" key was pressed
		// self: Boolean?
		//		optional flag that means that we are about to drop on itself
		
		if(keyPressed){ return true; }
		if(arguments.length < 2){
			self = this == dojo.dnd.manager().target;
		}
		if(self){
			if(this.copyOnly){
				return this.selfCopy;
			}
		}else{
			return this.copyOnly;
		}
		return false;	// Boolean
	},
	destroy: function(){
		// summary:
		//		prepares the object to be garbage-collected
		dojo.dnd.Source.superclass.destroy.call(this);
		dojo.forEach(this.topics, dojo.unsubscribe);
		this.targetAnchor = null;
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.Source(node, params);
	},

	// mouse event processors
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove
		// e: Event
		//		mouse event
		if(this.isDragging && this.targetState == "Disabled"){ return; }
		dojo.dnd.Source.superclass.onMouseMove.call(this, e);
		var m = dojo.dnd.manager();
		if(this.isDragging){
			// calculate before/after
			var before = false;
			if(this.current){
				if(!this.targetBox || this.targetAnchor != this.current){
					this.targetBox = dojo.position(this.current, true);
				}
				if(this.horizontal){
					before = (e.pageX - this.targetBox.x) < (this.targetBox.w / 2);
				}else{
					before = (e.pageY - this.targetBox.y) < (this.targetBox.h / 2);
				}
			}
			if(this.current != this.targetAnchor || before != this.before){
				this._markTargetAnchor(before);
				m.canDrop(!this.current || m.source != this || !(this.current.id in this.selection));
			}
		}else{
			if(this.mouseDown && this.isSource &&
					(Math.abs(e.pageX - this._lastX) > this.delay || Math.abs(e.pageY - this._lastY) > this.delay)){
				var nodes = this.getSelectedNodes();
				if(nodes.length){
					m.startDrag(this, nodes, this.copyState(dojo.isCopyKey(e), true));
				}
			}
		}
	},
	onMouseDown: function(e){
		// summary:
		//		event processor for onmousedown
		// e: Event
		//		mouse event
		if(!this.mouseDown && this._legalMouseDown(e) && (!this.skipForm || !dojo.dnd.isFormElement(e))){
			this.mouseDown = true;
			this._lastX = e.pageX;
			this._lastY = e.pageY;
			dojo.dnd.Source.superclass.onMouseDown.call(this, e);
		}
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup
		// e: Event
		//		mouse event
		if(this.mouseDown){
			this.mouseDown = false;
			dojo.dnd.Source.superclass.onMouseUp.call(this, e);
		}
	},
	
	// topic event processors
	onDndSourceOver: function(source){
		// summary:
		//		topic event processor for /dnd/source/over, called when detected a current source
		// source: Object
		//		the source which has the mouse over it
		if(this != source){
			this.mouseDown = false;
			if(this.targetAnchor){
				this._unmarkTargetAnchor();
			}
		}else if(this.isDragging){
			var m = dojo.dnd.manager();
			m.canDrop(this.targetState != "Disabled" && (!this.current || m.source != this || !(this.current.id in this.selection)));
		}
	},
	onDndStart: function(source, nodes, copy){
		// summary:
		//		topic event processor for /dnd/start, called to initiate the DnD operation
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		if(this.autoSync){ this.sync(); }
		if(this.isSource){
			this._changeState("Source", this == source ? (copy ? "Copied" : "Moved") : "");
		}
		var accepted = this.accept && this.checkAcceptance(source, nodes);
		this._changeState("Target", accepted ? "" : "Disabled");
		if(this == source){
			dojo.dnd.manager().overSource(this);
		}
		this.isDragging = true;
	},
	onDndDrop: function(source, nodes, copy, target){
		// summary:
		//		topic event processor for /dnd/drop, called to finish the DnD operation
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		// target: Object
		//		the target which accepts items
		if(this == target){
			// this one is for us => move nodes!
			this.onDrop(source, nodes, copy);
		}
		this.onDndCancel();
	},
	onDndCancel: function(){
		// summary:
		//		topic event processor for /dnd/cancel, called to cancel the DnD operation
		if(this.targetAnchor){
			this._unmarkTargetAnchor();
			this.targetAnchor = null;
		}
		this.before = true;
		this.isDragging = false;
		this.mouseDown = false;
		this._changeState("Source", "");
		this._changeState("Target", "");
	},
	
	// local events
	onDrop: function(source, nodes, copy){
		// summary:
		//		called only on the current target, when drop is performed
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		
		if(this != source){
			this.onDropExternal(source, nodes, copy);
		}else{
			this.onDropInternal(nodes, copy);
		}
	},
	onDropExternal: function(source, nodes, copy){
		// summary:
		//		called only on the current target, when drop is performed
		//		from an external source
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		
		var oldCreator = this._normalizedCreator;
		// transferring nodes from the source to the target
		if(this.creator){
			// use defined creator
			this._normalizedCreator = function(node, hint){
				return oldCreator.call(this, source.getItem(node.id).data, hint);
			};
		}else{
			// we have no creator defined => move/clone nodes
			if(copy){
				// clone nodes
				this._normalizedCreator = function(node, hint){
					var t = source.getItem(node.id);
					var n = node.cloneNode(true);
					n.id = dojo.dnd.getUniqueId();
					return {node: n, data: t.data, type: t.type};
				};
			}else{
				// move nodes
				this._normalizedCreator = function(node, hint){
					var t = source.getItem(node.id);
					source.delItem(node.id);
					return {node: node, data: t.data, type: t.type};
				};
			}
		}
		this.selectNone();
		if(!copy && !this.creator){
			source.selectNone();
		}
		this.insertNodes(true, nodes, this.before, this.current);
		if(!copy && this.creator){
			source.deleteSelectedNodes();
		}
		this._normalizedCreator = oldCreator;
	},
	onDropInternal: function(nodes, copy){
		// summary:
		//		called only on the current target, when drop is performed
		//		from the same target/source
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		
		var oldCreator = this._normalizedCreator;
		// transferring nodes within the single source
		if(this.current && this.current.id in this.selection){
			// do nothing
			return;
		}
		if(copy){
			if(this.creator){
				// create new copies of data items
				this._normalizedCreator = function(node, hint){
					return oldCreator.call(this, this.getItem(node.id).data, hint);
				};
			}else{
				// clone nodes
				this._normalizedCreator = function(node, hint){
					var t = this.getItem(node.id);
					var n = node.cloneNode(true);
					n.id = dojo.dnd.getUniqueId();
					return {node: n, data: t.data, type: t.type};
				};
			}
		}else{
			// move nodes
			if(!this.current){
				// do nothing
				return;
			}
			this._normalizedCreator = function(node, hint){
				var t = this.getItem(node.id);
				return {node: node, data: t.data, type: t.type};
			};
		}
		this._removeSelection();
		this.insertNodes(true, nodes, this.before, this.current);
		this._normalizedCreator = oldCreator;
	},
	onDraggingOver: function(){
		// summary:
		//		called during the active DnD operation, when items
		//		are dragged over this target, and it is not disabled
	},
	onDraggingOut: function(){
		// summary:
		//		called during the active DnD operation, when items
		//		are dragged away from this target, and it is not disabled
	},
	
	// utilities
	onOverEvent: function(){
		// summary:
		//		this function is called once, when mouse is over our container
		dojo.dnd.Source.superclass.onOverEvent.call(this);
		dojo.dnd.manager().overSource(this);
		if(this.isDragging && this.targetState != "Disabled"){
			this.onDraggingOver();
		}
	},
	onOutEvent: function(){
		// summary:
		//		this function is called once, when mouse is out of our container
		dojo.dnd.Source.superclass.onOutEvent.call(this);
		dojo.dnd.manager().outSource(this);
		if(this.isDragging && this.targetState != "Disabled"){
			this.onDraggingOut();
		}
	},
	_markTargetAnchor: function(before){
		// summary:
		//		assigns a class to the current target anchor based on "before" status
		// before: Boolean
		//		insert before, if true, after otherwise
		if(this.current == this.targetAnchor && this.before == before){ return; }
		if(this.targetAnchor){
			this._removeItemClass(this.targetAnchor, this.before ? "Before" : "After");
		}
		this.targetAnchor = this.current;
		this.targetBox = null;
		this.before = before;
		if(this.targetAnchor){
			this._addItemClass(this.targetAnchor, this.before ? "Before" : "After");
		}
	},
	_unmarkTargetAnchor: function(){
		// summary:
		//		removes a class of the current target anchor based on "before" status
		if(!this.targetAnchor){ return; }
		this._removeItemClass(this.targetAnchor, this.before ? "Before" : "After");
		this.targetAnchor = null;
		this.targetBox = null;
		this.before = true;
	},
	_markDndStatus: function(copy){
		// summary:
		//		changes source's state based on "copy" status
		this._changeState("Source", copy ? "Copied" : "Moved");
	},
	_legalMouseDown: function(e){
		// summary:
		//		checks if user clicked on "approved" items
		// e: Event
		//		mouse event
		
		// accept only the left mouse button
		if(!dojo.mouseButtons.isLeft(e)){ return false; }
		
		if(!this.withHandles){ return true; }
		
		// check for handles
		for(var node = e.target; node && node !== this.node; node = node.parentNode){
			if(dojo.hasClass(node, "dojoDndHandle")){ return true; }
			if(dojo.hasClass(node, "dojoDndItem") || dojo.hasClass(node, "dojoDndIgnore")){ break; }
		}
		return false;	// Boolean
	}
});

dojo.declare("dojo.dnd.Target", dojo.dnd.Source, {
	// summary: a Target object, which can be used as a DnD target
	
	constructor: function(node, params){
		// summary:
		//		a constructor of the Target --- see the `dojo.dnd.Source.constructor` for details
		this.isSource = false;
		dojo.removeClass(this.node, "dojoDndSource");
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.Target(node, params);
	}
});

dojo.declare("dojo.dnd.AutoSource", dojo.dnd.Source, {
	// summary:
	//		a source that syncs its DnD nodes by default
	
	constructor: function(node, params){
		// summary:
		//		constructor of the AutoSource --- see the Source constructor for details
		this.autoSync = true;
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.AutoSource(node, params);
	}
});

}

if(!dojo._hasResource["dojo.dnd.Mover"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Mover"] = true;
dojo.provide("dojo.dnd.Mover");




dojo.declare("dojo.dnd.Mover", null, {
	constructor: function(node, e, host){
		// summary:
		//		an object, which makes a node follow the mouse. 
		//		Used as a default mover, and as a base class for custom movers.
		// node: Node
		//		a node (or node's id) to be moved
		// e: Event
		//		a mouse event, which started the move;
		//		only pageX and pageY properties are used
		// host: Object?
		//		object which implements the functionality of the move,
		//	 	and defines proper events (onMoveStart and onMoveStop)
		this.node = dojo.byId(node);
		this.marginBox = {l: e.pageX, t: e.pageY};
		this.mouseButton = e.button;
		var h = this.host = host, d = node.ownerDocument, 
			firstEvent = dojo.connect(d, "onmousemove", this, "onFirstMove");
		this.events = [
			dojo.connect(d, "onmousemove", this, "onMouseMove"),
			dojo.connect(d, "onmouseup",   this, "onMouseUp"),
			// cancel text selection and text dragging
			dojo.connect(d, "ondragstart",   dojo.stopEvent),
			dojo.connect(d.body, "onselectstart", dojo.stopEvent),
			firstEvent
		];
		// notify that the move has started
		if(h && h.onMoveStart){
			h.onMoveStart(this);
		}
	},
	// mouse event processors
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove
		// e: Event
		//		mouse event
		dojo.dnd.autoScroll(e);
		var m = this.marginBox;
		this.host.onMove(this, {l: m.l + e.pageX, t: m.t + e.pageY});
		dojo.stopEvent(e);
	},
	onMouseUp: function(e){
		if(dojo.isWebKit && dojo.isMac && this.mouseButton == 2 ? 
				e.button == 0 : this.mouseButton == e.button){
			this.destroy();
		}
		dojo.stopEvent(e);
	},
	// utilities
	onFirstMove: function(){
		// summary:
		//		makes the node absolute; it is meant to be called only once. 
		// 		relative and absolutely positioned nodes are assumed to use pixel units
		var s = this.node.style, l, t, h = this.host;
		switch(s.position){
			case "relative":
			case "absolute":
				// assume that left and top values are in pixels already
				l = Math.round(parseFloat(s.left));
				t = Math.round(parseFloat(s.top));
				break;
			default:
				s.position = "absolute";	// enforcing the absolute mode
				var m = dojo.marginBox(this.node);
				// event.pageX/pageY (which we used to generate the initial
				// margin box) includes padding and margin set on the body.
				// However, setting the node's position to absolute and then
				// doing dojo.marginBox on it *doesn't* take that additional
				// space into account - so we need to subtract the combined
				// padding and margin.  We use getComputedStyle and
				// _getMarginBox/_getContentBox to avoid the extra lookup of
				// the computed style. 
				var b = dojo.doc.body;
				var bs = dojo.getComputedStyle(b);
				var bm = dojo._getMarginBox(b, bs);
				var bc = dojo._getContentBox(b, bs);
				l = m.l - (bc.l - bm.l);
				t = m.t - (bc.t - bm.t);
				break;
		}
		this.marginBox.l = l - this.marginBox.l;
		this.marginBox.t = t - this.marginBox.t;
		if(h && h.onFirstMove){
			h.onFirstMove(this);
		}
		dojo.disconnect(this.events.pop());
	},
	destroy: function(){
		// summary:
		//		stops the move, deletes all references, so the object can be garbage-collected
		dojo.forEach(this.events, dojo.disconnect);
		// undo global settings
		var h = this.host;
		if(h && h.onMoveStop){
			h.onMoveStop(this);
		}
		// destroy objects
		this.events = this.node = this.host = null;
	}
});

}

if(!dojo._hasResource["dojo.dnd.Moveable"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Moveable"] = true;
dojo.provide("dojo.dnd.Moveable");



/*=====
dojo.declare("dojo.dnd.__MoveableArgs", [], {
	// handle: Node||String
	//		A node (or node's id), which is used as a mouse handle.
	//		If omitted, the node itself is used as a handle.
	handle: null,

	// delay: Number
	//		delay move by this number of pixels
	delay: 0,

	// skip: Boolean
	//		skip move of form elements
	skip: false,

	// mover: Object
	//		a constructor of custom Mover
	mover: dojo.dnd.Mover
});
=====*/

dojo.declare("dojo.dnd.Moveable", null, {
	// object attributes (for markup)
	handle: "",
	delay: 0,
	skip: false,
	
	constructor: function(node, params){
		// summary:
		//		an object, which makes a node moveable
		// node: Node
		//		a node (or node's id) to be moved
		// params: dojo.dnd.__MoveableArgs?
		//		optional parameters
		this.node = dojo.byId(node);
		if(!params){ params = {}; }
		this.handle = params.handle ? dojo.byId(params.handle) : null;
		if(!this.handle){ this.handle = this.node; }
		this.delay = params.delay > 0 ? params.delay : 0;
		this.skip  = params.skip;
		this.mover = params.mover ? params.mover : dojo.dnd.Mover;
		this.events = [
			dojo.connect(this.handle, "onmousedown", this, "onMouseDown"),
			// cancel text selection and text dragging
			dojo.connect(this.handle, "ondragstart",   this, "onSelectStart"),
			dojo.connect(this.handle, "onselectstart", this, "onSelectStart")
		];
	},

	// markup methods
	markupFactory: function(params, node){
		return new dojo.dnd.Moveable(node, params);
	},

	// methods
	destroy: function(){
		// summary:
		//		stops watching for possible move, deletes all references, so the object can be garbage-collected
		dojo.forEach(this.events, dojo.disconnect);
		this.events = this.node = this.handle = null;
	},
	
	// mouse event processors
	onMouseDown: function(e){
		// summary:
		//		event processor for onmousedown, creates a Mover for the node
		// e: Event
		//		mouse event
		if(this.skip && dojo.dnd.isFormElement(e)){ return; }
		if(this.delay){
			this.events.push(
				dojo.connect(this.handle, "onmousemove", this, "onMouseMove"),
				dojo.connect(this.handle, "onmouseup", this, "onMouseUp")
			);
			this._lastX = e.pageX;
			this._lastY = e.pageY;
		}else{
			this.onDragDetected(e);
		}
		dojo.stopEvent(e);
	},
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove, used only for delayed drags
		// e: Event
		//		mouse event
		if(Math.abs(e.pageX - this._lastX) > this.delay || Math.abs(e.pageY - this._lastY) > this.delay){
			this.onMouseUp(e);
			this.onDragDetected(e);
		}
		dojo.stopEvent(e);
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup, used only for delayed drags
		// e: Event
		//		mouse event
		for(var i = 0; i < 2; ++i){
			dojo.disconnect(this.events.pop());
		}
		dojo.stopEvent(e);
	},
	onSelectStart: function(e){
		// summary:
		//		event processor for onselectevent and ondragevent
		// e: Event
		//		mouse event
		if(!this.skip || !dojo.dnd.isFormElement(e)){
			dojo.stopEvent(e);
		}
	},
	
	// local events
	onDragDetected: function(/* Event */ e){
		// summary:
		//		called when the drag is detected;
		//		responsible for creation of the mover
		new this.mover(this.node, e, this);
	},
	onMoveStart: function(/* dojo.dnd.Mover */ mover){
		// summary:
		//		called before every move operation
		dojo.publish("/dnd/move/start", [mover]);
		dojo.addClass(dojo.body(), "dojoMove"); 
		dojo.addClass(this.node, "dojoMoveItem"); 
	},
	onMoveStop: function(/* dojo.dnd.Mover */ mover){
		// summary:
		//		called after every move operation
		dojo.publish("/dnd/move/stop", [mover]);
		dojo.removeClass(dojo.body(), "dojoMove");
		dojo.removeClass(this.node, "dojoMoveItem");
	},
	onFirstMove: function(/* dojo.dnd.Mover */ mover){
		// summary:
		//		called during the very first move notification;
		//		can be used to initialize coordinates, can be overwritten.
		
		// default implementation does nothing
	},
	onMove: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
		// summary:
		//		called during every move notification;
		//		should actually move the node; can be overwritten.
		this.onMoving(mover, leftTop);
		var s = mover.node.style;
		s.left = leftTop.l + "px";
		s.top  = leftTop.t + "px";
		this.onMoved(mover, leftTop);
	},
	onMoving: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
		// summary:
		//		called before every incremental move; can be overwritten.
		
		// default implementation does nothing
	},
	onMoved: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
		// summary:
		//		called after every incremental move; can be overwritten.
		
		// default implementation does nothing
	}
});

}

if(!dojo._hasResource["dojox.string.Builder"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.string.Builder"] = true;
dojo.provide("dojox.string.Builder");

dojox.string.Builder = function(/*String?*/str){
	//	summary:
	//		A fast buffer for creating large strings.
	//
	//	length: Number
	//		The current length of the internal string.

	//	N.B. the public nature of the internal buffer is no longer
	//	needed because the IE-specific fork is no longer needed--TRT.
	var b = "";
	this.length = 0;
	
	this.append = function(/* String... */s){ 
		// summary: Append all arguments to the end of the buffer 
		if(arguments.length>1){
			/*  
				This is a loop unroll was designed specifically for Firefox;
				it would seem that static index access on an Arguments
				object is a LOT faster than doing dynamic index access.
				Therefore, we create a buffer string and take advantage
				of JS's switch fallthrough.  The peformance of this method
				comes very close to straight up string concatenation (+=).

				If the arguments object length is greater than 9, we fall
				back to standard dynamic access.

				This optimization seems to have no real effect on either
				Safari or Opera, so we just use it for all.

				It turns out also that this loop unroll can increase performance
				significantly with Internet Explorer, particularly when 
				as many arguments are provided as possible.

				Loop unroll per suggestion from Kris Zyp, implemented by 
				Tom Trenka.

				Note: added empty string to force a string cast if needed.
			 */
			var tmp="", l=arguments.length;
			switch(l){
				case 9: tmp=""+arguments[8]+tmp;
				case 8: tmp=""+arguments[7]+tmp;
				case 7: tmp=""+arguments[6]+tmp;
				case 6: tmp=""+arguments[5]+tmp;
				case 5: tmp=""+arguments[4]+tmp;
				case 4: tmp=""+arguments[3]+tmp;
				case 3: tmp=""+arguments[2]+tmp;
				case 2: {
					b+=""+arguments[0]+arguments[1]+tmp;
					break;
				}
				default: {
					var i=0;
					while(i<arguments.length){
						tmp += arguments[i++];
					}
					b += tmp;
				}
			}
		} else {
			b += s;
		}
		this.length = b.length;
		return this;	//	dojox.string.Builder
	};
	
	this.concat = function(/*String...*/s){
		//	summary:
		//		Alias for append.
		return this.append.apply(this, arguments);	//	dojox.string.Builder
	};
	
	this.appendArray = function(/*Array*/strings) {
		//	summary:
		//		Append an array of items to the internal buffer.

		//	Changed from String.prototype.concat.apply because of IE.
		return this.append.apply(this, strings);	//	dojox.string.Builder
	};
	
	this.clear = function(){
		//	summary: 
		//		Remove all characters from the buffer.
		b = "";
		this.length = 0;
		return this;	//	dojox.string.Builder
	};
	
	this.replace = function(/* String */oldStr, /* String */ newStr){
		// 	summary: 
		//		Replace instances of one string with another in the buffer.
		b = b.replace(oldStr,newStr);
		this.length = b.length;
		return this;	//	dojox.string.Builder
	};
	
	this.remove = function(/* Number */start, /* Number? */len){
		//	summary:
		//		Remove len characters starting at index start.  If len
		//		is not provided, the end of the string is assumed.
		if(len===undefined){ len = b.length; }
		if(len == 0){ return this; }
		b = b.substr(0, start) + b.substr(start+len);
		this.length = b.length;
		return this;	//	dojox.string.Builder
	};
	
	this.insert = function(/* Number */index, /* String */str){
		//	summary: 
		//		Insert string str starting at index.
		if(index == 0){
			b = str + b;
		}else{
			b = b.slice(0, index) + str + b.slice(index);
		}
		this.length = b.length;
		return this;	//	dojox.string.Builder
	};
	
	this.toString = function(){
		//	summary:
		//		Return the string representation of the internal buffer.
		return b;	//	String
	};

	//	initialize the buffer.
	if(str){ this.append(str); }
};

}

if(!dojo._hasResource["dojo.cldr.supplemental"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.cldr.supplemental"] = true;
dojo.provide("dojo.cldr.supplemental");



dojo.cldr.supplemental.getFirstDayOfWeek = function(/*String?*/locale){
// summary: Returns a zero-based index for first day of the week
// description:
//		Returns a zero-based index for first day of the week, as used by the local (Gregorian) calendar.
//		e.g. Sunday (returns 0), or Monday (returns 1)

	// from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/weekData/firstDay
	var firstDay = {/*default is 1=Monday*/
		mv:5,
		ae:6,af:6,bh:6,dj:6,dz:6,eg:6,er:6,et:6,iq:6,ir:6,jo:6,ke:6,kw:6,lb:6,ly:6,ma:6,om:6,qa:6,sa:6,
		sd:6,so:6,tn:6,ye:6,
		as:0,au:0,az:0,bw:0,ca:0,cn:0,fo:0,ge:0,gl:0,gu:0,hk:0,ie:0,il:0,is:0,jm:0,jp:0,kg:0,kr:0,la:0,
		mh:0,mo:0,mp:0,mt:0,nz:0,ph:0,pk:0,sg:0,th:0,tt:0,tw:0,um:0,us:0,uz:0,vi:0,za:0,zw:0,
		et:0,mw:0,ng:0,tj:0,
// variant. do not use?		gb:0,
		sy:4
	};

	var country = dojo.cldr.supplemental._region(locale);
	var dow = firstDay[country];
	return (dow === undefined) ? 1 : dow; /*Number*/
};

dojo.cldr.supplemental._region = function(/*String?*/locale){
	locale = dojo.i18n.normalizeLocale(locale);
	var tags = locale.split('-');
	var region = tags[1];
	if(!region){
		// IE often gives language only (#2269)
		// Arbitrary mappings of language-only locales to a country:
		region = {de:"de", en:"us", es:"es", fi:"fi", fr:"fr", he:"il", hu:"hu", it:"it",
			ja:"jp", ko:"kr", nl:"nl", pt:"br", sv:"se", zh:"cn"}[tags[0]];
	}else if(region.length == 4){
		// The ISO 3166 country code is usually in the second position, unless a
		// 4-letter script is given. See http://www.ietf.org/rfc/rfc4646.txt
		region = tags[2];
	}
	return region;
}

dojo.cldr.supplemental.getWeekend = function(/*String?*/locale){
// summary: Returns a hash containing the start and end days of the weekend
// description:
//		Returns a hash containing the start and end days of the weekend according to local custom using locale,
//		or by default in the user's locale.
//		e.g. {start:6, end:0}

	// from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/weekData/weekend{Start,End}
	var weekendStart = {/*default is 6=Saturday*/
		eg:5,il:5,sy:5,
		'in':0,
		ae:4,bh:4,dz:4,iq:4,jo:4,kw:4,lb:4,ly:4,ma:4,om:4,qa:4,sa:4,sd:4,tn:4,ye:4		
	};

	var weekendEnd = {/*default is 0=Sunday*/
		ae:5,bh:5,dz:5,iq:5,jo:5,kw:5,lb:5,ly:5,ma:5,om:5,qa:5,sa:5,sd:5,tn:5,ye:5,af:5,ir:5,
		eg:6,il:6,sy:6
	};

	var country = dojo.cldr.supplemental._region(locale);
	var start = weekendStart[country];
	var end = weekendEnd[country];
	if(start === undefined){start=6;}
	if(end === undefined){end=0;}
	return {start:start, end:end}; /*Object {start,end}*/
};

}

if(!dojo._hasResource["dojo.date.locale"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.date.locale"] = true;
dojo.provide("dojo.date.locale");

// Localization methods for Date.   Honor local customs using locale-dependent dojo.cldr data.







// Load the bundles containing localization information for
// names and formats


//NOTE: Everything in this module assumes Gregorian calendars.
// Other calendars will be implemented in separate modules.

(function(){
	// Format a pattern without literals
	function formatPattern(dateObject, bundle, options, pattern){
		return pattern.replace(/([a-z])\1*/ig, function(match){
			var s, pad,
				c = match.charAt(0),
				l = match.length,
				widthList = ["abbr", "wide", "narrow"];
			switch(c){
				case 'G':
					s = bundle[(l < 4) ? "eraAbbr" : "eraNames"][dateObject.getFullYear() < 0 ? 0 : 1];
					break;
				case 'y':
					s = dateObject.getFullYear();
					switch(l){
						case 1:
							break;
						case 2:
							if(!options.fullYear){
								s = String(s); s = s.substr(s.length - 2);
								break;
							}
							// fallthrough
						default:
							pad = true;
					}
					break;
				case 'Q':
				case 'q':
					s = Math.ceil((dateObject.getMonth()+1)/3);
//					switch(l){
//						case 1: case 2:
							pad = true;
//							break;
//						case 3: case 4: // unimplemented
//					}
					break;
				case 'M':
					var m = dateObject.getMonth();
					if(l<3){
						s = m+1; pad = true;
					}else{
						var propM = ["months", "format", widthList[l-3]].join("-");
						s = bundle[propM][m];
					}
					break;
				case 'w':
					var firstDay = 0;
					s = dojo.date.locale._getWeekOfYear(dateObject, firstDay); pad = true;
					break;
				case 'd':
					s = dateObject.getDate(); pad = true;
					break;
				case 'D':
					s = dojo.date.locale._getDayOfYear(dateObject); pad = true;
					break;
				case 'E':
					var d = dateObject.getDay();
					if(l<3){
						s = d+1; pad = true;
					}else{
						var propD = ["days", "format", widthList[l-3]].join("-");
						s = bundle[propD][d];
					}
					break;
				case 'a':
					var timePeriod = (dateObject.getHours() < 12) ? 'am' : 'pm';
					s = bundle[timePeriod];
					break;
				case 'h':
				case 'H':
				case 'K':
				case 'k':
					var h = dateObject.getHours();
					// strange choices in the date format make it impossible to write this succinctly
					switch (c){
						case 'h': // 1-12
							s = (h % 12) || 12;
							break;
						case 'H': // 0-23
							s = h;
							break;
						case 'K': // 0-11
							s = (h % 12);
							break;
						case 'k': // 1-24
							s = h || 24;
							break;
					}
					pad = true;
					break;
				case 'm':
					s = dateObject.getMinutes(); pad = true;
					break;
				case 's':
					s = dateObject.getSeconds(); pad = true;
					break;
				case 'S':
					s = Math.round(dateObject.getMilliseconds() * Math.pow(10, l-3)); pad = true;
					break;
				case 'v': // FIXME: don't know what this is. seems to be same as z?
				case 'z':
					// We only have one timezone to offer; the one from the browser
					s = dojo.date.locale._getZone(dateObject, true, options);
					if(s){break;}
					l=4;
					// fallthrough... use GMT if tz not available
				case 'Z':
					var offset = dojo.date.locale._getZone(dateObject, false, options);
					var tz = [
						(offset<=0 ? "+" : "-"),
						dojo.string.pad(Math.floor(Math.abs(offset)/60), 2),
						dojo.string.pad(Math.abs(offset)% 60, 2)
					];
					if(l==4){
						tz.splice(0, 0, "GMT");
						tz.splice(3, 0, ":");
					}
					s = tz.join("");
					break;
//				case 'Y': case 'u': case 'W': case 'F': case 'g': case 'A': case 'e':
//					console.log(match+" modifier unimplemented");
				default:
					throw new Error("dojo.date.locale.format: invalid pattern char: "+pattern);
			}
			if(pad){ s = dojo.string.pad(s, l); }
			return s;
		});
	}

/*=====
	dojo.date.locale.__FormatOptions = function(){
	//	selector: String
	//		choice of 'time','date' (default: date and time)
	//	formatLength: String
	//		choice of long, short, medium or full (plus any custom additions).  Defaults to 'short'
	//	datePattern:String
	//		override pattern with this string
	//	timePattern:String
	//		override pattern with this string
	//	am: String
	//		override strings for am in times
	//	pm: String
	//		override strings for pm in times
	//	locale: String
	//		override the locale used to determine formatting rules
	//	fullYear: Boolean
	//		(format only) use 4 digit years whenever 2 digit years are called for
	//	strict: Boolean
	//		(parse only) strict parsing, off by default
		this.selector = selector;
		this.formatLength = formatLength;
		this.datePattern = datePattern;
		this.timePattern = timePattern;
		this.am = am;
		this.pm = pm;
		this.locale = locale;
		this.fullYear = fullYear;
		this.strict = strict;
	}
=====*/

dojo.date.locale._getZone = function(/*Date*/dateObject, /*boolean*/getName, /*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Returns the zone (or offset) for the given date and options.  This
	//		is broken out into a separate function so that it can be overridden
	//		by timezone-aware code.
	//
	// dateObject:
	//		the date and/or time being formatted.
	//
	// getName:
	//		Whether to return the timezone string (if true), or the offset (if false)
	//
	// options:
	//		The options being used for formatting
	if(getName){
		return dojo.date.getTimezoneName(dateObject);
	}else{
		return dateObject.getTimezoneOffset();
	}
};


dojo.date.locale.format = function(/*Date*/dateObject, /*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Format a Date object as a String, using locale-specific settings.
	//
	// description:
	//		Create a string from a Date object using a known localized pattern.
	//		By default, this method formats both date and time from dateObject.
	//		Formatting patterns are chosen appropriate to the locale.  Different
	//		formatting lengths may be chosen, with "full" used by default.
	//		Custom patterns may be used or registered with translations using
	//		the dojo.date.locale.addCustomFormats method.
	//		Formatting patterns are implemented using [the syntax described at
	//		unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)
	//
	// dateObject:
	//		the date and/or time to be formatted.  If a time only is formatted,
	//		the values in the year, month, and day fields are irrelevant.  The
	//		opposite is true when formatting only dates.

	options = options || {};

	var locale = dojo.i18n.normalizeLocale(options.locale),
		formatLength = options.formatLength || 'short',
		bundle = dojo.date.locale._getGregorianBundle(locale),
		str = [],
		sauce = dojo.hitch(this, formatPattern, dateObject, bundle, options);
	if(options.selector == "year"){
		return _processPattern(bundle["dateFormatItem-yyyy"] || "yyyy", sauce);
	}
	var pattern;
	if(options.selector != "date"){
		pattern = options.timePattern || bundle["timeFormat-"+formatLength];
		if(pattern){str.push(_processPattern(pattern, sauce));}
	}
	if(options.selector != "time"){
		pattern = options.datePattern || bundle["dateFormat-"+formatLength];
		if(pattern){str.push(_processPattern(pattern, sauce));}
	}

	return str.length == 1 ? str[0] : bundle["dateTimeFormat-"+formatLength].replace(/\{(\d+)\}/g,
		function(match, key){ return str[key]; }); // String
};

dojo.date.locale.regexp = function(/*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Builds the regular needed to parse a localized date

	return dojo.date.locale._parseInfo(options).regexp; // String
};

dojo.date.locale._parseInfo = function(/*dojo.date.locale.__FormatOptions?*/options){
	options = options || {};
	var locale = dojo.i18n.normalizeLocale(options.locale),
		bundle = dojo.date.locale._getGregorianBundle(locale),
		formatLength = options.formatLength || 'short',
		datePattern = options.datePattern || bundle["dateFormat-" + formatLength],
		timePattern = options.timePattern || bundle["timeFormat-" + formatLength],
		pattern;
	if(options.selector == 'date'){
		pattern = datePattern;
	}else if(options.selector == 'time'){
		pattern = timePattern;
	}else{
		pattern = bundle["dateTimeFormat-"+formatLength].replace(/\{(\d+)\}/g,
			function(match, key){ return [timePattern, datePattern][key]; });
	}

	var tokens = [],
		re = _processPattern(pattern, dojo.hitch(this, _buildDateTimeRE, tokens, bundle, options));
	return {regexp: re, tokens: tokens, bundle: bundle};
};

dojo.date.locale.parse = function(/*String*/value, /*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Convert a properly formatted string to a primitive Date object,
	//		using locale-specific settings.
	//
	// description:
	//		Create a Date object from a string using a known localized pattern.
	//		By default, this method parses looking for both date and time in the string.
	//		Formatting patterns are chosen appropriate to the locale.  Different
	//		formatting lengths may be chosen, with "full" used by default.
	//		Custom patterns may be used or registered with translations using
	//		the dojo.date.locale.addCustomFormats method.
	//	
	//		Formatting patterns are implemented using [the syntax described at
	//		unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)
	//		When two digit years are used, a century is chosen according to a sliding 
	//		window of 80 years before and 20 years after present year, for both `yy` and `yyyy` patterns.
	//		year < 100CE requires strict mode.
	//
	// value:
	//		A string representation of a date

	var info = dojo.date.locale._parseInfo(options),
		tokens = info.tokens, bundle = info.bundle,
		re = new RegExp("^" + info.regexp + "$", info.strict ? "" : "i"),
		match = re.exec(value);

	if(!match){ return null; } // null

	var widthList = ['abbr', 'wide', 'narrow'],
		result = [1970,0,1,0,0,0,0], // will get converted to a Date at the end
		amPm = "",
		valid = dojo.every(match, function(v, i){
		if(!i){return true;}
		var token=tokens[i-1];
		var l=token.length;
		switch(token.charAt(0)){
			case 'y':
				if(l != 2 && options.strict){
					//interpret year literally, so '5' would be 5 A.D.
					result[0] = v;
				}else{
					if(v<100){
						v = Number(v);
						//choose century to apply, according to a sliding window
						//of 80 years before and 20 years after present year
						var year = '' + new Date().getFullYear(),
							century = year.substring(0, 2) * 100,
							cutoff = Math.min(Number(year.substring(2, 4)) + 20, 99),
							num = (v < cutoff) ? century + v : century - 100 + v;
						result[0] = num;
					}else{
						//we expected 2 digits and got more...
						if(options.strict){
							return false;
						}
						//interpret literally, so '150' would be 150 A.D.
						//also tolerate '1950', if 'yyyy' input passed to 'yy' format
						result[0] = v;
					}
				}
				break;
			case 'M':
				if(l>2){
					var months = bundle['months-format-' + widthList[l-3]].concat();
					if(!options.strict){
						//Tolerate abbreviating period in month part
						//Case-insensitive comparison
						v = v.replace(".","").toLowerCase();
						months = dojo.map(months, function(s){ return s.replace(".","").toLowerCase(); } );
					}
					v = dojo.indexOf(months, v);
					if(v == -1){
//						console.log("dojo.date.locale.parse: Could not parse month name: '" + v + "'.");
						return false;
					}
				}else{
					v--;
				}
				result[1] = v;
				break;
			case 'E':
			case 'e':
				var days = bundle['days-format-' + widthList[l-3]].concat();
				if(!options.strict){
					//Case-insensitive comparison
					v = v.toLowerCase();
					days = dojo.map(days, function(d){return d.toLowerCase();});
				}
				v = dojo.indexOf(days, v);
				if(v == -1){
//					console.log("dojo.date.locale.parse: Could not parse weekday name: '" + v + "'.");
					return false;
				}

				//TODO: not sure what to actually do with this input,
				//in terms of setting something on the Date obj...?
				//without more context, can't affect the actual date
				//TODO: just validate?
				break;
			case 'D':
				result[1] = 0;
				// fallthrough...
			case 'd':
				result[2] = v;
				break;
			case 'a': //am/pm
				var am = options.am || bundle.am;
				var pm = options.pm || bundle.pm;
				if(!options.strict){
					var period = /\./g;
					v = v.replace(period,'').toLowerCase();
					am = am.replace(period,'').toLowerCase();
					pm = pm.replace(period,'').toLowerCase();
				}
				if(options.strict && v != am && v != pm){
//					console.log("dojo.date.locale.parse: Could not parse am/pm part.");
					return false;
				}

				// we might not have seen the hours field yet, so store the state and apply hour change later
				amPm = (v == pm) ? 'p' : (v == am) ? 'a' : '';
				break;
			case 'K': //hour (1-24)
				if(v == 24){ v = 0; }
				// fallthrough...
			case 'h': //hour (1-12)
			case 'H': //hour (0-23)
			case 'k': //hour (0-11)
				//TODO: strict bounds checking, padding
				if(v > 23){
//					console.log("dojo.date.locale.parse: Illegal hours value");
					return false;
				}

				//in the 12-hour case, adjusting for am/pm requires the 'a' part
				//which could come before or after the hour, so we will adjust later
				result[3] = v;
				break;
			case 'm': //minutes
				result[4] = v;
				break;
			case 's': //seconds
				result[5] = v;
				break;
			case 'S': //milliseconds
				result[6] = v;
//				break;
//			case 'w':
//TODO				var firstDay = 0;
//			default:
//TODO: throw?
//				console.log("dojo.date.locale.parse: unsupported pattern char=" + token.charAt(0));
		}
		return true;
	});

	var hours = +result[3];
	if(amPm === 'p' && hours < 12){
		result[3] = hours + 12; //e.g., 3pm -> 15
	}else if(amPm === 'a' && hours == 12){
		result[3] = 0; //12am -> 0
	}

	//TODO: implement a getWeekday() method in order to test 
	//validity of input strings containing 'EEE' or 'EEEE'...

	var dateObject = new Date(result[0], result[1], result[2], result[3], result[4], result[5], result[6]); // Date
	if(options.strict){
		dateObject.setFullYear(result[0]);
	}

	// Check for overflow.  The Date() constructor normalizes things like April 32nd...
	//TODO: why isn't this done for times as well?
	var allTokens = tokens.join(""),
		dateToken = allTokens.indexOf('d') != -1,
		monthToken = allTokens.indexOf('M') != -1;

	if(!valid ||
		(monthToken && dateObject.getMonth() > result[1]) ||
		(dateToken && dateObject.getDate() > result[2])){
		return null;
	}

	// Check for underflow, due to DST shifts.  See #9366
	// This assumes a 1 hour dst shift correction at midnight
	// We could compare the timezone offset after the shift and add the difference instead.
	if((monthToken && dateObject.getMonth() < result[1]) ||
		(dateToken && dateObject.getDate() < result[2])){
		dateObject = dojo.date.add(dateObject, "hour", 1);
	}

	return dateObject; // Date
};

function _processPattern(pattern, applyPattern, applyLiteral, applyAll){
	//summary: Process a pattern with literals in it

	// Break up on single quotes, treat every other one as a literal, except '' which becomes '
	var identity = function(x){return x;};
	applyPattern = applyPattern || identity;
	applyLiteral = applyLiteral || identity;
	applyAll = applyAll || identity;

	//split on single quotes (which escape literals in date format strings) 
	//but preserve escaped single quotes (e.g., o''clock)
	var chunks = pattern.match(/(''|[^'])+/g),
		literal = pattern.charAt(0) == "'";

	dojo.forEach(chunks, function(chunk, i){
		if(!chunk){
			chunks[i]='';
		}else{
			chunks[i]=(literal ? applyLiteral : applyPattern)(chunk);
			literal = !literal;
		}
	});
	return applyAll(chunks.join(''));
}

function _buildDateTimeRE(tokens, bundle, options, pattern){
	pattern = dojo.regexp.escapeString(pattern);
	if(!options.strict){ pattern = pattern.replace(" a", " ?a"); } // kludge to tolerate no space before am/pm
	return pattern.replace(/([a-z])\1*/ig, function(match){
		// Build a simple regexp.  Avoid captures, which would ruin the tokens list
		var s,
			c = match.charAt(0),
			l = match.length,
			p2 = '', p3 = '';
		if(options.strict){
			if(l > 1){ p2 = '0' + '{'+(l-1)+'}'; }
			if(l > 2){ p3 = '0' + '{'+(l-2)+'}'; }
		}else{
			p2 = '0?'; p3 = '0{0,2}';
		}
		switch(c){
			case 'y':
				s = '\\d{2,4}';
				break;
			case 'M':
				s = (l>2) ? '\\S+?' : p2+'[1-9]|1[0-2]';
				break;
			case 'D':
				s = p2+'[1-9]|'+p3+'[1-9][0-9]|[12][0-9][0-9]|3[0-5][0-9]|36[0-6]';
				break;
			case 'd':
				s = '[12]\\d|'+p2+'[1-9]|3[01]';
				break;
			case 'w':
				s = p2+'[1-9]|[1-4][0-9]|5[0-3]';
				break;
		    case 'E':
				s = '\\S+';
				break;
			case 'h': //hour (1-12)
				s = p2+'[1-9]|1[0-2]';
				break;
			case 'k': //hour (0-11)
				s = p2+'\\d|1[01]';
				break;
			case 'H': //hour (0-23)
				s = p2+'\\d|1\\d|2[0-3]';
				break;
			case 'K': //hour (1-24)
				s = p2+'[1-9]|1\\d|2[0-4]';
				break;
			case 'm':
			case 's':
				s = '[0-5]\\d';
				break;
			case 'S':
				s = '\\d{'+l+'}';
				break;
			case 'a':
				var am = options.am || bundle.am || 'AM';
				var pm = options.pm || bundle.pm || 'PM';
				if(options.strict){
					s = am + '|' + pm;
				}else{
					s = am + '|' + pm;
					if(am != am.toLowerCase()){ s += '|' + am.toLowerCase(); }
					if(pm != pm.toLowerCase()){ s += '|' + pm.toLowerCase(); }
					if(s.indexOf('.') != -1){ s += '|' + s.replace(/\./g, ""); }
				}
				s = s.replace(/\./g, "\\.");
				break;
			default:
			// case 'v':
			// case 'z':
			// case 'Z':
				s = ".*";
//				console.log("parse of date format, pattern=" + pattern);
		}

		if(tokens){ tokens.push(match); }

		return "(" + s + ")"; // add capture
	}).replace(/[\xa0 ]/g, "[\\s\\xa0]"); // normalize whitespace.  Need explicit handling of \xa0 for IE.
}
})();

(function(){
var _customFormats = [];
dojo.date.locale.addCustomFormats = function(/*String*/packageName, /*String*/bundleName){
	// summary:
	//		Add a reference to a bundle containing localized custom formats to be
	//		used by date/time formatting and parsing routines.
	//
	// description:
	//		The user may add custom localized formats where the bundle has properties following the
	//		same naming convention used by dojo.cldr: `dateFormat-xxxx` / `timeFormat-xxxx`
	//		The pattern string should match the format used by the CLDR.
	//		See dojo.date.locale.format() for details.
	//		The resources must be loaded by dojo.requireLocalization() prior to use

	_customFormats.push({pkg:packageName,name:bundleName});
};

dojo.date.locale._getGregorianBundle = function(/*String*/locale){
	var gregorian = {};
	dojo.forEach(_customFormats, function(desc){
		var bundle = dojo.i18n.getLocalization(desc.pkg, desc.name, locale);
		gregorian = dojo.mixin(gregorian, bundle);
	}, this);
	return gregorian; /*Object*/
};
})();

dojo.date.locale.addCustomFormats("dojo.cldr","gregorian");

dojo.date.locale.getNames = function(/*String*/item, /*String*/type, /*String?*/context, /*String?*/locale){
	// summary:
	//		Used to get localized strings from dojo.cldr for day or month names.
	//
	// item:
	//	'months' || 'days'
	// type:
	//	'wide' || 'narrow' || 'abbr' (e.g. "Monday", "Mon", or "M" respectively, in English)
	// context:
	//	'standAlone' || 'format' (default)
	// locale:
	//	override locale used to find the names

	var label,
		lookup = dojo.date.locale._getGregorianBundle(locale),
		props = [item, context, type];
	if(context == 'standAlone'){
		var key = props.join('-');
		label = lookup[key];
		// Fall back to 'format' flavor of name
		if(label[0] == 1){ label = undefined; } // kludge, in the absense of real aliasing support in dojo.cldr
	}
	props[1] = 'format';

	// return by copy so changes won't be made accidentally to the in-memory model
	return (label || lookup[props.join('-')]).concat(); /*Array*/
};

dojo.date.locale.isWeekend = function(/*Date?*/dateObject, /*String?*/locale){
	// summary:
	//	Determines if the date falls on a weekend, according to local custom.

	var weekend = dojo.cldr.supplemental.getWeekend(locale),
		day = (dateObject || new Date()).getDay();
	if(weekend.end < weekend.start){
		weekend.end += 7;
		if(day < weekend.start){ day += 7; }
	}
	return day >= weekend.start && day <= weekend.end; // Boolean
};

// These are used only by format and strftime.  Do they need to be public?  Which module should they go in?

dojo.date.locale._getDayOfYear = function(/*Date*/dateObject){
	// summary: gets the day of the year as represented by dateObject
	return dojo.date.difference(new Date(dateObject.getFullYear(), 0, 1, dateObject.getHours()), dateObject) + 1; // Number
};

dojo.date.locale._getWeekOfYear = function(/*Date*/dateObject, /*Number*/firstDayOfWeek){
	if(arguments.length == 1){ firstDayOfWeek = 0; } // Sunday

	var firstDayOfYear = new Date(dateObject.getFullYear(), 0, 1).getDay(),
		adj = (firstDayOfYear - firstDayOfWeek + 7) % 7,
		week = Math.floor((dojo.date.locale._getDayOfYear(dateObject) + adj - 1) / 7);

	// if year starts on the specified day, start counting weeks at 1
	if(firstDayOfYear == firstDayOfWeek){ week++; }

	return week; // Number
};

}

if(!dojo._hasResource["dojox.html.metrics"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.html.metrics"] = true;
dojo.provide("dojox.html.metrics");

(function(){
	var dhm = dojox.html.metrics;

	//	derived from Morris John's emResized measurer
	dhm.getFontMeasurements = function(){
		//	summary
		//	Returns an object that has pixel equivilents of standard font size values.
		var heights = {
			'1em':0, '1ex':0, '100%':0, '12pt':0, '16px':0, 'xx-small':0, 'x-small':0,
			'small':0, 'medium':0, 'large':0, 'x-large':0, 'xx-large':0
		};
	
		if(dojo.isIE){
			//	we do a font-size fix if and only if one isn't applied already.
			//	NOTE: If someone set the fontSize on the HTML Element, this will kill it.
			dojo.doc.documentElement.style.fontSize="100%";
		}
	
		//	set up the measuring node.
		var div=dojo.doc.createElement("div");
		var ds = div.style;
		ds.position="absolute";
		ds.left="-100px";
		ds.top="0";
		ds.width="30px";
		ds.height="1000em";
		ds.border="0";
		ds.margin="0";
		ds.padding="0";
		ds.outline="0";
		ds.lineHeight="1";
		ds.overflow="hidden";
		dojo.body().appendChild(div);
	
		//	do the measurements.
		for(var p in heights){
			ds.fontSize = p;
			heights[p] = Math.round(div.offsetHeight * 12/16) * 16/12 / 1000;
		}
		
		dojo.body().removeChild(div);
		div = null;
		return heights; 	//	object
	};

	var fontMeasurements = null;
	
	dhm.getCachedFontMeasurements = function(recalculate){
		if(recalculate || !fontMeasurements){
			fontMeasurements = dhm.getFontMeasurements();
		}
		return fontMeasurements;
	};

	var measuringNode = null, empty = {};
	dhm.getTextBox = function(/* String */ text, /* Object */ style, /* String? */ className){
		var m;
		if(!measuringNode){
			m = measuringNode = dojo.doc.createElement("div");
			m.style.position = "absolute";
			m.style.left = "0px";
			m.style.top = "-10000px";
			dojo.body().appendChild(m);
		}else{
			m = measuringNode;
		}
		// reset styles
		m.className = "";
		m.style.border = "0";
		m.style.margin = "0";
		m.style.padding = "0";
		m.style.outline = "0";
		// set new style
		if(arguments.length > 1 && style){
			for(var i in style){
				if(i in empty){ continue; }
				m.style[i] = style[i];
			}
		}
		// set classes
		if(arguments.length > 2 && className){
			m.className = className;
		}
		// take a measure
		m.innerHTML = text;
		return dojo.marginBox(m);
	};

	//	determine the scrollbar sizes on load.
	var scroll={ w:16, h:16 };
	dhm.getScrollbar=function(){ return { w:scroll.w, h:scroll.h }; };

	dhm._fontResizeNode = null;

	dhm.initOnFontResize = function(interval){
		var f = dhm._fontResizeNode = dojo.doc.createElement("iframe");
		var fs = f.style;
		fs.position = "absolute";
		fs.width = "5em";
		fs.height = "10em";
		fs.top = "-10000px";
		if(dojo.isIE){
			f.onreadystatechange = function(){
				if(f.contentWindow.document.readyState == "complete"){
					f.onresize = f.contentWindow.parent[dojox._scopeName].html.metrics._fontresize;
				}
			};
		}else{
			f.onload = function(){
				f.contentWindow.onresize = f.contentWindow.parent[dojox._scopeName].html.metrics._fontresize;
			};
		}
		//The script tag is to work around a known firebug race condition.  See comments in bug #9046
		f.setAttribute("src", "javascript:'<html><head><script>if(\"loadFirebugConsole\" in window){window.loadFirebugConsole();}</script></head><body></body></html>'");
		dojo.body().appendChild(f);
		dhm.initOnFontResize = function(){};
	};

	dhm.onFontResize = function(){};
	dhm._fontresize = function(){
		dhm.onFontResize();
	}

	dojo.addOnUnload(function(){
		// destroy our font resize iframe if we have one
		var f = dhm._fontResizeNode;
		if(f){
			if(dojo.isIE && f.onresize){
				f.onresize = null;
			}else if(f.contentWindow && f.contentWindow.onresize){
				f.contentWindow.onresize = null;
			}
			dhm._fontResizeNode = null;
		}
	});

	dojo.addOnLoad(function(){
		// getScrollbar metrics node
		try{
			var n=dojo.doc.createElement("div");
			n.style.cssText = "top:0;left:0;width:100px;height:100px;overflow:scroll;position:absolute;visibility:hidden;";
			dojo.body().appendChild(n);
			scroll.w = n.offsetWidth - n.clientWidth;
			scroll.h = n.offsetHeight - n.clientHeight;
			dojo.body().removeChild(n);
			//console.log("Scroll bar dimensions: ", scroll);
			delete n;
		}catch(e){}

		// text size poll setup
		if("fontSizeWatch" in dojo.config && !!dojo.config.fontSizeWatch){
			dhm.initOnFontResize();
		}
	});
})();

}

if(!dojo._hasResource["dojox.html.entities"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.html.entities"] = true;
dojo.provide("dojox.html.entities");
(function(){
	// dojox.html.entities.html [public] Array
	//		Entity characters for HTML, represented as an array of 
	//		character code, entity name (minus & and ; wrapping.

	var _applyEncodingMap = function(str, map){
		// summary:
		//		Private internal function for performing encoding of entity characters.
		// tags:
		//		private

		// Check to see if we have genned and cached a regexp for this map yet
		// If we have, use it, if not, gen it, cache, then use.
		var mapper, regexp;
		if(map._encCache && 
			map._encCache.regexp && 
			map._encCache.mapper && 
			map.length == map._encCache.length){
			mapper = map._encCache.mapper;
			regexp = map._encCache.regexp;
		}else{
			mapper = {};
			regexp = ["["];
			var i;
			for(i = 0; i < map.length; i++){
				mapper[map[i][0]] = "&" + map[i][1] + ";";
				regexp.push(map[i][0]);
			}
			regexp.push("]");
			regexp = new RegExp(regexp.join(""), "g");
			map._encCache = {
				mapper: mapper,
				regexp: regexp,
				length: map.length
			};
		}
		str = str.replace(regexp, function(c){
			return mapper[c];
		});
		return str;
	};

	var _applyDecodingMap = function(str, map){
		// summary:
		//		Private internal function for performing deecoding of entity characters.
		// tags:
		//		private
		var mapper, regexp;
		if(map._decCache && 
			map._decCache.regexp && 
			map._decCache.mapper && 
			map.length == map._decCache.length){
			mapper = map._decCache.mapper;
			regexp = map._decCache.regexp;
		}else{
			mapper = {};
			regexp = ["("];
			var i;
			for(i = 0; i < map.length; i++){
				var e = "&" + map[i][1] + ";";
				if(i){regexp.push("|");}
				mapper[e] = map[i][0];
				regexp.push(e);
			}
			regexp.push(")");
			regexp = new RegExp(regexp.join(""), "g");
			map._decCache = {
				mapper: mapper,
				regexp: regexp,
				length: map.length
			};
		}
		str = str.replace(regexp, function(c){
			return mapper[c];
		});
		return str;
	};

	dojox.html.entities.html = [
		["\u0026","amp"], ["\u0022","quot"],["\u003C","lt"], ["\u003E","gt"],
		["\u00A0","nbsp"]
	];

	// dojox.html.entities.latin [public] Array
	//		Entity characters for latin characters and similar, represented as an array of 
	//		character code, entity name (minus & and ; wrapping.
	dojox.html.entities.latin = [
		["\u00A1","iexcl"],["\u00A2","cent"],["\u00A3","pound"],["\u20AC","euro"],
		["\u00A4","curren"],["\u00A5","yen"],["\u00A6","brvbar"],["\u00A7","sect"],
		["\u00A8","uml"],["\u00A9","copy"],["\u00AA","ordf"],["\u00AB","laquo"],
		["\u00AC","not"],["\u00AD","shy"],["\u00AE","reg"],["\u00AF","macr"],
		["\u00B0","deg"],["\u00B1","plusmn"],["\u00B2","sup2"],["\u00B3","sup3"],
		["\u00B4","acute"],["\u00B5","micro"],["\u00B6","para"],["\u00B7","middot"],
		["\u00B8","cedil"],["\u00B9","sup1"],["\u00BA","ordm"],["\u00BB","raquo"],
		["\u00BC","frac14"],["\u00BD","frac12"],["\u00BE","frac34"],["\u00BF","iquest"],
		["\u00C0","Agrave"],["\u00C1","Aacute"],["\u00C2","Acirc"],["\u00C3","Atilde"],
		["\u00C4","Auml"],["\u00C5","Aring"],["\u00C6","AElig"],["\u00C7","Ccedil"],
		["\u00C8","Egrave"],["\u00C9","Eacute"],["\u00CA","Ecirc"],["\u00CB","Euml"],
		["\u00CC","Igrave"],["\u00CD","Iacute"],["\u00CE","Icirc"],["\u00CF","Iuml"],
		["\u00D0","ETH"],["\u00D1","Ntilde"],["\u00D2","Ograve"],["\u00D3","Oacute"],
		["\u00D4","Ocirc"],["\u00D5","Otilde"],["\u00D6","Ouml"],["\u00D7","times"],
		["\u00D8","Oslash"],["\u00D9","Ugrave"],["\u00DA","Uacute"],["\u00DB","Ucirc"], 
		["\u00DC","Uuml"],["\u00DD","Yacute"],["\u00DE","THORN"],["\u00DF","szlig"],
		["\u00E0","agrave"],["\u00E1","aacute"],["\u00E2","acirc"],["\u00E3","atilde"],
		["\u00E4","auml"],["\u00E5","aring"],["\u00E6","aelig"],["\u00E7","ccedil"],
		["\u00E8","egrave"],["\u00E9","eacute"],["\u00EA","ecirc"],["\u00EB","euml"],
		["\u00EC","igrave"],["\u00ED","iacute"],["\u00EE","icirc"],["\u00EF","iuml"], 
		["\u00F0","eth"],["\u00F1","ntilde"],["\u00F2","ograve"],["\u00F3","oacute"],
		["\u00F4","ocirc"],["\u00F5","otilde"],["\u00F6","ouml"],["\u00F7","divide"],
		["\u00F8","oslash"],["\u00F9","ugrave"],["\u00FA","uacute"],["\u00FB","ucirc"],
		["\u00FC","uuml"],["\u00FD","yacute"],["\u00FE","thorn"],["\u00FF","yuml"],
		["\u0192","fnof"],["\u0391","Alpha"],["\u0392","Beta"],["\u0393","Gamma"],
		["\u0394","Delta"],["\u0395","Epsilon"],["\u0396","Zeta"],["\u0397","Eta"],
		["\u0398","Theta"], ["\u0399","Iota"],["\u039A","Kappa"],["\u039B","Lambda"],
		["\u039C","Mu"],["\u039D","Nu"],["\u039E","Xi"],["\u039F","Omicron"],
		["\u03A0","Pi"],["\u03A1","Rho"],["\u03A3","Sigma"],["\u03A4","Tau"],
		["\u03A5","Upsilon"],["\u03A6","Phi"],["\u03A7","Chi"],["\u03A8","Psi"], 
		["\u03A9","Omega"],["\u03B1","alpha"],["\u03B2","beta"],["\u03B3","gamma"],
		["\u03B4","delta"],["\u03B5","epsilon"],["\u03B6","zeta"],["\u03B7","eta"],
		["\u03B8","theta"],["\u03B9","iota"],["\u03BA","kappa"],["\u03BB","lambda"],
		["\u03BC","mu"],["\u03BD","nu"],["\u03BE","xi"],["\u03BF","omicron"],
		["\u03C0","pi"],["\u03C1","rho"],["\u03C2","sigmaf"],["\u03C3","sigma"], 
		["\u03C4","tau"],["\u03C5","upsilon"],["\u03C6","phi"],["\u03C7","chi"],
		["\u03C8","psi"],["\u03C9","omega"],["\u03D1","thetasym"],["\u03D2","upsih"],
		["\u03D6","piv"],["\u2022","bull"],["\u2026","hellip"],["\u2032","prime"],
		["\u2033","Prime"],["\u203E","oline"],["\u2044","frasl"],["\u2118","weierp"],
		["\u2111","image"],["\u211C","real"],["\u2122","trade"],["\u2135","alefsym"], 
		["\u2190","larr"],["\u2191","uarr"],["\u2192","rarr"],["\u2193","darr"],
		["\u2194","harr"],["\u21B5","crarr"],["\u21D0","lArr"],["\u21D1","uArr"],
		["\u21D2","rArr"],["\u21D3","dArr"],["\u21D4","hArr"],["\u2200","forall"],
		["\u2202","part"],["\u2203","exist"],["\u2205","empty"],["\u2207","nabla"],
		["\u2208","isin"],["\u2209","notin"],["\u220B","ni"],["\u220F","prod"], 
		["\u2211","sum"],["\u2212","minus"],["\u2217","lowast"],["\u221A","radic"],
		["\u221D","prop"],["\u221E","infin"],["\u2220","ang"],["\u2227","and"],
		["\u2228","or"],["\u2229","cap"],["\u222A","cup"],["\u222B","int"],
		["\u2234","there4"],["\u223C","sim"],["\u2245","cong"],["\u2248","asymp"],
		["\u2260","ne"],["\u2261","equiv"],["\u2264","le"],["\u2265","ge"], 
		["\u2282","sub"],["\u2283","sup"],["\u2284","nsub"],["\u2286","sube"],
		["\u2287","supe"],["\u2295","oplus"],["\u2297","otimes"],["\u22A5","perp"],
		["\u22C5","sdot"],["\u2308","lceil"],["\u2309","rceil"],["\u230A","lfloor"],
		["\u230B","rfloor"],["\u2329","lang"],["\u232A","rang"],["\u25CA","loz"],
		["\u2660","spades"],["\u2663","clubs"],["\u2665","hearts"],["\u2666","diams"], 
		["\u0152","Elig"],["\u0153","oelig"],["\u0160","Scaron"],["\u0161","scaron"],
		["\u0178","Yuml"],["\u02C6","circ"],["\u02DC","tilde"],["\u2002","ensp"],
		["\u2003","emsp"],["\u2009","thinsp"],["\u200C","zwnj"],["\u200D","zwj"],
		["\u200E","lrm"],["\u200F","rlm"],["\u2013","ndash"],["\u2014","mdash"],
		["\u2018","lsquo"],["\u2019","rsquo"],["\u201A","sbquo"],["\u201C","ldquo"],
		["\u201D","rdquo"],["\u201E","bdquo"],["\u2020","dagger"],["\u2021","Dagger"],
		["\u2030","permil"],["\u2039","lsaquo"],["\u203A","rsaquo"]
	];

	dojox.html.entities.encode = function(str/*string*/, m /*array?*/){
		// summary:
		//		Function to obtain an entity encoding for a specified characer
		// str:
		//		The string to process for possible entity encoding.
		// m:
		//		An optional list of character to entity name mappings (array of 
		//		arrays).  If not provided, it uses the and latin entities as the 
		//		set to map and escape.
		// tags:
		//		public
		if(str){
			if(!m){
				// Apply the basic mappings.  HTML should always come first when decoding
				// as well.
				str = _applyEncodingMap(str, dojox.html.entities.html);
				str = _applyEncodingMap(str, dojox.html.entities.latin);

			}else{
				str = _applyEncodingMap(str, m);
			}
		}
		return str;
	};

	dojox.html.entities.decode = function(str/*string*/, m /*array?*/){
		// summary:
		//		Function to obtain an entity encoding for a specified characer
		// str:
		//		The string to process for possible entity encoding to decode.
		// m:
		//		An optional list of character to entity name mappings (array of 
		//		arrays).  If not provided, it uses the and latin entities as the 
		//		set to map and unencode.
		// tags:
		//		public
		if(str){
			if(!m){
				// Apply the basic mappings.  HTML should always come first when decoding
				// as well.
				str = _applyDecodingMap(str, dojox.html.entities.html);
				str = _applyDecodingMap(str, dojox.html.entities.latin);

			}else{
				str = _applyDecodingMap(str, m);
			}
		}
		return str;
	};
})();


}

if(!dojo._hasResource["dojo.dnd.move"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.move"] = true;
dojo.provide("dojo.dnd.move");




/*=====
dojo.declare("dojo.dnd.move.__constrainedMoveableArgs", [dojo.dnd.__MoveableArgs], {
	// constraints: Function
	//		Calculates a constraint box.
	//		It is called in a context of the moveable object.
	constraints: function(){},

	// within: Boolean
	//		restrict move within boundaries.
	within: false
});
=====*/

dojo.declare("dojo.dnd.move.constrainedMoveable", dojo.dnd.Moveable, {
	// object attributes (for markup)
	constraints: function(){},
	within: false,
	
	// markup methods
	markupFactory: function(params, node){
		return new dojo.dnd.move.constrainedMoveable(node, params);
	},

	constructor: function(node, params){
		// summary:
		//		an object that makes a node moveable
		// node: Node
		//		a node (or node's id) to be moved
		// params: dojo.dnd.move.__constrainedMoveableArgs?
		//		an optional object with additional parameters;
		//		the rest is passed to the base class
		if(!params){ params = {}; }
		this.constraints = params.constraints;
		this.within = params.within;
	},
	onFirstMove: function(/* dojo.dnd.Mover */ mover){
		// summary:
		//		called during the very first move notification;
		//		can be used to initialize coordinates, can be overwritten.
		var c = this.constraintBox = this.constraints.call(this, mover);
		c.r = c.l + c.w;
		c.b = c.t + c.h;
		if(this.within){
			var mb = dojo.marginBox(mover.node);
			c.r -= mb.w;
			c.b -= mb.h;
		}
	},
	onMove: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
		// summary:
		//		called during every move notification;
		//		should actually move the node; can be overwritten.
		var c = this.constraintBox, s = mover.node.style;
		s.left = (leftTop.l < c.l ? c.l : c.r < leftTop.l ? c.r : leftTop.l) + "px";
		s.top  = (leftTop.t < c.t ? c.t : c.b < leftTop.t ? c.b : leftTop.t) + "px";
	}
});

/*=====
dojo.declare("dojo.dnd.move.__boxConstrainedMoveableArgs", [dojo.dnd.move.__constrainedMoveableArgs], {
	// box: Object
	//		a constraint box
	box: {}
});
=====*/

dojo.declare("dojo.dnd.move.boxConstrainedMoveable", dojo.dnd.move.constrainedMoveable, {
	// box:
	//		object attributes (for markup)
	box: {},
	
	// markup methods
	markupFactory: function(params, node){
		return new dojo.dnd.move.boxConstrainedMoveable(node, params);
	},

	constructor: function(node, params){
		// summary:
		//		an object, which makes a node moveable
		// node: Node
		//		a node (or node's id) to be moved
		// params: dojo.dnd.move.__boxConstrainedMoveableArgs?
		//		an optional object with parameters
		var box = params && params.box;
		this.constraints = function(){ return box; };
	}
});

/*=====
dojo.declare("dojo.dnd.move.__parentConstrainedMoveableArgs", [dojo.dnd.move.__constrainedMoveableArgs], {
	// area: String
	//		A parent's area to restrict the move.
	//		Can be "margin", "border", "padding", or "content".
	area: ""
});
=====*/

dojo.declare("dojo.dnd.move.parentConstrainedMoveable", dojo.dnd.move.constrainedMoveable, {
	// area:
	//		object attributes (for markup)
	area: "content",

	// markup methods
	markupFactory: function(params, node){
		return new dojo.dnd.move.parentConstrainedMoveable(node, params);
	},

	constructor: function(node, params){
		// summary:
		//		an object, which makes a node moveable
		// node: Node
		//		a node (or node's id) to be moved
		// params: dojo.dnd.move.__parentConstrainedMoveableArgs?
		//		an optional object with parameters
		var area = params && params.area;
		this.constraints = function(){
			var n = this.node.parentNode, 
				s = dojo.getComputedStyle(n), 
				mb = dojo._getMarginBox(n, s);
			if(area == "margin"){
				return mb;	// Object
			}
			var t = dojo._getMarginExtents(n, s);
			mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
			if(area == "border"){
				return mb;	// Object
			}
			t = dojo._getBorderExtents(n, s);
			mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
			if(area == "padding"){
				return mb;	// Object
			}
			t = dojo._getPadExtents(n, s);
			mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
			return mb;	// Object
		};
	}
});

// WARNING: below are obsolete objects, instead of custom movers use custom moveables (above)

dojo.dnd.move.constrainedMover = function(fun, within){
	// summary:
	//		returns a constrained version of dojo.dnd.Mover
	// description:
	//		this function produces n object, which will put a constraint on 
	//		the margin box of dragged object in absolute coordinates
	// fun: Function
	//		called on drag, and returns a constraint box
	// within: Boolean
	//		if true, constraints the whole dragged object withtin the rectangle, 
	//		otherwise the constraint is applied to the left-top corner

	dojo.deprecated("dojo.dnd.move.constrainedMover, use dojo.dnd.move.constrainedMoveable instead");
	var mover = function(node, e, notifier){
		dojo.dnd.Mover.call(this, node, e, notifier);
	};
	dojo.extend(mover, dojo.dnd.Mover.prototype);
	dojo.extend(mover, {
		onMouseMove: function(e){
			// summary: event processor for onmousemove
			// e: Event: mouse event
			dojo.dnd.autoScroll(e);
			var m = this.marginBox, c = this.constraintBox,
				l = m.l + e.pageX, t = m.t + e.pageY;
			l = l < c.l ? c.l : c.r < l ? c.r : l;
			t = t < c.t ? c.t : c.b < t ? c.b : t;
			this.host.onMove(this, {l: l, t: t});
		},
		onFirstMove: function(){
			// summary: called once to initialize things; it is meant to be called only once
			dojo.dnd.Mover.prototype.onFirstMove.call(this);
			var c = this.constraintBox = fun.call(this);
			c.r = c.l + c.w;
			c.b = c.t + c.h;
			if(within){
				var mb = dojo.marginBox(this.node);
				c.r -= mb.w;
				c.b -= mb.h;
			}
		}
	});
	return mover;	// Object
};

dojo.dnd.move.boxConstrainedMover = function(box, within){
	// summary:
	//		a specialization of dojo.dnd.constrainedMover, which constrains to the specified box
	// box: Object
	//		a constraint box (l, t, w, h)
	// within: Boolean
	//		if true, constraints the whole dragged object withtin the rectangle, 
	//		otherwise the constraint is applied to the left-top corner

	dojo.deprecated("dojo.dnd.move.boxConstrainedMover, use dojo.dnd.move.boxConstrainedMoveable instead");
	return dojo.dnd.move.constrainedMover(function(){ return box; }, within);	// Object
};

dojo.dnd.move.parentConstrainedMover = function(area, within){
	// summary:
	//		a specialization of dojo.dnd.constrainedMover, which constrains to the parent node
	// area: String
	//		"margin" to constrain within the parent's margin box, "border" for the border box,
	//		"padding" for the padding box, and "content" for the content box; "content" is the default value.
	// within: Boolean
	//		if true, constraints the whole dragged object within the rectangle, 
	//		otherwise the constraint is applied to the left-top corner

	dojo.deprecated("dojo.dnd.move.parentConstrainedMover, use dojo.dnd.move.parentConstrainedMoveable instead");
	var fun = function(){
		var n = this.node.parentNode, 
			s = dojo.getComputedStyle(n), 
			mb = dojo._getMarginBox(n, s);
		if(area == "margin"){
			return mb;	// Object
		}
		var t = dojo._getMarginExtents(n, s);
		mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
		if(area == "border"){
			return mb;	// Object
		}
		t = dojo._getBorderExtents(n, s);
		mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
		if(area == "padding"){
			return mb;	// Object
		}
		t = dojo._getPadExtents(n, s);
		mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
		return mb;	// Object
	};
	return dojo.dnd.move.constrainedMover(fun, within);	// Object
};

// patching functions one level up for compatibility

dojo.dnd.constrainedMover = dojo.dnd.move.constrainedMover;
dojo.dnd.boxConstrainedMover = dojo.dnd.move.boxConstrainedMover;
dojo.dnd.parentConstrainedMover = dojo.dnd.move.parentConstrainedMover;

}

if(!dojo._hasResource["dojo.dnd.TimedMoveable"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.TimedMoveable"] = true;
dojo.provide("dojo.dnd.TimedMoveable");



/*=====
dojo.declare("dojo.dnd.__TimedMoveableArgs", [dojo.dnd.__MoveableArgs], {
	// timeout: Number
	//		delay move by this number of ms,
	//		accumulating position changes during the timeout
	timeout: 0
});
=====*/

(function(){
	// precalculate long expressions
	var oldOnMove = dojo.dnd.Moveable.prototype.onMove;
		
	dojo.declare("dojo.dnd.TimedMoveable", dojo.dnd.Moveable, {
		// summary:
		//		A specialized version of Moveable to support an FPS throttling.
		//		This class puts an upper restriction on FPS, which may reduce 
		//		the CPU load. The additional parameter "timeout" regulates
		//		the delay before actually moving the moveable object.
		
		// object attributes (for markup)
		timeout: 40,	// in ms, 40ms corresponds to 25 fps
	
		constructor: function(node, params){
			// summary:
			//		an object that makes a node moveable with a timer
			// node: Node||String
			//		a node (or node's id) to be moved
			// params: dojo.dnd.__TimedMoveableArgs
			//		object with additional parameters.
			
			// sanitize parameters
			if(!params){ params = {}; }
			if(params.timeout && typeof params.timeout == "number" && params.timeout >= 0){
				this.timeout = params.timeout;
			}
		},
	
		// markup methods
		markupFactory: function(params, node){
			return new dojo.dnd.TimedMoveable(node, params);
		},
	
		onMoveStop: function(/* dojo.dnd.Mover */ mover){
			if(mover._timer){
				// stop timer
				clearTimeout(mover._timer)
				// reflect the last received position
				oldOnMove.call(this, mover, mover._leftTop)
			}
			dojo.dnd.Moveable.prototype.onMoveStop.apply(this, arguments);
		},
		onMove: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
			mover._leftTop = leftTop;
			if(!mover._timer){
				var _t = this;	// to avoid using dojo.hitch()
				mover._timer = setTimeout(function(){
					// we don't have any pending requests
					mover._timer = null;
					// reflect the last received position
					oldOnMove.call(_t, mover, mover._leftTop);
				}, this.timeout);
			}
		}
	});
})();

}

if(!dojo._hasResource["dijit._DialogMixin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._DialogMixin"] = true;
dojo.provide("dijit._DialogMixin");

dojo.declare("dijit._DialogMixin", null,
	{
		// summary:
		//		This provides functions useful to Dialog and TooltipDialog

		attributeMap: dijit._Widget.prototype.attributeMap,

		execute: function(/*Object*/ formContents){
			// summary:
			//		Callback when the user hits the submit button.
			//		Override this method to handle Dialog execution.
			// description:
			//		After the user has pressed the submit button, the Dialog
			//		first calls onExecute() to notify the container to hide the
			//		dialog and restore focus to wherever it used to be.
			//
			//		*Then* this method is called.
			// type:
			//		callback
		},

		onCancel: function(){
			// summary:
			//	    Called when user has pressed the Dialog's cancel button, to notify container.
			// description:
			//	    Developer shouldn't override or connect to this method;
			//		it's a private communication device between the TooltipDialog
			//		and the thing that opened it (ex: `dijit.form.DropDownButton`)
			// type:
			//		protected
		},

		onExecute: function(){
			// summary:
			//	    Called when user has pressed the dialog's OK button, to notify container.
			// description:
			//	    Developer shouldn't override or connect to this method;
			//		it's a private communication device between the TooltipDialog
			//		and the thing that opened it (ex: `dijit.form.DropDownButton`)
			// type:
			//		protected
		},

		_onSubmit: function(){
			// summary:
			//		Callback when user hits submit button
			// type:
			//		protected
			this.onExecute();	// notify container that we are about to execute
			this.execute(this.attr('value'));
		},

		_getFocusItems: function(/*Node*/ dialogNode){
			// summary:
			//		Find focusable Items each time a dialog is opened,
			//		setting _firstFocusItem and _lastFocusItem
			// tags:
			//		protected

			var elems = dijit._getTabNavigable(dojo.byId(dialogNode));
			this._firstFocusItem = elems.lowest || elems.first || dialogNode;
			this._lastFocusItem = elems.last || elems.highest || this._firstFocusItem;
			if(dojo.isMoz && this._firstFocusItem.tagName.toLowerCase() == "input" &&
					dojo.getNodeProp(this._firstFocusItem, "type").toLowerCase() == "file"){
				// FF doesn't behave well when first element is input type=file, set first focusable to dialog container
				dojo.attr(dialogNode, "tabIndex", "0");
				this._firstFocusItem = dialogNode;
			}
		}
	}
);

}

if(!dojo._hasResource["dijit.DialogUnderlay"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.DialogUnderlay"] = true;
dojo.provide("dijit.DialogUnderlay");




dojo.declare(
	"dijit.DialogUnderlay",
	[dijit._Widget, dijit._Templated],
	{
		// summary:
		//		The component that blocks the screen behind a `dijit.Dialog`
		//
		// description:
		// 		A component used to block input behind a `dijit.Dialog`. Only a single
		//		instance of this widget is created by `dijit.Dialog`, and saved as
		//		a reference to be shared between all Dialogs as `dijit._underlay`
		//
		//		The underlay itself can be styled based on and id:
		//	|	#myDialog_underlay { background-color:red; }
		//
		//		In the case of `dijit.Dialog`, this id is based on the id of the Dialog,
		//		suffixed with _underlay.

		// Template has two divs; outer div is used for fade-in/fade-out, and also to hold background iframe.
		// Inner div has opacity specified in CSS file.
		templateString: "<div class='dijitDialogUnderlayWrapper'><div class='dijitDialogUnderlay' dojoAttachPoint='node'></div></div>",

		// Parameters on creation or updatable later

		// dialogId: String
		//		Id of the dialog.... DialogUnderlay's id is based on this id
		dialogId: "",

		// class: String
		//		This class name is used on the DialogUnderlay node, in addition to dijitDialogUnderlay
		"class": "",

		attributeMap: { id: "domNode" },

		_setDialogIdAttr: function(id){
			dojo.attr(this.node, "id", id + "_underlay");
		},

		_setClassAttr: function(clazz){
			this.node.className = "dijitDialogUnderlay " + clazz;
		},

		postCreate: function(){
			// summary:
			//		Append the underlay to the body
			dojo.body().appendChild(this.domNode);
		},

		layout: function(){
			// summary:
			//		Sets the background to the size of the viewport
			//
			// description:
			//		Sets the background to the size of the viewport (rather than the size
			//		of the document) since we need to cover the whole browser window, even
			//		if the document is only a few lines long.
			// tags:
			//		private

			var is = this.node.style,
				os = this.domNode.style;

			// hide the background temporarily, so that the background itself isn't
			// causing scrollbars to appear (might happen when user shrinks browser
			// window and then we are called to resize)
			os.display = "none";

			// then resize and show
			var viewport = dijit.getViewport();
			os.top = viewport.t + "px";
			os.left = viewport.l + "px";
			is.width = viewport.w + "px";
			is.height = viewport.h + "px";
			os.display = "block";
		},

		show: function(){
			// summary:
			//		Show the dialog underlay
			this.domNode.style.display = "block";
			this.layout();
			this.bgIframe = new dijit.BackgroundIframe(this.domNode);
		},

		hide: function(){
			// summary:
			//		Hides the dialog underlay
			this.bgIframe.destroy();
			this.domNode.style.display = "none";
		},

		uninitialize: function(){
			if(this.bgIframe){
				this.bgIframe.destroy();
			}
			this.inherited(arguments);
		}
	}
);

}

if(!dojo._hasResource["dijit.TooltipDialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.TooltipDialog"] = true;
dojo.provide("dijit.TooltipDialog");






dojo.declare(
		"dijit.TooltipDialog",
		[dijit.layout.ContentPane, dijit._Templated, dijit.form._FormMixin, dijit._DialogMixin],
		{
			// summary:
			//		Pops up a dialog that appears like a Tooltip

			// title: String
			// 		Description of tooltip dialog (required for a11y)
			title: "",

			// doLayout: [protected] Boolean
			//		Don't change this parameter from the default value.
			//		This ContentPane parameter doesn't make sense for TooltipDialog, since TooltipDialog
			//		is never a child of a layout container, nor can you specify the size of
			//		TooltipDialog in order to control the size of an inner widget.
			doLayout: false,

			// autofocus: Boolean
			// 		A Toggle to modify the default focus behavior of a Dialog, which
			// 		is to focus on the first dialog element after opening the dialog.
			//		False will disable autofocusing. Default: true
			autofocus: true,

			// baseClass: [protected] String
			//		The root className to use for the various states of this widget
			baseClass: "dijitTooltipDialog",

			// _firstFocusItem: [private] [readonly] DomNode
			//		The pointer to the first focusable node in the dialog.
			//		Set by `dijit._DialogMixin._getFocusItems`.
			_firstFocusItem: null,

			// _lastFocusItem: [private] [readonly] DomNode
			//		The pointer to which node has focus prior to our dialog.
			//		Set by `dijit._DialogMixin._getFocusItems`.
			_lastFocusItem: null,

			templateString: dojo.cache("dijit", "templates/TooltipDialog.html", "<div waiRole=\"presentation\">\r\n\t<div class=\"dijitTooltipContainer\" waiRole=\"presentation\">\r\n\t\t<div class =\"dijitTooltipContents dijitTooltipFocusNode\" dojoAttachPoint=\"containerNode\" tabindex=\"-1\" waiRole=\"dialog\"></div>\r\n\t</div>\r\n\t<div class=\"dijitTooltipConnector\" waiRole=\"presentation\"></div>\r\n</div>\r\n"),

			postCreate: function(){
				this.inherited(arguments);
				this.connect(this.containerNode, "onkeypress", "_onKey");
				this.containerNode.title = this.title;
			},

			orient: function(/*DomNode*/ node, /*String*/ aroundCorner, /*String*/ corner){
				// summary:
				//		Configure widget to be displayed in given position relative to the button.
				//		This is called from the dijit.popup code, and should not be called
				//		directly.
				// tags:
				//		protected
				var c = this._currentOrientClass;
				if(c){
					dojo.removeClass(this.domNode, c);
				}
				c = "dijitTooltipAB"+(corner.charAt(1) == 'L'?"Left":"Right")+" dijitTooltip"+(corner.charAt(0) == 'T' ? "Below" : "Above");
				dojo.addClass(this.domNode, c);
				this._currentOrientClass = c;
			},

			onOpen: function(/*Object*/ pos){
				// summary:
				//		Called when dialog is displayed.
				//		This is called from the dijit.popup code, and should not be called directly.
				// tags:
				//		protected

				this.orient(this.domNode,pos.aroundCorner, pos.corner);
				this._onShow(); // lazy load trigger

				if(this.autofocus){
					this._getFocusItems(this.containerNode);
					dijit.focus(this._firstFocusItem);
				}
			},

			onClose: function(){
				// summary:
				//		Called when dialog is hidden.
				//		This is called from the dijit.popup code, and should not be called directly.
				// tags:
				//		protected
				this.onHide();
			},

			_onKey: function(/*Event*/ evt){
				// summary:
				//		Handler for keyboard events
				// description:
				//		Keep keyboard focus in dialog; close dialog on escape key
				// tags:
				//		private

				var node = evt.target;
				var dk = dojo.keys;
				if(evt.charOrCode === dk.TAB){
					this._getFocusItems(this.containerNode);
				}
				var singleFocusItem = (this._firstFocusItem == this._lastFocusItem);
				if(evt.charOrCode == dk.ESCAPE){
					// Use setTimeout to avoid crash on IE, see #10396.
					setTimeout(dojo.hitch(this, "onCancel"), 0);
					dojo.stopEvent(evt);
				}else if(node == this._firstFocusItem && evt.shiftKey && evt.charOrCode === dk.TAB){
					if(!singleFocusItem){
						dijit.focus(this._lastFocusItem); // send focus to last item in dialog
					}
					dojo.stopEvent(evt);
				}else if(node == this._lastFocusItem && evt.charOrCode === dk.TAB && !evt.shiftKey){
					if(!singleFocusItem){
						dijit.focus(this._firstFocusItem); // send focus to first item in dialog
					}
					dojo.stopEvent(evt);
				}else if(evt.charOrCode === dk.TAB){
					// we want the browser's default tab handling to move focus
					// but we don't want the tab to propagate upwards
					evt.stopPropagation();
				}
			}
		}
	);

}

if(!dojo._hasResource["dijit.Dialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Dialog"] = true;
dojo.provide("dijit.Dialog");













/*=====
dijit._underlay = function(kwArgs){
	// summary:
	//		A shared instance of a `dijit.DialogUnderlay`
	//
	// description:
	//		A shared instance of a `dijit.DialogUnderlay` created and
	//		used by `dijit.Dialog`, though never created until some Dialog
	//		or subclass thereof is shown.
};
=====*/

dojo.declare(
	"dijit._DialogBase",
	[dijit._Templated, dijit.form._FormMixin, dijit._DialogMixin],
	{
		// summary:
		//		A modal dialog Widget
		//
		// description:
		//		Pops up a modal dialog window, blocking access to the screen
		//		and also graying out the screen Dialog is extended from
		//		ContentPane so it supports all the same parameters (href, etc.)
		//
		// example:
		// |	<div dojoType="dijit.Dialog" href="test.html"></div>
		//
		// example:
		// |	var foo = new dijit.Dialog({ title: "test dialog", content: "test content" };
		// |	dojo.body().appendChild(foo.domNode);
		// |	foo.startup();

		templateString: dojo.cache("dijit", "templates/Dialog.html", "<div class=\"dijitDialog\" tabindex=\"-1\" waiRole=\"dialog\" waiState=\"labelledby-${id}_title\">\r\n\t<div dojoAttachPoint=\"titleBar\" class=\"dijitDialogTitleBar\">\r\n\t<span dojoAttachPoint=\"titleNode\" class=\"dijitDialogTitle\" id=\"${id}_title\"></span>\r\n\t<span dojoAttachPoint=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" dojoAttachEvent=\"onclick: onCancel, onmouseenter: _onCloseEnter, onmouseleave: _onCloseLeave\" title=\"${buttonCancel}\">\r\n\t\t<span dojoAttachPoint=\"closeText\" class=\"closeText\" title=\"${buttonCancel}\">x</span>\r\n\t</span>\r\n\t</div>\r\n\t\t<div dojoAttachPoint=\"containerNode\" class=\"dijitDialogPaneContent\"></div>\r\n</div>\r\n"),

		attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
			title: [
				{ node: "titleNode", type: "innerHTML" },
				{ node: "titleBar", type: "attribute" }
			],
			"aria-describedby":""
		}),

		// open: Boolean
		//		True if Dialog is currently displayed on screen.
		open: false,

		// duration: Integer
		//		The time in milliseconds it takes the dialog to fade in and out
		duration: dijit.defaultDuration,

		// refocus: Boolean
		// 		A Toggle to modify the default focus behavior of a Dialog, which
		// 		is to re-focus the element which had focus before being opened.
		//		False will disable refocusing. Default: true
		refocus: true,

		// autofocus: Boolean
		// 		A Toggle to modify the default focus behavior of a Dialog, which
		// 		is to focus on the first dialog element after opening the dialog.
		//		False will disable autofocusing. Default: true
		autofocus: true,

		// _firstFocusItem: [private] [readonly] DomNode
		//		The pointer to the first focusable node in the dialog.
		//		Set by `dijit._DialogMixin._getFocusItems`.
		_firstFocusItem: null,

		// _lastFocusItem: [private] [readonly] DomNode
		//		The pointer to which node has focus prior to our dialog.
		//		Set by `dijit._DialogMixin._getFocusItems`.
		_lastFocusItem: null,

		// doLayout: [protected] Boolean
		//		Don't change this parameter from the default value.
		//		This ContentPane parameter doesn't make sense for Dialog, since Dialog
		//		is never a child of a layout container, nor can you specify the size of
		//		Dialog in order to control the size of an inner widget.
		doLayout: false,

		// draggable: Boolean
		//		Toggles the moveable aspect of the Dialog. If true, Dialog
		//		can be dragged by it's title. If false it will remain centered
		//		in the viewport.
		draggable: true,

		//aria-describedby: String
		//		Allows the user to add an aria-describedby attribute onto the dialog.   The value should
		//		be the id of the container element of text that describes the dialog purpose (usually
		//		the first text in the dialog).
		//		<div dojoType="dijit.Dialog" aria-describedby="intro" .....>
		//			<div id="intro">Introductory text</div>
		//			<div>rest of dialog contents</div>
		//		</div>
		"aria-describedby":"",

		postMixInProperties: function(){
			var _nlsResources = dojo.i18n.getLocalization("dijit", "common");
			dojo.mixin(this, _nlsResources);
			this.inherited(arguments);
		},

		postCreate: function(){
			dojo.style(this.domNode, {
				display: "none",
				position:"absolute"
			});
			dojo.body().appendChild(this.domNode);

			this.inherited(arguments);

			this.connect(this, "onExecute", "hide");
			this.connect(this, "onCancel", "hide");
			this._modalconnects = [];
		},

		onLoad: function(){
			// summary:
			//		Called when data has been loaded from an href.
			//		Unlike most other callbacks, this function can be connected to (via `dojo.connect`)
			//		but should *not* be overriden.
			// tags:
			//		callback

			// when href is specified we need to reposition the dialog after the data is loaded
			this._position();
			this.inherited(arguments);
		},

		_endDrag: function(e){
			// summary:
			//		Called after dragging the Dialog. Saves the position of the dialog in the viewport.
			// tags:
			//		private
			if(e && e.node && e.node === this.domNode){
				this._relativePosition = dojo.position(e.node);
			}
		},

		_setup: function(){
			// summary:
			//		Stuff we need to do before showing the Dialog for the first
			//		time (but we defer it until right beforehand, for
			//		performance reasons).
			// tags:
			//		private

			var node = this.domNode;

			if(this.titleBar && this.draggable){
				this._moveable = (dojo.isIE == 6) ?
					new dojo.dnd.TimedMoveable(node, { handle: this.titleBar }) :	// prevent overload, see #5285
					new dojo.dnd.Moveable(node, { handle: this.titleBar, timeout: 0 });
				dojo.subscribe("/dnd/move/stop",this,"_endDrag");
			}else{
				dojo.addClass(node,"dijitDialogFixed");
			}

			this.underlayAttrs = {
				dialogId: this.id,
				"class": dojo.map(this["class"].split(/\s/), function(s){ return s+"_underlay"; }).join(" ")
			};

			this._fadeIn = dojo.fadeIn({
				node: node,
				duration: this.duration,
				beforeBegin: dojo.hitch(this, function(){
					var underlay = dijit._underlay;
					if(!underlay){
						underlay = dijit._underlay = new dijit.DialogUnderlay(this.underlayAttrs);
					}else{
						underlay.attr(this.underlayAttrs);
					}

					var zIndex = 948 + dijit._dialogStack.length*2;
					dojo.style(dijit._underlay.domNode, 'zIndex', zIndex);
					dojo.style(this.domNode, 'zIndex', zIndex + 1);
					underlay.show();
				}),
				onEnd: dojo.hitch(this, function(){
					if(this.autofocus){
						// find focusable Items each time dialog is shown since if dialog contains a widget the
						// first focusable items can change
						this._getFocusItems(this.domNode);
						dijit.focus(this._firstFocusItem);
					}
				})
			 });

			this._fadeOut = dojo.fadeOut({
				node: node,
				duration: this.duration,
				onEnd: dojo.hitch(this, function(){
					node.style.display = "none";

					// Restore the previous dialog in the stack, or if this is the only dialog
					// then restore to original page
					var ds = dijit._dialogStack;
					if(ds.length == 0){
						dijit._underlay.hide();
					}else{
						dojo.style(dijit._underlay.domNode, 'zIndex', 948 + ds.length*2);
						dijit._underlay.attr(ds[ds.length-1].underlayAttrs);
					}

					// Restore focus to wherever it was before this dialog was displayed
					if(this.refocus){
						var focus = this._savedFocus;

						// If we are returning control to a previous dialog but for some reason
						// that dialog didn't have a focused field, set focus to first focusable item.
						// This situation could happen if two dialogs appeared at nearly the same time,
						// since a dialog doesn't set it's focus until the fade-in is finished.
						if(ds.length > 0){
							var pd = ds[ds.length-1];
							if(!dojo.isDescendant(focus.node, pd.domNode)){
								pd._getFocusItems(pd.domNode);
								focus = pd._firstFocusItem;
							}
						}

						dijit.focus(focus);
					}
				})
			 });
		},

		uninitialize: function(){
			var wasPlaying = false;
			if(this._fadeIn && this._fadeIn.status() == "playing"){
				wasPlaying = true;
				this._fadeIn.stop();
			}
			if(this._fadeOut && this._fadeOut.status() == "playing"){
				wasPlaying = true;
				this._fadeOut.stop();
			}
			
			// Hide the underlay, unless the underlay widget has already been destroyed
			// because we are being called during page unload (when all widgets are destroyed)
			if((this.open || wasPlaying) && !dijit._underlay._destroyed){
				dijit._underlay.hide();
			}
			if(this._moveable){
				this._moveable.destroy();
			}
			this.inherited(arguments);
		},

		_size: function(){
			// summary:
			// 		If necessary, shrink dialog contents so dialog fits in viewport
			// tags:
			//		private

			this._checkIfSingleChild();

			// If we resized the dialog contents earlier, reset them back to original size, so
			// that if the user later increases the viewport size, the dialog can display w/out a scrollbar.
			// Need to do this before the dojo.marginBox(this.domNode) call below.
			if(this._singleChild){
				if(this._singleChildOriginalStyle){
					this._singleChild.domNode.style.cssText = this._singleChildOriginalStyle;
				}
				delete this._singleChildOriginalStyle;
			}else{
				dojo.style(this.containerNode, {
					width:"auto",
					height:"auto"
				});
			}

			var mb = dojo.marginBox(this.domNode);
			var viewport = dijit.getViewport();
			if(mb.w >= viewport.w || mb.h >= viewport.h){
				// Reduce size of dialog contents so that dialog fits in viewport

				var w = Math.min(mb.w, Math.floor(viewport.w * 0.75)),
					h = Math.min(mb.h, Math.floor(viewport.h * 0.75));

				if(this._singleChild && this._singleChild.resize){
					this._singleChildOriginalStyle = this._singleChild.domNode.style.cssText;
					this._singleChild.resize({w: w, h: h});
				}else{
					dojo.style(this.containerNode, {
						width: w + "px",
						height: h + "px",
						overflow: "auto",
						position: "relative"	// workaround IE bug moving scrollbar or dragging dialog
					});
				}
			}else{
				if(this._singleChild && this._singleChild.resize){
					this._singleChild.resize();
				}
			}
		},

		_position: function(){
			// summary:
			//		Position modal dialog in the viewport. If no relative offset
			//		in the viewport has been determined (by dragging, for instance),
			//		center the node. Otherwise, use the Dialog's stored relative offset,
			//		and position the node to top: left: values based on the viewport.
			// tags:
			//		private
			if(!dojo.hasClass(dojo.body(),"dojoMove")){
				var node = this.domNode,
					viewport = dijit.getViewport(),
					p = this._relativePosition,
					bb = p ? null : dojo._getBorderBox(node),
					l = Math.floor(viewport.l + (p ? p.x : (viewport.w - bb.w) / 2)),
					t = Math.floor(viewport.t + (p ? p.y : (viewport.h - bb.h) / 2))
				;
				dojo.style(node,{
					left: l + "px",
					top: t + "px"
				});
			}
		},

		_onKey: function(/*Event*/ evt){
			// summary:
			//		Handles the keyboard events for accessibility reasons
			// tags:
			//		private

			var ds = dijit._dialogStack;
			if(ds[ds.length-1] != this){
				// console.debug(this.id + ': skipping because', this, 'is not the active dialog');
				return;
			}

			if(evt.charOrCode){
				var dk = dojo.keys;
				var node = evt.target;
				if(evt.charOrCode === dk.TAB){
					this._getFocusItems(this.domNode);
				}
				var singleFocusItem = (this._firstFocusItem == this._lastFocusItem);
				// see if we are shift-tabbing from first focusable item on dialog
				if(node == this._firstFocusItem && evt.shiftKey && evt.charOrCode === dk.TAB){
					if(!singleFocusItem){
						dijit.focus(this._lastFocusItem); // send focus to last item in dialog
					}
					dojo.stopEvent(evt);
				}else if(node == this._lastFocusItem && evt.charOrCode === dk.TAB && !evt.shiftKey){
					if(!singleFocusItem){
						dijit.focus(this._firstFocusItem); // send focus to first item in dialog
					}
					dojo.stopEvent(evt);
				}else{
					// see if the key is for the dialog
					while(node){
						if(node == this.domNode || dojo.hasClass(node, "dijitPopup")){
							if(evt.charOrCode == dk.ESCAPE){
								this.onCancel();
							}else{
								return; // just let it go
							}
						}
						node = node.parentNode;
					}
					// this key is for the disabled document window
					if(evt.charOrCode !== dk.TAB){ // allow tabbing into the dialog for a11y
						dojo.stopEvent(evt);
					// opera won't tab to a div
					}else if(!dojo.isOpera){
						try{
							this._firstFocusItem.focus();
						}catch(e){ /*squelch*/ }
					}
				}
			}
		},

		show: function(){
			// summary:
			//		Display the dialog
			if(this.open){ return; }

			// first time we show the dialog, there's some initialization stuff to do
			if(!this._alreadyInitialized){
				this._setup();
				this._alreadyInitialized=true;
			}

			if(this._fadeOut.status() == "playing"){
				this._fadeOut.stop();
			}

			this._modalconnects.push(dojo.connect(window, "onscroll", this, "layout"));
			this._modalconnects.push(dojo.connect(window, "onresize", this, function(){
				// IE gives spurious resize events and can actually get stuck
				// in an infinite loop if we don't ignore them
				var viewport = dijit.getViewport();
				if(!this._oldViewport ||
						viewport.h != this._oldViewport.h ||
						viewport.w != this._oldViewport.w){
					this.layout();
					this._oldViewport = viewport;
				}
			}));
			this._modalconnects.push(dojo.connect(dojo.doc.documentElement, "onkeypress", this, "_onKey"));

			dojo.style(this.domNode, {
				opacity:0,
				display:""
			});

			this.open = true;
			this._onShow(); // lazy load trigger

			this._size();
			this._position();
			dijit._dialogStack.push(this);
			this._fadeIn.play();

			this._savedFocus = dijit.getFocus(this);
		},

		hide: function(){
			// summary:
			//		Hide the dialog

			// if we haven't been initialized yet then we aren't showing and we can just return
			// or if we aren't the active dialog, don't allow us to close yet
			var ds = dijit._dialogStack;
			if(!this._alreadyInitialized || this != ds[ds.length-1]){
				return;
			}

			if(this._fadeIn.status() == "playing"){
				this._fadeIn.stop();
			}

			// throw away current active dialog from stack -- making the previous dialog or the node on the original page active
			ds.pop();

			this._fadeOut.play();

			if(this._scrollConnected){
				this._scrollConnected = false;
			}
			dojo.forEach(this._modalconnects, dojo.disconnect);
			this._modalconnects = [];

			if(this._relativePosition){
				delete this._relativePosition;
			}
			this.open = false;

			this.onHide();
		},

		layout: function(){
			// summary:
			//		Position the Dialog and the underlay
			// tags:
			//		private
			if(this.domNode.style.display != "none"){
				if(dijit._underlay){	// avoid race condition during show()
					dijit._underlay.layout();
				}
				this._position();
			}
		},

		destroy: function(){
			dojo.forEach(this._modalconnects, dojo.disconnect);
			if(this.refocus && this.open){
				setTimeout(dojo.hitch(dijit,"focus",this._savedFocus), 25);
			}
			this.inherited(arguments);
		},

		_onCloseEnter: function(){
			// summary:
			//		Called when user hovers over close icon
			// tags:
			//		private
			dojo.addClass(this.closeButtonNode, "dijitDialogCloseIcon-hover");
		},

		_onCloseLeave: function(){
			// summary:
			//		Called when user stops hovering over close icon
			// tags:
			//		private
			dojo.removeClass(this.closeButtonNode, "dijitDialogCloseIcon-hover");
		}
	}
);

dojo.declare(
	"dijit.Dialog",
	[dijit.layout.ContentPane, dijit._DialogBase],
	{}
);

// Stack of currenctly displayed dialogs, layered on top of each other
dijit._dialogStack = [];

// For back-compat.  TODO: remove in 2.0


}

if(!dojo._hasResource["dijit.layout.BorderContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.BorderContainer"] = true;
dojo.provide("dijit.layout.BorderContainer");




dojo.declare(
	"dijit.layout.BorderContainer",
	dijit.layout._LayoutWidget,
{
	// summary:
	//		Provides layout in up to 5 regions, a mandatory center with optional borders along its 4 sides.
	//
	// description:
	//		A BorderContainer is a box with a specified size, such as style="width: 500px; height: 500px;",
	//		that contains a child widget marked region="center" and optionally children widgets marked
	//		region equal to "top", "bottom", "leading", "trailing", "left" or "right".
	//		Children along the edges will be laid out according to width or height dimensions and may
	//		include optional splitters (splitter="true") to make them resizable by the user.  The remaining
	//		space is designated for the center region.
	//
	//		NOTE: Splitters must not be more than 50 pixels in width.
	//
	//		The outer size must be specified on the BorderContainer node.  Width must be specified for the sides
	//		and height for the top and bottom, respectively.  No dimensions should be specified on the center;
	//		it will fill the remaining space.  Regions named "leading" and "trailing" may be used just like
	//		"left" and "right" except that they will be reversed in right-to-left environments.
	//
	// example:
	// |	<div dojoType="dijit.layout.BorderContainer" design="sidebar" gutters="false"
	// |            style="width: 400px; height: 300px;">
	// |		<div dojoType="ContentPane" region="top">header text</div>
	// |		<div dojoType="ContentPane" region="right" splitter="true" style="width: 200px;">table of contents</div>
	// |		<div dojoType="ContentPane" region="center">client area</div>
	// |	</div>

	// design: String
	//		Which design is used for the layout:
	//			- "headline" (default) where the top and bottom extend
	//				the full width of the container
	//			- "sidebar" where the left and right sides extend from top to bottom.
	design: "headline",

	// gutters: Boolean
	//		Give each pane a border and margin.
	//		Margin determined by domNode.paddingLeft.
	//		When false, only resizable panes have a gutter (i.e. draggable splitter) for resizing.
	gutters: true,

	// liveSplitters: Boolean
	//		Specifies whether splitters resize as you drag (true) or only upon mouseup (false)
	liveSplitters: true,

	// persist: Boolean
	//		Save splitter positions in a cookie.
	persist: false,

	baseClass: "dijitBorderContainer",

	// _splitterClass: String
	// 		Optional hook to override the default Splitter widget used by BorderContainer
	_splitterClass: "dijit.layout._Splitter",

	postMixInProperties: function(){
		// change class name to indicate that BorderContainer is being used purely for
		// layout (like LayoutContainer) rather than for pretty formatting.
		if(!this.gutters){
			this.baseClass += "NoGutter";
		}
		this.inherited(arguments);
	},

	postCreate: function(){
		this.inherited(arguments);

		this._splitters = {};
		this._splitterThickness = {};
	},

	startup: function(){
		if(this._started){ return; }
		dojo.forEach(this.getChildren(), this._setupChild, this);
		this.inherited(arguments);
	},

	_setupChild: function(/*dijit._Widget*/ child){
		// Override _LayoutWidget._setupChild().

		var region = child.region;
		if(region){
			this.inherited(arguments);

			dojo.addClass(child.domNode, this.baseClass+"Pane");

			var ltr = this.isLeftToRight();
			if(region == "leading"){ region = ltr ? "left" : "right"; }
			if(region == "trailing"){ region = ltr ? "right" : "left"; }

			//FIXME: redundant?
			this["_"+region] = child.domNode;
			this["_"+region+"Widget"] = child;

			// Create draggable splitter for resizing pane,
			// or alternately if splitter=false but BorderContainer.gutters=true then
			// insert dummy div just for spacing
			if((child.splitter || this.gutters) && !this._splitters[region]){
				var _Splitter = dojo.getObject(child.splitter ? this._splitterClass : "dijit.layout._Gutter");
				var splitter = new _Splitter({
					container: this,
					child: child,
					region: region,
					live: this.liveSplitters
				});
				splitter.isSplitter = true;
				this._splitters[region] = splitter.domNode;
				dojo.place(this._splitters[region], child.domNode, "after");

				// Splitters arent added as Contained children, so we need to call startup explicitly
				splitter.startup();
			}
			child.region = region;
		}
	},

	_computeSplitterThickness: function(region){
		this._splitterThickness[region] = this._splitterThickness[region] ||
			dojo.marginBox(this._splitters[region])[(/top|bottom/.test(region) ? 'h' : 'w')];
	},

	layout: function(){
		// Implement _LayoutWidget.layout() virtual method.
		for(var region in this._splitters){ this._computeSplitterThickness(region); }
		this._layoutChildren();
	},

	addChild: function(/*dijit._Widget*/ child, /*Integer?*/ insertIndex){
		// Override _LayoutWidget.addChild().
		this.inherited(arguments);
		if(this._started){
			this.layout(); //OPT
		}
	},

	removeChild: function(/*dijit._Widget*/ child){
		// Override _LayoutWidget.removeChild().
		var region = child.region;
		var splitter = this._splitters[region];
		if(splitter){
			dijit.byNode(splitter).destroy();
			delete this._splitters[region];
			delete this._splitterThickness[region];
		}
		this.inherited(arguments);
		delete this["_"+region];
		delete this["_" +region+"Widget"];
		if(this._started){
			this._layoutChildren(child.region);
		}
		dojo.removeClass(child.domNode, this.baseClass+"Pane");
	},

	getChildren: function(){
		// Override _LayoutWidget.getChildren() to only return real children, not the splitters.
		return dojo.filter(this.inherited(arguments), function(widget){
			return !widget.isSplitter;
		});
	},

	getSplitter: function(/*String*/region){
		// summary:
		//		Returns the widget responsible for rendering the splitter associated with region
		var splitter = this._splitters[region];
		return splitter ? dijit.byNode(splitter) : null;
	},

	resize: function(newSize, currentSize){
		// Overrides _LayoutWidget.resize().

		// resetting potential padding to 0px to provide support for 100% width/height + padding
		// TODO: this hack doesn't respect the box model and is a temporary fix
		if(!this.cs || !this.pe){
			var node = this.domNode;
			this.cs = dojo.getComputedStyle(node);
			this.pe = dojo._getPadExtents(node, this.cs);
			this.pe.r = dojo._toPixelValue(node, this.cs.paddingRight);
			this.pe.b = dojo._toPixelValue(node, this.cs.paddingBottom);

			dojo.style(node, "padding", "0px");
		}

		this.inherited(arguments);
	},

	_layoutChildren: function(/*String?*/changedRegion){
		// summary:
		//		This is the main routine for setting size/position of each child

		if(!this._borderBox || !this._borderBox.h){
			// We are currently hidden, or we haven't been sized by our parent yet.
			// Abort.   Someone will resize us later.
			return;
		}

		var sidebarLayout = (this.design == "sidebar");
		var topHeight = 0, bottomHeight = 0, leftWidth = 0, rightWidth = 0;
		var topStyle = {}, leftStyle = {}, rightStyle = {}, bottomStyle = {},
			centerStyle = (this._center && this._center.style) || {};

		var changedSide = /left|right/.test(changedRegion);

		var layoutSides = !changedRegion || (!changedSide && !sidebarLayout);
		var layoutTopBottom = !changedRegion || (changedSide && sidebarLayout);

		// Ask browser for width/height of side panes.
		// Would be nice to cache this but height can change according to width
		// (because words wrap around).  I don't think width will ever change though
		// (except when the user drags a splitter).
		if(this._top){
			topStyle = layoutTopBottom && this._top.style;
			topHeight = dojo.marginBox(this._top).h;
		}
		if(this._left){
			leftStyle = layoutSides && this._left.style;
			leftWidth = dojo.marginBox(this._left).w;
		}
		if(this._right){
			rightStyle = layoutSides && this._right.style;
			rightWidth = dojo.marginBox(this._right).w;
		}
		if(this._bottom){
			bottomStyle = layoutTopBottom && this._bottom.style;
			bottomHeight = dojo.marginBox(this._bottom).h;
		}

		var splitters = this._splitters;
		var topSplitter = splitters.top, bottomSplitter = splitters.bottom,
			leftSplitter = splitters.left, rightSplitter = splitters.right;
		var splitterThickness = this._splitterThickness;
		var topSplitterThickness = splitterThickness.top || 0,
			leftSplitterThickness = splitterThickness.left || 0,
			rightSplitterThickness = splitterThickness.right || 0,
			bottomSplitterThickness = splitterThickness.bottom || 0;

		// Check for race condition where CSS hasn't finished loading, so
		// the splitter width == the viewport width (#5824)
		if(leftSplitterThickness > 50 || rightSplitterThickness > 50){
			setTimeout(dojo.hitch(this, function(){
				// Results are invalid.  Clear them out.
				this._splitterThickness = {};

				for(var region in this._splitters){
					this._computeSplitterThickness(region);
				}
				this._layoutChildren();
			}), 50);
			return false;
		}

		var pe = this.pe;

		var splitterBounds = {
			left: (sidebarLayout ? leftWidth + leftSplitterThickness: 0) + pe.l + "px",
			right: (sidebarLayout ? rightWidth + rightSplitterThickness: 0) + pe.r + "px"
		};

		if(topSplitter){
			dojo.mixin(topSplitter.style, splitterBounds);
			topSplitter.style.top = topHeight + pe.t + "px";
		}

		if(bottomSplitter){
			dojo.mixin(bottomSplitter.style, splitterBounds);
			bottomSplitter.style.bottom = bottomHeight + pe.b + "px";
		}

		splitterBounds = {
			top: (sidebarLayout ? 0 : topHeight + topSplitterThickness) + pe.t + "px",
			bottom: (sidebarLayout ? 0 : bottomHeight + bottomSplitterThickness) + pe.b + "px"
		};

		if(leftSplitter){
			dojo.mixin(leftSplitter.style, splitterBounds);
			leftSplitter.style.left = leftWidth + pe.l + "px";
		}

		if(rightSplitter){
			dojo.mixin(rightSplitter.style, splitterBounds);
			rightSplitter.style.right = rightWidth + pe.r +	"px";
		}

		dojo.mixin(centerStyle, {
			top: pe.t + topHeight + topSplitterThickness + "px",
			left: pe.l + leftWidth + leftSplitterThickness + "px",
			right: pe.r + rightWidth + rightSplitterThickness + "px",
			bottom: pe.b + bottomHeight + bottomSplitterThickness + "px"
		});

		var bounds = {
			top: sidebarLayout ? pe.t + "px" : centerStyle.top,
			bottom: sidebarLayout ? pe.b + "px" : centerStyle.bottom
		};
		dojo.mixin(leftStyle, bounds);
		dojo.mixin(rightStyle, bounds);
		leftStyle.left = pe.l + "px"; rightStyle.right = pe.r + "px"; topStyle.top = pe.t + "px"; bottomStyle.bottom = pe.b + "px";
		if(sidebarLayout){
			topStyle.left = bottomStyle.left = leftWidth + leftSplitterThickness + pe.l + "px";
			topStyle.right = bottomStyle.right = rightWidth + rightSplitterThickness + pe.r + "px";
		}else{
			topStyle.left = bottomStyle.left = pe.l + "px";
			topStyle.right = bottomStyle.right = pe.r + "px";
		}

		// More calculations about sizes of panes
		var containerHeight = this._borderBox.h - pe.t - pe.b,
			middleHeight = containerHeight - ( topHeight + topSplitterThickness + bottomHeight + bottomSplitterThickness),
			sidebarHeight = sidebarLayout ? containerHeight : middleHeight;

		var containerWidth = this._borderBox.w - pe.l - pe.r,
			middleWidth = containerWidth - (leftWidth + leftSplitterThickness + rightWidth + rightSplitterThickness),
			sidebarWidth = sidebarLayout ? middleWidth : containerWidth;

		// New margin-box size of each pane
		var dim = {
			top:	{ w: sidebarWidth, h: topHeight },
			bottom: { w: sidebarWidth, h: bottomHeight },
			left:	{ w: leftWidth, h: sidebarHeight },
			right:	{ w: rightWidth, h: sidebarHeight },
			center:	{ h: middleHeight, w: middleWidth }
		};

		// Nodes in IE<8 don't respond to t/l/b/r, and TEXTAREA doesn't respond in any browser
		var janky = dojo.isIE < 8 || (dojo.isIE && dojo.isQuirks) || dojo.some(this.getChildren(), function(child){
			return child.domNode.tagName == "TEXTAREA" || child.domNode.tagName == "INPUT";
		});
		if(janky){
			// Set the size of the children the old fashioned way, by setting
			// CSS width and height

			var resizeWidget = function(widget, changes, result){
				if(widget){
					(widget.resize ? widget.resize(changes, result) : dojo.marginBox(widget.domNode, changes));
				}
			};

			if(leftSplitter){ leftSplitter.style.height = sidebarHeight; }
			if(rightSplitter){ rightSplitter.style.height = sidebarHeight; }
			resizeWidget(this._leftWidget, {h: sidebarHeight}, dim.left);
			resizeWidget(this._rightWidget, {h: sidebarHeight}, dim.right);

			if(topSplitter){ topSplitter.style.width = sidebarWidth; }
			if(bottomSplitter){ bottomSplitter.style.width = sidebarWidth; }
			resizeWidget(this._topWidget, {w: sidebarWidth}, dim.top);
			resizeWidget(this._bottomWidget, {w: sidebarWidth}, dim.bottom);

			resizeWidget(this._centerWidget, dim.center);
		}else{
			// We've already sized the children by setting style.top/bottom/left/right...
			// Now just need to call resize() on those children telling them their new size,
			// so they can re-layout themselves

			// Calculate which panes need a notification
			var resizeList = {};
			if(changedRegion){
				resizeList[changedRegion] = resizeList.center = true;
				if(/top|bottom/.test(changedRegion) && this.design != "sidebar"){
					resizeList.left = resizeList.right = true;
				}else if(/left|right/.test(changedRegion) && this.design == "sidebar"){
					resizeList.top = resizeList.bottom = true;
				}
			}

			dojo.forEach(this.getChildren(), function(child){
				if(child.resize && (!changedRegion || child.region in resizeList)){
					child.resize(null, dim[child.region]);
				}
			}, this);
		}
	},

	destroy: function(){
		for(var region in this._splitters){
			var splitter = this._splitters[region];
			dijit.byNode(splitter).destroy();
			dojo.destroy(splitter);
		}
		delete this._splitters;
		delete this._splitterThickness;
		this.inherited(arguments);
	}
});

// This argument can be specified for the children of a BorderContainer.
// Since any widget can be specified as a LayoutContainer child, mix it
// into the base widget class.  (This is a hack, but it's effective.)
dojo.extend(dijit._Widget, {
	// region: [const] String
	//		Parameter for children of `dijit.layout.BorderContainer`.
	//		Values: "top", "bottom", "leading", "trailing", "left", "right", "center".
	//		See the `dijit.layout.BorderContainer` description for details.
	region: '',

	// splitter: [const] Boolean
	//		Parameter for child of `dijit.layout.BorderContainer` where region != "center".
	//		If true, enables user to resize the widget by putting a draggable splitter between
	//		this widget and the region=center widget.
	splitter: false,

	// minSize: [const] Number
	//		Parameter for children of `dijit.layout.BorderContainer`.
	//		Specifies a minimum size (in pixels) for this widget when resized by a splitter.
	minSize: 0,

	// maxSize: [const] Number
	//		Parameter for children of `dijit.layout.BorderContainer`.
	//		Specifies a maximum size (in pixels) for this widget when resized by a splitter.
	maxSize: Infinity
});



dojo.declare("dijit.layout._Splitter", [ dijit._Widget, dijit._Templated ],
{
	// summary:
	//		A draggable spacer between two items in a `dijit.layout.BorderContainer`.
	// description:
	//		This is instantiated by `dijit.layout.BorderContainer`.  Users should not
	//		create it directly.
	// tags:
	//		private

/*=====
 	// container: [const] dijit.layout.BorderContainer
 	//		Pointer to the parent BorderContainer
	container: null,

	// child: [const] dijit.layout._LayoutWidget
	//		Pointer to the pane associated with this splitter
	child: null,

	// region: String
	//		Region of pane associated with this splitter.
	//		"top", "bottom", "left", "right".
	region: null,
=====*/

	// live: [const] Boolean
	//		If true, the child's size changes and the child widget is redrawn as you drag the splitter;
	//		otherwise, the size doesn't change until you drop the splitter (by mouse-up)
	live: true,

	templateString: '<div class="dijitSplitter" dojoAttachEvent="onkeypress:_onKeyPress,onmousedown:_startDrag,onmouseenter:_onMouse,onmouseleave:_onMouse" tabIndex="0" waiRole="separator"><div class="dijitSplitterThumb"></div></div>',

	postCreate: function(){
		this.inherited(arguments);
		this.horizontal = /top|bottom/.test(this.region);
		dojo.addClass(this.domNode, "dijitSplitter" + (this.horizontal ? "H" : "V"));
//		dojo.addClass(this.child.domNode, "dijitSplitterPane");
//		dojo.setSelectable(this.domNode, false); //TODO is this necessary?

		this._factor = /top|left/.test(this.region) ? 1 : -1;

		this._cookieName = this.container.id + "_" + this.region;
		if(this.container.persist){
			// restore old size
			var persistSize = dojo.cookie(this._cookieName);
			if(persistSize){
				this.child.domNode.style[this.horizontal ? "height" : "width"] = persistSize;
			}
		}
	},

	_computeMaxSize: function(){
		// summary:
		//		Compute the maximum size that my corresponding pane can be set to

		var dim = this.horizontal ? 'h' : 'w',
			thickness = this.container._splitterThickness[this.region];
			
		// Get DOMNode of opposite pane, if an opposite pane exists.
		// Ex: if I am the _Splitter for the left pane, then get the right pane.
		var flip = {left:'right', right:'left', top:'bottom', bottom:'top', leading:'trailing', trailing:'leading'},
			oppNode = this.container["_" + flip[this.region]];
		
		// I can expand up to the edge of the opposite pane, or if there's no opposite pane, then to
		// edge of BorderContainer
		var available = dojo.contentBox(this.container.domNode)[dim] -
				(oppNode ? dojo.marginBox(oppNode)[dim] : 0) -
				20 - thickness * 2;

		return Math.min(this.child.maxSize, available);
	},

	_startDrag: function(e){
		if(!this.cover){
			this.cover = dojo.doc.createElement('div');
			dojo.addClass(this.cover, "dijitSplitterCover");
			dojo.place(this.cover, this.child.domNode, "after");
		}
		dojo.addClass(this.cover, "dijitSplitterCoverActive");

		// Safeguard in case the stop event was missed.  Shouldn't be necessary if we always get the mouse up.
		if(this.fake){ dojo.destroy(this.fake); }
		if(!(this._resize = this.live)){ //TODO: disable live for IE6?
			// create fake splitter to display at old position while we drag
			(this.fake = this.domNode.cloneNode(true)).removeAttribute("id");
			dojo.addClass(this.domNode, "dijitSplitterShadow");
			dojo.place(this.fake, this.domNode, "after");
		}
		dojo.addClass(this.domNode, "dijitSplitterActive");
		dojo.addClass(this.domNode, "dijitSplitter" + (this.horizontal ? "H" : "V") + "Active");
		if(this.fake){
			dojo.removeClass(this.fake, "dijitSplitterHover");
			dojo.removeClass(this.fake, "dijitSplitter" + (this.horizontal ? "H" : "V") + "Hover");
		}

		//Performance: load data info local vars for onmousevent function closure
		var factor = this._factor,
			max = this._computeMaxSize(),
			min = this.child.minSize || 20,
			isHorizontal = this.horizontal,
			axis = isHorizontal ? "pageY" : "pageX",
			pageStart = e[axis],
			splitterStyle = this.domNode.style,
			dim = isHorizontal ? 'h' : 'w',
			childStart = dojo.marginBox(this.child.domNode)[dim],
			region = this.region,
			splitterStart = parseInt(this.domNode.style[region], 10),
			resize = this._resize,
			mb = {},
			childNode = this.child.domNode,
			layoutFunc = dojo.hitch(this.container, this.container._layoutChildren),
			de = dojo.doc.body;

		this._handlers = (this._handlers || []).concat([
			dojo.connect(de, "onmousemove", this._drag = function(e, forceResize){
				var delta = e[axis] - pageStart,
					childSize = factor * delta + childStart,
					boundChildSize = Math.max(Math.min(childSize, max), min);

				if(resize || forceResize){
					mb[dim] = boundChildSize;
					// TODO: inefficient; we set the marginBox here and then immediately layoutFunc() needs to query it
					dojo.marginBox(childNode, mb);
					layoutFunc(region);
				}
				splitterStyle[region] = factor * delta + splitterStart + (boundChildSize - childSize) + "px";
			}),
			dojo.connect(dojo.doc, "ondragstart", dojo.stopEvent),
			dojo.connect(dojo.body(), "onselectstart", dojo.stopEvent),
			dojo.connect(de, "onmouseup", this, "_stopDrag")
		]);
		dojo.stopEvent(e);
	},

	_onMouse: function(e){
		var o = (e.type == "mouseover" || e.type == "mouseenter");
		dojo.toggleClass(this.domNode, "dijitSplitterHover", o);
		dojo.toggleClass(this.domNode, "dijitSplitter" + (this.horizontal ? "H" : "V") + "Hover", o);
	},

	_stopDrag: function(e){
		try{
			if(this.cover){
				dojo.removeClass(this.cover, "dijitSplitterCoverActive");
			}
			if(this.fake){ dojo.destroy(this.fake); }
			dojo.removeClass(this.domNode, "dijitSplitterActive");
			dojo.removeClass(this.domNode, "dijitSplitter" + (this.horizontal ? "H" : "V") + "Active");
			dojo.removeClass(this.domNode, "dijitSplitterShadow");
			this._drag(e); //TODO: redundant with onmousemove?
			this._drag(e, true);
		}finally{
			this._cleanupHandlers();
			delete this._drag;
		}

		if(this.container.persist){
			dojo.cookie(this._cookieName, this.child.domNode.style[this.horizontal ? "height" : "width"], {expires:365});
		}
	},

	_cleanupHandlers: function(){
		dojo.forEach(this._handlers, dojo.disconnect);
		delete this._handlers;
	},

	_onKeyPress: function(/*Event*/ e){
		// should we apply typematic to this?
		this._resize = true;
		var horizontal = this.horizontal;
		var tick = 1;
		var dk = dojo.keys;
		switch(e.charOrCode){
			case horizontal ? dk.UP_ARROW : dk.LEFT_ARROW:
				tick *= -1;
//				break;
			case horizontal ? dk.DOWN_ARROW : dk.RIGHT_ARROW:
				break;
			default:
//				this.inherited(arguments);
				return;
		}
		var childSize = dojo.marginBox(this.child.domNode)[ horizontal ? 'h' : 'w' ] + this._factor * tick;
		var mb = {};
		mb[ this.horizontal ? "h" : "w"] = Math.max(Math.min(childSize, this._computeMaxSize()), this.child.minSize);
		dojo.marginBox(this.child.domNode, mb);
		this.container._layoutChildren(this.region);
		dojo.stopEvent(e);
	},

	destroy: function(){
		this._cleanupHandlers();
		delete this.child;
		delete this.container;
		delete this.cover;
		delete this.fake;
		this.inherited(arguments);
	}
});

dojo.declare("dijit.layout._Gutter", [dijit._Widget, dijit._Templated ],
{
	// summary:
	// 		Just a spacer div to separate side pane from center pane.
	//		Basically a trick to lookup the gutter/splitter width from the theme.
	// description:
	//		Instantiated by `dijit.layout.BorderContainer`.  Users should not
	//		create directly.
	// tags:
	//		private

	templateString: '<div class="dijitGutter" waiRole="presentation"></div>',

	postCreate: function(){
		this.horizontal = /top|bottom/.test(this.region);
		dojo.addClass(this.domNode, "dijitGutter" + (this.horizontal ? "H" : "V"));
	}
});

}

if(!dojo._hasResource["dijit.ToolbarSeparator"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.ToolbarSeparator"] = true;
dojo.provide("dijit.ToolbarSeparator");




dojo.declare("dijit.ToolbarSeparator",
		[ dijit._Widget, dijit._Templated ],
		{
		// summary:
		//		A spacer between two `dijit.Toolbar` items
		templateString: '<div class="dijitToolbarSeparator dijitInline"></div>',
		postCreate: function(){ dojo.setSelectable(this.domNode, false); },
		isFocusable: function(){
			// summary:
			//		This widget isn't focusable, so pass along that fact.
			// tags:
			//		protected
			return false;
		}

	});



}

if(!dojo._hasResource["dijit.Toolbar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Toolbar"] = true;
dojo.provide("dijit.Toolbar");





dojo.declare("dijit.Toolbar",
	[dijit._Widget, dijit._Templated, dijit._KeyNavContainer],
	{
	// summary:
	//		A Toolbar widget, used to hold things like `dijit.Editor` buttons

	templateString:
		'<div class="dijit dijitToolbar" waiRole="toolbar" tabIndex="${tabIndex}" dojoAttachPoint="containerNode">' +
		//	'<table style="table-layout: fixed" class="dijitReset dijitToolbarTable">' + // factor out style
		//		'<tr class="dijitReset" dojoAttachPoint="containerNode"></tr>'+
		//	'</table>' +
		'</div>',

	postCreate: function(){
		this.connectKeyNavHandlers(
			this.isLeftToRight() ? [dojo.keys.LEFT_ARROW] : [dojo.keys.RIGHT_ARROW],
			this.isLeftToRight() ? [dojo.keys.RIGHT_ARROW] : [dojo.keys.LEFT_ARROW]
		);
	},

	startup: function(){
		if(this._started){ return; }

		this.startupKeyNavChildren();

		this.inherited(arguments);
	}
}
);

// For back-compat, remove for 2.0


}

if(!dojo._hasResource["dijit.dijit"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.dijit"] = true;
dojo.provide("dijit.dijit");

/*=====
dijit.dijit = {
	// summary:
	//		A roll-up for common dijit methods
	// description:
	//	A rollup file for the build system including the core and common
	//	dijit files.
	//
	// example:
	// | <script type="text/javascript" src="js/dojo/dijit/dijit.js"></script>
	//
};
=====*/

// All the stuff in _base (these are the function that are guaranteed available without an explicit dojo.require)


// And some other stuff that we tend to pull in all the time anyway







}

if(!dojo._hasResource["xwt.widget.toolbar.Toolbar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.toolbar.Toolbar"] = true;
/*******************************************************************   
 *        Copyright (c) 2009-2011 Cisco Systems, Inc.   
 *        All rights reserved.   
 *  
 * @fileoverview 
 * The xwt.widget.toolbar.Toolbar is an extension of dijit.Toolbar. 
 * @author Jeff Hu jefhu@cisco.com
 */
dojo.provide("xwt.widget.toolbar.Toolbar");




//dojo.require("xwt.widget.MessageBox");


dojo.declare("xwt.widget.toolbar.Toolbar", [dijit.Toolbar], {
	// summary:
    //     xwt.widget.toolbar.Toolbar
    // description:
    //  Extends from dijit.Toolbar. It manages toolbar items.  It has an 
    // 	enhanced API to prevent adding existing items, deleting non-existent items, etc.
	//     
    // example:
    // 
    // | var toolbar = new xwt.widget.toolbar.Toolbar();
    // | toobar.addChild(new xwt.widget.form.TextButton({"label":"hello"});
    
    showError:function (/* String */ errormessage){
		// summary:
        //   Show an alert to indicate an error occurred.
        alert (errormessage);
	},
	
	getItemAt: function(/* Integer */index){
        // summary:
        //    Returns the item at the given index.
        var children = this.getChildren();
        if (children && children.length > 0) {
            return children[index];
        }
        
        return null;
    },

	isChild: function(/*Widget*/ w){
		// summary: 
        //    Check if the given widget is a child of ButtonGroup.
        var o = this.getChild(w);
        if (o) {
        	return true;
        }else{
        	return false;
        }
	},
	
	isExist: function(/*Widget*/ o){
		// summary: 
        //    Helper function to check if the given object "o" is null.
		if (o) {
        	return true;
		}else{
        	return false;
		}
	},
	
	
	getChild: function(/*Widget*/ w){
		// summary: 
        //    Search if the given widget "w" is a child of ButtonGroup.
		var children = this.getChildren();
		var obj = null;
		for (var i=0;i<children.length;i++){
			if (children[i]==w){
				obj=children[i];
				break;
			}
		}
		return obj;
	},
	
    update:function(button, attributeName, attributeValue){
		// summary: 
        // Update the button's attribute.
		
		 if (this.isChild(button)){
				if (button instanceof dijit.form.Button){
					button.attr(attributeName,  attributeValue);
				}else{
					this.showError("Widget Error occurred! Can not update " );
				}
			}			
			else{
				this.showError("Widget Error occurred! Widget " + button + " not child of toolbar " );
			}
	},
	
	enableButton:function(/*Widget*/ button, /*boolean*/ disabled){
		// summary: 
        // Enable or disable the button.
        if (this.isChild(button)){
			if (button instanceof dijit.form.Button){
				button.attr("disabled",  disabled);
			}else{
				this.showError("Widget Error occurred! Cannot update " );
			}
		}			
		else{
			this.showError("Widget Error occurred! Widget " + button + " not already exists " );
		}
	},
	
	updateChildButtonIcon:function(/*Button*/ button, /*String*/ iconClassString){
		// summary: 
        // Update an existing child button's icon.
    	if (this.isChild(button)){
			if (button instanceof dijit.form.Button){
				button.attr("iconClass",  iconClassString);
			}else{
				this.showError("Widget Error occurred! Cannot update " );
			}
		}			
		else{
			this.showError("Widget Error occurred! Widget " + button + " not already exists " );
		}
	},
	
	updateChildButtonText:function (/*Button */ button, /*String */ labeltext){
		// summary: 
        // Update an existing child button's text.
		if (this.isChild(button)){
			if (button instanceof dijit.form.Button){
				button.attr("label", labeltext);
			}else{
				this.showError("Widget Error occurred! Can not update " );
			}
		}			
		else{
			this.showError("Widget Error occurred! Widget " + button + " not already exists " );
		}
	},
	
	switchChildButtonText:function (/*Button */ button, /*Boolean*/ on){
		// summary: 
        //   Toggle the display of an existing child button's text.
        if (this.isChild(button)){
			if (button instanceof dijit.form.Button){
				button.showLabel=on;	
				//button.attr("showLabel", on);
				if(!on){
					dojo.byId(button.id + '_label').style.visibility = 'hidden';
					dojo.addClass(dojo.byId(button.id + '_label'), "dijitDisplayNone");
				}else{				
					dojo.byId(button.id + '_label').style.visibility = 'visible';
					dojo.removeClass(dojo.byId(button.id + '_label'), "dijitDisplayNone");
				}

			}else{
				this.showError("Widget Error occurred! Can not update " );
			}
		}			
		else{
			this.showError("Widget Error occurred! Widget " + button + " not already exists " );
		}
	},
	
	removeChild: function(/*Widget*/ w){
		// summary: 
        //    Remove a child widget if it exists.
		try
		  {
			var b = this.isChild(w);
			if (b){
				this.inherited(arguments);
			}else{
				this.showError("Widget Error occurred! Widget " +  w + " not already exists " );
			}
		  }
		catch(err)
		  {
			this.showError("Widget Error occurred! " + err);
		  }
    },
    
    checkBeforeAdd:function(/*Widget*/ w){
    // summary:
    //This is an API hook. App should overwrite this method to check if input widget is allowed to add in this toolbar    
    	return true;
    },
	
	addChild: function(/*Widget*/ w, /*Integer*/ i){
    	// summary: 
        //    Add a child widget if it does not already exist.
		try
		  {
			var b = this.isChild(w);
			if (!b){
				if (this.checkBeforeAdd(w))
					this.inherited(arguments);
				else{
					this.showError(this.declaredClasss + " input widget " + w + " is not allowed to add in  " );		
				}
			}else{
				this.showError("Widget Error occurred! Widget " +  w + " already exists " );
			}
		  }
		catch(err)
		  {
			this.showError("Widget Error occurred! " + err);
		  }
    }
});

}

if(!dojo._hasResource["xwt.widget.form.TextButtonGroup"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.form.TextButtonGroup"] = true;
/* ************************************************** */
/* Copyright (c) 2009-2011 Cisco Systems, Inc.       */
/* All rights reserved.                               */
/* ************************************************** */ 

/**
 * @fileoverview 
 * The xwt.widget.form.TextButtonGroup is an extension of the existing xwt.widget.toolbar.Toolbar.
 * There are no added functions; the extension is compliant with the Cisco UX specification. 
 *   
 *
 * @author Jeff Hu  jefhu@cisco.com
 *
 * @version 0.1 
 */
dojo.provide("xwt.widget.form.TextButtonGroup");






dojo.declare("xwt.widget.form.TextButtonGroup", [xwt.widget.toolbar.Toolbar], {
	// Summary:
	// 		This widget extends xwt.widget.toolbar.Toolbar. It manages multiple TextButtons 
	//		as a group. There are no additional APIs.
	
	//description:
	// This widget is like a toolbar. It manages Text buttons and keeps a 5px margin between buttons, per the Cisco UX specification.
	
	// example:
	//	|		var layoutToolbar2 = new xwt.widget.form.TextButtonGroup({id:"layoutToobar2" ,style:"width: 300px;"}).placeAt(dojo.byId("toolbar2"));
	//	|		
	//	|		
    //	|       layoutToolbar2.addChild(new xwt.widget.form.TextButton({id: "id-l1", label: "Yes", baseClass:"defaultButton"}));
    //	|       layoutToolbar2.addChild(new xwt.widget.form.TextButton({id: "id-l2", label: "No"}));
	//	|		layoutToolbar2.addChild(new xwt.widget.form.TextButton({id: "id-l3", label: "Cancel"}));       
	//	|		layoutToolbar2.startup();
	//  |
	//
	//example:
	//	|<div dojoType="xwt.widget.form.TextButtonGroup" jsId="tb1" id="toolbar1" style="width: 500px;"> 
	//	|	<button dojoType="xwt.widget.form.TextButton" style="margin-right:100px;" id="toolbar1-first" baseClass="defaultButton" onClick="alert(this.label)">Item1</button>
	//	|	<button dojoType="xwt.widget.form.TextButton" id="toolbar1-second" onClick="alert(this.label)">Item2</button>
	//	|	<button dojoType="xwt.widget.form.TextButton" id="toolbar1-third" onClick="alert(this.label)">Item3</button>
	//	|	<button dojoType="xwt.widget.form.TextButton" id="toolbar1-diabled" tabindex="4" disabled>Disabled</button>
	//	|	<button dojoType="xwt.widget.form.TextButton" id="toolbar1-4" baseClass="defaultButton" >Item4</button>
	//	|</div>
	
	//set baseClass name;
	baseClass: "xwtTextButtonGroup",
	
	
	postCreate: function(){
	// summary:
	// Overwrite api.  Set name-space to "xwtTextButtonGroup". So that see textbuttongroup.css  
        this.inherited(arguments);
        dojo.addClass(this.domNode, "xwtTextButtonGroup");
	}
});

}

if(!dojo._hasResource["xwt.widget.util"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.util"] = true;
/******************************************************************************
 *        Copyright (c) 2009-2011 Cisco Systems, Inc.   
 *        All rights reserved.   
 * 
 * @fileoverview 
 * The util is general utility class for xwt widgets.
 *  
 * @author Dennis Park denpark@cisco.com
******************************************************************************/
dojo.provide("xwt.widget.util");



//  Fix for defect #CSCti55382
//  See:  https://support.sitepen.com/issues/20796
xwtPopups = {
		closePopupSuspended: false,
		previousSuspensionValue: -1,
		
	    restorePopups: function(){
	            // Renables the the closing of popups  
	            this.closePopupSuspended = false;
	            this.suspendedZIndex = this.previousSuspensionValue;

	    },
	    //suspendPopups tells poups with a zIndex less that
	    // passed value to stay open, those above can close. 

	    suspendPopups: function(zIndex) {
	    	
	    	if(parseFloat(zIndex) <=parseFloat(this.suspendedZIndex)){
	    		return;
	    	}
	    	
	    		this.previousSuspensionValue = this.suspendedZIndex;
	            this.suspendedZIndex = zIndex;

	            if(this.closePopupSuspended ) {
	                    //If we modify the function twice the
	                    // original popup function will be gone for good
	                    return;
	            }

	            // Will suspend the the closing of popups
	            this.closePopupSuspended = true;
	            
	    },

	    popupsSuspended: function(zIndex) {
            // checks the status of suspension so that popups can check to see if they
            // should close or not. 
            // checks the status of suspension so that popups can check to see if they
            if(parseFloat(zIndex) > parseFloat(this.suspendedZIndex)) {
            	return false;
    	    }
            return this.closePopupSuspended ;
	    }
};


//xwtAnchoredOverlayManager = {
//		openedAOid: null,
//		
//		aoClosed: function(_id){
//			openedAOid = null;
//			
//		},
//		
//		aoOpened: function(_id){
//			
//			if(_id === this.openedAOid) return;
//			
//			// first close current.
//			dijit.byId(this.openedAOid).closeDropDown();
//			
//			//	set newly opened id
//			if(_id){
//				this.openedAOid = _id;
//			}
//		},
//		
//		getCurrentlyOpenedAOid: function(){
//			return this.openedAOid;
//		}
//		
//			
//};

//xwtPopups = {
//		closePopupSuspended: false,
//		previousSuspensionValue: -1,
//		
//	    restorePopups: function(){	        
//	    },
//	    //suspendPopups tells poups with a zIndex less that
//	    // passed value to stay open, those above can close. 
//
//	    suspendPopups: function(zIndex) {   	
//	    },
//
//	    popupsSuspended: function(zIndex) {
//           return false;
//	    }
//};

}

if(!dojo._hasResource["xwt.widget.dijit"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.dijit"] = true;
dojo.provide("xwt.widget.dijit");





if(dojo.isIE){
	console.log("patching registerWin");
	
	// dijit._base.focus patches:
	dojo.mixin(dijit, {
		registerWin: function(/*Window?*/targetWindow, /*DomNode?*/ effectiveNode){
			console.log("patched registerWin");
	
			// summary:
			//		Registers listeners on the specified window (either the main
			//		window or an iframe's window) to detect when the user has clicked somewhere
			//		or focused somewhere.
			// description:
			//		Users should call registerIframe() instead of this method.
			// targetWindow:
			//		If specified this is the window associated with the iframe,
			//		i.e. iframe.contentWindow.
			// effectiveNode:
			//		If specified, report any focus events inside targetWindow as
			//		an event on effectiveNode, rather than on evt.target.
			// returns:
			//		Handle to pass to unregisterWin()
	
			// TODO: make this function private in 2.0; Editor/users should call registerIframe(),
	
			var mousedownListener = function(evt){
				dijit._justMouseDowned = true;
				setTimeout(function(){ dijit._justMouseDowned = false; }, 0);
	
				// workaround weird IE bug where the click is on an orphaned node
				// (first time clicking a Select/DropDownButton inside a TooltipDialog)
				if(dojo.isIE && evt && evt.srcElement && evt.srcElement.parentNode == null){
					return;
				}
	
				dijit._onTouchNode(effectiveNode || evt.target || evt.srcElement, "mouse");
			};
			//dojo.connect(targetWindow, "onscroll", ???);
	
			// Listen for blur and focus events on targetWindow's document.
			// IIRC, I'm using attachEvent() rather than dojo.connect() because focus/blur events don't bubble
			// through dojo.connect(), and also maybe to catch the focus events early, before onfocus handlers
			// fire.
			// Connect to <html> (rather than document) on IE to avoid memory leaks, but document on other browsers because
			// (at least for FF) the focus event doesn't fire on <html> or <body>.
			var doc = dojo.isIE ? targetWindow.document.documentElement : targetWindow.document;
			if(doc){
				if(dojo.isIE){
					doc.attachEvent('onmousedown', mousedownListener);
					var activateListener = function(evt){
						// IE reports that nodes like <body> have gotten focus, even though they have tabIndex=-1,
						// Should consider those more like a mouse-click than a focus....
						if(evt.srcElement.tagName.toLowerCase() != "#document" &&
							dijit.isTabNavigable(evt.srcElement)){
							dijit._onFocusNode(effectiveNode || evt.srcElement);
						}else{
							// active widgets on the stack
							if(! dijit._pendingActiveWidgetsCount ) {
								dijit._onTouchNode(effectiveNode || evt.srcElement, "activate");
							} else {
							}
						}
					};
					doc.attachEvent('onactivate', activateListener);
					var deactivateListener =  function(evt){
						dijit._onBlurNode(effectiveNode || evt.srcElement);
					};
					doc.attachEvent('ondeactivate', deactivateListener);
	
					return function(){
						doc.detachEvent('onmousedown', mousedownListener);
						doc.detachEvent('onactivate', activateListener);
						doc.detachEvent('ondeactivate', deactivateListener);
						doc = null;	// prevent memory leak (apparent circular reference via closure)
					};
				}else{
					doc.addEventListener('mousedown', mousedownListener, true);
					var focusListener = function(evt){
						dijit._onFocusNode(effectiveNode || evt.target);
					};
					doc.addEventListener('focus', focusListener, true);
					var blurListener = function(evt){
						dijit._onBlurNode(effectiveNode || evt.target);
					};
					doc.addEventListener('blur', blurListener, true);
	
					return function(){
						doc.removeEventListener('mousedown', mousedownListener, true);
						doc.removeEventListener('focus', focusListener, true);
						doc.removeEventListener('blur', blurListener, true);
						doc = null;	// prevent memory leak (apparent circular reference via closure)
					};
				}
			}
		},
		
		_onTouchNode: function(/*DomNode*/ node, /*String*/ by){
			// summary:
			//		Callback when node is focused or mouse-downed
			// node:
			//		The node that was touched.
			// by:
			//		"mouse" if the focus/touch was caused by a mouse down event
	
			// ignore the recent blurNode event
			if(dijit._clearActiveWidgetsTimer){
				clearTimeout(dijit._clearActiveWidgetsTimer);
				delete dijit._clearActiveWidgetsTimer;
			}
	
			// compute stack of active widgets (ex: ComboButton --> Menu --> MenuItem)
			var newStack=[];
			try{
				while(node){
					var popupParent = dojo.attr(node, "dijitPopupParent");
					if(popupParent){
						node=dijit.byId(popupParent).domNode;
					}else if(node.tagName && node.tagName.toLowerCase() == "body"){
						// is this the root of the document or just the root of an iframe?
						if(node === dojo.body()){
							// node is the root of the main document
							break;
						}
						// otherwise, find the iframe this node refers to (can't access it via parentNode,
						// need to do this trick instead). window.frameElement is supported in IE/FF/Webkit
						node=dijit.getDocumentWindow(node.ownerDocument).frameElement;
					}else{
						// if this node is the root node of a widget, then add widget id to stack,
						// except ignore clicks on disabled widgets (actually focusing a disabled widget still works,
						// to support MenuItem)
						var id = node.getAttribute && node.getAttribute("widgetId"),
							widget = id && dijit.byId(id);
						if(widget && !(by == "mouse" && widget.attr("disabled"))){
							newStack.unshift(id);
						}
						node=node.parentNode;
					}
				}
			}catch(e){ /* squelch */ }
	
			if(by && by == "activate" && !newStack.length) {
			} else {
				dijit._setStack(newStack, by);
			}
		},
	
		_setStack: function(/*String[]*/ newStack, /*String*/ by){
			// summary:
			//		The stack of active widgets has changed.  Send out appropriate events and records new stack.
			// newStack:
			//		array of widget id's, starting from the top (outermost) widget
			// by:
			//		"mouse" if the focus/touch was caused by a mouse down event
	
			var oldStack = dijit._activeStack;
			dijit._activeStack = newStack;
	
			// compare old stack to new stack to see how many elements they have in common
			for(var nCommon=0; nCommon<Math.min(oldStack.length, newStack.length); nCommon++){
				if(oldStack[nCommon] != newStack[nCommon]){
					break;
				}
			}
	
			var widget;
			// for all elements that have gone out of focus, send blur event
			for(var i=oldStack.length-1; i>=nCommon; i--){
				widget = dijit.byId(oldStack[i]);
				if(widget){
					widget._focused = false;
					widget._hasBeenBlurred = true;
					// in case oldStack [ a, b, c, d, e] and newStack [a, b, d, f, e]  ==> e, d should not be blur-out
					var boolWidgetStillInNewStack = (dojo.indexOf(newStack, widget.id)>-1);
					if (boolWidgetStillInNewStack)
						break;
					if(widget._onBlur){
						// temp flag to let IE know we're in the middle of setStack
						this._pendingActiveWidgetsCount = i - nCommon;
						// debug tip here -- compare oldStack and newStack content
						widget._onBlur(by);
						
					}
					if(widget._setStateClass){
						widget._setStateClass();
					}
					dojo.publish("widgetBlur", [widget, by]);
				}
			}
			delete this._pendingActiveWidgetsCount;
			
			// for all element that have come into focus, send focus event
			for(i=nCommon; i<newStack.length; i++){
				widget = dijit.byId(newStack[i]);
				if(widget){
					widget._focused = true;
					if(widget._onFocus){
						widget._onFocus(by);
					}
					if(widget._setStateClass){
						widget._setStateClass();
					}
					dojo.publish("widgetFocus", [widget, by]);
				}
			}
		}
		
	});
	// /dijit._base.focus patches
	
	console.log("re-defining dijit popup in patches.dijit.popup");
	// dijit._base.poupup patches:
	dijit.popup = {
		// summary:
		//		This singleton is used to show/hide widgets as popups.
	
		// _stack: dijit._Widget[]
		//		Stack of currently popped up widgets.
		//		(someone opened _stack[0], and then it opened _stack[1], etc.)
		_stack: [],
		
		// _beginZIndex: Number
		//		Z-index of the first popup.   (If first popup opens other
		//		popups they get a higher z-index.)
		_beginZIndex: 1000,
	
		_idGen: 1,
	
		moveOffScreen: function(/*DomNode*/ node){
			// summary:
			//		Initialization for nodes that will be used as popups
			//
			// description:
			//		Puts node inside a wrapper <div>, and
			//		positions wrapper div off screen, but not display:none, so that
			//		the widget doesn't appear in the page flow and/or cause a blank
			//		area at the bottom of the viewport (making scrollbar longer), but
			//		initialization of contained widgets works correctly
	
			var wrapper = node.parentNode;
	
			// Create a wrapper widget for when this node (in the future) will be used as a popup.
			// This is done early because of IE bugs where creating/moving DOM nodes causes focus
			// to go wonky, see tests/robot/Toolbar.html to reproduce
			if(!wrapper || !dojo.hasClass(wrapper, "dijitPopup")){
				wrapper = dojo.create("div",{
					"class":"dijitPopup",
					style:{
						visibility:"hidden",
						top: "-9999px"
					}
				}, dojo.body());
				dijit.setWaiRole(wrapper, "presentation");
				wrapper.appendChild(node);
			}
	
	
			var s = node.style;
			s.display = "";
			s.visibility = "";
			s.position = "";
			s.top = "0px";
	
			dojo.style(wrapper, {
				visibility: "hidden",
				// prevent transient scrollbar causing misalign (#5776), and initial flash in upper left (#10111)
				top: "-9999px",
				left: ""
			});
		},
	
		getTopPopup: function(){
			// summary:
			//		Compute the closest ancestor popup that's *not* a child of another popup.
			//		Ex: For a TooltipDialog with a button that spawns a tree of menus, find the popup of the button.
			console.log("re-defined getTopPopup");
	
			var stack = this._stack;
			for(var pi=stack.length-1; pi > 0 && stack[pi].parent === stack[pi-1].widget; pi--){
				/* do nothing, just trying to get right value for pi */
			}
			return stack[pi];
		},
	
		open: function(/*dijit.popup.__OpenArgs*/ args){
			// summary:
			//		Popup the widget at the specified position
			//
			// example:
			//		opening at the mouse position
			//		|		dijit.popup.open({popup: menuWidget, x: evt.pageX, y: evt.pageY});
			//
			// example:
			//		opening the widget as a dropdown
			//		|		dijit.popup.open({parent: this, popup: menuWidget, around: this.domNode, onClose: function(){...}});
			//
			//		Note that whatever widget called dijit.popup.open() should also listen to its own _onBlur callback
			//		(fired from _base/focus.js) to know that focus has moved somewhere else and thus the popup should be closed.
	
			console.log("re-defined popup.open");
			var stack = this._stack,
				widget = args.popup,
				orient = args.orient || (
					(args.parent ? args.parent.isLeftToRight() : dojo._isBodyLtr()) ?
					{'BL':'TL', 'BR':'TR', 'TL':'BL', 'TR':'BR'} :
					{'BR':'TR', 'BL':'TL', 'TR':'BR', 'TL':'BL'}
				),
				around = args.around,
				id = (args.around && args.around.id) ? (args.around.id+"_dropdown") : ("popup_"+this._idGen++);
	
	
			// The wrapper may have already been created, but in case it wasn't, create here
			var wrapper = widget.domNode.parentNode;
			if(!wrapper || !dojo.hasClass(wrapper, "dijitPopup")){
				this.moveOffScreen(widget.domNode);
				wrapper = widget.domNode.parentNode;
			}
	
			dojo.attr(wrapper, {
				id: id,
				style: {
					zIndex: this._beginZIndex + stack.length
				},
				"class": "dijitPopup " + (widget.baseClass || widget["class"] || "").split(" ")[0] +"Popup",
				dijitPopupParent: args.parent ? args.parent.id : ""
			});
	
			if(dojo.isIE || dojo.isMoz){
				var iframe = wrapper.childNodes[1];
				if(!iframe){
					iframe = new dijit.BackgroundIframe(wrapper);
					var cleanup = dojo.connect(widget, "destroy", this, function(){
						dojo.disconnect(cleanup);
						iframe.destroy();
						dojo.destroy(wrapper);
					});
				}
			}
	
			// position the wrapper node and make it visible
			var best = around ?
				dijit.placeOnScreenAroundElement(wrapper, around, orient, widget.orient ? dojo.hitch(widget, "orient") : null) :
				dijit.placeOnScreen(wrapper, args, orient == 'R' ? ['TR','BR','TL','BL'] : ['TL','BL','TR','BR'], args.padding);
	
			wrapper.style.visibility = "visible";
			widget.domNode.style.visibility = "visible";	// counteract effects from _HasDropDown
	
			var handlers = [];
	
			// provide default escape and tab key handling
			// (this will work for any widget, not just menu)
			handlers.push(dojo.connect(wrapper, "onkeypress", this, function(evt){
				if(evt.charOrCode == dojo.keys.ESCAPE && args.onCancel){
					dojo.stopEvent(evt);
					args.onCancel();
				}else if(evt.charOrCode === dojo.keys.TAB){
					dojo.stopEvent(evt);
					var topPopup = this.getTopPopup();
					if(topPopup && topPopup.onCancel){
						topPopup.onCancel();
					}
				}
			}));
	
			// watch for cancel/execute events on the popup and notify the caller
			// (for a menu, "execute" means clicking an item)
			if(widget.onCancel){
				handlers.push(dojo.connect(widget, "onCancel", args.onCancel));
			}
	
			handlers.push(dojo.connect(widget, widget.onExecute ? "onExecute" : "onChange", this, function(){
				var topPopup = this.getTopPopup();
				if(topPopup && topPopup.onExecute){
					topPopup.onExecute();
				}
			}));
	
			stack.push({
				wrapper: wrapper,
				iframe: iframe,
				widget: widget,
				parent: args.parent,
				onExecute: args.onExecute,
				onCancel: args.onCancel,
	 			onClose: args.onClose,
				handlers: handlers
			});
	
			if(widget.onOpen){
				// TODO: in 2.0 standardize onShow() (used by StackContainer) and onOpen() (used here)
				widget.onOpen(best);
			}
	
			return best;
		},
	
		close: function(/*dijit._Widget*/ popup){
			// summary:
			//		Close specified popup and any popups that it parented
	
			var stack = this._stack;
	
			// Basically work backwards from the top of the stack closing popups
			// until we hit the specified popup, but IIRC there was some issue where closing
			// a popup would cause others to close too.  Thus if we are trying to close B in [A,B,C]
			// closing C might close B indirectly and then the while() condition will run where stack==[A]...
			// so the while condition is constructed defensively.
			while(dojo.some(stack, function(elem){return elem.widget == popup;})){
				var top = stack.pop(),
					wrapper = top.wrapper,
					iframe = top.iframe,
					widget = top.widget,
					onClose = top.onClose;
	
				if(widget.onClose){
					// TODO: in 2.0 standardize onHide() (used by StackContainer) and onClose() (used here)
					widget.onClose();
				}
				dojo.forEach(top.handlers, dojo.disconnect);
	
				// Move the widget plus it's wrapper off screen, unless it has already been destroyed in above onClose() etc.
				if(widget && widget.domNode){
					this.moveOffScreen(widget.domNode);
				}else{
					dojo.destroy(wrapper);
				}
	                        
				if(onClose){
					onClose();
				}
			}
		}
	};
	// /dijit._base.poupup patches
	
	// dijit._hasDropDown patches
	console.log("extending dijit._hasDropDown");
	
	dojo.extend(dijit._HasDropDown, {
		_onBlur: function(){
			console.log("dijit._hasDropDown _onBlur override");
			// summary:
			//		Called magically when focus has shifted away from this widget and it's dropdown
	
			var focusMe = dijit._curFocus && this.dropDown && dojo.isDescendant(dijit._curFocus, this.dropDown.domNode);
			this.closeDropDown(focusMe);
			// don't focus on button.  the user has explicitly focused on something else.
			this.inherited("_onBlur", arguments); // original sitepen - this.inherited(arguments);
			
		},
		closeDropDown: function(/*Boolean*/ focus){
			console.log("dijit._hasDropDown closeDropDown override");
			// summary:
			//		Closes the drop down on this widget
			// tags:
			//		protected
	
			if(this._opened){
				if(focus){ 
					this.focus(); 
				}
				dijit.popup.close(this.dropDown);
				this._opened = false;
				this.state = "";
			}
		}
	});
	// dijit._hasDropDown patches
	
	// dijit.Menu patches:
	console.log("extending dijit.Menu");
	dojo.extend(dijit.Menu, {
		_closeChild: function(){
			// summary:
			//		Called when submenu is clicked or focus is lost.  Close hierarchy of menus.
			// tags:
			//		private
			this._stopPopupTimer();
			var fromItem = this.focusedChild && this.focusedChild.from_item; 
	
			if(this.currentPopup){ 
					// If focus is on my child menu then move focus to me, 
					// because IE doesn't like it when you display:none a node with focus 
					if(dijit._curFocus && dojo.isDescendant(dijit._curFocus, this.currentPopup.domNode)){ 
							this.focusedChild.focusNode.focus(); 
					} 
					console.log(this.id + " Menu _closeChild, closing " + this.currentPopup.id);
					// Close all popups that are open and descendants of this menu 
					dijit.popup.close(this.currentPopup); 
					this.currentPopup = null; 
			} 
	
			if(this.focusedChild){ // unhighlight the focused item
				this.focusedChild._setSelected(false);
				this.focusedChild._onUnhover();
				this.focusedChild = null;
			}
			if(this.currentPopup){
				// Close all popups that are open and descendants of this menu
				dijit.popup.close(this.currentPopup);
				this.currentPopup = null;
			}
		}
	});
	// /dijit.Menu patches
}

}

if(!dojo._hasResource["xwt.widget._ZIndexMixinHelper"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget._ZIndexMixinHelper"] = true;
/* ************************************************** */
/* Copyright (c) 2009-2011 Cisco Systems, Inc.       */
/* All rights reserved.                               */
/* ************************************************** */
/**
 * @author nbhattac
 */

dojo.provide("xwt.widget._ZIndexMixinHelper");


dojo.declare("xwt.widget.Layer", null, {

	constructor : function(args) {
		dojo.mixin(this, args);
	}
});

// internal utility classes


( function() {
	layers = new dojox.collections.Dictionary();
	widgetToLayersMap = new dojox.collections.Dictionary();
	var zIndexPrefix = dojo.config.zIndexPrefix ? parseInt(dojo.config.zIndexPrefix) : 0;
	layers.add('1', new xwt.widget.Layer( {
		id : 1,
		start : zIndexPrefix + 1000,
		end : zIndexPrefix + 2000,
		currentMaxIndex : zIndexPrefix + 1001
	}));

	layers.add('2', new xwt.widget.Layer( {
		id : 2,
		start : zIndexPrefix + 3000,
		end : zIndexPrefix + 4000,
		currentMaxIndex : zIndexPrefix + 3001
	}));
	// reserved for notification layers only
	layers.add('3', new xwt.widget.Layer( {
		id : 1,
		start : zIndexPrefix + 9000,
		end : zIndexPrefix + 10000,
		currentMaxIndex : zIndexPrefix + 9001
	}));

	/* map the widget to a layer */
	widgetToLayersMap.add('xwt.widget.layout.Dialog', '1');
	widgetToLayersMap.add('xwt.widget.table.SaveFilterDialog', '1');
	widgetToLayersMap.add('xwt.widget.anchoredoverlay._Overlay', '1');
	widgetToLayersMap.add('xwt.widget.quickview.QuickView', '1');
	widgetToLayersMap.add('xwt.widget.objectselector.ObjectSelector', '1');
	widgetToLayersMap.add('xwt.widget.layout.ProgressBall', '1');

	/* slider can launch other content widgets - QV, AO from table etc*/
	widgetToLayersMap.add('xwt.widget.navigation._SliderPanel', '1');
	widgetToLayersMap.add('xwt.widget.navigation.GlobalToolbar', '1');

	widgetToLayersMap.add('xwt.widget.navigation.Megamenu', '1');
	widgetToLayersMap.add('xwt.widget.uishell.Header15', '2');
	
	widgetToLayersMap.add('xwt.widget.notification.Alert', '3');
	widgetToLayersMap.add('xwt.widget.notification.Toaster', '3');
	/* nbhattac - CSCti16829 */
	widgetToLayersMap.add('xwt.widget.table._DeleteConfirm', '3');
	
	function getLayerForWidget(/* string */widget, _widgetRef) {
		if (widgetToLayersMap.containsKey(widget)) {
			layerId = widgetToLayersMap.entry(widget);
			layer = layers.entry(layerId);
			return layer;
		}
		
		var _list = widgetToLayersMap.getKeyList();
		for(var i = 0; i < _list.length; i++){
			var _obj = dojo.getObject(_list[i]);
			if(_obj && _widgetRef instanceof  _obj){
				layerId = widgetToLayersMap.entry(_list[i]);
				layer = layers.entry(layerId);
				return layer;
			}
		}
		return null;
	}

	xwt.layer = function(className, _widgetRef) {
		return getLayerForWidget(className, _widgetRef);
	};
	
	xwt.addClassToLayer = function(/*widget declared name*/ className, /*layer number*/ layerNumber) {
		if (!widgetToLayersMap.containsKey(className) && !isNaN(layerNumber)) {
			return widgetToLayersMap.add(className, layerNumber+'');
		}
		return false;
	};
	
	xwt.removeClassFromLayer = function(/*widget declared name*/ className) {
		if (widgetToLayersMap.containsKey(className)) {
			return widgetToLayersMap.remove(className);
		}
		return false;
	};
	/* not tested yet - */
	
	xwt.peekCurrentLayerIndex = function(layerId) {
		var layer = layers.entry(layerId);
		return layer.value.currentMaxIndex;
	};

	xwt.getCurrentLayerIndexAndIncrement = function(layerId) {
		var layer = layers.entry(layerId);
		var temp = layer.value.currentMaxIndex;
		layer.value.currentMaxIndex++;
		return temp;
	};
	
	
	/* Modify dijit popup manager here */
	dijit.popup._origOpen = dijit.popup.open;
    dijit.popup.open = function(/*dijit.popup.__OpenArgs*/ args){
        var widget = args.popup;
        var mybest = dijit.popup._origOpen.apply(this, arguments); 
        widget.domNode.parentNode.style.zIndex = xwt.getCurrentLayerIndexAndIncrement(1);  // replace with YOUR_ZINDEX_COUNTER
        return mybest;
    };
})();

}

if(!dojo._hasResource["xwt.widget._ZIndexMixin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget._ZIndexMixin"] = true;
/* ************************************************** */
/* Copyright (c) 2009-2011 Cisco Systems, Inc.       */
/* All rights reserved.                               */
/* ************************************************** */
/**
 * @author nbhattac
 */

dojo.provide("xwt.widget._ZIndexMixin");

dojo.provide("xwt.widget.Layer");


dojo.declare("xwt.widget._ZIndexMixin", null, {
	
	skipIndex: false,
	skipUnderlay : true,
	
	_setIndex :function(event){
		if(this.skipIndex) {return;}
		widgetClassName = this.declaredClass;		
		layerObj = xwt.layer(widgetClassName, this);		
		if(!layerObj) {return;}
		
		var index = layerObj.value.currentMaxIndex;
		if(widgetClassName === "xwt.widget.notification.Alert") {
			dojo.style(this.domNode, "zIndex", index );
			this._setUnderlay(index);
			
			return;
		}
		if (this.domNode){
			dojo.style(this.domNode,"zIndex", index);
		}
		layerObj.value.currentMaxIndex++;
		if(this.skipUnderlay) {
			return;
		}
		this._setUnderlay(index);	
	},
	
	_setUnderlay:function(index){
	//summary:
	//reset underlay item z-index
		var underlay = dojo.query('div.dijitDialogUnderlayWrapper');
		if(underlay && underlay.length > 0) {
			for(i=0; i < underlay.length; i++) {
				var dialogUnderlay = underlay[i];
				var display = dojo.style(dialogUnderlay, 'display');
				if(display != 'none') {
					console.log('underlay-index' + (index-1));
					dojo.style(dialogUnderlay, 'zIndex', (index-1));
				}
			}
		}
	},
	
	
	hookZIndex: function() {
		// nbhattac - CSCti16829
		widgetClassName = this.declaredClass;
		if(widgetClassName !== "xwt.widget.notification.Alert" && 
				widgetClassName !== "xwt.widget.table._DeleteConfirm") {
			setTimeout(dojo.hitch(this, "_setIndex"), 500);
			return;
		}
		// alert && delete confirm
		setTimeout(dojo.hitch(this, "_setIndex"), 100);

	},

    dummy:null
// end class
	}
);

}

if(!dojo._hasResource["xwt.widget.layout.Dialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.layout.Dialog"] = true;
/* ************************************************** */
/* Copyright (c) 2009-2011 Cisco Systems, Inc.             */
/* All rights reserved.                               */
/*                                                    */
/* @author Dennis Park denpark@cisco.com              */
/* ************************************************** */ 

dojo.provide("xwt.widget.layout.Dialog");












dojo.declare("xwt.widget.layout.Dialog", [dijit.Dialog, xwt.widget._ZIndexMixin], {
	// Summary:
	// 		An extension of the dijit.Dialog that implements the UX and Kubrick specs.	
	// description:
	// 		xwt.widget.layout.Dialog extends from dijit.Dialog with a new template and CSS file. 
	//	example:
	//		To create a new dialog, create a new Dialog instance and set the dialog's content. For example:
	//	|	var formDlg = new xwt.widget.layout.Dialog({title:"Edit Device"});
	//	|	dlgContent = new xwt.sample.DialogContent();
	//	|   formDlg.setDialogContent(dlgContent.domNode);	
	//	
	//	templateString : String
	//		Template as an HTML string.
	templateString: null,
	
	//	templatePath : String
	//		Template path.
	templateString:"<div class=\"dijitDialog\" tabindex=\"-1\" waiRole=\"dialog\" waiState=\"labelledby-${id}_title\">\r\n\r\n\r\n<table class=\"containerTable\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\r\n  <tr>\r\n    <td class=\"top-left\"></td>\r\n    <td class=\"top-center\"></td>\r\n    <td class=\"top-right\"></td>\r\n  </tr>\r\n  <tr dojoAttachPoint=\"middleContentArea\">\r\n    <td class=\"middle-left-col\" dojoAttachPoint=\"middleLeftColumn\" >\r\n    \t<table class=\"middle-column-table\">\r\n \t\t\t<tr class=\"fill-row\">\r\n    \t\t\t<td class=\"middle-left\" dojoAttachPoint=\"middleLeft\"></td>\t\t\t\t\r\n    \t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td class=\"middle-left-lower\"></td>\r\n\t\t\t</tr>\r\n    \t</table>\r\n    </td>\r\n    <td class=\"middle-center\" dojoAttachPoint=\"contentArea\">\r\n\t\t<div dojoAttachPoint=\"titleBar\" class=\"dijitDialogTitleBar\">\r\n\t\t\t<span dojoAttachPoint=\"titleNode\" class=\"dijitDialogTitle\" id=\"${id}_title\"></span>\r\n\t\t\t<span dojoAttachPoint=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" dojoAttachEvent=\"onclick: onCancel, onmouseenter: _onCloseEnter, onmouseleave: _onCloseLeave\" title=\"${buttonCancel}\">\r\n\t\t\t\t<span dojoAttachPoint=\"closeText\" class=\"closeText\" title=\"${buttonCancel}\">x</span>\r\n\t\t\t</span>\r\n\t\t</div>\r\n\t\t<div dojoAttachPoint=\"containerNode\" class=\"dijitDialogPaneContent\">\r\n\t\t</div>\t\t\t\t\r\n\t\t<div class=\"buttonPane\" dojoAttachPoint=\"buttonPane\">\r\n\t\t\t<div dojoAttachPoint=\"buttonGroup\" dojoType=\"xwt.widget.form.TextButtonGroup\"> \r\n\t\t\t</div>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t</div>\t\t\t\t\t\t\t\t\t\t\r\n\t</td>\r\n\t\r\n    <td class=\"middle-right-col\" dojoAttachPoint=\"middleRightColumn\">\r\n    \t<table class=\"middle-column-table\">\r\n    \t\t<tr class=\"fill-row\">\r\n    \t\t\t<td class=\"middle-right\" dojoAttachPoint=\"middleRight\"></td>\r\n    \t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td class=\"middle-right-lower\"></td>\r\n\t\t\t</tr>\r\n    \t</table>\r\n    \t\r\n    </td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"bottom-left\"></td>\r\n    <td class=\"bottom-center\"></td>\r\n    <td class=\"bottom-right\"></td>\r\n  </tr>\r\n</table>\r\n\r\n\r\n\r\n</div>\r\n",
	
	//	widgetsInTemplate : String
	//		Parse template to add child objects. Default value is true.
	widgetsInTemplate: true,
	
	// i18nPackageName: String
	//		To support I18N messages. By default, the value is "xwt". Modify based on your requirements.	
	i18nPackageName: "xwt",
	
	 // i18nBundlerName: String
    //		To support I18N messages. By default, the value is "XMPProperties". Modify based on your requirements.
	i18nBundleName : "XMPProperties",
	
	_messages:null,//widget level messages.
	_appMessages : null,//application level messages.
	
	button2Label:"Cancel",
	button1Label:"OK",
	
	//button1:null,
	//button2:null,
	 
    button1BassClass: "defaultButton",
    
	baseClass: "xwtDialog dijitDialog",
	
	
	getButtonGroup:function(){
		 var widget=dijit.byNode(this.buttonGroup);
		 return widget;
	},
	
	_position: function(){
        // summary:
        //        Position modal dialog in the viewport. If no relative offset
        //        in the viewport has been determined (by dragging, for instance),
        //        center the node. Otherwise, use the Dialog's stored relative offset,
        //        and position the node to top: left: values based on the viewport.
        // tags:
        //        private
        
        /* due to the following CDETs
         
         CSCtn82066 - xwt Dialog was lost when dragged out of viewport. 
		 CSCtn88279 - In case dialog is longer then view-port. dlg is unusable (top and bottom parts are out of screen, scroll bar won't help)
         
         dijit.Dialog shows the same problems  https://support.sitepen.com/issues/21047
         we overwrite private this api. 
          
         Dialog _position() can be called in many times, dlg's (w,h, x,y) changes as dialog internal contentPane reload. window scroll bar move,drag, etc
         */
         
         var viewport = dijit.getViewport(),
         np = dojo.position(this.domNode);  
         var mbox = dojo.marginBox(this.domNode);
         /*CSCto85905 start - prevent drag dlg below viewport then move scrollbar*/
        if (mbox.t>(viewport.t+viewport.h)){			
			dojo.marginBox(this.domNode, {t:(viewport.t+viewport.h-25)});
		}	
		 /*CSCto85905 end */
        if(!dojo.hasClass(dojo.body(),"dojoMove")){
            
            //console.log(this.id);
            //console.log(" _position() np " + " h=" +  np.h + " w=" +   np.w+ " x=" +  np.x+ " y=" +  np.y);
            //console.log(" _position() vp"  + " h=" +  viewport.h  + " l=" +  viewport.l+ " t=" +  viewport.t+ " w=" + viewport.w);
            // Try and make sure the dialog can be scrolled in.
            // the 25 is a buffer.
            if(this._showedOnce && (Math.ceil(np.x + np.w + 25) >= viewport.w ||Math.ceil(np.y + np.h + 25) >= viewport.h)){
            	// //This API called in subsequent time
            	if(!((np.h+25) <= viewport.h )){            		
	            	if (!this._adjusted){
		            	var left = (viewport.w - np.w)/2 + viewport.l;
		                if (left<0){ 
		                		left=0;
		                }
		                dojo.marginBox(this.domNode, {l: Math.floor(left)});
		                if( Math.ceil(np.y + np.h) >= viewport.h){
	                		dojo.marginBox(this.domNode, {t:(viewport.t+25) });
		                }
		                this._adjusted=true;
		            }
		            //console.log(this.id + "  _position() this._showedOnce  not use default " + (new Date()).getTime());
            	}else{
            		//console.log(this.id + "  _position() this._showedOnce  use default " + (new Date()).getTime());
            		this.inherited(arguments);
            	}                
            }else{
            	//the very first time this API called
            	this._showedOnce = true;   
				// In case dialog height is bigger than viewport height, 
				// to prevent dialog top/bottom chop off. Make sure dialog top is visible so that user can drag dialog and scroll.	
				if(!((np.h+25) <= viewport.h )){
                	var left = (viewport.w - np.w)/2 + viewport.l;
                	if (left<0){ 
                		left=0;
                	}
                	//console.log(this.id + " _position() not use default " +  (new Date()).getTime());
                	dojo.marginBox(this.domNode, {t:(viewport.t+25), l: Math.floor(left)});
				}else{
					//console.log(this.id + "  _position()  use default " + (new Date()).getTime());
					this.inherited(arguments);
				}			
            }
        }
    },
	
	
	
	postMixIProperties: function(){
		//	description:
		//		Called after the parameters to the widget have been read-in, 
		//		but before the widget template is instantiated. 
		//		Read in localization bundle.
		dojo['requireLocalization'](this.i18nPackageName, this.i18nBundleName );
		this._messages = dojo.i18n.getLocalization(this.i18nPackageName, this.i18nBundleName);
		if (this.i18nPackageName !== "" && this.i18nBundleName !== ""){
			dojo['requireLocalization'](this.i18nPackageName, this.i18nBundleName );
				this._appMessages = dojo.i18n.getLocalization(this.i18nPackageName, this.i18nBundleName);				
		}

		/*if(this._appMessages){
			this.dateText = this._appMessages[this.date_text];			
		}*/
				
		this.inherited(arguments);
	},
	
	postCreate: function(){	
		//	tags:
		//		protected extension
		//	description:
		//		Set up connections to events for the dialog.
		
		this.inherited(arguments);
	    this._createButtons();
		this._hookEvents();
		/* nbhattac - sitepen ticket 20700 patch*/
		this.__dijitDialogPatch();	
		
		//CSCto85905 Dialog hiding issue. After Drag stop, make Dlg no out of bound
		this.connect(this, "_endDrag",  "_endDragPosion" );
		
	},
	
	
	//CSCto85905 Dialog hiding issue. After Drag stop, make Dlg no out of bound
	_endDragPosion:function(){
	// summary:
	// Internal funciton
	// After Drag stop, make Dlg header no out of bound
		//console.log(this.declaredClass + " _endDragPosion()");
		var mbox = dojo.marginBox(this.domNode);
		var viewport = dijit.getViewport();
		if (mbox.t<0){
			var viewport = dijit.getViewport();
			dojo.marginBox(this.domNode, {t:(viewport.t+5)});
		}
		if (mbox.l<0){			
			dojo.marginBox(this.domNode, {l:(viewport.l+5)});
		}	
		if (mbox.l>(viewport.l+viewport.w)){			
			dojo.marginBox(this.domNode, {l:(viewport.l+viewport.w-25)});
		}	
		if (mbox.t>(viewport.t+viewport.h)){			
			dojo.marginBox(this.domNode, {t:(viewport.t+viewport.h-25)});
		}	
			   
	},
	
	/* patch from sitepen ticket - 20700 - nbhattac - start */
	__dijitDialogPatch : function() {

		/**
		* Add this patch to your other patches/inialization code after dijit.Dialog has loaded:
		*/
		var old = dijit.Dialog.prototype.uninitialize;
		dijit.Dialog.prototype.uninitialize = function(){
				var wasPlaying = false;
				if(this._fadeIn && this._fadeIn.status() == "playing"){
					wasPlaying = true;
					this._fadeIn.stop();
				}
				if(this._fadeOut && this._fadeOut.status() == "playing"){
					wasPlaying = true;
					this._fadeOut.stop();
					
					/**
					IF the animation is still playing we need to call the onEnd function to make 
					sure that the underlay is updated correctly.  See onEnd from dijit.Dialog.
					*/
					this._fadeOut.onEnd();
				}

				// Hide the underlay, unless the underlay widget has already been destroyed,
				// because we are being called during page unload (when all widgets are destroyed)
				
				var ds = dijit._dialogStack;
				if(ds.length == 0 && (this.open || wasPlaying) && !dijit._underlay._destroyed){
					dijit._underlay.hide();
				} 
			

				if(this._moveable){
					this._moveable.destroy();
				}
				old.call(this);
			};
			
	},
	/* patch from sitepen ticket - 20700 - nbhattac - end */
	
	/*
	startup:function(){
		if (this.isBtn1Default){
			this.ok.attr("baseClass","defaultButton");
		}
		this.inherited(arguments);
	},
	*/
	
	_createButtons:function(){
		
		var tg = this.buttonGroup;
		//console.log (tg.getChildren());				
		var button1 = new xwt.widget.form.TextButton({label: this.button1Label, baseClass:this.button1BassClass});
		var button2 = new xwt.widget.form.TextButton({label: this.button2Label});
		tg.addChild(button1);  
		tg.addChild(button2);  
	},

	_hookEvents: function(){
		//	summary:
		//		Connects the Ok and Cancel buttons. Used to close the dialog.
		//	tags:
		//		private
		//dojo.connect(this.ok, "onClick", this, "hide");
//		dojo.connect(this.buttonGroup.getItemAt(0), "onClick", this, "hide");
		
		//	Must revisit this eventually and allow an application method to 
		//	be attached to the cancel event. 
		
		// Cancel should call onCancel, which in the base dijit.Dialog also called hide.
		// Needed for widgets, like XWT Table, to properly catch when an edit dialog is canceled.
		this.cancelConnection = dojo.connect(this.buttonGroup.getItemAt(1), "onClick", this, "onCancel" );
	},

	_handleOneButton:function(){
		var buttonLen= this.buttonGroup.getChildren().length;
		if(buttonLen===1){
			this.autofocus=false;
			var button = this.buttonGroup.getChildren()[0];
			if(button){
				setTimeout(function(){
					//dijit.byId(button.id).focus();
					var btn = dijit.byId(button.id);					
//					dojo.style(btn.titleNode, "-moz-outline:none");					
//					if (btn.attr("baseClass")==="defaultButton"){
//						dojo.addClass(btn.domNode, "defaultButtonActive");
//					}else{
//						dojo.addClass(btn.domNode, "xwt-TextButtonActive");
//					}
					dijit.focus(btn.domNode);
					//This is to circumvent http://nmtg-jira.cisco.com/jira/browse/XMPGUI-400  					
				},10);					
			}
		}
	},
	
	show: function() {
		//	summary:
		//		Set height for the outer middle sections of the dialog container.
		//	tags:
		//		extension
		this.inherited(arguments);
		this.fixGradient();
		this._handleOneButton();
		// zindex on show
		
		if(this.buttonGroup.getChildren().length == 0){
			dojo.style(this.buttonPane, "display", "none");
		}
		
		
		
		this.skipUnderlay = false;
		this.hookZIndex();
		xwtPopups.suspendPopups(this.domNode.style.zIndex);
	},
	
	hide: function(){
		xwtPopups.restorePopups();
		this.inherited(arguments);
	},
	
	findHighestZ: function () {
//		summary:
		//		Find the highest z-index for the page. 
		//	returns: 
		//		The highest z-index number of divs in the current page
		
		 var documentDivs = new Array();
	     documentDivs = document.getElementsByTagName("DIV");
	     var highestZ = 0;
	     for (var i = 0; i < documentDivs.length; i++) {
	          var zindex = documentDivs[i].style.zIndex;
	          zindex = parseInt(zindex, 10);
	          if(!isNaN(zindex))
	          {
		          if (zindex > highestZ) {
		               highestZ = zindex;
		          }
	          }
	     }
	     return highestZ;
	},
	
	_setContent: function(){
		this.inherited(arguments);
		this.fixGradient();
	},
			
	setDialogContent: function(/*DomNode | String*/ node) {
		//	summary:
		//		API method to append a child DOM node to the dialog content container.
		
		this.dialogContentNode = node;
		this.containerNode.appendChild(this.dialogContentNode);		
	},
	
	fixGradient: function(){
	// summary:
	//		method should be invoked by application whenever the content of the
	//		dialog has changed.  Failure to do so will result in the top and
	//		bottom corners of the dialog on both sides to have gaps.
		
		//	removed for CSCti54926
		//	var _posContentArea = dojo.marginBox(this.contentArea);

		//  Fix for CSCti54926.  Taking the sum total height of each section of
		//		of the dialog content.
		var _posContentArea = dojo.marginBox(this.containerNode);
		var _posTitleArea = dojo.marginBox(this.titleBar);
		var _posButtonPaneArea = dojo.marginBox(this.buttonPane);
		
		// The constant int 85 is the height of the left and right images used
		//	for the border and drop shadow.  These images contain the extent
		//	of the vertical gradient.  The remaining height of the dialog is
		//	white and a separate image is used (of height 1), repeating on the
		//	y axis.  The dialog is a 4 row x 3 column table to achieve the 
		//	rounded	corners and gradient effect.
		
		//	removed for CSCti54926
//		tdHeight = _posContentArea.h;

		//  Fix for CSCti54926.  Taking the sum total height of each section of
		//		of the dialog content.
		tdHeight = _posContentArea.h + _posTitleArea.h + _posButtonPaneArea.h + 20;
		
		if(tdHeight > 85) {
			
			//	85px is the height of the gradient object.
			var _height = tdHeight - 85;

			dojo.style(this.middleLeft, {
			    "height": _height + "px"
			});
			
			dojo.style(this.middleRight, {
			    "height": _height + "px"
			});
		}		
	},	

	destroy: function(){		
		if(this.buttonGroup){
			 var _nChildren = this.buttonGroup.getChildren();
			 for(var i = 0; i < _nChildren; i++){
				 var _button = this.buttonGroup.getItemAt(i);
				 this.buttonGroup.removeChild(_button);
				 _button.destroy();
			 }
		}
		if(this.cancelConnection){
			dojo.disconnect(this.cancelConnection);
			delete this.cancelConnection;
		}

		// Only try to remove if it really looks like a dom node and has a parent (in tree);
		if(this.dialogContentNode && this.dialogContentNode.parentNode === this.containerNode){
			this.containerNode.removeChild(this.dialogContentNode);
		}
		delete this.dialogContentNode;
		this.inherited(arguments);
	}
});

}

if(!dojo._hasResource["xwt.widget.notification.Alert"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.notification.Alert"] = true;
/* ************************************************** */
/* Copyright (c) 2009-2011 Cisco Systems, Inc.       */
/* All rights reserved.                               */
/* ************************************************** */ 

dojo.provide("xwt.widget.notification.Alert");





(function(){
	var alertQueue = [];
	var showing;
	var slideDownNext = true;
	
	var Alert = dojo.declare("xwt.widget.notification.Alert", [xwt.widget.layout.Dialog],{
		//baseClass name for css namespace
		baseClass: "xwtAlert",
		// 	summary:
		//		An extension of the xwt.widget.layout.Dialog that provides alert-style notification
		//		of important events.
		//
		//	description:
		//		An extension of the xwt.widget.layout.Dialog that provides alert-style notification
		//		of important events.
		//
		//	example:
		//		To create a new alert, create a new Alert instance and set the dialog's content. For example:
		//	|	var alert = new xwt.widget.notification.Alert({
		//	|		messageType:"warning",
		//	|		buttons: [
		//	|			{
		//	|				label: "OK",
		//	|				onClick: function(){
		//	|					var dontShowAgain = alert.dontShowAgain;s
		//	|					...
		//	|				}
		//	|			},
		//	|			{
		//	|				label: "Cancel"
		//	|			}
		//	|		],
		//	|		dontShowAgainOption: true,
		//	|		messageNumber: 333
		//	|	});
		//	|	alert.setDialogContent("You have been warned");
		//
		//	example:
		//		We can create alerts with different message types as well. For example:
		//	|	var alert = new xwt.widget.notification.Alert({
		//	|		messageType:"critical",
		//	|		buttons: [
		//	|			{
		//	|				label: "OK",
		//	|			}
		//	|		]
		//	|	});
		//  |   var messageString = "Critical alert" // message set in the alert. 
		//	|	alert.setDialogContent("messageString");
		//  |  /*
		//  |  If the messageString is very long, you can set the text in "..." mode and set the tooltip to display extra information: 
		//  |  var divContent = dojo.create("div", {innerHTML: dotted_text, title: full_text}); //you create a div element
		//  |  then
		//  |  messageString = divContent.innerHtml;
		//  |  
		//  |  Another trick is to create a messageString in an HTML element, such as: <a href=" " target="_blank">sth</a> or <div > my very long text ..</div> 
		//  |   */
		
	
		//	buttons: Object[]
		//		Defines the buttons for the dialog. Each button object should contain a label property and an onClick function.
		buttons: [],
		
		// dontShowAgainOption: Boolean
		//		Indicates that the Alert should provide the "Do not show this message again option".  
		dontShowAgainOption: false, 
		
		// dontShowAgain: Boolean
		//		Indicates whether the user selected to disable showing this message again.  
		dontShowAgain: false,
		
		// messageType: String
		//		Indicates what type of dialog message is being displayed. It can have one of three
		//		values: "information", "warning", or "critical".  
		messageType: "",
		
		// messageNumber: String
		//		Indicates the message number for the alert.
		messageNumber:0,
		
		// number
		//		max message string length (see above how to handle very very long string/word)
		maxMessageStringLength:30,
		
		// boolean
		//		flag to indicate if there is extra long word in message
		_hasLongWord:false,
		
		// number
		//	width expand ratio
		wRatio :70,
		
		//rRatio number 
		//	In case message is sentence with long word. Alert needs to adjust the height. This is a number to set 
		rRatio:32,
		
		//setButtonTodefaultStyle if there is only one button in alert
		flagSetOnlyButtonToDefault:true,
				
		constructor: function(){
		// summary:
		//constructor - widget life circle api 
			alertQueue.push(this);
			setTimeout(showNext);
		},

		postMixInProperties: function(){
		// summary:
		//widget life circle api
			
			this.inherited(arguments);
			var messages = dojo.i18n.getLocalization("xwt", "notification");
			this.dontShowAgainMessage = messages.dontShowAgain;
		},
		
		postCreate: function(){
		// summary:
		//widget life circle api
			
            this.inherited(arguments);
            dojo.addClass(this.domNode, "xwtAlert");
		},
		
		fixGradient: function(){
		// summary:
		//Overwrite API
			
            var _pos_tdMiddleContentArea = dojo.marginBox(this.middleContentArea);
            var tdHeight  = _pos_tdMiddleContentArea.h;
            if(tdHeight > 85) {
                  var _height = tdHeight - 85;
                  dojo.style(this.middleLeft, {
                      "height": _height + "px"
                  });
                  dojo.style(this.middleRight, {
                      "height": _height + "px"
                  });
            }           
      },

     
      
      _isVeryLongWord:function(/*string */word, /*int*/ maxlength){    	  
    	  if (word.length>this.maxMessageStringLength+1){
    			return true;    		
    	  }
    	  return false;
    	  
      },
      
     
      
      _hasLongWordCheck: function(/*string */message, /*int*/ maxlength){
          // summary:
          // trim message String so that each word is no more than 30 characters . 30 is set in "maxMessageStringLength" property
        	  var haslongWord = false;
        	  var words = new Array();
        	  words = message.split(' ');
        	  var str ='';
        	  this._isSentence =  (words.length>1)? true:false;
        	  for(var i=0;i<words.length;i++){
        		  if(this._isVeryLongWord(words[i], maxlength))
        				  return true;        		  
        	  }
        	  return haslongWord;
          },
      
	  setDialogContent: function(content, _id){
    	// summary:
  		// set content in Alert - conent can be widget or string (html string)
    	  
			if(typeof content == "string"){
				var text=content;
				/*
				var boolWrapLongWord = (text.indexOf(" ")<0 && text.length>this.maxMessageStringLength+1);
				if (boolWrapLongWord){
					text = text.substring(0,this.maxMessageStringLength)+ "..";
					content = dojo.create("div", {innerHTML: text, title: content});
				}else{
					content = dojo.create("div", {innerHTML: text});
				}
				*/
				this._hasLongWord = this._hasLongWordCheck(content, this.maxMessageStringLength);
				
				//console.log("alert setDialogContent message " + text);
				content = dojo.create("div", {innerHTML: text});
			}

			var alertDiv = dojo.create("div", {className: "xwtAlert-" + this.messageType});
			if(this.helpText){
				dojo.create("div", {
					className: "xwtHelpText",
					innerHTML: this.helpText
				}, alertDiv);
			}
			
			var _newChild = alertDiv.appendChild(content);
			
			// CSCtj34949 - included Screen reader support logic.
			if(_id){
				var _newChild = alertDiv.appendChild(content);
				_newChild.id = _id;
			}
			
			if(this.dontShowAgainOption){
				dojo.create("div", {
					className: "xwtDontShowAgainMessage",
					innerHTML: "<input type='checkbox' class='xwtDontShowOption' /> " 
						+ "<label class='xwtDontShowLabel'>"
						+ this.dontShowAgainMessage + "</label>"
				}, alertDiv);
			}
			arguments[0] = alertDiv;
			this.inherited(arguments);
		},
		
		adjustSizeByTheme:function(){
		// summary:
		// adjust alert size basedon theme
		    var mbox = dojo.marginBox(this.domNode);
			if(dojo.hasClass(dojo.body(),"reboot2")){
				var h1 = (mbox.h-this.rRatio)? mbox.h-this.rRatio:0;
				dojo.marginBox(this.domNode, {h: h1});
			}			
		},
		show: function(){
		// summary:
		// show alert 
			console.log("show");
			this.inherited(arguments);
			if (this._hasLongWord){
				var mbox = dojo.marginBox(this.domNode);
				if (this._isSentence){
					dojo.marginBox(this.domNode, {w: mbox.w+this.wRatio+20});
					this.adjustSizeByTheme();
				}else{
					dojo.marginBox(this.domNode, {w: mbox.w+this.wRatio});
				}
			}
			// if alert has only one button, set it to default-style
			var buttonLen= this.buttons.length;
			if (this.flagSetOnlyButtonToDefault && buttonLen===1){				
				this.buttonGroup.getChildren()[0].attr("baseClass","defaultButton");				
			}
			if (buttonLen===1){
				//This is to circumvent http://nmtg-jira.cisco.com/jira/browse/XMPGUI-400  
				this.autofocus=false;
			}			
			var button = dojo.query("button", this.domNode)[0];
			if(button){
				setTimeout(function(){
					//dijit.byId(button.id).focus();
//					var btn = dijit.byId(button.id);
//					
//					dojo.style(btn.titleNode, "-moz-outline:none");
//					
//					if (btn.attr("baseClass")==="defaultButton"){
//						dojo.addClass(btn.domNode, "defaultButtonActive");						
//					}else{
//						dojo.addClass(btn.domNode, "xwt-TextButtonActive");
//					}
//					//This is to circumvent http://nmtg-jira.cisco.com/jira/browse/XMPGUI-400  
//					if (buttonLen>1){
//							btn.focus();
//					}
					dijit.focus(button.domNode);
				},200);	
				
			}

		},	
		
		updateOptions: function(){
			// summary:
			// 	This is called to update the state of the dontShowAgain attribute  
			var checkbox = dojo.query(".xwtDontShowOption", this.domNode)[0];
			this.dontShowAgain = checkbox && checkbox.checked;
		},
		_createButtons:function(){
		// summary:
		//widget create buttons
			
			var tg = this.buttonGroup;
			var self = this;
			var baseClass = "";
			//console.log (tg.getChildren());
			dojo.forEach(this.buttons, function(button){
				var widget;
				if (button.baseClass!=null && button.baseClass!="") {
					baseClass = button.baseClass;
					widget = new xwt.widget.form.TextButton({label: button.label, baseClass: baseClass});
				}else{
					widget = new xwt.widget.form.TextButton({label: button.label});
				}
				
				dojo.connect(widget, "onClick", function(){
					self.updateOptions();
					if(button.onClick){
						button.onClick();
					}
					self.hide();
					self.destroyRecursive();
				});
				tg.addChild(widget);
				baseClass = "";
			});
			if(this.messageNumber){
				dojo.create("div",{
					className: "xwtMessageNumber",
					innerHTML: "Message Number: " + "<span>" + this.messageNumber + "</span>"
				},tg.domNode);
			}
		},
		hide: function(){			
		// summary:
		//widget hide alert
			this.duration = 0; // immediately dismiss this dialog
			this.inherited(arguments);
			showing = null;
			setTimeout(showNext, 400); 
		},
		_position: function(){
		// summary:
		// set position
			var node = this.domNode,
				viewport = dijit.getViewport(),
				p = this._relativePosition,
				bb = p ? null : dojo._getBorderBox(node),
				l = Math.floor(viewport.l + (p ? p.x : (viewport.w - bb.w) / 2));
			dojo.style(node,{
				left: l + "px",
				top: slideDownNext ? (-bb.h + "px"): "",
				bottom: 1 + "px",
				height: bb.h + "px"
			});
			
			var s = dojo.fx.slideTo({
				node: node,
				duration: 500,
				left: l,
				bottom: bb.h 
			}).play();
		}
	});
	
	function showNext(){
	// summary:
	//show alert
		if(!showing){
			showing = alertQueue.shift();
			if(showing){
				showing.show();
				/*slideDownNext = !slideDownNext;*/
			}
			else{
				slideDownNext = true;
			}
		}
	}
	xwt.widget.notification.Alert.getList = function(){
		// summary:
		//		Returns an array of all the alerts in the queue 
		return alertQueue;
	};
	xwt.widget.notification.Alert.remove = function(alert){
		// summary:
		//		Removes an alert from the queue
		alertQueue.splice(dojo.indexOf(alertQueue, alert), 1);
		alert.destroyRecursive();
	};
})();

}

if(!dojo._hasResource["xwt.widget.table.ellipsis"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.table.ellipsis"] = true;
/* ************************************************** */
/* Copyright (c) 2009-2011 Cisco Systems, Inc.       */
/* All rights reserved.                               */
/* ************************************************** */

dojo.provide("xwt.widget.table.ellipsis");

(function(d){
	var st = d.doc.documentElement.style;
	if(!('textOverflow' in st || 'OTextOverflow' in st)){
		// Feature detection for XUL bindings
		// disabled ellipses after UX review (harjeesi)
		if(true){
			return;
		}
		if('MozBinding' in st){
			// Create our stub XUL elements for cloning later.
			var sNS = 'http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul';
			var xml = document.createElementNS(sNS, 'window');
			var label = document.createElementNS(sNS, 'description');
			label.setAttribute('crop', 'end');
			xml.appendChild(label);
			
			var createXULEllipsis = function(/* Node */ n){
				// Summary:
				//		Given a node, create the XUL and set its
				//		content so that it will have an ellipsis.
				var x = xml.cloneNode(true);
				x.firstChild.setAttribute('value', n.textContent);
				n.innerHTML = '';
				n.appendChild(x);
			};
			
			// Create our iframe elements for cloning later.
			var create = d.create;
			var dd = d.doc;
			var dp = d.place;
			var iFrame = create("iframe", {className: "ellipsis-iframe",
						src: "javascript:'<html><head><script>if(\"loadFirebugConsole\" in window){window.loadFirebugConsole();}</script></head><body></body></html>'"});
			var rollRange = function(/* W3C Range */ r, /* int? */ cnt){
				// Summary:
				//		Rolls the given range back one character from the end.
				//
				//	r: W3C Range
				//		The range to roll back.
				//	cnt: int?
				//		An optional number of times to roll back (defaults to 1).
				if(r.collapsed){
					// Do nothing, we are already collapsed.
					return;
				}
				if(cnt > 0){
					do{
						rollRange(r);
						cnt--;
					}while(cnt);
					return;
				}
				if(r.endContainer.nodeType == 3 && r.endOffset > 0){
					r.setEnd(r.endContainer, r.endOffset - 1);
				}else if(r.endContainer.nodeType == 3){
					r.setEndBefore(r.endContainer);
					rollRange(r);
					return;
				}else if(r.endOffset && r.endContainer.childNodes.length >= r.endOffset){
					var nCont = r.endContainer.childNodes[r.endOffset - 1];
					if(nCont.nodeType == 3){
						r.setEnd(nCont, nCont.length - 1);
					}else if(nCont.childNodes.length){
						r.setEnd(nCont, nCont.childNodes.length);
						rollRange(r);
						return;
					}else{
						r.setEndBefore(nCont);
						rollRange(r);
						return;
					}
				}else{
					r.setEndBefore(r.endContainer);
					rollRange(r);
					return;
				}
			};
			var createIFrameEllipsis = function(/* Node */ n){
				// Summary:
				//		Given a node, create an iframe and an ellipsis div and
				//		set up the connections so that they will work correctly.
				//		Use this when you cannot use createXULEllipsis 
				//		because there is markup within the node. It is
				//		a bit slower, but does the trick.
				var c = create("div", {className: "ellipsis-container"});
				var e = create("div", {className: "ellipsis-shown", style: {display: "none"}});
				n.parentNode.replaceChild(c, n);
				c.appendChild(n);
				c.appendChild(e);
				var i = iFrame.cloneNode(true);
				var ns = n.style;
				var es = e.style;
				var ranges;
				var resizeNode = function(){
					ns.display = "";
					es.display = "none";
					if(n.scrollWidth <= n.offsetWidth){ return; }
					var r = dd.createRange();
					r.selectNodeContents(n);
					ns.display = "none";
					es.display = "";
					var done = false;
					do{
						var numRolls = 1;
						dp(r.cloneContents(), e, "only");
						var sw = e.scrollWidth, ow = e.offsetWidth;
						done = (sw <= ow);
						var pct = (1 - ((ow * 1) / sw));
						if(pct > 0){
							numRolls = Math.max(Math.round(e.textContent.length * pct) - 1, 1);
						}
						rollRange(r, numRolls);
					}while(!r.collapsed && !done);
				};
				i.onload = function(){
					i.contentWindow.onresize = resizeNode;
					resizeNode();
				};
				c.appendChild(i);
			};

			xwt.widget.table.ellipsizeCells = function(table, domNode, dontWatch){
				// Function for updating the ellipsis
				var hc = d.hasClass,
					css = table._css,
					ellipsisNotDone = css.ellipsisNotDone;

				var query = " ." + css.cellContainer + " ." + ellipsisNotDone + ", " +
							" ." + css.groupCellContainer + " ." + ellipsisNotDone;
				var ellipsize = function(){
					dojo.query(query, domNode).forEach(function(n){
						if(hc(n, 'ellipsis')){ return; }
						var cn = n.className;
						n.className = dojo.trim((" " + cn + " ").replace(/ ellipsis-not-done /g, ' ellipsis '));
						if(n.textContent == n.innerHTML && !hc(n, "selectable")){
							// We can do the faster XUL version, instead of calculating
							createXULEllipsis(n);
						}
						// FIXME: this doesn't work with the markup we have
						/*else{
							createIFrameEllipsis(n);
						}*/
					});
				};

				if(dontWatch){ ellipsize(); return; }

				var t = null;
				var c = null;
				var connFx = function(){
					if(c){
						// disconnect us - so we don't fire anymore
						d.disconnect(c);
						c = null;
					}
					if(t){ window.clearTimeout(t); t = null; }
					t = window.setTimeout(function(){
						window.clearTimeout(t);
						t = null;
						ellipsize();
						// Connect to the modified function so that we can catch
						// our next change.
						c = d.connect(domNode, "DOMNodeInserted", connFx);
					}, 10);
				};
				connFx();
			}

			d.addOnUnload(function(){
				dojo.destroy(iFrame);
				iFrame = null;
				dojo.destroy(xml);
				xml = null;
			});
		}
	}
	st = null;
})(dojo);

}

if(!dojo._hasResource["xwt.widget.table.Column"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.table.Column"] = true;
/* ************************************************** */
/* Copyright (c) 2009-2011 Cisco Systems, Inc.       */
/* All rights reserved.                               */
/* ************************************************** */

dojo.provide("xwt.widget.table.Column");














/*=====
xwt.widget.table.Column.__editWidgetArgs = function(widget, options, setWidth){
	//	summary:
	//		An object passed to the xwt.widget.table.Column.__ctorArgs.editWidget property.
	//
	//	widget: Constructor
	//		The constructor for the widget to be created/used.
	//	options: Object?
	//		The keyword arguments object you would normally pass to the widget constructor.
	//	setWidth: Boolean?
	//		An optional flag allowing the developer to turn off automatic setting of the width of the widget.  Defaults to true.
	//		Use this when you are using a widget with a fixed width, such as a checkbox or a radio button.
	this.widget = widget;
	this.options = options;
	this.setWidth = setWidth;
};

xwt.widget.table.Column.__ctorArgs = function(type, label, attr, meta, width, locked, frozen, hidden, sortable, filterable, editable, editWidget, align, valign, wrap, formatter, table){
	//	summary:
	//		Named arguments object to create a Column.
	//
	//	type: Object?
	//		The type the column represents.  Pass this (along with label and attr) if
	//		you want the Column constructor to create the underlying Meta object for you.
	//	label: String?
	//		The label for the Column. Will also be used for the underlying meta object.
	//	attr: String?
	//		The name of the attribute in the underlying dojo.data Store.
	//	meta: xwt.widget.table.Meta?
	//		If you have an existing Meta object, pass it this way.
	//	width: Number?
	//		The initial width of the column, in pixels.
	//	locked: Boolean?
	//		Indicates whether this column is locked (i.e., not moveable). Not used currently.
	//	frozen: Boolean?
	//		Indicates whether this column is anchored (i.e., Columns.lock). Not used currently.
	//	hidden: Boolean?
	//		Indicates whether this column is hidden.
	//	sortable: Boolean?
	//		Indicates whether this column is sortable.
	//	filterable: Boolean?
	//		Indicates whether this column is filterable.
	//	editable: Boolean?
	//		Indicates whether the data in the column can be edited.
	//	editWidget: xwt.widget.table.Column.__editWidgetArgs?
	//		An optional object that defines the widget constructor to be used, and any optional arguments to that constructor.
	//	align: String?
	//		How the data in this column is to be aligned.
	//	valign: String?
	//		How the data in this column is to be vertically aligned.
	//	wrap: Boolean?
	//		If the data in the cell is to wrap based on width or if it is to be "clipped".
	//	formatter: Function?
	//		An optional formatting function to be used to display data.
	//	table: xwt.widget.table.Table?
	//		An optional reference to the table this column belongs to.  Used for special types of columns,
	//		such as selector and index columns.
this.type = type;
this.label = label;
this.attr = attr;
this.meta = meta;
this.width = width;
this.locked = locked;
this.frozen = frozen;
this.hidden = hidden;
this.sortable = sortable;
this.filterable = filterable;
this.editable = editable;
this.editWidget = editWidget;
this.align = align;
this.valign = valign;
this.wrap = wrap;
this.formatter = formatter;
this.table = table;
}
=====*/

dojo.declare("xwt.widget.table.Meta", null, {
	//	summary:
	//		The "meta" definition for each column defined for a Table.  This contains
	//		information such as data type, labeling, source attribute in a Store, width,
	//		if it's resizable or sortable, and more.  Also defines any kind of formatter
	//		for the represented attribute.
	//	description:
	//		The xwt.widget.table.Meta class describes type information about a
	//		specific column.  This is necessary so that things like proper sorting, formatting,
	//		etc., can be used with an xwt.widget.table.Column and not be treated as a String
	//		(which is the default type).
	//
	//		The xwt.widget.table.Meta also serves as a mapping mechanism between a cisco.tables.Column
	//		and an attribute on an item from a dojo.data Store. This can be useful (particularly
	//		the label property) when you want to have a column display one title and yet map to a different
	//		attribute name from a dojo.data Item.
	//
	//	type: Constructor?
	//		The underlying data type to which item attributes must be cast.  String is the default.
	//	isIdentity: Boolean
	//		Whether this meta object is used to identify dojo.data.items.
	//	label: String
	//		The label for the meta object (i.e. Column 1, Column 2)
	//	attr: String
	//		The attribute to be called on a dojo.data item to get the value of this meta.
	type: String,
	label: "",
	attr: null,
	isIdentity: false,
	constructor: function(type, attr, label, isIdentity){
		this.type = type;
		this.attr = attr;
		this.label = label;
		this.isIdentity = isIdentity;
	}
});

dojo.declare("xwt.widget.table.ColumnFormatters", null, {
	//	summary:
	//		A set of formatting methods for the most common JavaScript data types.
	//	description:
	//		xwt.widget.table.ColumnFormatters is a static/singleton object that contains
	//		basic formatting functions for the most common JS data types. When creating
	//		a Column object, if you do not pass a formatting function and you specify
	//		one of the types matched here, the corresponding formatter will be used
	//		instead.
	format: function(data, type){
		//	summary:
		//		Format the given data according to the passed type.
		//	data: Object
		//		The data to be formatted.
		//	type: Constructor
		//		The type that data is being cast to.
		//	returns:
		//		A formatted string.
		switch(type){
			case Array: return this["Array"](data);	//	String
			case Boolean: return this["Boolean"](data);	//	String
			case Date: return this["Date"](data);	//	String
			case Node: return this["HTML"](data);	//	String
			case Number: return this["Number"](data);	//	String
			case String: return data;	//	String
			default: return data.toString();	//	String
		}
	},
	"Array": function(data){
		//	summary:
		//		Return a formatted value; it will be assumed that all elements are strings.
		//	data: String[]
		//		The array of strings to format.
		//	returns:
		//		A formatted string.
		return data.join(", ");	//	String
	},
	"Boolean": function(data){
		//	summary:
		//		Format the boolean as a string and return the value.
		//	data: Boolean
		//		The boolean to format.
		//	returns:
		//		A formatted string.
		return (data===true) ? "Yes":"No";	//	String
	},
	"Date": function(data){
		//	summary:
		//		Format the Date as a string and return the value.
		//	data: Date
		//		The JS date object to format.
		//	returns:
		//		A formatted string.
		return dojo.date.locale.format(data, {});	//	String
	},
	"HTML": function(data){
		//	summary:
		//		Assume that the data is a passed node, and simply grab the innerHTML and return it.
		//	data: DOMNode
		//		The node to get the contents of.
		//	returns:
		//		A formatted string.
		return data.innerHTML;	//	String
	},
	"Number": function(data){
		//	summary:
		//		Return a formatted number.
		//	data: Number
		//		A number object to format.
		//	returns:
		//		A formatted string.
		return dojo.number.format(data, {});	// String
	},
	"String": function(data){
		//	summary:
		//		Return the data (i.e., no formatting needed).
		//	data: String
		//		The string to format.
		//	returns:
		//		A formatted string.
		return data;	//	String
	}
});


xwt.widget.table.ColumnTypes = {
	//	summary:
	//		An enumeration for different types of columns.
	//
	//	description:
	//		Certain types of columns have special properties and behaviors.  This enumeration
	//		is used by xwt.widget.table.Column and its subclasses to let other interested
	//		parties know what type it is, in order to know how to deal with it.  Note that
	//		while this is set up as a bit mask, it is not used that way in the current
	//		version.
	UNKNOWN: 	0,
	COLUMN: 	1,
	INDEX: 		2,
	SELECTOR: 	4,
	GROUP:		8,
	EXPANDER: 	16
};

dojo.declare("xwt.widget.table.Column", null, {
	//	summary:
	//		A column definition.  While all attributes of a dojo.data.item should have
	//		a corresponding Meta object, only those columns shown in a Table should
	//		be defined here.
	//	description:
	//		An xwt.widget.table.Column is one of the main mechanisms for Table UI manipulation
	//		on a xwt.widget.table.Table.  It represents a number of things about a column and
	//		the column's current state, including:
	//
	//		* whether the column is hidden
	//		* if the column is currently frozen or locked in the table
	//		* if the column is sortable
	//		* if it can be used for filtering purposes
	//		* whether the column can be edited or not
	//
	//		It also includes any meta information about the dojo.data.item's attribute that
	//		it represents.
	//
	//		A xwt.widget.table.Column should not be shared across cisco.tables.Table instances (although
	//		this is subject to change).
	//
	//	meta: xwt.widget.table.Meta?
	//		The corresponding meta information.  If this is a grouping, the value will be null.
	//	width: [readonly] Number
	//		The width of the column, in pixels.
	//	locked: Boolean
	//		If the column is locked or not (i.e., moveable). This is currently not supported.
	//	frozen: Boolean
	//		If the column has been "frozen" or not (i.e., Columns.lock).This is currently not supported.
	//	hidden: Boolean
	//		If the column is hidden or not.
	//	children: Array?
	//		If this column is acting as a "group", then references to the child
	//		columns are made here.
	//	sortable: Boolean?
	//		Whether this column can be sorted or not.
	//	sorted: String?
	//		Whether this column is initially sorted.  The value can be ascending, descending, or false; false is the default.
	//		If more than one column is defined as sorted, the left-most column is initially sorted.
	//	filterable: Boolean
	//		Whether this column can be used for filtering or not.
	//	editable: Boolean
	//		Whether this column's value can be edited.
	//	editWidget: xwt.widget.table.Column.__editWidgetArgs?
	//		If a custom widget is to be used for editing the contents of this column, pass an object of the form
	//		{ widget, options? }, where "widget" is the widget constructor and "options" is the optional keyword
	//		arguments object that you would pass to that constructor.
	//	label: String
	//		The column label. Could be a string, img or both.  
	//	title: String?
	//		The title for the Column. Only to be used when the label is an icon.Used at other places column is referenced.
	//	alignment: String?
	//		The horizontal alignment of the data in the column.  Can be left, center or right. Defaults to left.
	//	vAlignment: String?
	//		The vertical alignment of the data in the column.  Can be top, middle or bottom. Defaults to middle.
	//	wrapping: Boolean?
	//		Whether the cell should wrap its data or display as much of the data as it can, with an ellipsis for
	//		the parts there is not enough room to show, and use a hovering tooltip for the entire contents of the cell.  
	//		Defaults to false.
	//	formatter: Function?
	//		An optional formatter function that will be called when a row's content
	//		is rendered.
	//	collapseConfirm: xwt.widget.notification.Alert
	//		The Alert dialog to be used if the button is collapsed and the editable panel is dirty.
	
	//
	//	example:
	//		Create a new column.
	//	|	var myColumn = new xwt.widget.table.Column({
	//	|		meta: myMeta,
	//	|		width: 300,
	//	|		sortable: true,
	//	|		filterable: true,
	//	|		editable: false,
	//	|		editWidget: {
	//	|			widget: dijit.form.Select,
	//	|			options: {
	//	|				options: [ { label: "foo", value: "foo" }, { label: "bar", value: "bar" }]
	//	|			}
	//	|		},
	//	|		sorter: function(a,b){ return a >= b ? 1 : -1; }
	//	|	});
	//	|
	meta: null,
	width: 0,
	locked: false,
	frozen: false,
	hidden: false,
	children: null,
	sortable: false,
	sorted: false,
	filterable: true,
	editable: false,
	editWidget: null,
	alignment: 'left',
	vAlignment: 'middle',
	collapseConfirm: null,
	wrapping: false,
	label: "",
	title:null,

	columnType: xwt.widget.table.ColumnTypes.COLUMN,

	_columns: null,
	_index: -1,
	_groupIndex: -1,

	_containerProps: null,
	_cellProps: null,

	constructor: function(kwArgs){
		//	summary:
		//		The constructor function for the Column.
		//	kwArgs: xwt.widget.table.Column.__ctorArgs?
		//		A named arguments object that specifies the various options
		//		a Column may have.
		//	table: xwt.widget.table.Table?
		//		The table this column belongs to.
		dojo.mixin(this, kwArgs);

		if(this.children && !(this.children instanceof xwt.widget.table._ColumnGroup)){
			this.children = new xwt.widget.table._ColumnGroup(this.children, this);
		}

		if((""+this.width).lastIndexOf("%")==(""+this.width).length-1){
			this._pwidth = parseFloat(this.width, 10)/100;
		}

		if(this.editable){
		   	if(!this.editWidget){
				this.editWidget = new dijit.form.TextBox({
					name: this.label,
					value: "",
					intermediateChanges: true
				});
				this._setEditWidth = true;
			}else{
				try {
					var ctor = this.editWidget.widget, 
						opts = this.editWidget.options || {};
						opts.intermediateChanges = true; // Try to force onchange to fire more often.
					this._setEditWidth = (this.editWidget.setWidth !== undefined) ? this.editWidget.setWidth : true;
					this.editWidget = new (ctor)(opts);
				} catch(ex){
					console.warn("Edit widget on column " + this.label + " cannot be created: ", ex);
				}
			}
			this.editWidget && this.editWidget.startup && this.editWidget.startup();
		}else{
			// Create it as an uneditable widget.
                        if(!this.editWidget){
                                this.editWidget = new dijit.form.TextBox({
                                        name: this.label,
                                        value: ""
                                });
                                this._setEditWidth = true;
			}
			this.editWidget.attr("disabled", true);			
		}

		if(this._index > -1 && this._columns){
			this.createProps(this._groupIndex > -1);
		}

		if(this.editWidget){
			// We need to destroy this widget when the table is is bound to is destroyed.
			this.editWidget.connect(this._columns.table, "destroy", "destroy");
		}

	},

	setIndex: function(i){
		this._index = i;
		if(this.children){
			var last = this.children.columns.length-1;
			this.children.forEach(function(col, j){
				col._groupIndex = i;
				col.isLast = (j==last);
				col.createProps(true);
			});
		}
		this.createProps();
	},

	createProps: function(fromGroup){
		var table = this._columns.table,
			css = table._css,
			baseCellClass = css[fromGroup ? 'groupCell' : 'cell'],
			baseContainerClass = css[fromGroup ? 'groupCellContainer' : 'cellContainer'];
		var cell_props = this._cellProps = {
			cellClass: baseCellClass + ' ' + baseCellClass + '-' + this._index,
			ellipsizeStyle: '',
			cellStyle: 'text-align: ' + this.alignment + ';',
			cellRole: 'gridcell',
			cellAttrs: '',
			cellTitle: '',
			containerClass: baseContainerClass + ' ' + baseContainerClass + '-' + this._index,
			containerStyle: 'vertical-align: ' + this.vAlignment + ';',
			containerAttrs: '',
			columnIdx: this._index,
			innerHTML: '',
			title:''
		};
		if(fromGroup){
			if(this.isLast){
				cell_props.containerClass += ' ' + css.groupCellContainerLast;
			}
			cell_props.columnIdx = this._groupIndex;
			cell_props.containerAttrs = 'groupIdx="' + this._index + '"';
		}
		// disabled ellipses after UX review (harjeesi)
		if(!this.wrapping){
			cell_props.cellClass += ' ' + css["ellipsis"] + ' no-wrapping';
		}
	},

	formatter: function(data, item, store){
		//	summary:
		//		The default formatter; simply returns whatever was passed to it.
		//	description:
		//		The formatter is intended to be an override-able or definable function created
		//		with the constructor. When a Table outputs a value for a column or row
		//		intersection, this function will be called for rendering.
		//	data: Object
		//		The data of a "cell" to be formatted. This would be the result of
		//		a store's getValue function.
		//	item: dojo.data.Item
		//		The item the data belongs to.  You can use this to create special values,
		//		such as by concatenating multiple fields.
		//	store: dojo.data.api.Read
		//		The store the item belongs to.
		//	returns:
		//		The formatted data (usually a string).
		return data != null && data.toString && data.toString() || "";	//	String
	},

	_getCellContents: function(item, table){
		return this.formatter(this.attr ? table.store.getValue(item, this.attr) : item, item, table.store);
	},

	_createEditorCell: function(rowNode, table){
		//	if this column has an editor widget defined, create the cell based on it.
		if(this.children){
			dojo.forEach(this.children, function(child){
				child._createEditorCell(rowNode);
			});
		}
		var containerProps = {
			className: table._css["cellContainer"] + ' ' + table._css["cellContainer"] + '-' + this._index,
			role: "presentation",
			columnIdx: this._index,
			style: {
				"text-align": "center",
				"verticalAlign": "middle"
			}
		},
		cellProps = {
			className: table._css["cell"] + ' ' + table._css["cell"] + '-' + this._index + (!this.editable ? ' not-editable':''),
			style: {
				"textAlign": this.alignment
			}
		};
		if(this.hidden){
			containerProps.className += ' ' + table._css["hidden"];
		}
		
		// disabled ellipses after UX review (harjeesi)
		if(!this.wrapping){
			cellProps.className += ' ' + (this.editable? "": table._css["ellipsis"]) + ' no-wrapping';
		}
		var container = dojo.create("td", containerProps, rowNode);
		var cell = dojo.create("div", cellProps, container);

		//	fixme: check this
		dojo.setSelectable(cell, true);

		//	Figure out if this is proportional or not.
		var w = this.width;
		if(this._pwidth){
			var box = dojo.marginBox(table.domNode);
			w = box.w * this._pwidth;
		}
		//	make sure IE doesn't screw us up.
		w = w < 0 ? 0 : w;

		if(!isNaN(w)){
			container.style.width = (w+2) + 'px';
		}

		//	TODO: if CSS definitions change again (2010-04-21), it's likely the +4 and the -2 in the width calcs that
		//	follow will need to be addressed again (TRT)
		if(this._contentWidthDifference && dojo.boxModel != 'border-box'){
			var diff = w - this._contentWidthDifference;
			if(diff > 0){
				cell.style.width = diff + 'px';
			}
		}

		if(this.editable){
			//	TODO: figure out how to force a widget to not push out cell widths.
			if(this._setEditWidth){
				dojo.style(this.editWidget.domNode, "width", (w - (this._contentWidthDifference || 0) - 2) + "px");
				try{
					if(dojo.isFunction(this.editWidget.resize)){
						this.editWidget.resize(w-(this._contentWidthDifference || 0) - 2);
					}
				}catch(e){
					console.warn("error in resizing of edit widget.  " + e);
				}
			}
			dojo.place(this.editWidget.domNode, cell);
		}
		return container;
	},

	_createCell:function(rowIndex, builder, table, item, fromGroup){
		if(this.children && !fromGroup){
			this.children._createGroup(rowIndex, builder, table, item);
			return;
		}
		var cell_props = dojo.clone(this._cellProps);
		if(rowIndex<0){ // header
			cell_props.innerHTML = this.label;
			cell_props.cellRole = "columnheader";

			if(!this.locked){
				cell_props.containerAttrs += ' dndType="tableColumn_' + table.id + '"';
				cell_props.containerClass += (fromGroup ? '' : ' dojoDndItem');
			}else{
				cell_props.containerClass += ' locked';
			}
			cell_props.containerAttrs += ' tabIndex="-1" aria-readonly="true"';
			cell_props.cellClass += ' ' + table._css["ellipsis"] + ' no-wrapping';

			if(this.sortable){
				table._applySortProperties(this, cell_props);
			}else{
				//we need to see if a title is provided. Use the title then, otherwise use the label
				//useful when column label is an icon - CSCti46809
				var displayStr;
				if (this.title)
				{
					displayStr = this.title;
				}
				else{
					displayStr = this.label;
				}
				if(this.columnType !== xwt.widget.table.ColumnTypes.SELECTOR && 
					this.columnType !== xwt.widget.table.ColumnTypes.INDEX &&
					this.columnType !== xwt.widget.table.ColumnTypes.EXPANDER
				){
					cell_props.containerAttrs += ' title="' + displayStr.replace(/<[^>]*>/g, "").replace(/\s+/g, " ").replace(/[\r\n\t]/g, " ")  + table.l10n.notSortable + '"';
					cell_props.cellTitle = displayStr.replace(/<[^>]*>/g, "").replace(/\s+/g, " ").replace(/[\r\n\t]/g, " ")  + table.l10n.notSortable;
				}
			}

			if(this.filterable){
				cell_props.containerClass += ' filterable';
			}
		}else{
			cell_props.cellRole = "gridcell";
		}
		if(this.hidden && !fromGroup){
			cell_props.containerClass += ' ' + table._css.hidden;
		}

		if(typeof item != 'undefined'){
			var data = this._getCellContents(item, table);
			if(typeof data == 'string'){
				cell_props.innerHTML = data;
				if(!this.wrapping){
					//TODO: this gets messed up if there is markup in it
					//Fix for CSCtn63831
					if(this.columnType === xwt.widget.table.ColumnTypes.EXPANDER)
					{
						data="";
					}
					
					//cell_props.cellTitle = data.replace(/"/g, '\\"').replace(/</g, "&lt;").replace(/>/g, "&gt;");
			//		cell_props.cellTitle = data.replace(/<[^>]*>/g, "").replace(/\s+/g, " ");
				cell_props.containerAttrs += ' title="' + data.replace(/<[^>]*>/g, "").replace(/\s+/g, " ").replace(/[\r\n\t]/g, " ") + '"';
				}
				
				// harjeesi added to fix cellTitle for tooltip
				//if(cell_props.cellTitle && cell_props.cellTitle === ""){
					cell_props.cellTitle = data.replace(/<[^>]*>/g, "").replace(/\s+/g, " ").replace(/[\r\n\t]/g, " ");
					if(cell_props.cellTitle == "&nbsp;" || dojo.trim(cell_props.cellTitle) ==  ""){
						// If it is blank space, then clear it so we don't
						// get blank tooltips.
						cell_props.cellTitle = "";
					}
				//}

			}/*else{
				//TODO: figure out how to append a DOM node
				cell.appendChild(data);
			}*/
		}

		if(rowIndex<0){	// header
			if(this.sortable && this.sorted){
				table._createSortIndicator(this, cell_props);
			}
			//dojo.setSelectable(container, false);
		} else {
			//dojo.setSelectable(cell, true);
		}

		if(!isNaN(this.width)){
			cell_props.containerStyle += 'width: ' + this.width + 'px;';
		}

		if(dojo.boxModel == 'border-box' && this.columnType != xwt.widget.table.ColumnTypes.SELECTOR){
			cell_props.cellStyle += 'width: ' + this.width + 'px;';
		}else{
			if(this._contentWidthDifference){
				var diff = this.width - this._contentWidthDifference;
				if(diff > 0){
					cell_props.cellStyle += 'width: ' + diff + 'px;';
				}
			}
		}
		//Fix for CSCtn63831
		if(this.columnType === xwt.widget.table.ColumnTypes.EXPANDER)
		{
			cell_props.cellTitle="";
		}

		//	changed to match the fall-through args of Builder.
		builder.append(
			'<td class="', cell_props.containerClass, " ", table._uniqueCssId, '" role="presentation" columnidx="',
			cell_props.columnIdx, '" style="', cell_props.containerStyle, '"', cell_props.containerAttrs||''
		);
		builder.append(
			'><div class="', cell_props.cellClass, " ", table._uniqueCssId, '" role="', cell_props.cellRole, '" style="',
			cell_props.cellStyle, '" title="', cell_props.cellTitle
		);
		builder.append(
			'"', cell_props.cellAttrs, '>', cell_props.innerHTML, '</div></td>'
		);
	},

	_replaceCell: function(cellNode, table, item, fromGroup){
		if(this.children && !fromGroup){
			this.children._replaceGroup(cellNode, table, item);
			return;
		}

		var cn = cellNode.className;
		if(xwt.widget.table.ellipsizeCells){
			cellNode.className = dojo.trim((" " + cn + " ").replace(/ ellipsis /g, ' ellipsis-not-done '));
		}
		if(typeof item != 'undefined'){
			var data = this._getCellContents(item, table);
			if(typeof data == 'string'){
				cellNode.innerHTML = data;
				if(!this.wrapping){
					//TODO: this gets messed up if there is markup in it
					//cell_props.cellTitle = data.replace(/"/g, '\\"').replace(/</g, "&lt;").replace(/>/g, "&gt;");
				}
			}
		}
		cellNode = null;
	},

	_ellipsize: (function(){
		var s = dojo.doc.documentElement.style;
		// Feature detection for text-overflow
		if(!('textOverflow' in s || 'OTextOverflow' in s)){
			// Feature detection for XUL bindings
			if('MozBinding' in s){
				s = null;
				var binding = dojo.moduleUrl('xwt.widget.table', 'resources/ellipsis.xml');
				return function(cell_props){
					cell_props.ellipsizeStyle = ' -moz-binding: url(' + binding.uri + '#ellipsis);';
				};
			}
		}
		// Either ellipsis is natively supported, or there isn't a way
		// to bind XUL to the node.
		s = null;
		return null;
	})(),

	_getHeaderNode: function(){
	}
});

dojo.declare("xwt.widget.table.IndexColumn", xwt.widget.table.Column, {
	//	summary:
	//		A specialized column that is intended to serve as the left-most
	//		column, with the content being a row index.
	//
	//	description:
	//		An index column is similar to the type of left-most column seen in common
	//		spreadsheet programs, such as Excel or Numbers. It shows the current
	//		row index for a record.  In addition, an index column may be designated as
	//		"draggable", for drag-and-drop row reordering.  You do not create this
	//		column directly; definitions on an xwt.widget.table.Table will handle this
	//		for you.

	columnType: xwt.widget.table.ColumnTypes.INDEX,
	_dragHandleWidth: 16,

	constructor: function(kwArgs){
		kwArgs.locked = true;
		kwArgs.vAlignment = 'middle';
		kwArgs.alignment = 'right';
		kwArgs.hidden = false;
		kwArgs.sortable = false;
		kwArgs.filterable = false;
		kwArgs.editable = false;
		kwArgs.wrapping = false;
		kwArgs.label = "&nbsp;";
		kwArgs.formatter = (function(table){
			return (function(item){
				var id = table.store.getIdentity(item), out = '&nbsp;';
				if("_rowIndex" in this){
					out = this._rowIndex + 1;
				}else{
					out = table._idToIndex[id] + 1;
				}
				return "<table class=\"row-index-table\"><tbody><tr class=\"row-index-table-container\">" + 
						(table.store.orderAttribute && table.moveTo ? '<td class=\"row-index-table-gripper-cell\"><div class="dojoDndHandle"></div></td>':'') +
						"<td class=\"row-index-table-index-cell\">" + out + "</td></tr></tbody></table>";
	// Old way, removed to use the above table for 'centering'  
	//			return (table.store.orderAttribute && table.moveTo ? '<div class="dojoDndHandle"></div>':'')
	//				+ '<span>' + out + '</span>';
			});
		})(kwArgs._columns.table);
		
		// We need to watch for row count changes and update the width if it changes.
		var table = this._columns.table;
		if(table){
			table.connect(table, "onRowCountUpdate", dojo.hitch(this, function(count){
				try{
					var n = count.toString(10),
						m = dojox.html.metrics.getCachedFontMeasurements();
					var w = Math.round((m["1ex"] * (n.length+1)) + (table.store.orderAttribute && table.store.moveTo ? this._dragHandleWidth : 0) + 8);
					if(w != this.width && w > 0){
						// Resize it!
						this._columns.resize(this, w);
					}
				}catch(e){
					console.log(e);
				}
			}));
		}
		this.inherited(arguments, [ kwArgs ]);
	},

	createProps: function(fromGroup){
		var table = this._columns.table,
			css = table._css,
			baseCellClass = css['cell'],
			baseContainerClass = css['cellContainer'];
		var cell_props = this._cellProps = {
			cellClass: baseCellClass + ' ' + baseCellClass + '-' + this._index,
			ellipsizeStyle: '',
			cellStyle: 'text-align: ' + this.alignment + ';',
			cellRole: 'gridcell',
			cellAttrs: '',
			cellTitle: '',
			containerClass: baseContainerClass + ' ' + baseContainerClass + '-' + this._index,
			containerStyle: 'vertical-align: ' + this.vAlignment + ';',
			containerAttrs: '',
			columnIdx: this._index,
			innerHTML: ''
		};
		cell_props.containerClass += ' row-index';
	},

	_createCell:function(rowIndex, builder, table, item, fromGroup){
		this._rowIndex = rowIndex;
		if(!this.width){
			//	TODO: cache the total row count, check to see if it is a different order of magnitude, and then force a header re-render?
			var n = table._totalRows.toString(10),
				m = dojox.html.metrics.getCachedFontMeasurements();

			this.width = Math.round((m["1ex"] * (n.length+1)) + (table.store.orderAttribute && table.store.moveTo ? this._dragHandleWidth : 0) + 8);
		}
		this.inherited(arguments);
	}	
});

dojo.declare("xwt.widget.table.SelectorColumn", xwt.widget.table.Column, {
	//	summary:
	//		A specialized column that represents the selector for a table using
	//		the input selection model.
	//
	//	description:
	//		A selector column is a preset column automatically created during
	//		xwt.widget.table.Table creation to handle an "input" selection model.
	//		You do not have to create this directly (and probably should not).

	columnType: xwt.widget.table.ColumnTypes.SELECTOR,

	constructor: function(kwArgs){
		//	Reset/hardcode what we need; make sure that the kwArgs include whether or not multiple selection
		//	is to be done, and if there's a select all option.
		kwArgs.locked = true;
		kwArgs.vAlignment = 'middle';
		kwArgs.alignment = 'center';
		kwArgs.hidden = false;
		kwArgs.sortable = false;
		kwArgs.filterable = false;
		kwArgs.editable = false;
		kwArgs.wrapping = false;

		var multiple = kwArgs.selectOptions && kwArgs.selectOptions.multiple || false, 
			selectAll = kwArgs.selectOptions && kwArgs.selectOptions.selectAllOption || false;

		var type = (multiple ? "checkbox" : "radio");
		var tClass = (multiple ? "dijitCheckBox" : "dijitRadio");
		var sClass = tClass + "Checked";
		var dClass = tClass + "Disabled";
			
		kwArgs.label = '<div class="dijitCheckBox"" style="visibility:' 
			+ (multiple && selectAll ? 'visible' : 'hidden') + '"><input type="' 
			+ (multiple ? 'checkbox' : 'radio') + '" class="select-all" style="visibility:' 
			+ (multiple && selectAll ? 'visible' : 'hidden') + '"  /></div>';
		kwArgs.formatter = (function(table){
			return (function(item){
				var selected = table.isSelected(item);
				var selectable = table.isSelectable(item);
				return '<div class="' + tClass + (selected? " " + sClass : "") + 
					(selectable ? '' : ' ' + dClass+ ' dijitDisabled') + 
					'"><input type="' + type + '" ' +
					(selectable ? '' : 'disabled="true" ') + 
					(selected ? "checked " : "") +
					'class="selection-input" /></div>';
			});
		})(kwArgs._columns.table);
		this.inherited(arguments, [kwArgs]);
		this.columnType = xwt.widget.table.ColumnTypes.SELECTOR;
	},

	createProps: function(){
		// summary:
		//	Over-ridden property creator to allow inclusion of a selector 
		//	class name.
		this.inherited(arguments);
		if(this._cellProps && this._cellProps.cellClass){
			this._cellProps.cellClass += " cell-selector";
			this._cellProps.containerClass += " cell-selector";
		}
	}
});

dojo.declare("xwt.widget.table.ExpanderColumn", xwt.widget.table.Column, {
	//	summary:
	//		A specialized column that represents the control to open up hidden
	//		detail panels within an xwt.widget.table.Table that supports detail
	//		inlays (whether read-only, editable, or a mix of both types).
	//
	//	description:
	//		An expander column is a small, non-resizable or movable column that
	//		contains the toggle control to show or hide hidden detail inlay
	//		panels within a table.  You do not create this column directly,
	//		but instead provide a table with widget references to handle the
	//		display of details for a particular item in a table.
	//
	//		Note that this object has a "mode", which you get or set with the "mode"
	//		method.  Possible modes are "read" and "edit".

	columnType: xwt.widget.table.ColumnTypes.EXPANDER,

	//	properties to track state and item
	_item: null,
	_widget: null,
	_mode: "read",
	_rowHeight: 0,

	constructor: function(kwArgs){
		kwArgs = kwArgs || {};
		//	NOTE: Pass a reference to the table's detailWidget with the keyword arguments!
		if(!kwArgs.widget){
	//		throw new Error("xwt.widget.table.ExpanderColumn.constructor: a widget definition MUST be passed to create this column!");
		}

		kwArgs.width = 20;
		kwArgs.locked = true;
		kwArgs.vAlignment = 'middle';
		kwArgs.alignment = 'center';
		kwArgs.hidden = false;
		kwArgs.sortable = false;
		kwArgs.filterable = false;
		kwArgs.editable = false;
		kwArgs.wrapping = false;
		kwArgs.label = "&nbsp;";
		kwArgs.formatter = function(item){
			return '<div class="cell-expander" title="Expand"></div><span class="cell-expandera11y" title="">V/></span>';
		};
		this.inherited(arguments, [ kwArgs ]);
		this.columnType = xwt.widget.table.ColumnTypes.EXPANDER;
		this._widget = kwArgs.widget;

		//	Set up our handler.
		//	We do the click handler on the table body, so that we don't have to worry about setting up a slew of handlers.
		var connects = [];
		connects.push(dojo.connect(this._columns.table.tableBody, "onclick", this, "_onClick"));
		connects.push(dojo.connect(this._columns.table, "onRender", this, function(){
			if(this._item){ this._expandRow(this._item); }
		}));
		var cleanC = dojo.connect(this._columns.table, "destroy", function(){
			dojo.disconnect(cleanC);
			dojo.forEach(connects, function(c) {
				dojo.disconnect(c);	
			});
		});
		var evts = ["onResize", "onShow", "onHide"];
		dojo.forEach(evts, function(evt){
			// More connection cleanup.
			var cc = [];
			cc.push(dojo.connect(this._columns, evt, this, function(){
				if(this._item){ this._expandRow(this._item); }
			}));
			var ccc = dojo.connect(this._columns.table, "destroy", function(){
				dojo.disconnect(ccc);
				dojo.forEach(cc, function(hdl){
					dojo.disconnect(hdl);
				});
			});
		}, this);

		//	Add a couple of convenience methods to the table itself.
		this._columns.table.expanded = dojo.hitch(this, function(){
			return this.expanded();
		});
		this._columns.table.getExpander = dojo.hitch(this, function(){
			return this;
		});
		this._columns.table.expandable = function(){
			return true;
		};

		/*
		setTimeout(dojo.hitch(this, function(){
			if(this._columns.table.onEditorClose){
				dojo.connect(this._columns.table, "onEditorClose", dojo.hitch(this, function(){
					if(this.expanded()){
						this.mode("read");
						this._expandRow(this._item);
					}
				}));
			}
		}), 0);
		*/
	},
	createProps: function(fromGroup){
		var table = this._columns.table,
			css = table._css,
			baseCellClass = css['cell'],
			baseContainerClass = css['cellContainer'];
		var cell_props = this._cellProps = {
			cellClass: baseCellClass + ' ' + baseCellClass + '-' + this._index + ' ' + 'cell-row-expander',
			ellipsizeStyle: '',
			cellStyle: 'text-align: ' + this.alignment + ';',
			cellRole: 'gridcell',
			cellAttrs: '',
			cellTitle: '',
			containerClass: baseContainerClass + ' ' + baseContainerClass + '-' + this._index,
			containerStyle: 'vertical-align: ' + this.vAlignment + ';',
			containerAttrs: '',
			columnIdx: this._index,
			innerHTML: '',
			title:''
		};
		cell_props.containerClass += ' row-expander';
	},

	_createEditorCell: function(rowNode, table){
		var container = this.inherited(arguments);
		dojo.addClass(container.firstChild, "expander");
		return container;
	},

	mode: function(mode){
		//	summary:
		//		Change the mode of the expander column, or get the current mode.
		//	mode: String?
		//		The expander mode to be set.  Supports "read" and "edit".
		//	returns: String
		//		The current mode of the column.
		if(mode === undefined){ 
			return this._mode; //	String
		}
		var test = this._mode;
		this._mode = (mode == "edit") ? mode : "read";
		if(this._widget && this._widget.mode){
			this._widget.mode(mode);
		}
		if(test != this._mode && this._item){
			this._expandRow(this._item);
		}
		return this._mode;	//	String
	},
	expanded: function(){
		//	summary:
		//		Check to see if we are expanded or not.
		return (this._item != null);
	},
	_expandRow: function(item){
		//	Place the detail widget in either our widget placeholder or the row editor,
		//	and set our current item and row height.
		// console.warn("EXPANDROW");
		var table = this._columns.table, row, editor;
		var idx = table._idToIndex[table.store.getIdentity(item)];
		if(this._mode == "edit"){
			editor = table._editor.inline;
		}
		row = dojo.query("." + table._css.row + "-" + idx + "." + table._uniqueCssId, table.tableBody)[0];
		if(!row){ return; }
		
		//if in edit mode, check to see which twisty was clicked
		//proceed only if the same row's twisty is clicked
		//otherwise ignore - CSCti75018
		if (table.editing && table.editing())
		{
			//if editing, check if the twistie of the same column was clicked or not
			if (table._editor.item != item) {
				console.log("editing in progress. cannot expand");
				return ;
			}
		}				

		dojo.addClass(row, "row-expanded");

		// Locate the actual table and height the row based on it.  Is this a problem later?
		// Otherwise, the table keeps growing.  May need to fix later.
		var tableRow = dojo.query("table.row-table", row)[0];
		var page = Math.floor(idx / table.rowsPerPage),
			ph = table._pageHeights[page],
			rowBox = dojo.position(tableRow);

		var indexCol = this._columns.get(0),
			test = indexCol.columnType == xwt.widget.table.ColumnTypes.INDEX;
		if(test){
			if(!this.__indexHolder){
				this.__indexHolder = dojo.create("div", {
					className: "row-index index-holder",
					style: "float: left; width: " + indexCol.width + "px;"
				});
				if(dojo.isIE < 8){
					// IE 7 doesn't seem to set them using dojo.create,
					// so forcibly set it.
					dojo.style(this.__indexHolder, {
						"width": indexCol.width + "px",
						"float": "left"
					});
				}
			}
		}

		if(!this.__widgetHolder){
			var args = { className: "widget-holder" };
			if(test){ args["style"] = "margin-left: " + (indexCol.width + 2) + "px"; }
			this.__widgetHolder = dojo.create("div", args);
		}

		//	cache our item and current row height.
		if(this._item != item){
			this._rowHeight = rowBox.h;
			this._item = item;
		}
		if(test){ dojo.place(this.__indexHolder, row); }
		dojo.place(this.__widgetHolder, row);

		var values = xwt.widget.table.util.getValueObject(table.store, item), 
			expandHeight = 200, widgetBox;	
			
		if(this._widget){
			// Temp assign a reference to the detail widget back to the table so that columns and editWidgets in the inline
			// editor can be accessed.
			this._widget.table = table;
			dojo.place(this._widget.domNode, (this._mode=="edit" ? table._editor.inline : this.__widgetHolder));
			this._widget.mode(this._mode);
			this._widget.setValues(values, item, table.store);
			dojo.addClass(this._widget.domNode, 'row-editor-expandPane');			
			dojo.style(this._widget.domNode, "display", "");

			//	Measure it up and make sure it can be displayed.
			widgetBox = dojo.marginBox(this._widget.domNode);
			expandHeight = widgetBox.h;
		}

		dojo.style(row, "height", (expandHeight + this._rowHeight) + "px");
		if(this.__indexHolder){
			dojo.style(this.__indexHolder, "height", expandHeight + "px");
		}
		if(!editor){
			cellExpDiv=dojo.query(".cell-expander", row);
			cellExpDiv.addClass("expanded");
			cellExpDiv.attr("title","Collapse");
			
		} else {
			cellEditExpDiv=dojo.query(".cell-expander", table._editor.inline)
			cellEditExpDiv.addClass("expanded");
			cellEditExpDiv.attr("title", "Collapse");
		}

		//table._updatePageHeight(page, ph + expandHeight, true);
		table._invalidatePageHeights();
		//table._repositionPages();
		dijit.scrollIntoView(row);

		this.onExpand(this._item, row);
	},
	
	_changeHeight:function(newHeight)
	{
		var table = this._columns.table, row, editor;
		var idx = table._idToIndex[table.store.getIdentity(this._item)];
		
		row = dojo.query("." + table._css.row + "-" + idx + "." + table._uniqueCssId, table.tableBody)[0];
		if(!row){ return; }
		

		var page = Math.floor(idx / table.rowsPerPage),
			ph = table._pageHeights[page];
		
		dojo.style(row, "height", (newHeight + this._rowHeight) + "px");
		
		if(this.__indexHolder){
			dojo.style(this.__indexHolder, "height", (newHeight + this._rowHeight) + "px");
		}

			
		//table._updatePageHeight(page, ph + newHeight, true);
		table._invalidatePageHeights();
		//table._repositionPages();
		//dijit.scrollIntoView(row);
		
	},
	_collapseRow: function(/*dojo.data.Item*/ item){
		//	restore any existing opened rows to the original state.
		//console.warn("COLLAPSEROW");		
		
		var table = this._columns.table;
		item = item || this._item;

		var idx = table._idToIndex[table.store.getIdentity(item)],
			row = dojo.query("." + table._css.row + "-" + idx + "." + table._uniqueCssId, table.tableBody)[0];
		if(row){
			dojo.removeClass(row, "row-expanded");
			var page = Math.floor(idx / table.rowsPerPage),
				ph = table._pageHeights[page],
				rowBox = dojo.position(row);

			if(this._widget){
				this._widget.domNode.parentNode && this._widget.domNode.parentNode.removeChild(this._widget.domNode);
			}
			if(this.__indexHolder){
				this.__indexHolder.parentNode && this.__indexHolder.parentNode.removeChild(this.__indexHolder);
			}
			if(this.__widgetHolder){
				this.__widgetHolder.parentNode && this.__widgetHolder.parentNode.removeChild(this.__widgetHolder);
			}
			dojo.style(row, "height", this._rowHeight + "px");
			table._updatePageHeight(page, ph - (rowBox.h - this._rowHeight), true);
			//reverting the change because rows are gobbled up with this.CSCtn72198
			table._invalidatePageHeights(); 
			//table._repositionPages();
			
			//	Restore the icon correctly.
			dojo.query(".expanded", row).attr("title","Expand");
			dojo.query(".expanded", row).removeClass("expanded");
			dojo.query(".row-editor .expanded", table.tableContainer).attr("title","Expand");
			dojo.query(".row-editor .expanded", table.tableContainer).removeClass("expanded");
			var tb = dojo.query(".row-editor .expanded", table.tableContainer).removeClass("expanded");
			
			//dojo.query(".cell-expander", table._editor.inline).attr(title, "Expand");
			
		}

		var item = this._item;
		this._rowHeight = 0;
		this._item = null;
		this.onCollapse(item, row);
		item = null;
	},
	_onClick: function(e){

		if(dojo.hasClass(e.target, "cell-expander")||dojo.hasClass(e.target, "cell-expandera11y")){
			//console.warn("COLUMN ONCLICK");
			var p = e.target, table = this._columns.table, row, editor;

			while(p && dojo.attr(p, "rowindex") == null){
				// Have to compare to null, as IE returns number zero instead of "0"
				// which would fail it on the first row.
				p = p.parentNode;
			}
			if(!p){ return; }
			if(dojo.hasClass(p, "row-editor")){
				editor = p;
				row = dojo.query(".row-" + dojo.attr(p, "rowindex") + "." + table._uniqueCssId, table.tableBody)[0];
				//this.mode("edit");
			} else {
				row = p;
				//this.mode("read");
			}
			
			var idx = dojo.attr(row, "rowindex"), 
				item = table._indexToItem[idx];
				
		//if in edit mode, check to see which twisty was clicked
		//proceed only if the same row's twisty is clicked
		//otherwise ignore - CSCti75018
		if (table.editing && table.editing())
		{
			//if editing, check if the twisty of the same column was clicked or not
			if (table._editor.item != item) {
				console.log("editing in progress. cannot expand another row");
				return this;
			}
		}	
		
		//set the mode now, after checking for editing above.
		//because setting the mode expands the row so we cannot do it earlier.
		if(dojo.hasClass(p, "row-editor")){
			this.mode("edit");
		}
		else
		{
			this.mode("read");
		}
		
			if(this._item){
				//	collapse the previous row
				var prev = this._item;			
				if((this._mode==="edit") && (table._editor.dirty))
				{
					this.collapseConfirm = new xwt.widget.notification.Alert({
						messageType: "warning",
						dontShowAgainOption: false,
						buttons: [
							{ 
								label: "OK",
								baseClass:"defaultButton",
								onClick: dojo.hitch(this, function(){
								this.collapseConfirm.hide();
								table.getExpander()._collapseRow();
								
								})
							},
							{ 
								label: "Cancel",
								baseClass:"xwt-TextButton",
								onClick: dojo.hitch(this, function(){
									this.collapseConfirm.hide();
								})
							}
						]
					});
				

				this.collapseConfirm.setDialogContent('<div>You will lose your changes if any, on collapsing this row. Do you want to continue?</div>');
				}
				else
				{
					table.getExpander()._collapseRow();
				}
				
				
				if(prev == item){
					//	we just toggled the same item, so go away.
					return;	//	we're done.
				}
			}
			this._expandRow(item);
		}
	},
	//	events
	onExpand: function(item, row){
		//	summary:
		//		Stub function for when an item is expanded.
		//	item: dojo.data.Item
		//		The item which is being expanded.
		//	row: DOMNode
		//		The row which is being expanded.
		
		this._columns.table.onRowExpand(item, row);
	},
	
	onCollapse: function(item, row){
		//	summary:
		//		Stub function for when an item is collapsed.
		//	item: dojo.data.Item
		//		The item which is being collapsed.
		//	row: DOMNode
		//		The row which is being collapsed.
		this._columns.table.onRowCollapse(item, row);
	}
});

dojo.declare("xwt.widget.table._ColumnGroup", null, {
	parent: null,
	columns: [],

	_groupContainerProps: null,
	_groupCellProps: null,

	constructor: function(columns, parent){
		this.parent = parent;
		var cols = parent._columns,
			last = columns.length-1;
		this.columns = dojo.map(columns, function(column, i){
			if(column instanceof xwt.widget.table.Column){
				column._columns = cols,
				column._index = i;
				column._groupIndex = parent._index;
				column.isLast = (i==last);
				column.createProps(true);
				return column;
			}else{
				return new xwt.widget.table.Column(dojo.mixin(column, {
					_columns: cols,
					_index: i,
					_groupIndex: parent._index,
					isLast: (i==last)
				}));
			}
		});

		if(parent._index > -1){
			this.createProps();
		}
	},

	createProps: function(){
		var column = this.parent,
			table = column._columns.table,
			css = table._css;
		var group_cell_props = this._groupCellProps = {
			cellClass: css.cell + ' ' + css.cell +  '-' + column._index,
			cellStyle: 'text-align: ' + column.alignment + ';',
			cellAttrs: '',
			containerClass: css.cellContainer + ' ' + css.cellContainer + '-' + column._index,
			containerStyle: 'vertical-align: ' + column.vAlignment + ';',
			columnIdx: column._index,
			innerHTML: ''
		};
		if(!column.locked){
			group_cell_props.containerClass += ' dojoDndItem';
		}
	},

	forEach: function(/* Function */func, /*Object? */ scope){
		//	summary:
		//		Implement an iterator for our columns.
		var columns = this.columns;
		for(var i=0, column; column=columns[i]; i++){
			func.call(scope, column, i);
		}
	},

	get: function(/* Number */index){
		//	summary:
		//		Get the column at the specified index.
		return this.columns[index];	//	xwt.widget.table.Column
	},

	_createGroup: function(rowIndex, builder, table, item){
		var column = this.parent;
		var _css = table._css;
		var cell_props = dojo.clone(this._groupCellProps);
		var strings = [
			'<td class="', cell_props.containerClass, '" role="presentation" columnidx="',
			cell_props.columnIdx, '" style="', cell_props.containerStyle,
			'"><table border="0" cellspacing="0" cellpadding="0" class="', cell_props.cellClass,
			'" role="presentation" style="', cell_props.cellStyle, '"', cell_props.cellAttrs||'',
			'><tbody><tr>'
		];

		if(rowIndex<0){
			strings.splice(strings.length, 0,
				'<td colspan="', this.columns.length, '" class="', _css.groupCellContainer, ' ',
				_css.groupLabelContainer, '" columnIdx="', column._index, '"><div class="',
				_css.groupCell, ' ', _css.groupLabel, '">', column.label, '</div></td></tr><tr class="group-row">'
			);
		}
		builder.append(strings.join(""));

		for(var i=0, col; col=this.columns[i]; i++){
			col._createCell(rowIndex, builder, table, item, true);
		}
		builder.append('</tr></tbody></table></td>');
	},

	_replaceGroup: function(cellNode, table, item){
		var groupCells = cellNode.rows[0].cells;

		for(var i=0, col; col=this.columns[i]; i++){
			col._replaceCell(groupCells[i].firstChild, table, item);
		}
	}
});

dojo.declare("xwt.widget.table.Columns", null, {
	//	summary:
	//		A collection of columns.  There should only be one Columns object
	//		per Table.
	//	description:
	//		The xwt.widget.table.Columns class represents a set of Columns on a given
	//		table. It is a collection that the Table uses to deal with vertical
	//		operations, such as showing or hiding columns, locking columns, resizing
	//		them, and more.	There is only one Columns object per Table (i.e., a one-to-one 
	//		mapping), and the expectation is that *all* possible columns (regardless 
	//		of whether they are to be displayed or not) are defined when creating an instance
	//		of this collection. If the expectation for usage is to be able to have
	//		a number of hidden columns that can be shown later, then make sure the
	//		column to be hidden is marked as such before adding it to this collection,
	//		or make those adjustments before calling a table's initial rendering.
	//
	//		Note that most of the methods of this class are designed so that they can be chained.
	//
	//	example:
	//	|	myColumns.lock(col1)
	//	|		.borders(true)
	//	|		.hide(col4);
	//

	_borders: false,

	constructor: function(/* xwt.widget.table.Column[] */cols, /* xwt.widget.table.Table */table, /* Boolean? */borders, /* Boolean? */showLast){
		//	summary:
		//		Initialize the columns structure.
		//	cols: xwt.widget.table.Column[]
		//		The array of columns to be rendered in a Table.
		//	table: xwt.widget.table.Table
		//		The table this object belongs to.
		//	borders: Boolean?
		//		Show or hide column borders (left/right).  Defaults to false.
		//	showLast: Boolean?
		//		Show or hide the last border (rightmost).  Defaults to false.
		//	example:
		//		Create a column set, with borders but without showing the last border:
		//	|	var columns = new xwt.widget.table.Columns(colArray, true);
		//	example:
		//		Create a column set, no borders:
		//	|	var columns = new xwt.widget.table.Columns(colArray);
		this.table = table;

		var self = this;
		this.columns = dojo.map(cols, function(column, i){
			if(column instanceof xwt.widget.table.Column){
				column._columns = self;
				column.setIndex(i);
				return column;
			}else{
				var args = dojo.mixin(column, {
					_index: i,
					_columns: self
				});
				var ctor = xwt.widget.table.Column;
				if(args && args.columnType){
					switch(args.columnType){
						case xwt.widget.table.ColumnTypes.INDEX:
							ctor = xwt.widget.table.IndexColumn; break;
						case xwt.widget.table.ColumnTypes.SELECTOR:
							ctor = xwt.widget.table.SelectorColumn; break;
						case xwt.widget.table.ColumnTypes.EXPANDER:
							ctor = xwt.widget.table.ExpanderColumn; break;
					}
				}
				return new ctor(args);
			}
		});

		this._borders = borders;
		this._showLast = showLast;
	},

	forEach: function(/* Function */func, /* Object? */scope){
		//	summary:
		//		Implement an iterator for our columns.
		var columns = this.columns;
		for(var i=0, column; column=columns[i]; i++){
			func.call(scope, column, i);
		}
	},

	get: function(/* Number */index){
		//	summary:
		//		Get the column at the specified index.
		return this.columns[index];	//	xwt.widget.table.Column
	},

	getByLabel: function(/* String */label){
		//	summary:
		//		Get the column with the given label.
		for(var i=0, l=this.columns.length; i<l; i++){
			if(this.columns[i].label == label){
				return this.columns[i];	//	xwt.widget.table.Column
			}
		}
		return null;
	},

	getByAttribute: function(/* String */attr){
		//	summary:
		//		Get the column that represents the given attribute.
		for(var i=0, l=this.columns.length; i<l; i++){
			if(this.columns[i].attr == attr){
				return this.columns[i];	//	xwt.widget.table.Column
			}
		}
		return null;
	},

	getByNode: function(/* DOMNode */ node, /* Integer? */ pos){
		// summary:
		//     Get the column that "node" points to or that contains "node".  If "pos" is given,
		//     it will take into account the mouse position.
		var columnIdx = parseInt(dojo.attr(node, 'columnIdx'), 10);

		while(isNaN(columnIdx) && node.parentNode){
			node = node.parentNode;
			columnIdx = parseInt(dojo.attr(node, 'columnIdx'), 10);
		}
		if(isNaN(columnIdx)){
			return null;
		}

		var groupIdx = null;
		if(typeof pos != 'undefined' && pos < 4){
			columnIdx -= 1;
		}else{
			groupIdx = parseInt(dojo.attr(node, 'groupIdx'), 10);
		}

		var column = this.get(columnIdx);
		if(!isNaN(groupIdx) && groupIdx !== null){
			column = column.children.get(groupIdx);
		}
		return column;
	},

	_haveFrozen: function(){
		//	summary:
		//		Find out if any columns are frozen.  Note that we ignore the
		//		selector column (if present), since that automatically gets frozen
		//		if there are other frozen columns.
		for(var i=0, col; col = this.get(i); i++){
			if(col.columnType == xwt.widget.table.ColumnTypes.COLUMN && col.frozen){
				return true;
			}
		}
		return false;
	},

	//	column freezing
	freeze: function(/* xwt.widget.table.Column */column){
		//	summary:
		//		Freeze the given column.
		//	column: xwt.widget.table.Column
		//		The column to be frozen to the left side of the table.
		//	returns:
		//		'this' to allow for functional chaining.
		console.log("Locking ", column.label);
		if(!this._haveFrozen()){
			//	TODO: the cloning table setup is to happen here.
		}

		//	cache the old index for unlocking.
		column._oldIndex = column._index;

		//	Get the last locked index and move this column to the next one.
		for(var i=0, col; col = this.get(i); i++){
			console.log("Is column[" + i + "] locked? ", col, col.frozen);
			if(col.columnType == xwt.widget.table.ColumnTypes.COLUMN && !col.frozen){
				break;
			}
		}
		this.move(column, i);
		column.frozen = true;
		//	Cache the old locked setting (unmoveable).
		column._oldLocked = column.locked;
		column.locked = true;

		this.onFreeze(column);
		return this;	//	xwt.widget.table.Columns
	},
	unfreeze: function(/* xwt.widget.table.Column */column){
		//	summary:
		//		Unfreeze the given column.
		//	column: xwt.widget.table.Column
		//		The column to unfreeze. Unfreezing a column will attempt to restore the
		//		original column position.
		//	returns:
		//		'this' to allow for functional chaining.
		console.log("Unlocking ", column.label);
		column.locked = column._oldLocked || false;
		column.frozen = false;
		if("_oldLocked" in column){
			delete column._oldLocked;
		}

		if("_oldIndex" in column){
			//	move it back to the original position
			console.log("The old index is: ", column._oldIndex);
			this.move(column, column._oldIndex + 1);
			delete column._oldIndex;
		}

		//	Check to see if this is the last column to be unlocked, and if so, do the work involved.
		var stillFrozen = this._haveFrozen();
		if(!stillFrozen){
			//	TODO: the stuff we need to do to revert the cloned table elements back out of the rendering.
		}
		this.onUnfreeze(column);
		return this;	//	xwt.widget.table.Columns
	},

	lock: function(/* xwt.widget.table.Column */column){
		//	summary:
		//		Lock the given column (i.e., make it so that it is not movable or re-orderable).
		//	column: xwt.widget.table.Column
		//		The column to be locked in position.
		//	returns:
		//		'this' to allow for functional chaining.
		var header = dojo.query(".cell-container-" + column._index, this.table.tableHead)[0];
		if(header){
			column.locked = true;
			dojo.removeAttr(header, 'dndType');
			dojo.removeClass(header, 'dojoDndItem');
			dojo.addClass(header, 'locked');
			this.onLock(column);
		}
		return this;	//	xwt.widget.table.Columns
	},
	unlock: function(/* xwt.widget.table.Column */column){
		//	summary:
		//		Unlock the given column (i.e., make it so that it is movable or re-orderable).
		//	column: xwt.widget.table.Column
		//		The column to be unlocked.
		//	returns:
		//		'this' to allow for functional chaining.
		var header = dojo.query(".cell-container-" + column._index, this.table.tableHead)[0];
		if(header){
			column.locked = false;
			dojo.attr(header, 'dndType', 'tableColumn_' + this.table.id);
			dojo.removeClass(header, 'locked');
			dojo.addClass(header, 'dojoDndItem');
			this.onUnlock(column);
		}
		return this;	//	xwt.widget.table.Columns
	},

	//	visuals
	borders: function(/* Boolean */show, /* Boolean? */last){
		//	summary:
		//		Turn column borders on or off.
		//	show: Boolean
		//		Turn the borders on or off.
		//	last: Boolean?
		//		Whether or not to show the last border (rightmost).  Defaults to false.
		//	returns:
		//		'this' to allow for functional chaining.

		var css = this.table._css;
		dojo.toggleClass(this.table.tableBody, css.columnBorders, show);
		dojo.toggleClass(this.table.tableBody, css.columnLastBorder, !!last);

		//	Keep track of whether the borders are on or not.
		this._borders = show;
		this.table.resize();
		return this;	//	xwt.widget.table.Columns
	},

	//	column handling
	show: function(/* xwt.widget.table.Column */column, /* Number? */index){
		//	summary:
		//		Show the given column at optional index. If index is not passed,
		//		it will be shown at the end of the given column set.
		//	column: xwt.widget.table.Column
		//		The column to show.
		//	index: Number?
		//		The place at which the column is to appear.  If not passed, the column
		//		will be placed to the right of any other columns.
		//	returns:
		//		'this' to allow for functional chaining.
		if(column.hidden){
			column.hidden = false;
			dojo.query(".cell-container-" + column._index + "." + this.table._uniqueCssId, this.table.domNode).removeClass(this.table._css.hidden);
			this.table.resize();
			this.onShow(column);
		}
		return this;	//	xwt.widget.table.Columns
	},
	hide: function(/* xwt.widget.table.Column */column){
		//	summary:
		//		Hide the given column.
		//	column: xwt.widget.table.Column
		//		The column to hide.
		//	returns:
		//		'this' to allow for functional chaining.
		if(!column.hidden){
			column.hidden = true;
			dojo.query(".cell-container-" + column._index + "." + this.table._uniqueCssId, this.table.domNode).addClass(this.table._css.hidden);
			this.table.resize();
			this.onHide(column);
		}
		return this;	//	xwt.widget.table.Columns
	},
	move: function(/* xwt.widget.table.Column */column, /* Number */index){
		//	summary:
		//		Move the given column to the corresponding column index.
		//	column: xwt.widget.table.Column
		//		The column to be reordered (i.e., dragged to a new place).
		//	index: Number
		//		The index to which the column is to be moved.
		//	returns:
		//		'this' to allow for functional chaining.
		var colIndex = column._index,
			cols = this.columns,
			index = colIndex < index ? index - 1 : index;
		if(colIndex != index){
			var shiftCol = cols[index];
			// Make SURE we're not dropping in from/replacing an expander, selecter, or index column!
			if(shiftCol && 
				shiftCol.columnType != xwt.widget.table.ColumnTypes.COLUMN){
				// It's an index, expander, selector, etc., so skip it.  We can't move before them.
				return;
			} 

			cols.splice(colIndex, 1);
			cols.splice(index, 0, column);
			var max=(colIndex>index?colIndex:index),
				min=(colIndex<index?colIndex:index);
			for(;min<=max;min++){
				cols[min]._index = min;
				if(cols[min].children){
					cols[min].children.createProps();
					cols[min].children.forEach(function(col){
						col._groupIndex = min;
						col.createProps(true);
					});
				}
				cols[min].createProps();
			}
		}
		this.onMove(column, colIndex, index);
		return this;	//	xwt.widget.table.Columns
	},
	resize: function(/* xwt.widget.table.Column */column, /* Number */width, /* Boolean? */ dontResizeGroup){
		//	summary:
		//		Resize the column to the given width.
		//	column: xwt.widget.table.Column
		//		The column to be resized
		//	width: Number
		//		The new column width, in pixels.
		//	returns:
		//		'this' to allow for functional chaining.

		// Make sure we're resizing to a size that works with the included
		// padding, otherwise contents don't resize properly.
		if(column._contentWidthDifference < width){
			if(column._groupIndex > -1 && !dontResizeGroup){
				var groupColumn = this.get(column._groupIndex);
				this.resize(groupColumn, groupColumn.width + (width - column.width), true);
			}
			if(column.children && !dontResizeGroup){
				var childColumn = column.children.get(column.children.columns.length-1);
				this.resize(childColumn, childColumn.width + (width - column.width), true);
			}
			column.width = width;
			var css = this.table._css,
				query = '.' + css.cell + '-';
	
			if(column._groupIndex > -1){
				query += column._groupIndex + ' .' + css.groupCell + '-' + column._index;
			}else{
				query += column._index;
			}
	
			// Try to avoid any widget holder held tables.
			query += "." + this.table._uniqueCssId;
	
			dojo.query(query, this.table.domNode).forEach(function(n){
				n.parentNode.style.width = width + 'px';
				var diff = width - column._contentWidthDifference;
				if(diff > 0){
					n.style.width = diff + 'px';
				}
			});
			
			// Remove this before resize, on this column only
			// otherwise the table will go wonky. CSCtk01066
			if(column._pwidth)
				delete column._pwidth;
			
			this.table.resize();
			this.onResize(column);
	
			//	Kill any _pwidths
			/* Do not delete these, the table goes 'wonky' in sizing..CSCtk01066
			for(var i=0, columns = this.table.getColumns(), col; col=columns.get(i); i++){
				if(col._pwidth){
					delete col._pwidth;
				}
			}*/
		}
		return this;	//	xwt.widget.table.Columns
	},

	_createRow: function(node, builder, rowIndex, item){
		//	FIXME: TRT - pull the node argument, it is not being used here.
		//	Create a row as a child of node, given row properties and table properties.
		var row, tr, tbody, tableNode,
			table = this.table,
			_selected = table._selectedIds,
			css = table._css;

			
		// TODO: figure out how to do this in one shot
		var selected = _selected ?
			(table.isSelected(item) ? ' ' + table._selectedCssClass : '') :
			'';

		var id = table.store.getIdentity(item);
		var locked = table._lockedItems[id];	

		// We have to make sure that HTML entities
		// in the ID are properly encoded when building
		// the HTML string, or parse errors may happen.		
		var entityEnc = dojox.html.entities.encode;
		var entityDec = dojox.html.entities.decode;
		var entityMap = dojox.html.entities.html;
		var noSel; 
		if((table.isSelectable!=null) && (table.isSelectable(item)) && table._selectionModel==="row")
		{
			noSel='';
		}
		else
		{
			noSel="noSel";
		}
		
		builder.append('<div class="', css.row, ' ', noSel, ' ', css.row, '-', rowIndex, ' ', (rowIndex % 2 == 0 ? css.even : css.odd), 
			' ', table._uniqueCssId, ' ', css.row, "-itemid-", table._santizeIdentityForCss(id),(locked ? " row-locked" : ""));
		builder.append(selected, '" tabIndex="-1" role="row" rowindex="', rowIndex, '" item-id="', entityEnc(entityDec(id + "", entityMap), entityMap), '"');
		builder.append('><table class="', css.rowTable,
			'" cellspacing="0" cellpadding="0" border="0" role="presentation"><tbody><tr>'
		);
		for(var i=0, column; column=this.get(i); i++){
			column._createCell(rowIndex, builder, table, item);
		}
		builder.append('</tr></tbody></table></div>');
	},

	_createRows: function(page, items, start){
		//	we want to make sure that the even/odd isn't compromised by not rendering
		//	locked rows.
		var rows = new dojox.string.Builder();
		for(var i=0, idx=0, item; (item=items[i]); i++){
			this._createRow(page, rows, start+idx, item);
			idx++;
		}
		page.innerHTML = rows.toString();
	},

	_replaceRows: function(page, items, start){
		// summary:
		//	Reuse the rows in a page, if possible, to save creation time.
		// page:
		//	The DOM page to update.
		// items:
		//	The data store items.
		// start:
		//	The index to start at.
		// tags:
		//	private
		var rows = page.childNodes;
		if(rows.length != items.length){
			// Rows and items don't match, so just recreate.
			page.innerHTML = "";
			this._createRows(page, items, start);
		}else{
			// Rows match items, replace.
			var rRow = 0;
			for(var i=0, item; (item=items[i]); i++){
				this._replaceRow(rows[rRow], i, start+i, item);
				rRow++;
			}
			if(rRow != items.length){
				// There were some locked rows, so we need to clean up
				// ones we didn't update.
				while(page.childNodes[rRow]){
					dojo.destroy(page.childNodes[rRow]);
				}
			}
		}
		page = null;
	},

	_replaceRow: function(row, pageRowIndex, rowIndex, item){
		// summary:
		//	Replace an individual row in a page.
		var table = this.table,
			css = table._css,
			start = pageRowIndex * this.columns.length,
			cells = row.firstChild.rows[0].cells,
			selected = table.isSelected && table.isSelected(item);

		row.className = css.row + ' ' + css.row + '-' + rowIndex + ' ' + (rowIndex % 2 == 0 ? css.even : css.odd) + 
			' ' + table._uniqueCssId + ' ' + css.row + '-itemid-' + table._santizeIdentityForCss(table.store.getIdentity(item));
		if(selected){
			row.className += ' selected';
		}
		dojo.attr(row, 'rowindex', rowIndex);

		for(var i=0, column; column=this.get(i); i++){
			column._replaceCell(cells[i].firstChild, table, item);
		}
		cells = row = null;
	},

	//	event stubs
	onLock: function(/* xwt.widget.table.Column */column){
		//	summary:
		//		Fired when a column is locked.
		//	tags:
		//		callback
	},
	onUnlock: function(/* xwt.widget.table.Column */column){
		//	summary:
		//		Fired when a column is unlocked.
		//	tags:
		//		callback
	},
	onFreeze: function(/* xwt.widget.table.Column */column){
		//	summary:
		//		Fired when a column is frozen.
		//	tags:
		//		callback
	},
	onUnfreeze: function(/* xwt.widget.table.Column */column){
		//	summary:
		//		Fired when a column is unfrozen.
		//	tags:
		//		callback
	},
	onShow: function(/* xwt.widget.table.Column */column){
		//	summary:
		//		Fired when a column is shown.
		//	tags:
		//		callback
	},
	onHide: function(/* xwt.widget.table.Column */column){
		//	summary:
		//		Fired when a column is hidden.
		//	tags:
		//		callback
	},
	onMove: function(/* xwt.widget.table.Column */column, /* Integer */ oldIndex, /* Integer */ newIndex){
		//	summary:
		//		Fired when a column is moved (i.e., reordering).
		//	tags:
		//		callback
	},
	onResize: function(/* xwt.widget.table.Column */column){
		//	summary:
		//		Fired when a column is resized.
		//	tags:
		//		callback
	}
});

dojo.declare("xwt.widget.table._ColumnMover", dojo.dnd.Source, {
	horizontal: true,
	table: null,
	columnIdx: -1,

	constructor: function(node, params){
		this.accept = [ "tableColumn_" + this.table.id ];
		if(dojo.isIE){
			// IE triggers a mouseout if a node is resized, so we need to work around 
			// that and re-establish the link.  Otherwise resize handles are lost.
			this._ieMMListener = dojo.connect(this.node, "onmousemove", dojo.hitch(this, function(e){
				this.onOverEvent();
			}));
		}
	},

	onOverEvent: function(){
		// summary:
		//		Override to fix an IE lost-event issue.
		if(!this.onmousemoveEvent && this.node){
			this.onmousemoveEvent = dojo.connect(this.node, "onmousemove", this, "onMouseMove");
		}
	},

	destroy: function() {
		// summary:
		//	Override to clean up IE-specific listener for IE onMouseOut on resize.
		//	bug.
		if(this._ieMMListener){
			dojo.disconnect(this._ieMMListener);
			delete this._ieMMListener;
		}
		this.inherited(arguments);
	},

	getAllNodes: function(){
		return dojo.query("> table.table-header > tbody > tr > .dojoDndItem", this.parent);	// NodeList
	},
	_overResizeArea: function(e){
		if(dojo.hasClass(dojo.body(), "dojoDndMove")){
			return false;
		}
		var node = e.target,
			columnIdx = parseInt(dojo.attr(node, 'columnIdx'), 10);
			
		while(isNaN(columnIdx) && node.parentNode){
			node = node.parentNode;
			columnIdx = parseInt(dojo.attr(node, 'columnIdx'), 10);
		}
		
		if(isNaN(columnIdx)){
			return false;
		}
		var groupIdx = parseInt(dojo.attr(node, 'groupIdx'), 10),
			column = this.table._columns.get(columnIdx);
		if(!isNaN(groupIdx)){
			column = column.children.get(groupIdx);
		}
		if(column && column.columnType != xwt.widget.table.ColumnTypes.COLUMN){ return false; }
		
		if(!this._currentOverColumnNode || node != this._currentOverColumnNode || !this._overTargetBox){
			this._currentOverColumnNode = node;
			this._overTargetBox = {
				xy: dojo.coords(node, true),
				w: node.offsetWidth,
				h: node.offsetHeight
			};
		}

		var pos = e.pageX - this._overTargetBox.xy.x,
			leftGood = (columnIdx > 0) && (this.table.getColumns().get(columnIdx - 1).columnType == xwt.widget.table.ColumnTypes.COLUMN);
		return ((leftGood && pos < 4) || (pos >= node.offsetWidth - 4));
	},
	onMouseMove: function(e){
		var table = this.table,
			_css = table._css;
		if(this._resizer){
			return;
		}
		this.inherited(arguments);
		if(!this.isDragging && !this._resizer){
			if(this._overResizeArea(e, this.current)){
				if(!dojo.hasClass(table.tableHead, _css.resizing)){
					dojo.addClass(table.tableHead, _css.resizing);
				}
				dojo.forEach(this.additionalNodes, function(n){
					if(!dojo.hasClass(n, _css.resizing)){
						dojo.addClass(n, _css.resizing);
					}
				});
			}else{
				if(dojo.hasClass(table.tableHead, _css.resizing)){
					dojo.removeClass(table.tableHead, _css.resizing);
				}
				dojo.forEach(this.additionalNodes, function(n){
					if(dojo.hasClass(n, _css.resizing)){
						dojo.removeClass(n, _css.resizing);
					}
				});
			}
		}else{
			if(dojo.hasClass(table.tableHead, _css.resizing)){
				return;
			}
		}
	},
	onMouseOut: function(e){
		this.inherited(arguments);
		var table = this.table,
			_css = table._css;
		if(dojo.hasClass(table.tableHead, _css.resizing)){
			dojo.removeClass(table.tableHead, _css.resizing);
		}
		this._overTargetBox = this._currentOverColumnNode = null;
	},
	onMouseDown: function(e){
		var table = this.table;
		if(dojo.hasClass(table.tableHead, table._css.resizing) && this._overResizeArea(e)){
			var pos = e.pageX - this._overTargetBox.xy.x,
				column = table._columns.getByNode(this._currentOverColumnNode, pos);
			if(!column || (column && column.columnType != xwt.widget.table.ColumnTypes.COLUMN)){
				dojo.stopEvent(e);
				return;
			}

			table.moverDiv = document.createElement("div");

			var m = this._resizer = new xwt.widget.table._ColumnResizer(table.moverDiv, {
				table: table,
				column: column,
				origLeft: e.clientX
			});
			dojo.connect(m, 'onMoveStop', this, function(){
				this._resizer.destroy();
				delete this._resizer;
				this._resizer = null;
			});
			m.onMouseDown(e);

			return;
		}
		this.inherited(arguments);
	},
	onDrop: function(source, nodes, copy){
		var table = this.table;
		if(this != source){
			return;
		}else{
			if(!this.current){ return; }
			var indexTo = 0;
			if(this.targetAnchor){
				indexTo = dojo.attr(this.targetAnchor, 'columnIdx');
			}
			var column = table._columns.get(this.columnIdx);
			window.setTimeout(function(){
				table._columns.move(column, indexTo);
			},50);
			this.isDropping = true;
		}
	},
	_getChildByEvent: function(e){
		var node = e.target,
			returnNode = null;
		if(node){
			for(var parent = node.parentNode; parent; node = parent, parent = node.parentNode){
				if(dojo.hasClass(node, 'dojoDndItem')){
					returnNode = node;
				}
				if(parent == this.parent && returnNode){ return returnNode; }
			}
		}
		return null;
	},
	onDndStart: function(source, nodes, copy){
		if(this === source){
			this.columnIdx = dojo.attr(nodes[0], 'columnIdx');
		}
		this.inherited(arguments);
	},
	onDndCancel: function(){
		this.inherited(arguments);
		this.isDropping = false;
		this.columnIdx = -1;
	},
	_markTargetAnchor: function(before){
		// summary: 
		//	Assigns a class to the current target anchor based on "before" status.
		//	before: Boolean
		//	Insert before if true; after if false.
		if(this.current == this.targetAnchor && this.before == before){ return; }
		var changed = false,
			colIdx = -1,
			table = this.table;
		if(this.targetAnchor){
			this._removeItemClass(this.targetAnchor, this.before ? "Before" : "After");
			if(this.targetAnchor != this.current){
				colIdx = dojo.attr(this.targetAnchor, 'columnIdx') || 0;
				dojo.query('.' + table._css.cellContainer + '-' + colIdx + "." + table._uniqueCssId, table.domNode)
					.removeClass('column-reorder-selected');
			}
		}else{
			if(this.targetAnchor != this.current){
				colIdx = 0;
			}
		}
		this.targetAnchor = this.current;
		this.targetBox = null;
		this.before = before;
		if(this.targetAnchor){
			if(colIdx > -1){
				if(this.targetAnchor != this.anchor){
					this._addItemClass(this.targetAnchor, this.before ? "Before" : "After");
					colIdx = dojo.attr(this.targetAnchor, 'columnIdx');
					dojo.query('.' + table._css.cellContainer + '-' + colIdx + "." + table._uniqueCssId, table.domNode)
						.addClass('column-reorder-selected');
				}else{
					dojo.addClass(this.targetAnchor, 'table-column-no-drop');
				}
			}
		}
	},
	_unmarkTargetAnchor: function(){
		// summary: 
		//	Removes a class of the current target anchor based on "before" status.
		if(!this.targetAnchor){ return; }
		var colIdx = dojo.attr(this.targetAnchor, 'columnIdx');
		var table = this.table;
		if(colIdx > -1){
			dojo.query('.' + table._css.cellContainer + '-' + colIdx + "." + table._uniqueCssId, this.table.domNode)
				.removeClass('column-reorder-selected');
		}
		this._removeItemClass(this.targetAnchor, this.before ? "Before" : "After");
		dojo.removeClass(this.targetAnchor, 'table-column-no-drop');
		this.targetAnchor = null;
		this.targetBox = null;
		this.before = true;
	}
});

dojo.declare("xwt.widget.table._ColumnAvatar", dojo.dnd.Avatar, {
	construct: function(){
		this.isA11y = dojo.hasClass(dojo.body(),"dijit_a11y");
		var source = this.manager.source,
			table = source.table,
			thcmb = dojo.marginBox(table.tableHeadNodeContainer),
			columnIdx = dojo.attr(source.current, 'columnidx'),
			column = table._columns.get(columnIdx),
			d = dojo.create("div", {
				"class": "dojoDndAvatar table-column-avatar",
				style: {
					position: "absolute",
					zIndex:   "1999",
					margin:   "0px",
					height: thcmb.h + "px",
					width: (column.width+2) + "px",
					overflowY: "hidden",
					overflowX: "hidden",
					opacity: 0.8
				}
			}),
			a = dojo.create("table", {
				"class": "table-header",
				style: {
					height: thcmb.h + "px"
				}
			}, d),
			b = dojo.create("tbody", null, a);

		// header node
		var tr = dojo.create("tr", null, b);
		tr.appendChild(
			dojo.clone(
				dojo.query('.' + table._css.cellContainer + '-' + columnIdx, table.tableHeadInnerContainer)[0]
			)
		);

		// Try to create a chunk of data to show moving.
		var data = dojo.query('.' + table._css.cellContainer + '-' + columnIdx + "." + table._uniqueCssId, table.tableBody);
		if(data.length){
			var content = dojo.create("table", {"class": "table-body"}, d);
			var tbody = dojo.create("tbody", null, content);
			var subset = false;
			if(data.length > 5){
				subset = true;
				data = data.slice(0,5);
			}
			data.forEach(function(cell){
				var nTr = dojo.create("tr", {"class": "row"}, tbody);
				nTr.appendChild(
					dojo.clone(cell)
				);
				thcmb.h += dojo.position(cell).h;	
			});
			if(subset){
				var nTr = dojo.create("tr", {"class": "row"}, tbody);
				nTr.appendChild(dojo.create("td", {"align": "center", "valign": "middle", "class": table._css.cellContainer,  "innerHTML":  "..."}));
				thcmb.h += dojox.html.metrics.getTextBox("...").h;
			}
		}
		dojo.style(d, "height", thcmb.h + "px");
		tr = null;
		this.node = d;
	}
});

(function(){
	var ddm = dojo.dnd.manager();
	var oldMakeAvatar = ddm.makeAvatar;
	ddm.makeAvatar = function(){
		if(this.source instanceof xwt.widget.table._ColumnMover){
			return new xwt.widget.table._ColumnAvatar(this);
		}
		return oldMakeAvatar.call(this);
	};
})();

dojo.declare("xwt.widget.table._ColumnResizer", dojo.dnd.Moveable, {
	constructor: function(node, params){
		this.table = params.table;
		this.column = params.column;
		this.origLeft = params.origLeft;

		dojo.style(node, {position: "absolute", left:0}); // to make DnD work with dir=rtl
		dojo.body().appendChild(node);
	},
	onMoveStart: function(mover){
		this.inherited(arguments);

		var table = this.table;
		var headMB = dojo.marginBox(table.tableHead),
			headPos = dojo._abs(table.tableHead, true),
			content = table._contentBoxHeight;
		dojo.style(mover.node, {
			top: headPos.y + "px",
			left: this.origLeft + "px",
			height: (headMB.h + content - (table._overflowX ? table._getScrollBarDims().h : 0)) + "px"
		});
		dojo.addClass(mover.node, 'table-column-resizer');
		dojo.addClass(table.tableHeadContainer, table._css.resizing);

		this.drag = {};
	},
	onMove: function(mover, leftTop){
		this.drag.leftTop = leftTop;
		
		var size = parseInt(this.column.width, 10) + (this.drag.leftTop.l - this.origLeft);
		if(size > this.column._contentWidthDifference){
			dojo.style(mover.node, {
				left: leftTop.l + "px"
			});
		}else{
			// We went past the column left, so just move the line to the min-width the cell can be.
			dojo.style(mover.node, {
				left: (this.origLeft - parseInt(this.column.width, 10) + this.column._contentWidthDifference)  + "px"
			});
		}
	},
	onMoveStop: function(mover){
		this.inherited(arguments);

		var drag = this.drag,
			table = this.table;
			
		if(this.column.width && dojo.isString(this.column.width)){
			this.column.width = parseInt(this.column.width, 10);
		}
			
		if(drag.leftTop){
			var size = parseInt(this.column.width, 10) + (dojo.style(mover.node, "left") - this.origLeft);
			if(size > 0){
				var size = (size > this.column._contentWidthDifference) ? size : this.column._contentWidthDifference + 1;
				table._columns.resize(this.column, size);
			}
		}
		dojo.removeClass(table.tableHeadContainer, table._css.resizing);

		dojo.destroy(mover.node);
		delete mover.node;
		mover.node = null;
	}
});


dojo.declare("xwt.widget.table.DetailMixin", null, {
	//	summary:
	//		A mixin that any detail widget (expandable rows) should use when being defined.  You
	//		should override at least the setValues method.

	// table: Object
	//		The table object currently handling the detail panel.  Assigned each time a 
	//		detail panel is opened.
	table: null,

	setValues: function(/* Object */values, /* dojo.data.api.Read? */store, /* dojo.data.Item? */item){
		//	summary:
		//		Override this method with your own custom widget code. The Edit plugin will go
		//		through the selected item(s) and provide you with an object of key/value pairs
		//		you can use to set the initial values of any elements within your widget.  The
		//		keys in this object will match the attributes available within a dojo.data.item
		//		(as provided by `dojo.data.api.Read.getAttributes()`).
	},
	mode: function(/* String? */mode){
		//	summary:
		//		Override this method only if your widget supports more than one "mode".  This should
		//		act as both a setter and getter; if the mode is not passed, return the current value.
		if(mode === undefined){ return "read"; }
		this._mode = mode;
		return this._mode;
	},

	changeHeight:function(newHeight){
		//	summary:
		//		Use this method only if you need to adjust the size of the expanded pane, after it is expanded.
		//		Do not use this method if the row hasnt been expanded yet.

		//get the expander pane and call change height on it.
		for (var i = 0, column; column = this.table._columns.get(i); i++) {
			if (column.columnType != xwt.widget.table.ColumnTypes.EXPANDER &&
			column.columnType != xwt.widget.table.ColumnTypes.EXPANDER) {
				continue;
			}
			else {
				column._changeHeight(newHeight);
				break;
			}
		}
	}
});

dojo.declare("xwt.widget.table.EditorMixin", xwt.widget.table.DetailMixin, {
	//	summary:
	//		A mixin that any Editor widget should use when being defined.  You should override
	//		at least the getValues, mode and setValues methods when implementing your editing widget.
	
	// table: Object
	//		The table object currently handling the edit widget/detail panel.  Assigned each time a 
	//		detail panel is opened.
	table: null,

	getValues: function(){
		//	summary:
		//		Override this method with your own code to get the values out of your editor.
		//		It should return an object of key/value pairs that can be used to set the values
		//		on an item or a set of items. The keys of the object should be an attribute on
		//		the data item in question.
		//
		//	example:
		//		Say you have an editor for a data store, whose items look like this:
		//
		//	|	{  foo, bar, baz };
		//
		//		...where foo, bar and baz are attributes on each item.  The getValues function
		//		should return something that looks like this:
		//
		//	|	{ foo: "value1", bar: "value2", baz: "value3" };
		//
		//		The Edit plugin, when your widget calls `onExecute`, will call this method to
		//		get any values it needs, and will do the dojo.data.api.Write needed to update
		//		the underlying store.
		return {}; //	Object
	},

	//	The following three methods are the ones to which you should hook up any actionable widgets (i.e. buttons).
	execute: function(){
		//	summary:
		//		Fire this when someone clicks your "Save" button.
		this.onExecute();
	},
	executeAndNext: function(){
		//	summary:
		//		Fire this when someone clicks your "Save and Edit Next" button.
		this.onExecuteAndNext();
	},
	cancel: function(){
		//	summary:
		//		Fire this when someone clicks your "Cancel" button.
		this.onCancel();
	},

	onShow: function(){
		//	summary:
		//		Callback for when your widget is shown.
	},

	onHide: function(){
		//	summary:
		//		Callback for when your widget is hidden.
	},

	onExecute: function(/* Object? */values){
		//	summary:
		//		Callback for when the user has clicked the equivilent of "Save".
	},

	onExecuteAndNext: function(/* Object? */values){
		//	summary:
		//		Callback for when the user has clicked the equivilent of "Save and Edit Next".
	},

	onCancel: function(){
		//	summary:
		//		Callback for when the user has clicked the equivilent of "Cancel".
	},
	
	destroy: function(){
		// summary:
		//		Over-ridden cleanup function
		delete this.table;
		this.inherited(arguments);
	}
});

}

if(!dojo._hasResource["dojo.number"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.number"] = true;
dojo.provide("dojo.number");







/*=====
dojo.number = {
	// summary: localized formatting and parsing routines for Number
}

dojo.number.__FormatOptions = function(){
	//	pattern: String?
	//		override [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	//		with this string.  Default value is based on locale.  Overriding this property will defeat
	//		localization.
	//	type: String?
	//		choose a format type based on the locale from the following:
	//		decimal, scientific (not yet supported), percent, currency. decimal by default.
	//	places: Number?
	//		fixed number of decimal places to show.  This overrides any
	//		information in the provided pattern.
	//	round: Number?
	//		5 rounds to nearest .5; 0 rounds to nearest whole (default). -1
	//		means do not round.
	//	locale: String?
	//		override the locale used to determine formatting rules
	this.pattern = pattern;
	this.type = type;
	this.places = places;
	this.round = round;
	this.locale = locale;
}
=====*/

dojo.number.format = function(/*Number*/value, /*dojo.number.__FormatOptions?*/options){
	// summary:
	//		Format a Number as a String, using locale-specific settings
	// description:
	//		Create a string from a Number using a known localized pattern.
	//		Formatting patterns appropriate to the locale are chosen from the
	//		[CLDR](http://unicode.org/cldr) as well as the appropriate symbols and
	//		delimiters.  See <http://www.unicode.org/reports/tr35/#Number_Elements>
	//		If value is Infinity, -Infinity, or is not a valid JavaScript number, return null.
	// value:
	//		the number to be formatted

	options = dojo.mixin({}, options || {});
	var locale = dojo.i18n.normalizeLocale(options.locale);
	var bundle = dojo.i18n.getLocalization("dojo.cldr", "number", locale);
	options.customs = bundle;
	var pattern = options.pattern || bundle[(options.type || "decimal") + "Format"];
	if(isNaN(value) || Math.abs(value) == Infinity){ return null; } // null
	return dojo.number._applyPattern(value, pattern, options); // String
};

//dojo.number._numberPatternRE = /(?:[#0]*,?)*[#0](?:\.0*#*)?/; // not precise, but good enough
dojo.number._numberPatternRE = /[#0,]*[#0](?:\.0*#*)?/; // not precise, but good enough

dojo.number._applyPattern = function(/*Number*/value, /*String*/pattern, /*dojo.number.__FormatOptions?*/options){
	// summary:
	//		Apply pattern to format value as a string using options. Gives no
	//		consideration to local customs.
	// value:
	//		the number to be formatted.
	// pattern:
	//		a pattern string as described by
	//		[unicode.org TR35](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	// options: dojo.number.__FormatOptions?
	//		_applyPattern is usually called via `dojo.number.format()` which
	//		populates an extra property in the options parameter, "customs".
	//		The customs object specifies group and decimal parameters if set.

	//TODO: support escapes
	options = options || {};
	var group = options.customs.group;
	var decimal = options.customs.decimal;

	var patternList = pattern.split(';');
	var positivePattern = patternList[0];
	pattern = patternList[(value < 0) ? 1 : 0] || ("-" + positivePattern);

	//TODO: only test against unescaped
	if(pattern.indexOf('%') != -1){
		value *= 100;
	}else if(pattern.indexOf('\u2030') != -1){
		value *= 1000; // per mille
	}else if(pattern.indexOf('\u00a4') != -1){
		group = options.customs.currencyGroup || group;//mixins instead?
		decimal = options.customs.currencyDecimal || decimal;// Should these be mixins instead?
		pattern = pattern.replace(/\u00a4{1,3}/, function(match){
			var prop = ["symbol", "currency", "displayName"][match.length-1];
			return options[prop] || options.currency || "";
		});
	}else if(pattern.indexOf('E') != -1){
		throw new Error("exponential notation not supported");
	}
	
	//TODO: support @ sig figs?
	var numberPatternRE = dojo.number._numberPatternRE;
	var numberPattern = positivePattern.match(numberPatternRE);
	if(!numberPattern){
		throw new Error("unable to find a number expression in pattern: "+pattern);
	}
	if(options.fractional === false){ options.places = 0; }
	return pattern.replace(numberPatternRE,
		dojo.number._formatAbsolute(value, numberPattern[0], {decimal: decimal, group: group, places: options.places, round: options.round}));
}

dojo.number.round = function(/*Number*/value, /*Number?*/places, /*Number?*/increment){
	//	summary:
	//		Rounds to the nearest value with the given number of decimal places, away from zero
	//	description:
	//		Rounds to the nearest value with the given number of decimal places, away from zero if equal.
	//		Similar to Number.toFixed(), but compensates for browser quirks. Rounding can be done by
	//		fractional increments also, such as the nearest quarter.
	//		NOTE: Subject to floating point errors.  See dojox.math.round for experimental workaround.
	//	value:
	//		The number to round
	//	places:
	//		The number of decimal places where rounding takes place.  Defaults to 0 for whole rounding.
	//		Must be non-negative.
	//	increment:
	//		Rounds next place to nearest value of increment/10.  10 by default.
	//	example:
	//		>>> dojo.number.round(-0.5)
	//		-1
	//		>>> dojo.number.round(162.295, 2)
	//		162.29  // note floating point error.  Should be 162.3
	//		>>> dojo.number.round(10.71, 0, 2.5)
	//		10.75
	var factor = 10 / (increment || 10);
	return (factor * +value).toFixed(places) / factor; // Number
}

if((0.9).toFixed() == 0){
	// (isIE) toFixed() bug workaround: Rounding fails on IE when most significant digit
	// is just after the rounding place and is >=5
	(function(){
		var round = dojo.number.round;
		dojo.number.round = function(v, p, m){
			var d = Math.pow(10, -p || 0), a = Math.abs(v);
			if(!v || a >= d || a * Math.pow(10, p + 1) < 5){
				d = 0;
			}
			return round(v, p, m) + (v > 0 ? d : -d);
		}
	})();
}

/*=====
dojo.number.__FormatAbsoluteOptions = function(){
	//	decimal: String?
	//		the decimal separator
	//	group: String?
	//		the group separator
	//	places: Number?|String?
	//		number of decimal places.  the range "n,m" will format to m places.
	//	round: Number?
	//		5 rounds to nearest .5; 0 rounds to nearest whole (default). -1
	//		means don't round.
	this.decimal = decimal;
	this.group = group;
	this.places = places;
	this.round = round;
}
=====*/

dojo.number._formatAbsolute = function(/*Number*/value, /*String*/pattern, /*dojo.number.__FormatAbsoluteOptions?*/options){
	// summary: 
	//		Apply numeric pattern to absolute value using options. Gives no
	//		consideration to local customs.
	// value:
	//		the number to be formatted, ignores sign
	// pattern:
	//		the number portion of a pattern (e.g. `#,##0.00`)
	options = options || {};
	if(options.places === true){options.places=0;}
	if(options.places === Infinity){options.places=6;} // avoid a loop; pick a limit

	var patternParts = pattern.split(".");
	var maxPlaces = (options.places >= 0) ? options.places : (patternParts[1] && patternParts[1].length) || 0;
	if(!(options.round < 0)){
		value = dojo.number.round(value, maxPlaces, options.round);
	}

	var valueParts = String(Math.abs(value)).split(".");
	var fractional = valueParts[1] || "";
	if(options.places){
		var comma = dojo.isString(options.places) && options.places.indexOf(",");
		if(comma){
			options.places = options.places.substring(comma+1);
		}
		valueParts[1] = dojo.string.pad(fractional.substr(0, options.places), options.places, '0', true);
	}else if(patternParts[1] && options.places !== 0){
		// Pad fractional with trailing zeros
		var pad = patternParts[1].lastIndexOf("0") + 1;
		if(pad > fractional.length){
			valueParts[1] = dojo.string.pad(fractional, pad, '0', true);
		}

		// Truncate fractional
		var places = patternParts[1].length;
		if(places < fractional.length){
			valueParts[1] = fractional.substr(0, places);
		}
	}else{
		if(valueParts[1]){ valueParts.pop(); }
	}

	// Pad whole with leading zeros
	var patternDigits = patternParts[0].replace(',', '');
	pad = patternDigits.indexOf("0");
	if(pad != -1){
		pad = patternDigits.length - pad;
		if(pad > valueParts[0].length){
			valueParts[0] = dojo.string.pad(valueParts[0], pad);
		}

		// Truncate whole
		if(patternDigits.indexOf("#") == -1){
			valueParts[0] = valueParts[0].substr(valueParts[0].length - pad);
		}
	}

	// Add group separators
	var index = patternParts[0].lastIndexOf(',');
	var groupSize, groupSize2;
	if(index != -1){
		groupSize = patternParts[0].length - index - 1;
		var remainder = patternParts[0].substr(0, index);
		index = remainder.lastIndexOf(',');
		if(index != -1){
			groupSize2 = remainder.length - index - 1;
		}
	}
	var pieces = [];
	for(var whole = valueParts[0]; whole;){
		var off = whole.length - groupSize;
		pieces.push((off > 0) ? whole.substr(off) : whole);
		whole = (off > 0) ? whole.slice(0, off) : "";
		if(groupSize2){
			groupSize = groupSize2;
			delete groupSize2;
		}
	}
	valueParts[0] = pieces.reverse().join(options.group || ",");

	return valueParts.join(options.decimal || ".");
};

/*=====
dojo.number.__RegexpOptions = function(){
	//	pattern: String?
	//		override [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	//		with this string.  Default value is based on locale.  Overriding this property will defeat
	//		localization.
	//	type: String?
	//		choose a format type based on the locale from the following:
	//		decimal, scientific (not yet supported), percent, currency. decimal by default.
	//	locale: String?
	//		override the locale used to determine formatting rules
	//	strict: Boolean?
	//		strict parsing, false by default.  Strict parsing requires input as produced by the format() method.
	//		Non-strict is more permissive, e.g. flexible on white space, omitting thousands separators
	//	places: Number|String?
	//		number of decimal places to accept: Infinity, a positive number, or
	//		a range "n,m".  Defined by pattern or Infinity if pattern not provided.
	this.pattern = pattern;
	this.type = type;
	this.locale = locale;
	this.strict = strict;
	this.places = places;
}
=====*/
dojo.number.regexp = function(/*dojo.number.__RegexpOptions?*/options){
	//	summary:
	//		Builds the regular needed to parse a number
	//	description:
	//		Returns regular expression with positive and negative match, group
	//		and decimal separators
	return dojo.number._parseInfo(options).regexp; // String
}

dojo.number._parseInfo = function(/*Object?*/options){
	options = options || {};
	var locale = dojo.i18n.normalizeLocale(options.locale);
	var bundle = dojo.i18n.getLocalization("dojo.cldr", "number", locale);
	var pattern = options.pattern || bundle[(options.type || "decimal") + "Format"];
//TODO: memoize?
	var group = bundle.group;
	var decimal = bundle.decimal;
	var factor = 1;

	if(pattern.indexOf('%') != -1){
		factor /= 100;
	}else if(pattern.indexOf('\u2030') != -1){
		factor /= 1000; // per mille
	}else{
		var isCurrency = pattern.indexOf('\u00a4') != -1;
		if(isCurrency){
			group = bundle.currencyGroup || group;
			decimal = bundle.currencyDecimal || decimal;
		}
	}

	//TODO: handle quoted escapes
	var patternList = pattern.split(';');
	if(patternList.length == 1){
		patternList.push("-" + patternList[0]);
	}

	var re = dojo.regexp.buildGroupRE(patternList, function(pattern){
		pattern = "(?:"+dojo.regexp.escapeString(pattern, '.')+")";
		return pattern.replace(dojo.number._numberPatternRE, function(format){
			var flags = {
				signed: false,
				separator: options.strict ? group : [group,""],
				fractional: options.fractional,
				decimal: decimal,
				exponent: false};
			var parts = format.split('.');
			var places = options.places;
			if(parts.length == 1 || places === 0){flags.fractional = false;}
			else{
				if(places === undefined){ places = options.pattern ? parts[1].lastIndexOf('0')+1 : Infinity; }
				if(places && options.fractional == undefined){flags.fractional = true;} // required fractional, unless otherwise specified
				if(!options.places && (places < parts[1].length)){ places += "," + parts[1].length; }
				flags.places = places;
			}
			var groups = parts[0].split(',');
			if(groups.length>1){
				flags.groupSize = groups.pop().length;
				if(groups.length>1){
					flags.groupSize2 = groups.pop().length;
				}
			}
			return "("+dojo.number._realNumberRegexp(flags)+")";
		});
	}, true);

	if(isCurrency){
		// substitute the currency symbol for the placeholder in the pattern
		re = re.replace(/([\s\xa0]*)(\u00a4{1,3})([\s\xa0]*)/g, function(match, before, target, after){
			var prop = ["symbol", "currency", "displayName"][target.length-1];
			var symbol = dojo.regexp.escapeString(options[prop] || options.currency || "");
			before = before ? "[\\s\\xa0]" : "";
			after = after ? "[\\s\\xa0]" : "";
			if(!options.strict){
				if(before){before += "*";}
				if(after){after += "*";}
				return "(?:"+before+symbol+after+")?";
			}
			return before+symbol+after;
		});
	}

//TODO: substitute localized sign/percent/permille/etc.?

	// normalize whitespace and return
	return {regexp: re.replace(/[\xa0 ]/g, "[\\s\\xa0]"), group: group, decimal: decimal, factor: factor}; // Object
}

/*=====
dojo.number.__ParseOptions = function(){
	//	pattern: String?
	//		override [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	//		with this string.  Default value is based on locale.  Overriding this property will defeat
	//		localization.
	//	type: String?
	//		choose a format type based on the locale from the following:
	//		decimal, scientific (not yet supported), percent, currency. decimal by default.
	//	locale: String?
	//		override the locale used to determine formatting rules
	//	strict: Boolean?
	//		strict parsing, false by default.  Strict parsing requires input as produced by the format() method.
	//		Non-strict is more permissive, e.g. flexible on white space, omitting thousands separators
	this.pattern = pattern;
	this.type = type;
	this.locale = locale;
	this.strict = strict;
}
=====*/
dojo.number.parse = function(/*String*/expression, /*dojo.number.__ParseOptions?*/options){
	// summary:
	//		Convert a properly formatted string to a primitive Number, using
	//		locale-specific settings.
	// description:
	//		Create a Number from a string using a known localized pattern.
	//		Formatting patterns are chosen appropriate to the locale
	//		and follow the syntax described by
	//		[unicode.org TR35](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	// expression:
	//		A string representation of a Number
	var info = dojo.number._parseInfo(options);
	var results = (new RegExp("^"+info.regexp+"$")).exec(expression);
	if(!results){
		return NaN; //NaN
	}
	var absoluteMatch = results[1]; // match for the positive expression
	if(!results[1]){
		if(!results[2]){
			return NaN; //NaN
		}
		// matched the negative pattern
		absoluteMatch =results[2];
		info.factor *= -1;
	}

	// Transform it to something Javascript can parse as a number.  Normalize
	// decimal point and strip out group separators or alternate forms of whitespace
	absoluteMatch = absoluteMatch.
		replace(new RegExp("["+info.group + "\\s\\xa0"+"]", "g"), "").
		replace(info.decimal, ".");
	// Adjust for negative sign, percent, etc. as necessary
	return absoluteMatch * info.factor; //Number
};

/*=====
dojo.number.__RealNumberRegexpFlags = function(){
	//	places: Number?
	//		The integer number of decimal places or a range given as "n,m".  If
	//		not given, the decimal part is optional and the number of places is
	//		unlimited.
	//	decimal: String?
	//		A string for the character used as the decimal point.  Default
	//		is ".".
	//	fractional: Boolean?|Array?
	//		Whether decimal places are used.  Can be true, false, or [true,
	//		false].  Default is [true, false] which means optional.
	//	exponent: Boolean?|Array?
	//		Express in exponential notation.  Can be true, false, or [true,
	//		false]. Default is [true, false], (i.e. will match if the
	//		exponential part is present are not).
	//	eSigned: Boolean?|Array?
	//		The leading plus-or-minus sign on the exponent.  Can be true,
	//		false, or [true, false].  Default is [true, false], (i.e. will
	//		match if it is signed or unsigned).  flags in regexp.integer can be
	//		applied.
	this.places = places;
	this.decimal = decimal;
	this.fractional = fractional;
	this.exponent = exponent;
	this.eSigned = eSigned;
}
=====*/

dojo.number._realNumberRegexp = function(/*dojo.number.__RealNumberRegexpFlags?*/flags){
	// summary:
	//		Builds a regular expression to match a real number in exponential
	//		notation

	// assign default values to missing paramters
	flags = flags || {};
	//TODO: use mixin instead?
	if(!("places" in flags)){ flags.places = Infinity; }
	if(typeof flags.decimal != "string"){ flags.decimal = "."; }
	if(!("fractional" in flags) || /^0/.test(flags.places)){ flags.fractional = [true, false]; }
	if(!("exponent" in flags)){ flags.exponent = [true, false]; }
	if(!("eSigned" in flags)){ flags.eSigned = [true, false]; }

	// integer RE
	var integerRE = dojo.number._integerRegexp(flags);

	// decimal RE
	var decimalRE = dojo.regexp.buildGroupRE(flags.fractional,
		function(q){
			var re = "";
			if(q && (flags.places!==0)){
				re = "\\" + flags.decimal;
				if(flags.places == Infinity){ 
					re = "(?:" + re + "\\d+)?"; 
				}else{
					re += "\\d{" + flags.places + "}"; 
				}
			}
			return re;
		},
		true
	);

	// exponent RE
	var exponentRE = dojo.regexp.buildGroupRE(flags.exponent,
		function(q){ 
			if(q){ return "([eE]" + dojo.number._integerRegexp({ signed: flags.eSigned}) + ")"; }
			return ""; 
		}
	);

	// real number RE
	var realRE = integerRE + decimalRE;
	// allow for decimals without integers, e.g. .25
	if(decimalRE){realRE = "(?:(?:"+ realRE + ")|(?:" + decimalRE + "))";}
	return realRE + exponentRE; // String
};

/*=====
dojo.number.__IntegerRegexpFlags = function(){
	//	signed: Boolean?
	//		The leading plus-or-minus sign. Can be true, false, or `[true,false]`.
	//		Default is `[true, false]`, (i.e. will match if it is signed
	//		or unsigned).
	//	separator: String?
	//		The character used as the thousands separator. Default is no
	//		separator. For more than one symbol use an array, e.g. `[",", ""]`,
	//		makes ',' optional.
	//	groupSize: Number?
	//		group size between separators
	//	groupSize2: Number?
	//		second grouping, where separators 2..n have a different interval than the first separator (for India)
	this.signed = signed;
	this.separator = separator;
	this.groupSize = groupSize;
	this.groupSize2 = groupSize2;
}
=====*/

dojo.number._integerRegexp = function(/*dojo.number.__IntegerRegexpFlags?*/flags){
	// summary: 
	//		Builds a regular expression that matches an integer

	// assign default values to missing paramters
	flags = flags || {};
	if(!("signed" in flags)){ flags.signed = [true, false]; }
	if(!("separator" in flags)){
		flags.separator = "";
	}else if(!("groupSize" in flags)){
		flags.groupSize = 3;
	}
	// build sign RE
	var signRE = dojo.regexp.buildGroupRE(flags.signed,
		function(q){ return q ? "[-+]" : ""; },
		true
	);

	// number RE
	var numberRE = dojo.regexp.buildGroupRE(flags.separator,
		function(sep){
			if(!sep){
				return "(?:\\d+)";
			}

			sep = dojo.regexp.escapeString(sep);
			if(sep == " "){ sep = "\\s"; }
			else if(sep == "\xa0"){ sep = "\\s\\xa0"; }

			var grp = flags.groupSize, grp2 = flags.groupSize2;
			//TODO: should we continue to enforce that numbers with separators begin with 1-9?  See #6933
			if(grp2){
				var grp2RE = "(?:0|[1-9]\\d{0," + (grp2-1) + "}(?:[" + sep + "]\\d{" + grp2 + "})*[" + sep + "]\\d{" + grp + "})";
				return ((grp-grp2) > 0) ? "(?:" + grp2RE + "|(?:0|[1-9]\\d{0," + (grp-1) + "}))" : grp2RE;
			}
			return "(?:0|[1-9]\\d{0," + (grp-1) + "}(?:[" + sep + "]\\d{" + grp + "})*)";
		},
		true
	);

	// integer RE
	return signRE + numberRE; // String
}

}

if(!dojo._hasResource["xwt.widget.table.util"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.table.util"] = true;
/* ************************************************** */
/* Copyright (c) 2009-2011 Cisco Systems, Inc.       */
/* All rights reserved.                               */
/* ************************************************** */

dojo.provide("xwt.widget.table.util");

(function(){
	var u = xwt.widget.table.util;

	u.getValueObject = function(/* dojo.data.api.Read */store, /* dojo.data.Item|dojo.data.Item[] */item){
		//	summary:
		//		For given item/items, return a key/value pair object.  If "item" is an array,
		//		only return an object with properties that have a common value for an attribute.
		if(dojo.isArray(item)){
			//	assume that all passed items have the same attributes.
			var attrs = store.getAttributes(item[0]), test = {}, comp = {};

			//	Prescan the attributes.
			dojo.forEach(attrs, function(attr){
				test[attr] = true;
				comp[attr] = store.getValue(item[0], attr);
			});

			//	Run the test over all the items.
			dojo.forEach(item, function(i){
				dojo.forEach(attrs, function(attr){
					test[attr] = (store.getValue(i, attr) == comp[attr]);
				});
			});

			//	Assemble the final object.
			var uniq = {};
			dojo.forEach(attrs, function(attr){
				if(test[attr]){
					uniq[attr] = comp[attr];
				} else {
					uniq[attr] = "";
				}
			});
			return uniq;
		}

		//	single item value object
		var o = {}, attrs = store.getAttributes(item);
		dojo.forEach(attrs, function(attr){
			o[attr] = store.getValue(item, attr);
		});
		return o;
	}
})();

}

if(!dojo._hasResource["dojox.widget.Toaster"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.widget.Toaster"] = true;
dojo.provide("dojox.widget.Toaster");





dojo.declare("dojox.widget.Toaster", [dijit._Widget, dijit._Templated], {
		// summary:
		//		Message that slides in from the corner of the screen, used for notifications
		//		like "new email".

		templateString: '<div class="dijitToasterClip" dojoAttachPoint="clipNode"><div class="dijitToasterContainer" dojoAttachPoint="containerNode" dojoAttachEvent="onclick:onSelect"><div class="dijitToasterContent" dojoAttachPoint="contentNode"></div></div></div>',

		// messageTopic: String
		//		Name of topic; anything published to this topic will be displayed as a message.
		//		Message format is either String or an object like
		//		{message: "hello word", type: "error", duration: 500}
		messageTopic: "",

		// messageTypes: Enumeration
		//		Possible message types.
		messageTypes: {
			MESSAGE: "message",
			WARNING: "warning",
			ERROR: "error",
			FATAL: "fatal"
		},

		// defaultType: String
		//		If message type isn't specified (see "messageTopic" parameter),
		//		then display message as this type.
		//		Possible values in messageTypes enumeration ("message", "warning", "error", "fatal")
		defaultType: "message",

		// positionDirection: String
		//		Position from which message slides into screen, one of
		//		["br-up", "br-left", "bl-up", "bl-right", "tr-down", "tr-left", "tl-down", "tl-right"]
		positionDirection: "br-up",
		
		// positionDirectionTypes: Array
		//		Possible values for positionDirection parameter
		positionDirectionTypes: ["br-up", "br-left", "bl-up", "bl-right", "tr-down", "tr-left", "tl-down", "tl-right"],

		// duration: Integer
		//		Number of milliseconds to show message
		duration: 2000,

		// slideDuration: Integer
		//		Number of milliseconds for the slide animation, increasing will cause the Toaster 
		//    to slide in more slowly.
		slideDuration: 500,

		//separator: String
		//		String used to separate messages if consecutive calls are made to setContent before previous messages go away
		separator: "<hr></hr>",

		postCreate: function(){
			this.inherited(arguments);
			this.hide();
			
			// place node as a child of body for positioning
			dojo.body().appendChild(this.domNode);
			
			if(this.messageTopic){
				dojo.subscribe(this.messageTopic, this, "_handleMessage");
			}
		},

		_handleMessage: function(/*String|Object*/message){
			if(dojo.isString(message)){
				this.setContent(message);
			}else{
				this.setContent(message.message, message.type, message.duration);
			}
		},

		_capitalize: function(/* String */w){
				return w.substring(0,1).toUpperCase() + w.substring(1);
		},

		setContent: function(/*String|Function*/message, /*String*/messageType, /*int?*/duration){
			// summary:
			//		sets and displays the given message and show duration
			// message:
			//		the message. If this is a function, it will be called with this toaster widget as the only argument.
			// messageType:
			//		type of message; possible values in messageTypes enumeration ("message", "warning", "error", "fatal")
			// duration:
			//		duration in milliseconds to display message before removing it. Widget has default value.
			duration = duration||this.duration;
			// sync animations so there are no ghosted fades and such
			if(this.slideAnim){
				if(this.slideAnim.status() != "playing"){
					this.slideAnim.stop();
				}
				if(this.slideAnim.status() == "playing" || (this.fadeAnim && this.fadeAnim.status() == "playing")){
					setTimeout(dojo.hitch(this, function(){
						this.setContent(message, messageType, duration);
					}), 50);
					return;
				}
			}

			// determine type of content and apply appropriately
			for(var type in this.messageTypes){
				dojo.removeClass(this.containerNode, "dijitToaster" + this._capitalize(this.messageTypes[type]));
			}

			dojo.style(this.containerNode, "opacity", 1);

			this._setContent(message);

			dojo.addClass(this.containerNode, "dijitToaster" + this._capitalize(messageType || this.defaultType));

			// now do funky animation of widget appearing from
			// bottom right of page and up
			this.show();
			var nodeSize = dojo.marginBox(this.containerNode);
			this._cancelHideTimer();
			if(this.isVisible){
				this._placeClip();
				//update hide timer if no sticky message in stack 
				if(!this._stickyMessage) {
					this._setHideTimer(duration);
				}
			}else{
				var style = this.containerNode.style;
				var pd = this.positionDirection;
				// sets up initial position of container node and slide-out direction
				if(pd.indexOf("-up") >= 0){
					style.left=0+"px";
					style.top=nodeSize.h + 10 + "px";
				}else if(pd.indexOf("-left") >= 0){
					style.left=nodeSize.w + 10 +"px";
					style.top=0+"px";
				}else if(pd.indexOf("-right") >= 0){
					style.left = 0 - nodeSize.w - 10 + "px";
					style.top = 0+"px";
				}else if(pd.indexOf("-down") >= 0){
					style.left = 0+"px";
					style.top = 0 - nodeSize.h - 10 + "px";
				}else{
					throw new Error(this.id + ".positionDirection is invalid: " + pd);
				}
				this.slideAnim = dojo.fx.slideTo({
					node: this.containerNode,
					top: 0, left: 0,
					duration: this.slideDuration});
				this.connect(this.slideAnim, "onEnd", function(nodes, anim){
						//we build the fadeAnim here so we dont have to duplicate it later
						// can't do a fadeHide because we're fading the
						// inner node rather than the clipping node
						this.fadeAnim = dojo.fadeOut({
							node: this.containerNode,
							duration: 1000});
						this.connect(this.fadeAnim, "onEnd", function(evt){
							this.isVisible = false;
							this.hide();
						});
						this._setHideTimer(duration);
						this.connect(this, 'onSelect', function(evt){
							this._cancelHideTimer();
							//force clear sticky message
							this._stickyMessage=false;
							this.fadeAnim.play();
						});

						this.isVisible = true;
					});
				this.slideAnim.play();
			}
		},
		
		_setContent: function(message){
			if(dojo.isFunction(message)){
				message(this);
				return;
			}
			if(message && this.isVisible){
				message = this.contentNode.innerHTML + this.separator + message;
			}
			this.contentNode.innerHTML = message;
		},
		_cancelHideTimer:function(){
			if (this._hideTimer){
				clearTimeout(this._hideTimer);
				this._hideTimer=null;
			}
		},
		
		_setHideTimer:function(duration){
			this._cancelHideTimer();
			//if duration == 0 we keep the message displayed until clicked
			if(duration>0){
				this._cancelHideTimer();
				this._hideTimer=setTimeout(dojo.hitch(this, function(evt){
					// we must hide the iframe in order to fade
					// TODO: figure out how to fade with a BackgroundIframe
					if(this.bgIframe && this.bgIframe.iframe){
						this.bgIframe.iframe.style.display="none";
					}
					this._hideTimer=null;
					//force clear sticky message
					this._stickyMessage=false;
					this.fadeAnim.play();
				}), duration);
			}
			else
				this._stickyMessage=true;
		},
		
		_placeClip: function(){
			var view = dijit.getViewport();

			var nodeSize = dojo.marginBox(this.containerNode);

			var style = this.clipNode.style;
			// sets up the size of the clipping node
			style.height = nodeSize.h+"px";
			style.width = nodeSize.w+"px";

			// sets up the position of the clipping node
			var pd = this.positionDirection;
			if(pd.match(/^t/)){
				style.top = view.t+"px";
			}else if(pd.match(/^b/)){
				style.top = (view.h - nodeSize.h - 2 + view.t)+"px";
			}
			if(pd.match(/^[tb]r-/)){
				style.left = (view.w - nodeSize.w - 1 - view.l)+"px";
			}else if(pd.match(/^[tb]l-/)){
				style.left = 0 + "px";
			}

			style.clip = "rect(0px, " + nodeSize.w + "px, " + nodeSize.h + "px, 0px)";
			if(dojo.isIE){
				if(!this.bgIframe){
					this.clipNode.id = dijit.getUniqueId("dojox_widget_Toaster_clipNode");
					this.bgIframe = new dijit.BackgroundIframe(this.clipNode);
				}
				var iframe = this.bgIframe.iframe;
				if(iframe){ iframe.style.display="block"; }
			}
		},

		onSelect: function(/*Event*/e){
			// summary: callback for when user clicks the message
		},

		show: function(){
			// summary: show the Toaster
			dojo.style(this.domNode, 'display', 'block');

			this._placeClip();

			if(!this._scrollConnected){
				this._scrollConnected = dojo.connect(window, "onscroll", this, this._placeClip);
			}
		},

		hide: function(){
			// summary: hide the Toaster

			dojo.style(this.domNode, 'display', 'none');

			if(this._scrollConnected){
				dojo.disconnect(this._scrollConnected);
				this._scrollConnected = false;
			}

			dojo.style(this.containerNode, "opacity", 1);
		}
	}
);

}

if(!dojo._hasResource["xwt.widget.notification.Toaster"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.notification.Toaster"] = true;
/* ************************************************** */
/* Copyright (c) 2009-2011 Cisco Systems, Inc.       */
/* All rights reserved.                               */
/* ************************************************** */ 

dojo.provide("xwt.widget.notification.Toaster");





dojo.declare("xwt.widget.notification.Toaster", [dojox.widget.Toaster, xwt.widget._ZIndexMixin], {
	//	summary:
	//		An extension of the dojox.widget.Toaster that provides filtering and queuing
	//
	//	description:
	//		An extension of the dojox.widget.Toaster that provides filtering and queuing.
	//		One toaster should be created for a page, and all messages can triggered by
	//		calling newMessage.
	//
	//	example:
	//	|	toaster = xwt.widget.notification.Toaster({}, node);
	//	|	toaster.newMessage("Some information", "information", "Info");
	//	|	toaster.newMessage("A warning, "warning", "Warning");

	templateString: '<div class="xwtToaster" dojoAttachPoint="clipNode"><div class="dijitToasterContainer" dojoAttachPoint="containerNode"><div class="dijitToasterContent" dojoAttachPoint="contentNode"></div></div></div>',
	
	// filteredMessageTypes: String[]
	//		Define a set of message types to filter out.
	// 		example: 
	// 		|	toaster.filteredMessageTypes = ["warning"] 
	// 		will filter out warning messages.
	filteredMessageTypes: [],
	
	postCreate: function(){
		this.overflowQueue = [];
		this.filteredMessageTypes = [];
		this._closeConnects = [];
		this.inherited(arguments);
		this.connect(dojo.global, "onresize", "_placeClip");
	},
	
	filterMessage: function(/*String*/message, /*String*/messageType, /*String*/ title){
	//Summary:
	//filter out not-want-to-see message.  
	//Your application should overwrite this function to implement customized filter logic.
		if(!this.shouldBeShown(messageType)){
			return true;
		}else{
			return false;
		}
	},
	
	newMessage: function(/*String*/message, /*String*/messageType, /*String*/ title){
		// summary:
		//		Displays a new message through the toaster notification system. If the
		//		message limit is exceeded, the message will be queued until there is room
		// 		to display the messsage.
		// 	message: String
		//		The message to display.
		//	messageType: String
		//		The type of message to display. Can be "success", "information", or "warning".
		//	title: String
		//		The title of the toaster message.
		
		if (this.filterMessage(message, messageType, title)){
			return;
		}
		if(message.length > this.maxCharacters){
			message = message.substring(0, this.maxCharacters - 3) + "...";
		}
	    
		var content = "<div class='xwtToasterMessageWrapper'><div class='xwt-" + 
				(messageType || "success") + "-message'><div class='xwtTitle'>" + title + 
				"</div><div class='xwtBody'>" + message + "</div></div></div>";
		if(this._currentlyShown >= this.maxMessages){
			this.overflowQueue.push(content);
			//console.log("in newMessage this.overflowQueue.length "+ this.overflowQueue.length);
		}else{
			this._showMessage(content);
		}
	},
	shouldBeShown: function(messageType){
		//	summary:
		//		For a given message: Indicates whether or not it should be shown, based on 
		// 		the filter. Can be overriden to provide custom filtering.
		if(dojo.indexOf(this.filteredMessageTypes, messageType) > -1){
			return false;
		}
		return true;		 
	},
	
	_showMessage: function(content){
		this._currentlyShown++;
		this.setContent(content);
		// zindex hook
		this.hookZIndex();
		//console.log("in _showMessage() this.overflowQueue.length "+ this.overflowQueue.length);
	},
	_setContent: function(message){
		if(!this.isVisible){
			this.contentNode.innerHTML = "";
			dojo.forEach(this._closeConnects, function(c){
				// Clean out any lingering connects.
				dojo.disconnect(c);	
			});
			this._closeConnects = [];
		}
		if(message){
			var toasterWrapper = dojo.create("div", {
				className: "xwtToasterWrapper",
				innerHTML: "<div class='xwtCloseIcon'></div>" + message
			}, this.contentNode);
			var closeIcon = dojo.query(".xwtCloseIcon", toasterWrapper)[0];
			
			var self = this;
			
			var cc = dojo.connect(closeIcon, "onclick", function(event){
				var i;
				// Clean up this connect, if possible.
				for(i = 0; i < self._closeConnects.length; i++){
					if(cc === self._closeConnects[i]){
						break;
					}
				}
				if(i < self._closeConnects.length){
					self._closeConnects.splice(i,1);
				}
				self.contentNode.removeChild(toasterWrapper);
				self._currentlyShown--;
				dojo.stopEvent(event);
				var content = self.overflowQueue.shift();
				if(content){
					self._showMessage(content);
				}else{
					self.setContent("");
				}
			});
			this._closeConnects.push(cc);
			if(!this._overflowHandler){
				this._overflowHandler = this.connect(this, "hide", function(evt){
					var content;
					self._currentlyShown = 0;
					while(self._currentlyShown < self.maxMessages && (content = self.overflowQueue.shift())){
						self._showMessage(content);
					}
				});
			}
		}
	},
	_placeClip: function(){
		if(this._currentlyShown){
			var view = dijit.getViewport();
			var nodeSize = dojo.marginBox(this.containerNode);
	
			var style = this.clipNode.style;
			// Sets up the size of the clipping node.
			style.height = nodeSize.h+"px";
			style.width = nodeSize.w+"px";
	
			// Sets up the position of the clipping node.
			var pd = this.positionDirection;
			// Calculate the bottom space between view and toaster container.
			var n = dojo.create("div", {style:{visibility:"hidden"}}, dojo.body());
			dojo.addClass(n,"xwtToasterBottomSpace");
			var bottomSpace = dojo.style(n,"height");
			
			if(pd.match(/^t/)){
				style.top = view.t+"px";
			}else if(pd.match(/^b/)){
				style.top = (view.h - nodeSize.h - 2 + view.t+bottomSpace)+"px";
			}
			
			if(pd.match(/^[tb]r-/)){
				style.left = (view.w - nodeSize.w - 1 - view.l)+"px";
			}else if(pd.match(/^[tb]l-/)){
				style.left = 0 + "px";
			}
			dojo.body().removeChild(n);
			style.clip = "rect(0px, " + nodeSize.w + "px, " + nodeSize.h + "px, 0px)";
			if(dojo.isIE){
				if(!this.bgIframe){
					this.clipNode.id = dijit.getUniqueId("dojox_widget_Toaster_clipNode");
					this.bgIframe = new dijit.BackgroundIframe(this.clipNode);
				}
				var iframe = this.bgIframe.iframe;
				if(iframe){ iframe.style.display="block"; }
			}
		}
	},
	_currentlyShown: 0,
	//	summary:
	//		The overflow queue
	overflowQueue: [],

	separator: "",

	//	summary:
	//		The maximum size of the message before showing ellipses.
	maxCharacters: 60,

	//	summary:
	//		The maximum messages before putting messages in the overflow queue.
	maxMessages: 10,
	
	duration:300,
	
	destroy: function(){
		try{
			if(this._closeConnects){
				dojo.forEach(this._closeConnects, function(c){
					dojo.disconnect(c);
				});
				delete this._closeConnects;
			}
			if(this._scrollConnected){
				// Clean up memleak in the dojox.widget.Toaster.
				dojo.disconnect(this._scrollConnected);
				delete this._scrollConnected;
			}
		}catch(e){}
		this.inherited(arguments);
	}
	
});
	

}

if(!dojo._hasResource["xwt.widget.table.Select"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.table.Select"] = true;
/* ************************************************* */
/* Copyright (c) 2009-2011 Cisco Systems, Inc.       */
/* All rights reserved.                              */
/* ************************************************* */

dojo.provide("xwt.widget.table.Select");




/*=====
xwt.widget.table.Select.__ctorArgs = function(model, multiple, selectAllOption, checkbox, radiobutton){
	//	summary:
	//		Arguments needed for the constructor to apply the Select component to
	//		a Table.
	//	model: String?
	//		The selection model to be used.  Valid values are row and input.
	//	multiple: Boolean?
	//		Indicates whether multiple selections are allowed.  Default is false.
	//	selectAllOption: Boolean?
	//		Indicates whether a "select all" option is given.  Only takes effect when multiple is true.
	//	checkbox: dijit._Widget.constructor?
	//		An optional widget constructor to be used in place of standard HTML checkboxes.
	//	radiobutton: dijit._Widget.constructor?
	//		An optional widget constructor to be used in place of standard HTML radio buttons.
	this.model = model;
	this.multiple = multiple;
	this.selectAllOption = selectAllOption;
	this.checkbox = checkbox;
	this.radiobutton = radiobutton;
}
=====*/
xwt.widget.table.Select = {
	//	summary:
	//		The component to enable item selection on a xwt.widget.table.Table.
	//	description:
	//		The Select pseudo-class (not intended to be instantiated directly) is applied
	//		to an existing xwt.widget.table.Table to allow for selection of items within a table.
	//		As such, it is essentially treated as a "mixin" to a Table.
	//
	//		When setting up the selection, you pass a named arguments object that specifies
	//		which selection model is to be used ("row" or "input"), and whether the table
	//		is to allow for multiple selections or not.
	//
	//	example:
	//		Set up a selection model on a Table:
	//	|	xwt.widget.table.Select.start.call(myTable, {
	//	|		model: "input",	//	Use radio or checkbox.
	//	|		multiple: true	//	Will use checkboxes.
	//	|		selectAllOption: true	//	Will include a checkbox in the header to select all items (note that this disables paging).
	//	|	});
	//
	//	_selected: [private] Array
	//		The internal array of selected items.
	//	_selectionModel: [const private] String
	//		The selection model being used on the table.  Valid values are row and input.
	//	_multiple: [const private] Boolean
	//		Indicates whether multiple selections are allowed on the table.
	//	_selectedCssClass: [const private] String
	//		The class that will be applied to a row on being selected.
	//	_checkbox: dijit._Widget
	//		The checkbox widget constructor to be used in a multiple selection model when "input"
	//		is used for the model.
	//	_radioButton: dijit._Widget
	//		The radio button widget constructor to be used in a single selection model when "input"
	//		is used for the model.
	_selected: null,
	_selectedIds: null,
	_selectionModel: "row",
	_multiple: false,
	_selectedCssClass: "selected",
	_checkbox: null,
	_radioButton: null,
	_unselectedIds: null,
	
	start: function(/* xwt.widget.table.Select.__ctorArgs */args){
		//	summary:
		//		The constructor is to be applied to a table instance; you should
		//		never call this directly.  It sets up the model and whether
		//		multiple selections are allowed or not.
		//	args: xwt.widget.table.Select.__ctorArgs
		//		The named arguments object that defines the selection model to be used.
		args = args || {};
		dojo.mixin(this, xwt.widget.table.Select);
		this._selected = [];
		this._selectedIds = {};
		this._unselectedIds = {};
		this._selectionModel = args.model || "row";
		this._selectAllOption = args.selectAllOption;
		this._multiple = args.multiple !== undefined ? args.multiple : false;
		this._checkbox = args.checkbox || null;
		this._radiobutton = args.radiobutton || null;
		
		// Check to see if the selection warning messages should be disabled or not.
		this._disableSelectAllMessage = args.disableSelectAllMessage;
		this._disableSelectAllMessage = args.disableSelectAllHardLimitMessage;
		this._disableShiftSelectWarning = args.disableShiftSelectWarning;

		// Try to set up the select all limit.
		this._selectAllLimit = args.selectAllLimit || 500;
		this._selectAllHardLimit = args.selectAllHardLimit || -1;
		if(this._selectAllHardLimit > 0 && 
			this._selectAllLimit > this._selectAllHardLimit){
			this._selectAllLimit = this._selectAllHardLimit;
		}
		//	Apply the rendering here.
		this._select_startup();
	},

	//	private methods.
	_select_startup: function(){
		//	summary:
		//		Set up what is needed on a table for implementing the selection model.
		//		This is called internally by our constructor.
		var self = this;

		// Build our informative toasters.
		this._selecti18n = dojo.i18n.getLocalization("xwt.widget.table", "Select");
		
		if(!this._disableSelectAllWarning || !this._disableShiftSelectWarning){
			this._selectToaster = new xwt.widget.notification.Toaster({
				id: this.id + "_xwtTable_selectEventMessages",
				duration: 15000,
				maxCharacters: 1000
			});
			dojo.body().appendChild(this._selectToaster.domNode);
			this._selectToaster.startup();
			this.connect(this._selectToaster.contentNode, "onclick", function(evt){
				if(evt){
					var node = evt.target;
					if(node && node.nodeType == 1){
						if(dojo.attr(node, "disableselectallmessage")){
							this._disableSelectAllMessage = node.checked;
						}else if(dojo.attr(node, "disableselectallhardlimitmessage")){
							this._disableSelectAllHardLimitMessage = node.checked;
						}else if(dojo.attr(node, "disableshiftselectmessage")){
							this._disableShiftSelectWarning = node.checked;
						}
					}
				}
			});
			var tCleanup = dojo.connect(this, "destroy", this, function(){
				dojo.disconnect(tCleanup);
				if(this._selectToaster){
					this._selectToaster.destroyRecursive();
					this._selectToaster.destroyRecursive = function(){};
					this._selectToaster.destroy = function(){};
					delete this._selectToaster;
				}
			});
		}
		
		if(this._selectAllOption){
			function connectToSelectAll(){
				var selectAllCheckbox = dojo.query(".select-all", self.tableHeadRow)[0];
				self.connect(selectAllCheckbox, "onclick", function(){
					self.selectAll(selectAllCheckbox.checked);
				});

				// We need to validate that all the rows were selected before we restore the
				// select all checkbox.
				var allSelected = self._selected.allSelected;
				if(allSelected){
					var except = dojo.isFunction(allSelected.except)? allSelected.except(): null;
					if(except && except.length){
						allSelected = false;
					}
				}
				var selAll = !!(self._selected && allSelected); 
				selectAllCheckbox.checked = selAll;
				if(selAll){
					dojo.addClass(selectAllCheckbox.parentNode, "dijitCheckBoxChecked");
				}else{
					dojo.removeClass(selectAllCheckbox.parentNode, "dijitCheckBoxChecked");
				}
			}
			connectToSelectAll();
			this.connect(this, "render", connectToSelectAll);
		}
		this.connect(this.tableBody, "onclick", "_selector");
		this.connect(this.tableRowTopNodeContainer, "onclick", "_selector");
		this.connect(this.tableRowBottomNodeContainer, "onclick", "_selector");
	},
	
	_selector: function(event){
		var element = event.target;
		var input = element.tagName.toLowerCase() == "input";
		if(this._selectionModel == "row" || (input && element.className == "selection-input")){
			//why do we need this?? Causes issues with clicking on hyperlink in row selectionModel. see CSCtl98282
			//if(!this._multiple){
			//	dojo.stopEvent(event);
			//}
			if(this._multiple && event.shiftKey && this._focusedNode){
				var prevRowIndex = dojo.attr(this._focusedNode, "rowindex");
				var prevRowItemId = dojo.attr(this._focusedNode, "item-id");
				if(this.isSelected(this._indexToItem[prevRowIndex])){
					// Okay we rally don't want the text selection, so
					// We need to clear it.  Reusing some logic from
					// dijit editor for clearing text selection.
					try{
						if(dojo.global.getSelection){
							var selection = dojo.global.getSelection();
							if(selection.removeAllRanges){ 
								// Mozilla and sometimes WebKit
								if(selection.rangeCount && selection.collapseToStart){
									selection.collapseToStart();
								}
							}else{ 
								// Safari
								selection.collapse(true);
							}
						}else if(dojo.doc.selection){ 
							// IE 
							var range = dojo.doc.selection.createRange();
							range.collapse(true);
							range.select();
						}
					}catch(e){
						// Ignore
					}
					
					//	previous index was selected, so select the range.
					var currentRowIndex = this._findRowId(element);
					var currentRowItemId = this._findItemId(element);
					var sItem = this._idToItem[prevRowItemId];
					var eItem = this._idToItem[currentRowItemId];
					
					var rangeInfo = {
						startRow: prevRowIndex,
						startId: this.store.isItem(sItem)? this.store.getIdentity(sItem): null,
						endRow: currentRowIndex,
						endId: this.store.isItem(eItem)? this.store.getIdentity(eItem): null,
						lockedItemIds: []
					};
					if(this._lockedItems){
						var id;
						for(id in this._lockedItems){
							rangeInfo.lockedItemIds.push(id);
						}
					}
					if(this._sortable){
						rangeInfo.sort = dojo.clone(this._getSortProps());
					}
					if(this._currentFilter){
						rangeInfo.filter = dojo.clone(this._currentFilter);
					}

					this.onSelectRange(rangeInfo);
					var start = parseInt(rangeInfo.startRow, 10);
					var end = parseInt(rangeInfo.endRow, 10);
					var size = Math.abs(end - start) + 1;
					
					var exceedsLimit = false;
					var exceedsBy = Math.abs(size - this._selectAllLimit);

					if(start > end){
						if(size > this._selectAllLimit){
							exceedsLimit = true;
							var end = start - (this._selectAllLimit - 1);
						}
						var tmp = start;
						start = end;
						end = tmp;
					}else if(size >= this._selectAllLimit){
						exceedsLimit = true;
						end = start + (this._selectAllLimit - 1);
					}
					
					if(start < 0){
						// Make sure we haven't gone negative.
						start = 0;
					}
					
					var loadingDef = this.scrollToRow(start);
					loadingDef.addCallback(dojo.hitch(this, function(){
						setTimeout(dojo.hitch(this, function(){
							if(this._selectToaster && exceedsLimit && !this._disableShiftSelectWarning){
								var msg = dojo.string.substitute(this._selecti18n.shiftSelectWarning, {0: this._selectAllLimit, 1: (start + 1), 2: (end + 1), 3: exceedsBy});
								msg += "<br><br><input type='checkbox' disableshiftselectmessage='true'> <i>" + this._selecti18n.shiftSelectDisableMsg + "</i>";
								this._selectToaster.newMessage(msg, "warning", this._selecti18n.shiftSelectTitle);
							}
							var def = this._selectionFetch(start, (end - start) + 1); 
							def.addCallback(dojo.hitch(this, function(){
								// console.log("shift-select done.");
							}));
						}),10);
					}));
				}else{
					this.select(this._indexToItem[this._findRowId(element)]);
				}
			}else{
				/* Not required anymore
				if(!this._multiple || (!(event.ctrlKey || event.metaKey) && this._selectionModel == "row")){
					this.deselectRange(this._selected);
				}
				*/
				this._setByRow(element);
			}
		}
	},

	_selectionFetch: function(start, count){
		// summary:
		//	A function to handle doing a selectAll-style fetch when invoked.
		// start:
		//	The 'index' to start at (usually 0).
		// count:
		//	The number of records to retrieve (usually selectAll limit).
		// tags:
		//	private
		
		var def = new dojo.Deferred();
		if(this._loadingIndicator){
			this._loadingIndicator.show();
			def.addCallback(dojo.hitch(this, function(){
				this._loadingIndicator.hide();
			}));
			def.addErrback(dojo.hitch(this, function(){
				this._loadingIndicator.hide();
			}));
		}
			
		def.addErrback(dojo.hitch(this, function(error){
			table._onLoadError(error);
		}));
			
		var req = this.store.fetch({
			query: this.query,
			filter: this._currentFilter,
			sort: this._sortable ? this._getSortProps() : null,
			start: start,
			count: count,
			queryOptions: this.queryOptions,
			onComplete: dojo.hitch(this, function(items, request){
					//console.log("Start: ", request.start)
					//console.log("Count: ", request.count);
					//console.log("Returned: ", items.length);
				if(items && items.length > 0){
					dojo.forEach(items, function(item){
						if(!this.isLocked(item)){
							this.select(item);
						}
					}, this);
				}
				def.callback(true);
			}),
			onError: function(err, request){
				def.errback(err);
			}
		});
		return def;
	},

	selectAll: function(selectAll){
		//	summary:
		//		"Select all" items toggle.
		// selectAll:
		//		Indicates whether to select all or deselect all.
		this.clearSelections();
		var self = this;
		
		// indicate that all are selected, even the ones we don't know about.
		self._selected.allSelected = selectAll ? {
			except: function(){
				var notSelected = [];
				// Enumerates the exceptions to the selection of all the items.
				for(id in self._unselectedIds){
					var item = self._idToItem[id];	
					if(item){
						notSelected.push(item);
					}
				}
				return notSelected;
			}
		} : false;
		self.__selectingAll = true;	//	We just want to know that we're doing something to everything.
		
		if(selectAll){
			// Scroll to the top and start selecting, as that's where select-all starts from.
			// We don't use scroll-to-row here, we want to clear and re-render to reset caches.
			setTimeout(dojo.hitch(this, function(){
				self._lastScrollTop = 0;
				self.tableContainer.scrollTop = 0;
				// We also want to allow fetch select since we will fetch from the top.
				this.__allowFetchSelect = true;
				var sDef = self.render();
				sDef.addCallback(dojo.hitch(this, function(){
					// SelectAll will just try to fetch up to the selection limit to avoid problems with performance.
					// self[selectAll ? "selectRange" : "deselectRange"](this._indexToItem);
					delete this.__allowFetchSelect;
					var selectAllCheckbox = dojo.query(".select-all", self.tableHeadRow)[0];
					if(selectAllCheckbox){
						selectAllCheckbox.checked = true;
						dojo.addClass(selectAllCheckbox.parentNode, "dijitCheckBoxChecked");
					}				
					
					// CSCth63766
					// We need to also handle 'locked' items.  Ugh.
					var lcCount = 0;
					if(self._lockedItems){
						var id;
						var lockedItems = [];
						for(id in self._lockedItems){
							lockedItems.push(self._lockedItems[id]);
							lcCount++;
						}
						if(lockedItems.length){
							// Make sure they're selected and tagged such in the table.
							self.deselectRange(lockedItems);
							self.selectRange(lockedItems);
						}
					}
			
					// Grab the data, up to the selection.
					var def = this._selectionFetch(0, (this._selectAllLimit - lcCount));
					def.addCallback(function(){	
						delete self.__selectingAll;
						if(selectAll && self._totalRows > self._selectAllLimit){
							setTimeout(function(){
								if(self._selectToaster && !self._disableSelectAllMessage){
									var msg = self._selectAllHardLimit > 0 ? self._selecti18n.selectAllWithLimitWarning : self._selecti18n.selectAllWarning;
									msg = dojo.string.substitute(msg, {0: self._selectAllLimit, 1: self.rowsPerPage, 2: self._selectAllHardLimit});
									msg += "<br><br><input type='checkbox' disableselectallmessage='true'> <i>" + self._selecti18n.selectAllDisableMsg + "</i>";
									self._selectToaster.newMessage(msg, "information", self._selecti18n.selectAllTitle);
								}
							}, 100);
							self.onSelectAll();
						}
					});
				}));
			}));
		}
	},
	//	methods applied to the Table in question.
	selected: function(/* dojo.data.Item[]? */items){
		//	summary:
		//		Getter/setter for the table selection.  If items is not undefined, then pre-select
		//		the items, firing off the appropriate events.  Will return all selected
		//		items as in an array, regardless of the selection model.
		//	items: dojo.data.Item[]?
		//		Optional items to be selected, if treating this as a setter.
		if(items){
			this.selectRange(items);
		}
		return this._selected.slice(0);	// dojo.data.Item[]
	},
	select: function(/* dojo.data.Item */item, /* DOMNode? */_element){
		//	summary:
		//		Given a dojo.data item, add a reference to the internal selection queue,
		//		making sure that said item is part of the underlying store.  If the selection
		//		allowed is only single, ensure that any other items selected are cleared.
		//	item: dojo.data.Item
		//		The item to select.
		//	returns:
		//		'this' to allow for functional chaining.
		var selectIt = true;
		if(this._selected.allSelected &&
			this._selectAllHardLimit > 0 && 
			this._selected.length == this._selectAllHardLimit){
			// We're at the limit, disallow any further selection, even programmatic ones.
			// So we need to pop a toaster here!  Whee.
			selectIt = false;			
		}
		if(!item) { return this; }
		if(!this.isSelectable(item)){
			return this;
		}
		var id = this.store.getIdentity(item);
		if(id in this._selectedIds){
			// already selected
			return this;
		}
		if(!this._multiple){
			this.deselectRange(this._selected);
		}
		var rowIndex = this._idToIndex[id];	
		if(!_element || !this._lockedItems || !this._lockedItems[id]){
			// _element = dojo.query('.' + this._css.row + '-' + rowIndex, this.tableBody)[0];
			// Query based on ID, not row index, experimental 'testfix'.
			// Use pure selectors, not selector and attribute, and it is much faster.
			_element = dojo.query("." + this._uniqueCssId + '.' + this._css.row + "-itemid-" + this._santizeIdentityForCss(id), this.tableBody)[0]
		}
		if(!_element || dojo.hasClass(_element, "row-locked")){
			//CSCth67366:  Might be a locked item, we have to go look in the lock area.
            var c = (this._visibleLockedContainer == "top" ? "Top" : "Bottom"),
            inner = this["tableRow" + c + "InnerContainer"];
			if(inner){
				var rows = dojo.query("." + this._uniqueCssId + '.' + this._css.row + "-itemid-" + this._santizeIdentityForCss(id), inner);
				if(rows && rows.length == 1){
					_element = rows[0];
				}
			}
		}
		if(_element){
			//if row-click selection get to the right element
			var row = _element;
			while(row && !dojo.attr(row, "item-id") && row != this.tableBody){
				row = row.parentNode;
			}
			if(dojo.attr(row, "item-id") == null){
				_element = null;
			}
			else{
				_element = row;
			}
		}
		if(_element){
			if(selectIt){
				var self = this;
				var e = _element;
				setTimeout(function(){
					var inputElements = dojo.query("." + self._uniqueCssId + ' ' + 'input.selection-input', e);
					if(!self._lockedItems || !self._lockedItems[id]){
						dojo.addClass(e, "selected");
					}
					inputElements.attr("checked", true);
					dojo.forEach(inputElements, function(inputNode){
						if(inputNode.parentNode){
							dojo.addClass(inputNode.parentNode, (inputNode.type == "radio" ? "dijitRadioChecked" : "dijitCheckBoxChecked"));
						}
					},self);
				});
			}else{
				// We don't actually want to select it because we hit select all hard limit
				// so make sure the state is right.
				// We should also pop the toaster here?   Could spam-message it,
				// Hm.  Oh, timeout would do it.
				if(this.__selectAllLimitTimer){
					clearTimeout(this.__selectAllLimitTimer);
				}
				if(this._selectToaster && !this._disableSelectAllHardLimitMessage){
					this.__selectAllLimitTimer = setTimeout(dojo.hitch(this, function(){
						var msg = this._selecti18n.selectAllLimitHitWarning;
						msg = dojo.string.substitute(msg, {0: this._selectAllLimit, 1: this._selectAllHardLimit});
						msg += "<br><br><input type='checkbox' disableselectallhardlimitmessage='true'> <i>" + this._selecti18n.selectAllHardLimitDisableMsg + "</i>";
						this._selectToaster.newMessage(msg, "warning", this._selecti18n.selectAllHitLimitTitle);
					}), 500);
				}
				
				if(!this._lockedItems || !this._lockedItems[id]){
					dojo.removeClass(_element, "selected");
				}
				var inputElements = dojo.query("." + this._uniqueCssId + ' ' + 'input.selection-input', _element);
				setTimeout(function(){
					inputElements.attr("checked", false);
					dojo.forEach(inputElements, function(inputNode){
						if(inputNode.parentNode){
							dojo.removeClass(inputNode.parentNode, (inputNode.type == "radio" ? "dijitRadioChecked" : "dijitCheckBoxChecked"));
						}
					});
				});
			}
		}
		if(selectIt){
			this._selected.push(item);
			this._selectedIds[id] = true;
			delete this._unselectedIds[id];
			this.onSelect(item, _element);
			_element = null;
			//	Check for select all option and whether all items have been selected.
			if(/*this._selectionModel == "input" &&*/ this._selectAllOption && !this.__selectingAll){
				var selectAllCheckbox = dojo.query(".select-all", this.tableHeadRow)[0];
				if(selectAllCheckbox){
					// We need to look at all items not just table index.
					if(this._selected.allSelected){
						var selAll = true;
						if(dojo.isFunction(this._selected.allSelected.except)){
							var except = this._selected.allSelected.except();
							if(except.length){
								if(!(this._selectAllHardLimit > 0 && this._selected.length == this._selectAllHardLimit)){
									// If there is no hard limit and there were exceptions, uncheck the select-all in the header
									// If there are values in the except list, but we're at the hard limit, go ahead and 
									// check it.
									selAll = false;
								}
							}
						}
						selectAllCheckbox.checked = selAll;
						if(selAll){
							dojo.addClass(selectAllCheckbox.parentNode, "dijitCheckBoxChecked");
						}else{
							dojo.removeClass(selectAllCheckbox.parentNode, "dijitCheckBoxChecked");
						}
					}
				}
			}
		}
		return this;	//	xwt.widget.table.Table
	},
	selectRange: function(/* dojo.data.Item[] */items){
		//	summary:
		//		Select a range of items at once.
		//	items: dojo.data.Item[]
		//		The data items to be selected.
		//	returns:
		//		'this' to allow for functional chaining.
		for(var i = 0; i < items.length; i++){
			this.select(items[i]);
		}
		return this;	//	xwt.widget.table.Table
	},
	selectByIndex: function(/* Number */idx){
		//	summary:
		//		Given a row index, create a selection by finding the item in question and
		//		internally firing select().
		//	idx: Number
		//		The row index number to select by.
		//	returns:
		//		'this' to allow for functional chaining.
		this.select(this._indexToItem[idx]);
		return this;	//	xwt.widget.table.Table
	},
	_findRowId: function(/* Node */element){
		while(element){
			var rowId = element.className && element.className.match(this._css.row + "\\-([0-9]+) ");
			if(rowId){
				return rowId && rowId[1];
			}
			element = element.parentNode;
		}
		
	},
	_setByRow: function(/* Node */element, /* Boolean */select){
		var rowId = this._findRowId(element);
		var itemId = this._findItemId(element);
		
	//if row-click selection, element will be div.cell, so traverse to get the parent		
		if(rowId){
			//dont select if locked
			var row = element;
			while(row && !dojo.attr(row, "item-id") && row != this.tableBody){
				row = row.parentNode;
			}
			if(dojo.attr(row, "item-id") == null){
				row = null;
			}
			
			if(!row || dojo.hasClass(row, "row-locked")){
				return false;
			}
				
			var item = this._idToItem[itemId];
			var id = this.store.getIdentity(item);
			select = typeof select == "boolean" ? select : !(id in this._selectedIds);
			if(select){
				this.select(item, element);
			}else{
				this.deselect(item, element);
			}
			return select;
		}else{
			// May be a locked row, dig a bit.
			if(itemId && this._lockedItems){
				var item = this._lockedItems[itemId];
				if(item){
					select = typeof select == "boolean" ? select : !(itemId in this._selectedIds);
					if(select){
						this.select(item, element);
					}else{
						this.deselect(item, element);
					}
					return select;
				}
			}
		}
	},

	_findItemId: function(element) {
		var itemId = null;
		while(element){
			itemId = dojo.attr(element, "item-id");
			if(itemId){
				return itemId;
			}
			element = element.parentNode;
		}
	},

	isSelected: function(/* dojo.data.Item */ item){
		//	summary:
		//		Returns whether this item is selected or not.
		var id = this.store.getIdentity(item);
		var except = this._selected.allSelected ? this._selected.allSelected.except() : [];
		var selected = true;
		var i;
		for(i = 0; i < except.length; i++){
			if(id == this.store.getIdentity(except[i])){
				selected = false;
				break;
			}
		}
		return (id in this._selectedIds) || (this._selected.allSelected && selected && !(id in this._idToIndex));	//	Boolean
	},

	isSelectable: function(/* dojo.data.Item */ item){
		//	summary:
		//		Returns whether or not this item can be selected. Exists so that it can be
		//		overriden with alternate selectability criteria.
		return true;
	},
	
	selectByRow: function(/* Node */row){
		//	summary:
		//		Given a row, create a selection by finding the item in question and
		//		internally firing select().
		//	row: DOMNode
		//		The node representing the row to be selected.
		//	returns:
		//		'this' to allow for functional chaining.
		this._setByRow(row, true);
		return this;	//	xwt.widget.table.Table
	},
		
	deselect: function(/* dojo.data.Item */item, /* DOMNode? */_element){
		//	summary:
		//		Given a dojo.data item, remove any internal references to the selection.
		//	item: dojo.data.Item
		//		The data item to be deselected.
		//	returns:
		//		'this' to allow for functional chaining.
		if(!item) { return; }
		var id = this.store.getIdentity(item);
		if(!(id in this._selectedIds)){
			// already not selected
			return this;
		}
		var selectedIndex = -1;
		var i;
		for(i = 0; i < this._selected.length; i++){
			if(id == this.store.getIdentity(this._selected[i])){
				selectedIndex = i;
				break;
			}
		}
		var rowIndex = this._idToIndex[id];
		
		// If it's a locked row, we can't find the row element this way. 
		if(!this._lockedItems || !this._lockedItems[id]){
			//_element = dojo.query('.' + this._css.row + '-' + rowIndex, this.tableBody)[0];
			// Select the row by its item ID.  Experimental fix for select/deselect.
			// Use pure selectors, not selector and attribute, and it is much faster.
			_element = dojo.query("." + this._uniqueCssId + '.' + this._css.row + "-itemid-" + this._santizeIdentityForCss(id), this.tableBody)[0];
		}
		if(!_element || dojo.hasClass(_element, "row-locked")){
			//CSCth67366:  Might be a locked item, we have to go look in the lock area.
			var c = (this._visibleLockedContainer == "top" ? "Top" : "Bottom"),
				inner = this["tableRow" + c + "InnerContainer"];
			if(inner){
				var rows = dojo.query("." + this._uniqueCssId + '.' + this._css.row + "-itemid-" + this._santizeIdentityForCss(id), inner);
				if(rows && rows.length == 1){
					_element = rows[0];
				}
			}
		}
		if(_element){
			//get to the right element
			var row = _element;
			while(row && !dojo.attr(row, "item-id") && row != this.tableBody){
				row = row.parentNode;
			}
			if(dojo.attr(row, "item-id") == null){
			_element = null;
			}
			else{
				_element = row;
			}
		}

		if(_element){			
			if(!this._lockedItems || !this._lockedItems[id]){
				dojo.removeClass(_element, "selected");
			}
			var e = _element;
			var self = this;
			setTimeout(function(){
				var inputElements = dojo.query("." + self._uniqueCssId + ' ' + 'input.selection-input', e);
				inputElements.attr("checked", false);
				dojo.forEach(inputElements, function(inputNode){
					if(inputNode.parentNode){
						dojo.removeClass(inputNode.parentNode, (inputNode.type == "radio" ? "dijitRadioChecked" : "dijitCheckBoxChecked"));
					}
				});
			});
		}

	 	this._selected.splice(selectedIndex, 1);
		delete this._selectedIds[id];
		this._unselectedIds[id] = true;
		this.onDeselect(item, _element);
		if(!this._selected.length){
			this.onClearSelections();
		}

		//	check for select all option and whether all items have been selected.
		if(/*this._selectionModel == "input" && */this._selectAllOption && !this.__selectingAll){
			var selectAllCheckbox = dojo.query(".select-all", this.tableHeadRow)[0];
			if(selectAllCheckbox){
				// We need to look at all items not just table index.
				if(this._selected.allSelected){
					var selAll = true;
					if(dojo.isFunction(this._selected.allSelected.except)){
						var except = this._selected.allSelected.except();
						if(except.length){
							selAll = false;
						}
					}
					selectAllCheckbox.checked = selAll;
					if(selAll){
						dojo.addClass(selectAllCheckbox.parentNode, "dijitCheckBoxChecked");
					}else{
						dojo.removeClass(selectAllCheckbox.parentNode, "dijitCheckBoxChecked");
					}
				}
			}
		}
		_element = null;
		return this;	//	xwt.widget.table.Table
	},
	deselectRange: function(/* dojo.data.Item[] */items){
		//	summary:
		//		Deselect a range of items at once.
		//	items: dojo.data.Item[]
		//		Any number of items to deselect.
		//	returns:
		//		'this' to allow for functional chaining.
		for(var i = items.length - 1; i >= 0; i--){
			if(items[i]){
				this.deselect(items[i]);
			}
		}
		return this;	//	xwt.widget.table.Table
	},
	deselectByIndex: function(/* Number */idx){
		//	summary:
		//		Given a row index, remove a selection by finding the item in question and
		//		internally firing deselect().
		//	idx: Number
		//		The row index at which to deselect something.
		//	returns:
		//		'this' to allow for functional chaining.
		this.deselect(this._indexToItem[idx]);
		return this;	//	xwt.widget.table.Table
	},
	deselectByRow: function(/* Node */row){
		//	summary:
		//		Given a row, remove a selection by finding the item in question and
		//		internally firing deselect().
		//	row: DOMNode
		//		The node representing the row in the table to deselect.
		//	returns:
		//		'this' to allow for functional chaining.
		this._setByRow(row, false);
		return this;	//	xwt.widget.table.Table
	},

	clearSelections: function(){
		//	summary:
		//		Clear all current selections, and fire onClearSelections().
		//	returns:
		//		'this' to allow for functional chaining.
		delete this._selected.allSelected;
		var selectAllCheckbox = dojo.query(".select-all", this.tableHeadRow)[0];
		if(selectAllCheckbox){
			selectAllCheckbox.checked = false;
			dojo.removeClass(selectAllCheckbox.parentNode, "dijitCheckBoxChecked");
		}
		this.deselectRange(this._selected.slice(0));		
		this._unselectedIds = {};
		this._selectedIds = {};
		this.onClearSelections();
		return this;	//	xwt.widget.table.Table
	},

	onSelect: function(/* dojo.data.Item */item, /* DOMNode? */row){
		//	summary:
		//		Event stub for when a selection is made.
		//	tags:
		//		callback
		if(row){
			dojo.query("." + this._uniqueCssId + ' ' + '.selection-input', row).attr("checked", 'checked');
		}
	},	
	onSelectRange: function(/* Object */ rangeInfo){
		// summary:
		//		Event that fires when a user does a shift-click to
		//		try and select a range of rows.  It provides the start and end
		//		row numbers and item IDs.  This is because it is possible
		//		that the range is huge and not all the items have been 
		//		cached into the browser.  This can be used by
		//		server-side services for handling the selection in some manner
		//		(apply actions).
		// rangeInfo: Object
		//		{
		//			startRow: int,
		//			startId: string|object,
		//			endRow: int,
		//			endId: string|object
		//			sort: undefined|array of sort field data (objects of format: { attribute: "attr", descending: true|false}
		//			filter: undefined|object clone of the filter parameters used for the table, including conjunction info and expression details.
		//		}
		// tags:
		//		callback
	},		
	onDeselect: function(/* dojo.data.Item */item, /* DOMNode? */row){
		//	summary:
		//		Event stub for when an item is unselected.
		//	tags:
		//		callback
		if(row){
			dojo.query("." + this._uniqueCssId + ' ' + '.selection-input', row).attr("checked", '');
		}
	},
	onClearSelections: function(){
		//	summary:
		//		Event stub for when all items are unselected.
		//	tags:
		//		callback
		var selectAllCheckbox = dojo.query(".select-all", this.tableHeadRow)[0];
		if(selectAllCheckbox){
			dojo.attr(selectAllCheckbox, "checked", false);
			selectAllCheckbox.checked = false;
			dojo.removeClass(selectAllCheckbox.parentNode, "dijitCheckBoxChecked");
		}
	},
	onSelectAll: function(){
		//	summary:
		//		Event stub for when all items are selected.
		//	tags:
		//		callback
	}
};

}

if(!dojo._hasResource["xwt.widget.table.Sort"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.table.Sort"] = true;
/* ************************************************** */
/* Copyright (c) 2009-2011 Cisco Systems, Inc.       */
/* All rights reserved.                               */
/* ************************************************** */

dojo.provide("xwt.widget.table.Sort");

xwt.widget.table.Sort = {
	//	summary:
	//		The sort extension for a Table.  As with other components, this
	//		constructor should be applied directly to a Table.
	//	description:
	//		This pseudo-class (not intended to be instantiated directly) is applied
	//		to an existing xwe.widget.table.Table to allow for any kind of sort capability.
	//		As such, it is essentially treated as a "mixin" to a Table.
	//
	//		If a default sort is desired, a xwe.widget.Column reference should be 
	//		passed to the constructor (see example, below).
	//
	//	example:
	//		Set up the sort ext on a Table.
	//	|	xwt.widget.table.Sort.call(myTable, myDefaultColumnToSortOn);
	//
	//	_sortedColumn: xwt.widget.Column?
	//		The current column used for sorting.
	//	_sortDirection: String?
	//		The sort direction.  Can be ascending or descending.
	_sortable: true,
	_sortedColumn: null,
	_sortDirection: "ascending",

	start: function(column){
		//	summary:
		//		Constructor function for the Sort ext.  To specify
		//		a default sort column, pass a column reference to the
		//		application of this constructor.
		//	column: xwe.widget.Column?
		//		An optional column reference passed to establish the default sorting.
		var oldOnSort = this.onSort;
		dojo.mixin(this, xwt.widget.table.Sort);
		this.onSort = oldOnSort;

		if(typeof column != 'undefined'){
			this._sortedColumn = column;
			this._sortDirection = column.sorted;
		}
	},

	_onSort: function(column, direction){
		var def = this.render(true);
		var c = column;
		var d = direction;
		def.addCallback(dojo.hitch(this, function(){
			this.onSort && this.onSort(c, d);
		}));
	},

	_getSortProps: function(){
		if(this._sortedColumn){
			return [{ attribute: this._sortedColumn.attr, descending: this._sortDirection == 'descending'  }];
		}else{
			return null;
		}
	},

	_applySortProperties: function(column, cell_props){
		cell_props.containerClass += ' sortable';
		var l10n = this.l10n,
			sort_tooltip = l10n.sortable;
			
		//we need to see if a title is provided. Use the title then, otherwise use the label
		//useful when column label is an icon - CSCti46809
		var displayStr;
		if (column.title)
		{
			displayStr = column.title;
		}
		else{
			displayStr = column.label;
		}

		if(column.sorted){
			sort_tooltip = l10n.sorted;
			cell_props.containerClass += ' sortable-' + column.sorted;
		}
		cell_props.containerAttrs += ' title="' + displayStr.replace(/<[^>]*>/g, "").replace(/\s+/g, " ").replace(/[\r\n\t]/g, " ") + sort_tooltip  + '"';
		cell_props.cellTitle = displayStr.replace(/<[^>]*>/g, "").replace(/\s+/g, " ").replace(/[\r\n\t]/g, " ") + sort_tooltip;
	},

	_sortIndicatorTemplate: '<div class="sortable-indicator" role="presentation"></div>',
	_createSortIndicator: function(column, cell_props){
		if(!column.wrapping){
			var ellipsisClass = column._columns.table._css[xwt.widget.table.ellipsizeCells ? 'ellipsisNotDone' : 'ellipsis'] + ' no-wrapping';
			var cn = " " + cell_props.cellClass + " ";
			cell_props.cellClass = dojo.trim(cn.replace(/ ellipsis|ellipsis-not-done /g, ' '));
			cell_props.innerHTML = this._sortIndicatorTemplate + '<div class="' + ellipsisClass + '">' +
				cell_props.innerHTML + '</div>';
		}else{
			cell_props.innerHTML = this._sortIndicatorTemplate + cell_props.innerHTML;
		}
	},

	sort: function(column, direction){
		//	summary:
		//		Begin the sort process on a Table.
		//	
		//	description:
		//		When sorting the table, pass a xwt.widget.table.Column reference
		//		and an optional direction (ascending or descending).  If no
		//		direction is passed, ascending is assumed.
		//	column: xwt.widget.table.Column
		//		The column you wish to use for sorting on.
		//	direction: String?
		//		An optional direction to sort; can be "ascending" or "descending".
		//	
		//	example:
		//	|	myTable.sort(someColumn);
		//
		//	returns:
		//		'this' to allow for functional chaining.

		//check for editing
		//if editing in progress ignore the click and do not do anything - CSCtj51445
		if (this.editing && this.editing())
		{
			console.log("editing in progress. cannot sort");
			return this;
		}
	
		//Fix for CSCtn54045
		//Check if a row is expanded and if it is close it first
		 
		if(this.expanded && this.expanded()){
			this.getExpander()._collapseRow();
		}

		if(!column.sortable){
			return this;
		}

		var oldColumn = this._sortedColumn;
		if(oldColumn){
			oldColumn.sorted = false;
		}

		this._sortDirection = column.sorted = direction;
		this._sortedColumn = column;

		// Don't sort quite yet, let the event bubble 
		// in case it is within a quickview.  Sorting
		// immediately can trigger the containing QV
		// to close.
		setTimeout(dojo.hitch(this, function(){
			this._onSort(column, direction);
		}),0);

		return this;	//	xwe.widget.table.Table
	},
	onSort: function(column, direction){
		//	summary:
		//		Event stub for when a sort is performed.
		//	description:
		//		When sorting the table, this event is fired so that anything
		//		can listen for when the table is sorted.
		//	column: xwe.widget.Column
		//		The column you want to sort on.
		//	direction: String
		//		The direction of the sort; can be "ascending" or "descending".
	},
	
	getSortInfo: function(){
		// summary:
		//		Function to obtain the 'sort' details of the table (for example, what
		//		attribute, asc/desc, and what Column (by label), was sorted).
		// returns:
		//		An array of column data the table is sorted by.  Structure of each is:
		//	|	{
		//	|		attribute: "attr", // String attribute name of the data field being sorted on.
		//	|		descending: boolean|undefined|null, // Indicator if the sort is descending, if false|null|undefined, is it ascending.
		//	|		columnLabel: "someLabel" // Text label of the column.
		//	|	}
		// tags:
		//		public
		var sort = [];
		if(this._sortable){
			var props = this._getSortProps();
			if(props){
				dojo.forEach(props, function(sProp){
					var c = this._sortedColumn;
					if(c){
						sort.push({
							attribute: sProp.attribute,
							descending: sProp.descending,
							columnLabel: c.label
						});
					}
				}, this);
			}
		}
		return sort; // Array
	}
};

}

if(!dojo._hasResource["xwt.widget.table.Edit"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.table.Edit"] = true;
/* ************************************************** */
/* Copyright (c) 2009-2011 Cisco Systems, Inc.       */
/* All rights reserved.                               */
/* ************************************************** */

dojo.provide("xwt.widget.table.Edit");

(function(){
	function setEditorValues(table, item){
		var isFirst = false, columns = table.getColumns();

		// See if we can find the row to attach a class to.
		// This should adjust row style to match row editable.
		dojo.query(".xwtTableInlineEditing" + "." + table._uniqueCssId, table.tableBody).forEach(function(n){
			dojo.removeClass(n, "xwtTableInlineEditing");
		});
		if(table._idToIndex && table.store.isItem(item)){
			var id = table.store.getIdentity(item);
			var rowIndex = table._idToIndex[id];
			if(rowIndex >= 0){
				var rows = dojo.query("." + table._css.row + "-itemid-" + table._santizeIdentityForCss(id) + "." + table._uniqueCssId, table.tableBody);
				if(rows.length == 1){
					dojo.addClass(rows[0], "xwtTableInlineEditing");
					var height = dojo.position(rows[0]).h;
					dojo.style(table._editor.inline, {
						"height": height + "px",
						paddingTop: "0px",
						paddingBottom: "0px"
					});
				}
				var rowActions = dojo.query(".rowActions", table._editor.inline)[0];
				if(rowActions){
					var rb = dojo.position(rowActions);
					dojo.style(rowActions, "bottom", -rb.h + "px");
				}
				if(rowIndex == (table._totalRows - 1)){
					var height = dojo.style(table.tableBody, "height");
					if(dojo.isIE){
						var row = rows[0];
						var page = row;
						var addHeight = true;
						while(page && !dojo.hasClass(page, "page") && page !== table.tableBody){
							page = page.parentNode;
						}
						if(page && dojo.hasClass(page, "page")){
							var pHeight = table._calculatePageHeight(page);
							var pTop = dojo.style(page, "top");
							var pBottom = pTop + pHeight;
							if((pBottom + rb.h) <= height){
								addHeight = false;
							}
						}
						if(addHeight){
							height = height + (rb.h);
							dojo.style(table.tableBody, "height", height + "px");
						}
					}
					// Scroll it down as much as possible to put the save/cancel tabs in view.
					table.tableContainer.scrollTop = height;
				}
			}
		}

		for(var i=0, column; column = columns.get(i); i++){
			if(column.columnType != xwt.widget.table.ColumnTypes.COLUMN
				&& column.columnType != xwt.widget.table.ColumnTypes.EXPANDER
			){ continue; }
			if(column.columnType == xwt.widget.table.ColumnTypes.EXPANDER){
				//	there's never an attribute for an expander column, so we need to set that up here.
				var cell = dojo.query("." + table._css.cell + '-' + column._index, table._editor.inline)[0];
				cell.innerHTML = column.formatter();
				var expanded = column.expanded();
				var nodes = dojo.query(".cell-expander", cell);
				if(expanded && nodes.length == 1){
					column._collapseRow(item);
					// Fake a click, the function only uses the target node.
					column._onClick({target: nodes[0]});	
				}

				// Rig up cleanup calls so disconnects are done on the edit nodes.
				var clm = column;
				if(clm.__editConnects){
					dojo.forEach(clm.__editConnects, function(cncts){
						dojo.disconnect(cncts);
					});
					delete clm.__editConnects;
				}
				clm.__editConnects = [];
				dojo.forEach(nodes, function(n){
					clm.__editConnects.push(dojo.connect(n, "onclick", column, "_onClick"));
				});
				if(clm.__tableConnect){
					dojo.disconnect(clm.__tableConnect);
				}
				clm.__tableConnect = dojo.connect(table, "destroy", function(){
					dojo.disconnect(clm.__tableConnect);
					dojo.forEach(clm.__editConnects, function(cncts){
						dojo.disconnect(cncts);
					});
					delete clm.__tableConnect;
				});
				// These leak.  Need to clean them up.
				//nodes.connect("onclick", column, "_onClick");
				column.mode("edit");
			} else {
				var v = table.store.getValue(item, column.attr);
				if(column.editable){
					column.editWidget._onChangeActive = false;
					//If the value is false, the next command sets value="", so separate handling //CSCtj10003
					try{
					if (v === false) {
						column.editWidget.attr("value", v);
					}
					else
					{
						column.editWidget.attr("value", v || "");	
					}
					}
					catch(e)
					{
						//if there was error in setting value for 1 widget, we still continue with others.
						console.log("error in setting value for " + column.editWidget + ": " + e); 
					}
					column.editWidget._onChangeActive = true;
					if(!isFirst){
						dijit.focus(column.editWidget.domNode);
						if(column.editWidget.textbox){
							try {
								dijit.selectInputText(column.editWidget.textbox);
							} catch(ex){ 
								console.warn("There was a problem selecting the contents of the textbox: ", ex.message);
							}
						}
						isFirst = true;
					}
				} else {
					column.editWidget._onChangeActive = false;
					//If the value is false, the next command sets value="", so separate handling //CSCtj10003
					if (v === false) {
						column.editWidget.attr("value", v);
					}
					else
					{
						column.editWidget.attr("value", v || "");	
					}
					column.editWidget._onChangeActive = true;
					var cell = dojo.query("." + table._css.cell + '-' + column._index, table._editor.inline)[0];
					cell.appendChild(column.editWidget.domNode);
					var w = dojo.contentBox(cell).w;
					if(w >= 0){	
						dojo.style(column.editWidget.domNode, "width", w + "px");
					}
				}
			}
		}
		// Try to center as best we can.
		var eh = dojo.position(table._editor.inline.firstChild).h;
		var ch = dojo.position(table._editor.inline).h;
		if(ch != eh && ch > eh){
			var firstCell = dojo.query(".cell-container", table._editor.inline)[0];
			if(firstCell){
				dojo.style(firstCell, "height", ch + "px");
			}
		}
	}

	function createEditor(table, immediate){
		var css = table._css,
			columns = table.getColumns(),
			width = Math.min(dojo.marginBox(table.tableContainer).w, dojo.marginBox(table.tableBody).w);

		//	Create our inline edit row.
		//	TODO: set the width of the row.
		var row = dojo.create("div", {
			role: 'row', 
			tabIndex: "-1", 
			className: css.row + ' ' + css.row + '-editor', 
			style: "display: none;" 
		}, table.tableContainer);

		var tr = dojo.create('tr', {},
			dojo.create('tbody', {},
				dojo.create('table', {
					cellSpacing: 0,
					cellPadding: 0,
					border: 0,
					className: css.rowTable,
					presentation: 'presentation'
				}, row)
			)
		);

		//	Add in the row actions if needed.
		if(!immediate){
			var tabIndex = columns.columns.length;
			var actions = dojo.create("div", { 
				className: "rowActions", 
				innerHTML: '<a href="#" tabindex="' + "0"+ '" class="row-editor-save">Save</a> '
					+ '| <a href="#" tabindex="' + "0" + '" class="row-editor-cancel">Cancel</a>' 
			}, table.tableBody);

			//	Measure and fix.
			var tmpBox = dojo.marginBox(actions);
			if(tmpBox.w){
				dojo.style(actions, "marginLeft", -(Math.floor(tmpBox.w/2)) + "px");
			}
			dojo.place(actions, row);

			//	Hook up the events for save and cancel.
			var save_onclick = function(e){
				var properties = {}, hasError = false, errorWidget = null;
				for(var i=0, col; col = columns.get(i); i++){
					if(col.editable){
						var v = col.editWidget.attr("value");
						if(col.editWidget.isValid && !col.editWidget.isValid() || v === undefined){
							hasError = true;
							errorWidget = col.editWidget;
							var invalidDataAlert = new xwt.widget.notification.Alert({
								messageType:"warning",
								buttons: [
								{
									label: "OK",
									baseClass: "defaultButton"
								}
							]
							});							
							invalidDataAlert.setDialogContent("Cannot save invalid data.");
							invalidDataAlert.show();

							break;
						} else {
							properties[col.attr] = col.editWidget.attr("value");
						}
					}
				}

				if(!hasError){
					//	Get some info first, THEN commit the item.
					table.commit(table._editor.item, properties, true);
					table.closeEditor();
				} else {
					dijit.focus(errorWidget.domNode);
					if(errorWidget.displayMessage){
						var msg = errorWidget._message;
						errorWidget._message = "";
						errorWidget.displayMessage(msg);
					}
					if(errorWidget.textbox){
						try {
							dijit.selectInputText(errorWidget.textbox);
						} catch(ex){ 
							console.warn("There was a problem selecting the contents of the textbox: ", ex.message);
						}
					}
				}
				return false;
			};
			var save = dojo.query("a.row-editor-save", row)[0];
			if(save){
				save.onclick = function(){ return false; };
			}
			dojo.query("a.row-editor-cancel", row)[0].onclick = function(e){
				table.cancelEdit();	//	just close it.
				return false;
			};
			var cn = dojo.connect(table, "onEditDirty", function(flag){
				var save = dojo.query("a.row-editor-save", row)[0];
				if(!save){ return; }
				if(flag){
					dojo.addClass(save, "row-editor-dirty");
				}else{
					dojo.removeClass(save, "row-editor-dirty");
				}
				
				save.onclick = save_onclick;
				/* commented because we want to invoke save irrespective of whether the dirty was set to false or true - CSCti74978
				if(flag){
					save.onclick = save_onclick;
				} else {
					save.onclick = function(){ return false; };
				}
				*/
			});
			var cln = dojo.connect(table, "destroy", function(){
				// Cleanup on table destroy.
				dojo.disconnect(cln);
				dojo.disconnect(cn);
			});
		}

		//	fake cell for row height fixing.
		if(table._editor.heightAdjuster){
			dojo.place(table._editor.heightAdjuster, dojo.create("td", { width: "1px" }, tr));
		} else {
			table._editor.heightAdjuster = dojo.create(
				"div",
				{ width:"1px", height:"auto" },
				dojo.create("td", { width: "1px" }, tr)
			);
		}

		//	do the rest of the columns.
		var leftOffset = 0,
			isFirst = true, 
			firstEditableIdx = null, 
			lastEditableIdx = 0, 
			evts = ["__shiftTabHandler", "__tabHandler"];
		for(var i=0, column, cell; column = columns.get(i); i++){
			if(column 
				&& column.columnType != xwt.widget.table.ColumnTypes.COLUMN 
				&& column.columnType != xwt.widget.table.ColumnTypes.EXPANDER
			){
				//	we don't want an editor cell, but we need to adjust the row position.
				var w = dojo.marginBox(dojo.query(".cell-container-" + i, table.tableHeadRow)[0]).w;
				leftOffset += w;
			} else {
				if(isFirst && leftOffset){
					dojo.style(row, "left", leftOffset + "px");
				}
				if(isFirst){
					var eNode = tr;
					while(eNode && !dojo.hasClass(eNode, "row-editor")){
						eNode = eNode.parentNode;
					}
					var offsetReduce = 4;
					if(eNode){
						var padding = dojo._getPadBorderExtents(eNode);
						var margin = dojo._getMarginExtents(eNode);	
						offsetReduce = padding.l + margin.l + 1; // The + 1 is for a known 1px width cell for heighting.
						 
					}
					var oldWidth = column.width;
					column.width = oldWidth - offsetReduce; // the value here is the 1px height adjuster + 2px padding + 1px border

				}
				cell = column._createEditorCell(tr, table);
				if(isFirst){
					column.width = oldWidth;
					isFirst = false;
				}

				if(column.editable){
				//	column.editWidget.attr("tabIndex", i);
					connectColumn(table, column, immediate);
					if(!firstEditableIdx && !column.hidden){
						firstEditableIdx = i;
					}
					if(!column.hidden){
						lastEditableIdx = i;
					}
				}
			}
/*	//no more immediate mode - CSCtj08246		
			//	Check for the special handlers and disconnect them if need be.
			if(immediate && column.editable){
				dojo.forEach(evts, function(evt){
					if(column[evt]){
						dojo.disconnect(column[evt]);
						delete column[evt];
					}
				});
				//	Attach the shift key handlers.
				if(!column.__shiftHandlerDown){
					column.__shiftHandlerDown = dojo.connect(column.editWidget.domNode, "onkeydown", function(e){
						if(e.keyCode == dojo.keys.SHIFT){
							table._editor._shiftKey = true;
						}
					});
					column.__shiftHandlerUp = dojo.connect(column.editWidget.domNode, "onkeyup", function(e){
						if(e.keyCode == dojo.keys.SHIFT){
							table._editor._shiftKey = false;
						}
					});
				}
				if(!column.__genericKeyHandler){
					column.__genericKeyHandler = dojo.connect(column.editWidget.domNode, "onkeydown", function(e){
						if(e.keyCode == dojo.keys.ENTER){
							//	check for errors; if none, commit and close.
							var properties = {}, hasError = false, errorWidget = null;
							for(var i=0, col; col = columns.get(i); i++){
								if(col.editable){
									var v = col.editWidget.attr("value");
									if(col.editWidget.isValid && !col.editWidget.isValid() || v === undefined){
										hasError = true;
										errorWidget = col.editWidget;
										break;
									} else {
										properties[col.attr] = col.editWidget.attr("value");
									}
								}
							}

							if(!hasError){
								//	Get some info first, THEN commit the item.
								table.commit(table._editor.item, properties, true);
								table.closeEditor();
							} else {
								dijit.focus(errorWidget.domNode);
								if(errorWidget.displayMessage){
									var msg = errorWidget._message;
									errorWidget._message = "";
									errorWidget.displayMessage(msg);
								}
								if(errorWidget.textbox){
									try {
										dijit.selectInputText(errorWidget.textbox);
									} catch(ex){ 
										console.warn("There was a problem selecting the contents of the textbox: ", ex.message);
									}
								}
							}
							dojo.stopEvent(e);
						}
					});
				}
			}
			*/
			if(column.editWidget && !column.__mouseOverHandler && column.editWidget.displayMessage){
				column.__mouseOverHandler = dojo.connect(column.editWidget.domNode, "onmouseenter", dojo.hitch(column.editWidget, function(e){
					if(!this.isValid()){
						var m = this.invalidMessage;
						this._message = "";
						this.displayMessage(m);
					}
				}));
				column.__mouseOutHandler = dojo.connect(column.editWidget.domNode, "onmouseleave", dojo.hitch(column.editWidget, function(e){
					if(!this.isValid()){
						dijit.hideTooltip(this.domNode);
					}
				}));
				var c = column;
				var cleanupL = dojo.connect(table, "destroy", function(){
					dojo.disconnect(cleanupL);
					dojo.disconnect(c.__mouseOverHandler);
					dojo.disconnect(c.__mouseOutHandler);
				});
			}
		}
/* //no more immediate mode - CSCtj08246
		if(immediate){
			var first = columns.get(firstEditableIdx), last = columns.get(lastEditableIdx);
			first.__shiftTabHandler = dojo.connect(first.editWidget.domNode, "onkeydown", function(e){
				if(e.keyCode == dojo.keys.TAB && table._editor._shiftKey){
					//	We are moving away from the field, so we need to move the editor to the previous row for editing.
					//	Get the values in the inline editor and commit it.
					var properties = {}, hasError = false, errorWidget = null;
					for(var i=0, column; column = columns.get(i); i++){
						if(column.editable){
							var v = column.editWidget.attr("value");
							if(column.editWidget.isValid && !column.editWidget.isValid() || v === undefined){
								hasError = true;
								errorWidget = column.editWidget;
								break;
							} else {
								properties[column.attr] = column.editWidget.attr("value");
							}
						}
					}

					if(!hasError){
						//	Get some info first, THEN commit the item.
						var id = table.store.getIdentity(table._editor.item),
							idx = table._idToIndex[id];
						table.commit(table._editor.item, properties, true);
						if(idx < table._totalRows){
							var item = table._indexToItem[++idx];
							table.edit(item);
							dojo.stopEvent(e);
						}
					} else {
						dojo.stopEvent(e);
						dijit.focus(errorWidget.domNode);
						if(errorWidget.displayMessage){
							var msg = errorWidget._message;
							errorWidget._message = "";
							errorWidget.displayMessage(msg);
						}
						if(errorWidget.textbox){
							try {
								dijit.selectInputText(errorWidget.textbox);
							} catch(ex){ 
								console.warn("There was a problem selecting the contents of the textbox: ", ex.message);
							}
						}
					}
				}
			});
			last.__tabHandler = dojo.connect(last.editWidget.domNode, "onkeydown", function(e){
				if(e.keyCode == dojo.keys.TAB){
					//	get the editor values, commit it and move it to the next row.
					var properties = {}, hasError = false, errorWidget = null;
					for(var i=0, column; column = columns.get(i); i++){
						if(column.editable){
							var v = column.editWidget.attr("value");
							if(column.editWidget.isValid && !column.editWidget.isValid() || v === undefined){
								hasError = true;
								errorWidget = column.editWidget;
								break;
							} else {
								properties[column.attr] = column.editWidget.attr("value");
							}
						}
					}

					if(!hasError){
						//	Get some info first, THEN commit the item.
						var id = table.store.getIdentity(table._editor.item),
							idx = table._idToIndex[id];
						table.commit(table._editor.item, properties, true);
						if(idx < table._totalRows){
							var item = table._indexToItem[++idx];
							table.edit(item);
							dojo.stopEvent(e);
						}
					} else {
						dojo.stopEvent(e);
						dijit.focus(errorWidget.domNode);
						if(errorWidget.displayMessage){
							var msg = errorWidget._message;
							errorWidget._message = "";
							errorWidget.displayMessage(msg);
						}
						if(errorWidget.textbox){
							try {
								dijit.selectInputText(errorWidget.textbox);
							} catch(ex){ 
								console.warn("There was a problem selecting the contents of the textbox: ", ex.message);
							}
						}
					}
				}
			});
		}
		*/

		dojo.style(row, "display", "none");
		return row;
	}

	function positionEditor(table){
		//	make sure the editor is placed in the right position (i.e. top).
		if(table._editor.mode){
			var id = table.store.getIdentity(table._editor.item),
				idx = table._idToIndex[id],
				n = null,
				box = null,
				height = null,
				pageBox = null,
				added = 0;
			if(xwt.widget.table.TreeTable && table instanceof xwt.widget.table.TreeTable){
				n = dojo.query('tr[item-id="' + id + '"]' + "." + table._uniqueCssId, table.tableBody)[0];
				if(n){
					var row = n.parentNode.parentNode.parentNode,
						rowBox = dojo.marginBox(row);
					box = dojo.marginBox(n);
					height = box.h;
					box.t += rowBox.t;
					pageBox = dojo.marginBox(row.parentNode);
					row = null;
				}
			}else{
				n = dojo.query("." + table._css.row + "-itemid-" + table._santizeIdentityForCss(id) + "." + table._uniqueCssId, table.tableBody)[0];
				if(n){
					box = dojo.marginBox(n);
					height = box.h;
					pageBox = dojo.marginBox(n.parentNode);
				}
			}
			if(n){
				//	get our offset for any non-user defined columns, like the index or selector.
				var expander = null;
				for(var i=0, columns=table.getColumns(), col; col = columns.get(i); i++){
					if(table.expanded && table.expanded() && col.columnType == xwt.widget.table.ColumnTypes.EXPANDER){
						height = col._rowHeight;
					}
					if(col.columnType == xwt.widget.table.ColumnTypes.COLUMN){
						break;	//	break out on our first real column
					}
					added += Math.ceil(dojo.position(dojo.query(".cell-container-" + i, table.tableHeadRow)[0]).w);
				}
				var sWidth = table.tableContainer.scrollWidth;
				var tData  = dojo.position(table.tableContainer);	
			
				// Determine which width we need, the table area, 
				// or the scrollable area, if any.	
				var nWidth = (sWidth > tData.w) ? sWidth : tData.w;
				if(table._overflowX){
					// Adapt on the scrollbar adjustments.
					var scrollers = table._getScrollBarDims();
					nWidth += scrollers.w;
				}
				dojo.style(table._editor.inline, { 
					top: (box.t + pageBox.t) + "px",
					width: ((nWidth - added) + 6) + "px"
				});
				dojo.style(table._editor.heightAdjuster, "height", (height > 22 ? (height - 6) + "px" : "auto"));
				table._editor.row_height = box.h;
				dijit.scrollIntoView(n);
			}
		}
	}

	function restoreEditor(table){
		//	read in the properties on our private _editor object and restore our state.
		if(table._editor.mode){
			if(table._editor.inline){
				table._editor.inline.parentNode.removeChild(table._editor.inline);
			}
			table._editor.inline = createEditor(table, table._editor.immediate);
			var id = table.store.getIdentity(table._editor.item),
				idx = table._idToIndex[id],
				n = null,
				box = null,
				height = null,
				pageBox = null,
				added = 0;

			dojo.attr(table._editor.inline, "rowindex", idx);
			positionEditor(table);
			if(xwt.widget.table.TreeTable && table instanceof xwt.widget.table.TreeTable){
				var columns = table.getColumns();
				dojo.query('td.cell-container', table._editor.inline).forEach(function(n){
					var colIdx = dojo.attr(n, 'columnidx'),
						column = columns.get(colIdx);
					if(!column.editable){ return; }
					if(column.aggregate && table.model.mayHaveChildren(table._editor.item)){
						dojo.query('div.cell > *[widgetid]', n).forEach(function(wn){
							dijit.byNode(wn).attr('disabled', true);
						});
					}else{
						dojo.query('div.cell > *[widgetid]', n).forEach(function(wn){
							dijit.byNode(wn).attr('disabled', false);
						});
					}
				});
			}
			dojo.style(table._editor.inline, "display", "");
			setEditorValues(table, table._editor.item);
		} else {
			dojo.style(table._editor.inline, "display", "none");
		}
	}

	function reset(table){
		table._editor.setDirty(false);
		table._editor.isNew = false;
		table._editor.item = null;
		table._editor.items = null;
		table._editor.itemsValueObject = null;
		table._editor.mode = false;
	}

	function closeEditor(table){
		if(table._editor.inline){
			dojo.style(table._editor.inline, "display", "none");
		}
		reset(table);
	}

	function connectColumn(table, column, immediate){
		//	We use this function to set up an event connection to a column. But we also
		//	set a handle reference on the column so we can connect and disconnect the event.
		//	Wishing that suspend/resume was part of DTK.
		column.editWidget.connect(column.editWidget, "onChange", function(value){
			//*
			if(!table._editor.item){ return; }
			var id = table.store.getIdentity(table._editor.item),
				idx = table._idToIndex[id],
				cell,
				n = null;
			if(xwt.widget.table.TreeTable && table instanceof xwt.widget.table.TreeTable){
				n = dojo.query('tr[item-id="' + id + '"]' + "." + table._uniqueCssId, table.tableBody)[0];
			}else{
				n = dojo.query("." + table._css.row + "-" + idx + "." + table._uniqueCssId, table.tableBody)[0];
			}
			if(n){
				cell = dojo.query("." + table._css.cell + "-" + column._index + "." + table._uniqueCssId, n)[0];
			}
			//	*/
		   if(column.editWidget.isValid && !column.editWidget.isValid() || value === undefined){
				if(n){
					if(xwt.widget.table.TreeTable && table instanceof xwt.widget.table.TreeTable){
						dojo.addClass(n, "row-error");

						var parentPath = dojo.attr(n, 'parentpath');
						while(parentPath){
							n = dojo.query('tr[treepath="' + parentPath + '"]' + "." + table._uniqueCssId, table.tableBody)[0];
							if(n){
								dojo.addClass(n, "row-error");
								parentPath = dojo.attr(n, 'parentpath');
							}else{
								break;
							}
						}
					}else{
						dojo.addClass(n, "row-error");
					}
				}
				if(cell){ dojo.addClass(cell, "cell-error"); }
				//in any case, set the editor dirty - CSCti74978
				// Don't clear the dirty flag, save should still enable.  There is already
				// a popup that notes you can't save invalid data.
				//table._editor.setDirty(false);
			} else {
				var displayedValue = column.editWidget.attr("displayedValue");
				var oldValue = table.store.getValue(table._editor.item, column.attr);
				// Check both value and displayed value, in case there was conversion, but it is
				// equivilent
				if(oldValue != value && oldValue != displayedValue){
					table._editor.setDirty(true);
				}
				if(n){
					if(xwt.widget.table.TreeTable && table instanceof xwt.widget.table.TreeTable){
						dojo.removeClass(n, "row-error");

						var parentPath = dojo.attr(n, 'parentpath');
						while(parentPath){
							n = dojo.query('tr[treepath="' + parentPath + '"]' + "." + table._uniqueCssId, table.tableBody)[0];
							if(n){
								dojo.removeClass(n, "row-error");
								parentPath = dojo.attr(n, 'parentpath');
							}else{
								break;
							}
						}
					}else{
						dojo.removeClass(n, "row-error");
					}
				}
				if(cell){ dojo.removeClass(cell, "cell-error"); }
			}
			n = cell = null;
		});

	}

	function setupDetailEvents(table){
		var w = table.detailWidget;
		if(!w){ return; }
		if(w.onExecute){
			table.connect(w, "onExecute", dojo.hitch(w, function(){
				table.onEditComplete();

				//	Get the values out of the detail editor.
				var values = this.getValues();

				//	Now get the values out of the row editor, and let it take precedence.
				for(var i=0, columns=table.getColumns(), column; column = columns.get(i); i++){
					if(column.editable){
						var value = column.editWidget.attr("value"),
							old = table.store.getValue(table._editor.item, column.attr);

						//Validate inline edit changes, if any. Do not proceed if invalid. //CSCtj10548
						if (column.editWidget.isValid && !column.editWidget.isValid() || value === undefined) {
							hasError = true;
							errorWidget = column.editWidget;
							var invalidDataAlert = new xwt.widget.notification.Alert({
								messageType:"warning",
								buttons: [
								{
									label: "OK",
									baseClass: "defaultButton"
								}
							]
							});							
							invalidDataAlert.setDialogContent("Cannot save invalid data.");
							invalidDataAlert.show();
							return;
						}
						if(value != old && values[column.attr] != value){
							values[column.attr] = value;
						}
					}
				}

				var item = table._editor.item;

				var saveL;
				var errorL;
				var cleanState = function(){
					setEditorValues(table, item);
					var expanded = table.expandable() && table.expanded();
					if(expanded){
						table.getExpander()._collapseRow();
					}
				}

				saveL = dojo.connect(table, "onSaveComplete", function(){
					dojo.disconnect(saveL);
					if(errorL){
						dojo.disconnect(errorL);
					}
					cleanState();
					table.closeEditor();
				});
				errorL = dojo.connect(table, "onSaveError", function(){
					dojo.disconnect(errorL);
					if(saveL){
						dojo.disconnect(saveL);
					}
					/* Not sure we want this.
					if(expanded){
						table.getExpander()._collapseRow();
					}
					*/
				});
				table.commit(item, values);
			}));
		}
		if(w.onExecuteAndNext){
			table.connect(w, "onExecuteAndNext", dojo.hitch(w, function(){
				var id = table.store.getIdentity(table._editor.item),
					idx = table._idToIndex[id];
				table.onEditComplete();

				//	Get the values out of the detail editor.
				var values = this.getValues();

				//	Now get the values out of the row editor, and let it take precedence.
				for(var i=0, columns=table.getColumns(), column; column = columns.get(i); i++){
					if(column.editable){
						var value = column.editWidget.attr("value"),
							old = table.store.getValue(table._editor.item, column.attr);

						//Validate inline edit changes, if any. Do not proceed if invalid. //CSCtj10548
						if (column.editWidget.isValid && !column.editWidget.isValid() || value === undefined) {
							hasError = true;
							errorWidget = column.editWidget;
							var invalidDataAlert = new xwt.widget.notification.Alert({
								messageType:"warning",
								buttons: [
								{
									label: "OK",
									baseClass: "defaultButton"
								}
							]
							});							
							invalidDataAlert.setDialogContent("Cannot save invalid data.");
							invalidDataAlert.show();
							return;
						}
						if(value != old && values[column.attr] != value){
							values[column.attr] = value;
						}
					}
				}

				table.commit(table._editor.item, values);

				//	Get the next item and edit it.
				if(idx + 1 < table._totalRows){
					reset(table);
					var expanded = table.expandable() && table.expanded();
					expanded && table.getExpander()._collapseRow();
					table.edit(table._indexToItem[idx + 1]);
					expanded && table.getExpander()._expandRow(table._editor.item);
				}
			}));
		}
		if(w.onCancel){
			table.connect(w, "onCancel", dojo.hitch(w, function(){
				table.cancelEdit();
			}));
		}
	}

	function setupDialogEvents(table){
		var w = table._editor.dialog;;
		if(!w){ return; }
		table.connect(w, "onExecute", dojo.hitch(w, function(){
			//	oddly enough, dijit.Dialog has getValues and setValues already.  Had no idea.
			var dv = w.getValues(), tv = table._editor.itemsValueObject, v = {};
			//	Filter out values that have not changed.
			for(var attr in dv){
				if(attr in tv && dv[attr] != tv[attr]){
					v[attr] = dv[attr];
				}
			}
			table.commit(table._editor.items, v);
			table.closeEditor();
		}));
		table.connect(w, "onCancel", dojo.hitch(w, function(){
			table.cancelEdit();
		}));
	}

	function restoreRow(table, item){
		//	assuming we are moving away from this, just restore the row's original height
		var id = table.store.getIdentity(item),
			idx = table._idToIndex[id],
			n = null;
		if(xwt.widget.table.TreeTable && table instanceof xwt.widget.table.TreeTable){
			n = dojo.query('tr[item-id="' + id + '"]' + "." + table._uniqueCssId, table.tableBody)[0];
		}else{
			n = dojo.query("." + table._css.row + "-" + idx + "." + table._uniqueCssId, table.tableBody)[0];
		}
		if(n){
			dojo.style(n, "height", table._editor.row_height + "px");
		}
	}

	function clearErrors(table, item){
		if(!item){ return; }
		var id = table.store.getIdentity(item),
			idx = table._idToIndex[id],
			rowQuery = null;
		if(xwt.widget.table.TreeTable && table instanceof xwt.widget.table.TreeTable){
			rowQuery = 'tr[item-id="' + id + '"]';
		}else{
			rowQuery = "." + table._css.row + "-" + idx;
		}
		rowQuery += "." + table._uniqueCssId;
		dojo.query(rowQuery, table.tableBody).removeClass("row-error");
		dojo.query(rowQuery + " .cell", table.tableBody).removeClass("cell-error");
	}

	function template(attrs){
		//	create a real template.
		var o = {};
		dojo.forEach(attrs, function(attr){
			o[attr] = "";
		});
		return o;
	}

	function createTemplate(table){
		//	try to get an item, read its attributes and set up default values.
		if(table._indexToItem.length){
			var item = table._indexToItem[0];
			var attrs = table.store.getAttributes(item);
			table._editor.itemTemplate = template(attrs);
		} else {
			var h = dojo.connect(table, "_onFetchComplete", function(){
				dojo.disconnect(h);
				if(table._indexToItem.length){
					var item = table._indexToItem[0];
					var attrs = table.store.getAttributes(item);
					table._editor.itemTemplate = template(attrs);
				} else {
					//	best guess based on column definitions.
					var attrs = [];
					for(var i=0, columns = table.getColumns(), col; col = columns.get(i); i++){
						if(col.columnType == xwt.widget.table.ColumnTypes.COLUMN){
							attrs.push(col.attr);
						}
					}
					table._editor.itemTemplate = template(attrs);
				}
			});
		}
	}

	var editor = {
		itemTemplate: null,		//	The template for a new item.
		lastId: 0,				//	The variable used for incrementing the ID for new rows.
		inline: null,			//	Reference to the inline edit row.
		_shiftKey: false,		//	To hold a shift key state for keyboard navigation.
		item: null,				//	Edit item.
		isNew: false,			//	If the edit item is actually a newItem.
		mode: false,			//	If we're editing something inline or not.  We don't care about multiple ones here.
		dirty: false,			//	If the inline item edited is dirty or not.
		immediate: false,		//	If we are supposed to commit a change to an item immediately or via commit.
		row_height: 0,			//	Inline editor original row height.
		dialog: null,			//	Multiple item edit widget.
		items: null,			//	Multiple items, we do this separately.
		itemsValueObject: null, //	Cache the values object that we use to set the values in the dialog with, to only.
								//	Let values that have actually changed be pushed into the store.
		editWidgetIds: null,	//	Cache all of the edit widget IDs stored with our columns.
		addRequested: false		//	Whether an edit has been requested from the toolbar via add item.
	};

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//
	//	BEGIN EDIT PLUGIN
	//
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	xwt.widget.table.Edit = {
		//	summary:
		//		Implements editing on a table.  This is row-based and 
		//		not cell-based.
		//
		//	example:
		//		Apply the Edit component to a Table:
		//	|	xwt.widget.table.Edit.start.call(myTable);
		//

		//	The initializer function.  For table use only.
		start: function(options){
			//	summary:
			//		Startup for anything to be added to the table in whose scope this function is called.
			//	options: Object?
			//		An optional key/value pair dictionary to set various options on the edit plugin.
			dojo.mixin(this, xwt.widget.table.Edit);
			this._editor = dojo.clone(editor);
			this._editor.setDirty = dojo.hitch(this, function(flag){
				//if(this._editor.dirty != flag) -	CSCti74978
				//{
					//	only set and fire this if the flag changes.
				this._editor.dirty = flag;
				this.onEditDirty(flag);
				//}
			});

			//	Set our options.
			this._editor.itemTemplate = options && options.itemTemplate && dojo.clone(options.itemTemplate);
			this._editor.immediate = options && options.immediate || false;
			this._editor.dialog = options && options.dialog;

			this._editor.lastId = options && options.lastId || 0;
			if(!this._editor.itemTemplate){
				//	create a def JSON object from the first item in the store.
				createTemplate(this);
			}
			if(this.detailWidget){ setupDetailEvents(this); }
			if(this._editor.dialog){ setupDialogEvents(this); }

			//	create our inline editor.
			this._editor.inline = createEditor(this, this._editor.immediate);

			//	Make sure we redraw the inline editor on any of these events and methods.
			var events = [ 'onMove', 'onResize', 'onShow', 'onHide', 'borders' ], self = this;

			dojo.forEach(events, function(e){
				self.connect(self.getColumns(), e, function(){
					if(!self.editing()){ return; }
					if(!self._editor.inline){ return; }
					var enode = self._editor.inline;
					self._editor.inline = createEditor(self, self._editor.immediate);
					if(enode){ enode.parentNode.removeChild(enode); }
					restoreEditor(self);
					enode = null;
				});
			});

			this.connect(this.tableBody, "onclick", function(e){
				var node = e.target;
				
				// It's a quick view node, we don't want to go into edit mode.
				if(dojo.hasClass(e.target, "xwtQVHintHover")) { 
					var box = dojo.position(e.target);
					var cBox = { min: (box.h/2) - 6, max: (box.h/2) + 6};
					var yPos = e.layerY;
					if(!(yPos < cBox.min || yPos > cBox.max)){
						// It's the image, no edit mode.
						return;
					}
				}
				
				// Start by making sure, if this is a TreeTable, that the user didn't click
				// a twisty.
				if(xwt.widget.table.TreeTable && this instanceof xwt.widget.table.TreeTable){
					if(dojo.hasClass(node, 'twisty') && !dojo.hasClass(node, 'twisty-hidden')){
						return;
					}
				}
				//	Next make sure we're not in one of our non-traditional columns.
				while(node && !dojo.hasClass(node, "cell-container")){
					node = node.parentNode;
				}
				if(!node){
					//	didn't come from a cell, so bug out.
					return;
				}
				//	Get the index of the cell, and then check to make sure it is a regular column.
				var column = this.getColumns().getByNode(node);
				if(column && column.columnType != xwt.widget.table.ColumnTypes.COLUMN){
					//	Ignore click events on any non-standard column.
					return;
				}
				
				while(node && !dojo.attr(node, "rowindex")){
					node = node.parentNode;
				}
				if(!node){
					//	Our trace up the ancestry revealed nothing.
					return;
				}

				// Can't edit locked rows.
				if(dojo.hasClass(node, "row-locked")) { return; }
				
				var idx = parseInt(dojo.attr(node, "rowindex"), 10),
					item = this._indexToItem[idx];

				if(item){
					//If already editing, we don't do anything for any other click.
					if(this.editing() === true)
					{	
						return;
					}
					//	Check to see if we have an expander column, and if we're expanded.
					var col, expanded = this.expandable() && this.expanded();
					expanded && this.getExpander()._collapseRow();

					//	Pop it into edit mode if we have a different item.
					if(this.editing() && item != this._editor.item){
						this.edit(item);
					} else {
						this.edit(item);
					}
					//	Prevent something else from trying to do the same thing we just did.
					//dojo.stopEvent(e);
				}
			});

			//	Set it up so that a document click outside of the table cancels edit mode.
			//	First cache our edit widget IDs.
			//	At the same time, look for an expander column, and if found hook up the onExpand/onCollapse handlers.
			this._editor.editWidgetIds = {};
			for(var i=0, cols=this.getColumns(), col; col=cols.get(i); i++){
				if(col.editable){
					this._editor.editWidgetIds[col.editWidget.id] = true;
				}
				if(col.columnType == xwt.widget.table.ColumnTypes.EXPANDER){
					this.connect(col, "onExpand", function(){
						positionEditor(this);
						//Now that we have expand, save, etc., buttons, hide the tiny save/cancel box.
						var rowActions = dojo.query(".rowActions", this._editor.inline)[0];
						dojo.style(rowActions, "display", "none");
						
					});
					this.connect(col, "onCollapse", function(){
						positionEditor(this);
						//Unhide the tiny save/cancel box.
						var rowActions = dojo.query(".rowActions", this._editor.inline)[0];
						dojo.style(rowActions, "display", "");
						
					});
				}
			}
			
/*			
			dojo.connect(dojo.body(), "onclick", dojo.hitch(this, function(e){
				//	Get rid of any spurious clicks that have nothing to do with us.
				if(!this.editing()){ return; }
				if(this._editor.dialog && this._editor.dialog.open){ return; }

				//	Now comes the fun part.  We have to make sure we aren't in the middle of any kind of editor action.
				//	That means making some educated guesses to make sure the click actually *did* happen outside of some editor
				//	action.
				var node = e.target;
				while(node && node != this.domNode){
					//	Popup for edit widgets other than ComboBox and FilteringSelect.
					if(dojo.attr(node, "dijitPopupParent") && this._editor.editWidgetIds[dojo.attr(node, "dijitPopupParent")]){
						return;	//	This is the popup for one of our edit widgets.
					}

					//	Popups for ComboBox and FilteringSelect.
					var test = dojo.attr(node, "id");
					if(test && this._editor.editWidgetIds[test.substring(0, test.indexOf("_popup"))]){
						return;
					}

					if(test && test.search("\_popup") != -1){
						  return;
					} 
					
					//	Make sure the click isn't in a detail widget, if it's present.
					if(this.detailWidget && node == this.detailWidget.domNode){
						console.warn("document.body onclick came from the detail widget.");
						return;
					}
					node = node.parentNode; 
				}
				if(node != this.domNode){ 
				
				//CSCth63801, CSCth64143
				if (this.editing)
				{// Something was being edited, save that first
					if(this._editor.item){
				// Something was already edited, warn the user.
				//The onChange event is not fired when clicked outside of rows and that's why editor is not set dirty - WHY? 
				//Need to set editor dirty onBlur also.
				//If(this._editor.dirty){
					//	Check first to see if any values changed.
					var val = {}, changed = false;	//	Change is a double-check.
					for(var i=0, column; column = this.getColumns().get(i); i++){
						if(column.editable){
							var oldValue = this.store.getValue(this._editor.item, column.attr),
								newValue = column.editWidget.attr("value");
									if (newValue != oldValue) {
										//Validate the new value.
										//If validation fails, we don't want to change the value.
										//If isValid is not even there, then assume the value is valid.
										if (column.editWidget.isValid) {
											if (column.editWidget.isValid()) {
												val[column.attr] = newValue;
												changed = true;
											}
											else {
												//Changed value might have been set to true earlier for some other column.
												//So set it back to false here and just exit the loop, since we don't want to save if even 1 entry is invalid.
												changed = false;
												break;
											}
										}
										else {
											val[column.attr] = newValue;
											changed = true;
										}
									}
						}
					}

					//	TODO: i18ln and/or use a custom widget for this?
					if(changed && confirm("Would you like to save any changes you've made?")){
						this.commit(this._editor.item, val);
					}
				//}
				//	Do any kind of row restoring on this item.
				restoreRow(this, this._editor.item);
				clearErrors(this, this._editor.item);
			}
						
				}
					this.cancelEdit();
					
				}
			}));
			
*/
			//	TRT: Bloody shift key handling!  GRRR.
			this.connect(dojo.doc, (dojo.isIE ? "onfocusout" : "onblur"), function(){
				console.log("Table Edit.js onBlur() called");
				this._editor._shiftKey = false;
			});
		},

		_templateForItem: function(){
			var template = dojo.clone(this._editor.itemTemplate);
			if(!this.store.getFeatures()["generateId"]){
				var idAttrs = this.store.getIdentityAttributes(),
				id = parseInt(Math.random().toString().substring(2), 10);
				dojo.forEach(idAttrs, function(attr){
					template[attr] = id;
				}, this);
			}
			return template;
		},

		editing: function(){
			return this._editor.mode;
		},

		edit: function(item){
			//	summary:
			//		The main interface in which to begin editing an item or a set of items.  To enter edit mode
			//		or to open an optional multiple-edit dialog, you should call this method.
			//	item: dojo.data.Item|dojo.data.Item[]
			//		The item or items to be edited.  If it is an array of items and a multiple edit dialog
			//		widget has been provided, edit mode is NOT entered and instead the dialog is shown.
			//	returns:
			//		'this' to allow for functional chaining.
			if(!this.store.setValue){
				throw new Error("xwt.widget.table.Edit: cannot edit using a store that is not writable.");
			}
			this._editor.mode = true;

			if(dojo.isArray(item) && !this.store.isItem(item)){
				if(!this._editor.dialog){
					throw new Error("xwt.widget.table.Edit.edit: you cannot edit multiple items without defining a dialog to edit with.");
				}
				this._editor.items = item;
				this._editor.itemsValueObject = xwt.widget.table.util.getValueObject(this.store, item);
				this._editor.dialog.setValues(this._editor.itemsValueObject);
				this._editor.dialog.show();
				this.onEdit(item);
				return this;	//	xwt.widget.table.Table
			}

			// Only check for dirty if the item is different from what was already assigned.
			if(this._editor.item){
				//	something was already edited, warn the user.
				if(this._editor.dirty){
					//	check first to see if any values changed.
					var val = {}, changed = false;	//	Change is a double-check.
					for(var i=0, column; column = this.getColumns().get(i); i++){
						if(column.editable){
							var oldValue = this.store.getValue(this._editor.item, column.attr),
								newValue = column.editWidget.attr("value");
							if(newValue != oldValue) {
								//validate the new value
								//If validation fails, we don't want to change the value.
								//If isValid is not even there, then assume the value is valid.
								if(column.editWidget.isValid) {
									if (column.editWidget.isValid()) {
										val[column.attr] = newValue;
										changed = true;
									}
									else {
										//Changed value might have been set to true earlier for some other column.
										//So set it back to false here and just exit the loop, since we don't want to save if even 1 entry is invalid.
										changed = false;
										break;
									}
								}else{
									val[column.attr] = newValue;
									changed = true;
								}
							}
						}
					}

					//	TODO: i18ln and/or use a custom widget for this?
					if(changed && confirm("Would you like to save any changes you've made?")){
						this.commit(this._editor.item, val);
					}
				}
				//	do any kind of row restoring on this item.
				restoreRow(this, this._editor.item);
				clearErrors(this, this._editor.item);
			}
			this._editor.item = item;
			this._editor.setDirty(false);
			restoreEditor(this);
			this.onEdit(item);
			return this;	//	xwt.widget.table.Table
		},

		commit: function(item, value, render){
			//	summary:
			//		The main interface to call when editing has been completed on an item or a set of
			//		items.  This can be called with inline edit onChange events, on clicking Save or OK
			//		within either a detail editor or a multiple-item dialog editor.
			//	item: dojo.data.Item|dojo.data.Item[]
			//		The item or items to which the value object is to be applied.
			//	value: Object
			//		A dictionary of key/value pairs that will be applied to the given item(s).
			//	returns:
			//		'this' to allow for functional chaining.

			//	Unless explicitly stated, always re-render the table.
			render = render !== undefined ? render : true;
			var items = dojo.isArray(item) ? item : [ item ],
				attrs = this.store.getAttributes(items[0]);
			var properties = {};
			dojo.forEach(attrs, function(attr){
				if(attr in value){
					properties[attr] = value[attr];
				}
			}, this);
			if(item.allSelected){
				this.store.setValuesOnAllItems(properties, item.allSelected.except());
			}else{
				dojo.forEach(items, function(item){
					for(var i in properties){
						this.store.setValue(item, i, properties[i]);
					}
				}, this);
			}
			this.store.save && this.store.save({ 
				onComplete: dojo.hitch(this, function() {
					if(render){
						var def = this.render(true);
						def.addCallback(dojo.hitch(this, function(){
							this.onSaveComplete();
							this.onCommit(item, value);
						}));
					}else{
						this.onSaveComplete();
					}
				}),
				onError: dojo.hitch(this, function(e){
					if(render){
						var def = this.render(true);
						def.addCallback(dojo.hitch(this, function(){
							this.onSaveError(e);
							this.onCommit(item, value);
						}));
					}else{
						this.onSaveError(e);
					}
				})
			});
			return this;	//	xwt.widget.table.Table
		},

		editError: function(item, ex){
			//	summary:
			//		The main method to call in the case of an error when either committing or editing an
			//		item or set of items.
			//	item: dojo.data.Item|dojo.data.Item[]
			//		The item(s) that have had an error reported.
			//	ex: Error
			//		The exception thrown with regard to the item(s) in question.
			//	returns:
			//		'this' to allow for functional chaining.
			this.onEditError(item, ex);
			return this;	//	xwt.widget.table.Table
		},

		cancelEdit: function(){
			//	summary:
			//		If edit has been called beforehand, this method will simply close all edit facilities
			//		and ignore any pending information.
			//	returns:
			//		'this' to allow for functional chaining.
			console.warn("cancelling the edit");
			if(this._editor.mode){
				if(this._editor.item){
					clearErrors(this, this._editor.item);
				}
				if(this.store.isDirty()){
					this.store.revert && this.store.revert();
				}
				this.closeEditor(this);
				if(this.expandable() && this.expanded()){
					this.getExpander()._collapseRow();
				}
				var selected = this.selected? this.selected() : [];
				dojo.forEach(selected, function(i){
					if(!this.store.isItem(i)){
						// Clearing any 'new' items that were reverted and no 
						// longer valid store items.
						this.deselect(i);
					}
				}, this);
				this.render(true);
				this.onCancelEdit();
				return this;	//	xwt.widget.table.Table
			}
		},

		closeEditor: function(){
			//	summary:
			//		Close the editor.  Needs to be called explicitly so that store operations are
			//		not included with the close.
			//	returns:
			//		'this' to allow for functional chaining.
			if(this._editor.item && this.store.isItem(this._editor.item)){
				this.deselect(this._editor.item);
				// See if we can find the row to attach a class to.
				// This should adjust row style to match row editable.
				if(this._idToIndex){
					var rowIndex = this._idToIndex[this.store.getIdentity(this._editor.item)];
					if(rowIndex >= 0){
						var rows = dojo.query("." + this._css.row + "-" + rowIndex + "." + this._uniqueCssId, this.tableBody);
						if(rows.length == 1){
							dojo.removeClass(rows[0], "xwtTableInlineEditing");
						}
					}
				}
			}
			closeEditor(this);
			this.onEditorClose();
			return this;
		},

		onEdit: function(item){
			//	summary:
			//		Event stub called when edit begins.
			//	item: dojo.data.Item|dojo.data.Item[]
			//		The item or items to be edited.
			//	tags:
			//		callback
		},
		onEditDirty: function(flag){
			//	summary:
			//		Event stub called when a value is changed.
			//	flag: Boolean
			//		Whether or not the editor is "dirty".
			//	tags:
			//		callback
		},
		onEditError: function(item, ex){
			//	summary:
			//		Event stub called when edit begins.
			//	item: dojo.data.Item|dojo.data.Item[]
			//		The item or items to be edited.
			//	ex: Error
			//		The error thrown as applied to item.
			//	tags:
			//		callback
		},
		onCommit: function(item, value){
			//	summary:
			//		Event stub called when a commit happens.
			//	item: dojo.data.Item|dojo.data.Item[]
			//		The item or items to have values committed to them.
			//	value: Object?
			//		A key/value dictionary that has been applied to the item(s).
			//	tags:
			//		callback
		},
		onSaveComplete: function(){
			//	summary:
			//		Event stub called if a store.save was successful.
			//	tags:
			//		callback
		},
		onSaveError: function(err){
			//	summary:
			//		Event stub called if there was an error during a store.save.
			//	err: Error
			//		The error thrown by the save.
			//	tags:
			//		callback
		},
		onEditComplete: function(item){
			//	summary:
			//		Event stub called when an edit is completed.
			//	item: dojo.data.Item|dojo.data.Item[]
			//		The edited item(s).
			//	tags:
			//		callback
		},
		onEditorClose: function(){
			//	summary:
			//		Event stub called when the editor has been closed.
			//	tags:
			//		callback
		},
		onCancelEdit: function(){
			//	summary:
			//		Event stub called when an edit has been cancelled.
			//	tags:
			//		callback
		}
	};
})();	//	END CLOSURE

}

if(!dojo._hasResource["xwt.widget.i18nMixin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.i18nMixin"] = true;
/*******************************************************************   
 *        Copyright (c) 2009-2011 Cisco Systems, Inc.   
 *        All rights reserved.     
 * @fileoverview 
 * The XWT i18nMixin  
 * 
 * @author Harjeet Singh harjeesi@cisco.com
 *
 ********************************************************************/

dojo.provide("xwt.widget.i18nMixin");
dojo.declare("xwt.widget.i18nMixin", null , {
	// Universal mixin for i18n. includes the xwt.properties by default.
	
   // i18nPackageName: String
    i18nPackageName: "",
    
    // i18nBundlerName: String
    i18nBundleName: "",
    
    //flag to indicate if i18 to be used.
    _useI18: false,
    
    
    constructor: function(i18nPackage, i18Bundle, lang){
	    // summary:
	    //    The widget's life-cycle method.
	    // description:
	    //    This method sets up the i18n mixin for internationalization 
	    //    and initializes the required attributes.        
	    // Prepare the widget for internationalization

		dojo['requireLocalization']("xwt", "XMPProperties");
		this._messages = dojo.i18n.getLocalization("xwt", "XMPProperties");

		if(i18nPackage && i18Bundle && lang) {
			this.i18nPackageName = i18nPackage;
			this.i18nBundleName = i18Bundle;
			this.lang = lang;
			
			dojo['requireLocalization'](this.i18nPackageName, this.i18nBundleName);
	        this._messages = dojo.mixin(this._messages, dojo.i18n.getLocalization(this.i18nPackageName, this.i18nBundleName));
	    	this._useI18 = true;
		}
	},
	
	addBundle: function(/*String*/ p_i18Package, /*String*/ p_i18Bundle) {
		// summary adds a i18 resource
		// p_i18Package:
		//		i18 package name
		// p_i18Bundle:
		//		i18 bundle name.
		if(p_i18Package && p_i18Bundle) {
			dojo['requireLocalization'](p_i18Package, p_i18Bundle );
            this._messages = dojo.mixin(this._messages, dojo.i18n.getLocalization(p_i18Package, p_i18Bundle));
		}
	}
});

}

if(!dojo._hasResource["xwt.widget.layout.XwtGlobalUtility"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.layout.XwtGlobalUtility"] = true;
// summary: common reusable UI utilities 
// description: encapsulates some of complexities of working with cross browser widgets and handling UI tricks not built into dojo
// author: matander


dojo.provide("xwt.widget.layout.XwtGlobalUtility");

dojo.declare("xwt.widget.layout.XwtGlobalUtility", null, {


// summary: emove top level text nodes  in client's template for very tight alignment
_stripSurroundingTextNodes : function ( node ) {
	if ( node ) {
	 var childrenNodes = node.childNodes;
	 for ( var i=childrenNodes.length-1; i>=0; i--) {
		 var n = childrenNodes[i];
		 if ( n && n.nodeType == 3 || n.nodeType == 4) { this.srcNodeRef.removeChild(n); }
		 }
	}
},


// summary : for IE6, will create a correctly function PNG background image for the given node.	creates the filter on the fly
_recreateIE6PNG : function ( d /* domNode */, sizeType /* scale or crop */ ) {
		if ( d == null ) { return; }
		 if( sizeType == null ) { 
			 // default handler : inspect the repeat property of the background to see if it has any repeat declarations, use "scale"
			 sizeType =  dojo.style( d, "backgroundRepeat").indexOf("repeat") == 0 ? "scale" : "crop";
		 }

		var imageURL = this.convertFullURLFromCSS ( d );

		 // erase reference to old background
		d.style.backgroundImage = "none";
		d.style.backgroundColor = "transparent";
		d.style.zoom = 1;

		var pngFilter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + imageURL + "',sizingMethod='" + sizeType + "')";
		d.style.filter += pngFilter;
},

// summary: after its ready, unhide widget's DOM.. Some widgets like tabcontainers get confused if hidden..so this is optional
_makeWidgetVisible : function() {
		if( dojo.hasClass(this.domNode, "dijitHidden") ) { this._makeElementVisible ( this.domNode ); }
},


_makeElementVisible : function( d ) { dojo.removeClass(d, "dijitHidden"); },
_makeElementHidden : function( d ) { dojo.addClass(d, "dijitHidden"); },



// summary : utility to extract a fully qualified URL ( which is expressed via relative URI )
convertFullURLFromCSS : function ( d /* image domNode */ ) {

		 var imageURL = dojo.style( d, "backgroundImage");
		 imageURL= imageURL.substr (imageURL.indexOf("url") + (3 + 1) );
		 imageURL= imageURL.substr (0, imageURL.lastIndexOf(")")  );
// FF3.5 and below, and maybe IE6 do NOT show quote marks (even tho in CSS src )
// see if quoted
if ( imageURL.indexOf('"') == 0 ) {
		 imageURL= imageURL.substr (1);
		 imageURL= imageURL.substr (0, imageURL.length - 1 );
}


		 return imageURL;
}


});

}

if(!dojo._hasResource["xwt.widget.DropShadowLarge"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.DropShadowLarge"] = true;
/* ************************************************** */
/* Copyright (c) 2009-2011 Cisco Systems, Inc.       */
/* All rights reserved.                               */
/* ************************************************** */
dojo.provide("xwt.widget.DropShadowLarge");




dojo.declare("xwt.widget.DropShadowLarge", [dijit._Widget, dijit._Templated], {
	dsWidth: "",
	dsHeight: "",
	dsCurvedCorners: "false",
	dsBackgroundColor: "",
	dsBackgroundImage: "",
	dsRepeat: "",
    
	
	templateString: '<table class="DropShadowLarge">' +
'				<tr class="r1"><td class="r1c1"></td><td class="r1c2"></td><td class="r1c3"></td></tr>' +
'				<tr>' +
'					<td class="r2c1"></td>' +
'					<td class="r2c2"><table class="dsl_roundedCorners" dojoAttachPoint="decorationWidgetContentPoint">' +
'								<tr class="r2t1r1">' +
'									<td class="dsl_rc_topleft_corner"><div class="dsl_topColor"></div></td>' +
'									<td class="dsl_rc_topmiddle"></td>' +
'									<td class="dsl_rc_topright_corner"><div class="dsl_topColor"></td>' +
'								</tr>' +
'								<tr class="r2t1r2">' +
'									<td class="dsl_leftside"></td>' +
'									<td class="dsl_back" dojoAttachPoint="containerNode"></td>' +
'									<td class="dsl_rightside"></td>' +
'								</tr>' +
'								<tr class="r2t1r3">' +
'									<td class="dsl_rc_bottomleft_corner"><div class="dsl_bottomColor"></div></td>' +
'									<td class="dsl_rc_bottommiddle"></td>' +
'									<td class="dsl_rc_bottomright_corner"><div class="dsl_bottomColor"></td>' +
'								</tr>' +
'							</table></td>' +
'					<td class="r2c3"></td>' +
'				</tr>' +
'				<tr class="r3a"><td colspan="3"><table class="r3"><tr><td class="r3c1"></td><td class="r3c2"></td><td class="r3c3"></td></tr></table></td></tr>' +
'			</table>',

	postMixInProperties: function(){
		this.inherited("postMixInProperties", arguments);
	},

	postCreate: function(){

		if (this.dsWidth != null && this.dsWidth != "")
		{
			dojo.query(".dsl_back", this.domNode).style("width", this.dsWidth);
		}

		if (this.dsHeight != null && this.dsHeight != "")
		{
			dojo.query(".dsl_back", this.domNode).style("height", this.dsHeight);
		}

		if (this.dsCurvedCorners != null && this.dsCurvedCorners == "false")
		{
			dojo.query(".r2t1r1", this.domNode).style("display", "none");
			dojo.query(".r2t1r3", this.domNode).style("display", "none");

			dojo.query(".dsl_rc_topleft_corner", this.domNode).style("display", "none");
			dojo.query(".dsl_rc_topmiddle", this.domNode).style("display", "none");
			dojo.query(".dsl_rc_topright_corner", this.domNode).style("display", "none");
			dojo.query(".dsl_leftside", this.domNode).style("display", "none");
			dojo.query(".dsl_rightside", this.domNode).style("display", "none");
			dojo.query(".dsl_rc_bottomleft_corner", this.domNode).style("display", "none");
			dojo.query(".dsl_rc_bottommiddle", this.domNode).style("display", "none");
			dojo.query(".dsl_rc_bottomright_corner", this.domNode).style("display", "none");
		}

		if (this.dsRepeat != null && this.dsRepeat != "")
		{
			dojo.query(".dsl_leftside", this.domNode).style("backgroundRepeat", this.dsRepeat);
			dojo.query(".dsl_back", this.domNode).style("backgroundRepeat", this.dsRepeat);
			dojo.query(".dsl_rightside", this.domNode).style("backgroundRepeat", this.dsRepeat);
		}

		if (this.dsBackgroundColor != null && this.dsBackgroundColor != "")
		{
			// Color Background
			dojo.query(".dsl_topColor", this.domNode).style("backgroundImage", "none");
			dojo.query(".dsl_bottomColor", this.domNode).style("backgroundImage", "none");
			dojo.query(".dsl_rc_topmiddle", this.domNode).style("backgroundImage", "none");
			dojo.query(".dsl_leftside", this.domNode).style("backgroundImage", "none");
			dojo.query(".dsl_back", this.domNode).style("backgroundImage", "none");
			dojo.query(".dsl_rightside", this.domNode).style("backgroundImage", "none");
			dojo.query(".dsl_rc_bottommiddle", this.domNode).style("backgroundImage", "none");

			dojo.query(".dsl_topColor", this.domNode).style("backgroundColor", this.dsBackgroundColor);
			dojo.query(".dsl_bottomColor", this.domNode).style("backgroundColor", this.dsBackgroundColor);
			dojo.query(".dsl_rc_topmiddle", this.domNode).style("backgroundColor", this.dsBackgroundColor);
			dojo.query(".dsl_leftside", this.domNode).style("backgroundColor", this.dsBackgroundColor);
			dojo.query(".dsl_back", this.domNode).style("backgroundColor", this.dsBackgroundColor);
			dojo.query(".dsl_rightside", this.domNode).style("backgroundColor", this.dsBackgroundColor);
			dojo.query(".dsl_rc_bottommiddle", this.domNode).style("backgroundColor", this.dsBackgroundColor);

			if (this.dsCurvedCorners != null && this.dsCurvedCorners == "false")
			{
				dojo.query(".dsl_rc_topleft_corner", this.domNode).style("backgroundImage", "none");
				dojo.query(".dsl_rc_topright_corner", this.domNode).style("backgroundImage", "none");
				dojo.query(".dsl_rc_bottomleft_corner", this.domNode).style("backgroundImage", "none");
				dojo.query(".dsl_rc_bottomright_corner", this.domNode).style("backgroundImage", "none");

				dojo.query(".dsl_rc_topleft_corner", this.domNode).style("backgroundColor", this.dsBackgroundColor);
				dojo.query(".dsl_rc_topright_corner", this.domNode).style("backgroundColor", this.dsBackgroundColor);
				dojo.query(".dsl_rc_bottomleft_corner", this.domNode).style("backgroundColor", this.dsBackgroundColor);
				dojo.query(".dsl_rc_bottomright_corner", this.domNode).style("backgroundColor", this.dsBackgroundColor);

				if( dojo.isIE && dojo.isIE < 7 )
				{
					dojo.query(".dsl_rc_topleft_corner", this.domNode).style("filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='',sizingMethod='scale')");
					dojo.query(".dsl_rc_topright_corner", this.domNode).style("filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='',sizingMethod='scale')");
					dojo.query(".dsl_rc_bottomleft_corner", this.domNode).style("filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='',sizingMethod='scale')");
					dojo.query(".dsl_rc_bottomright_corner", this.domNode).style("filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='',sizingMethod='scale')");
				}
			}
		}
		else if (this.dsBackgroundImage != null && this.dsBackgroundImage != "")
		{
			// Gradient Background
			dojo.query(".dsl_topColor", this.domNode).style("backgroundImage", "url(" + this.dsBackgroundImage + ")");
			dojo.query(".dsl_bottomColor", this.domNode).style("backgroundImage", "url(" + this.dsBackgroundImage + ")");
			dojo.query(".dsl_rc_topmiddle", this.domNode).style("backgroundImage", "url(" + this.dsBackgroundImage + ")");
			dojo.query(".dsl_leftside", this.domNode).style("backgroundImage", "url(" + this.dsBackgroundImage + ")");
			dojo.query(".dsl_back", this.domNode).style("backgroundImage", "url(" + this.dsBackgroundImage + ")");
			dojo.query(".dsl_rightside", this.domNode).style("backgroundImage", "url(" + this.dsBackgroundImage + ")");
			dojo.query(".dsl_rc_bottommiddle", this.domNode).style("backgroundImage", "url(" + this.dsBackgroundImage + ")");

			dojo.query(".dsl_topColor", this.domNode).style("backgroundColor", "transparent");
			dojo.query(".dsl_bottomColor", this.domNode).style("backgroundColor", "transparent");
			dojo.query(".dsl_rc_topmiddle", this.domNode).style("backgroundColor", "transparent");
			dojo.query(".dsl_leftside", this.domNode).style("backgroundColor", "transparent");
			dojo.query(".dsl_back", this.domNode).style("backgroundColor", "transparent");
			dojo.query(".dsl_rightside", this.domNode).style("backgroundColor", "transparent");
			dojo.query(".dsl_rc_bottommiddle", this.domNode).style("backgroundColor", "transparent");

			var re = RegExp("png$", "i");
			if( dojo.isIE && dojo.isIE < 7 && re.test(this.dsBackgroundImage) )
			{
				dojo.query(".dsl_topColor", this.domNode).style("backgroundImage", "none");
				dojo.query(".dsl_bottomColor", this.domNode).style("backgroundImage", "none");
				dojo.query(".dsl_rc_topmiddle", this.domNode).style("backgroundImage", "none");
				dojo.query(".dsl_leftside", this.domNode).style("backgroundImage", "none");
				dojo.query(".dsl_back", this.domNode).style("backgroundImage", "none");
				dojo.query(".dsl_rightside", this.domNode).style("backgroundImage", "none");
				dojo.query(".dsl_rc_bottommiddle", this.domNode).style("backgroundImage", "none");

				dojo.query(".dsl_topColor", this.domNode).style("filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + this.dsBackgroundImage + "',sizingMethod='crop')");
				dojo.query(".dsl_bottomColor", this.domNode).style("filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + this.dsBackgroundImage + "',sizingMethod='crop')");
				dojo.query(".dsl_rc_topmiddle", this.domNode).style("filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + this.dsBackgroundImage + "',sizingMethod='scale')");
				dojo.query(".dsl_leftside", this.domNode).style("filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + this.dsBackgroundImage + "',sizingMethod='scale')");
				dojo.query(".dsl_back", this.domNode).style("filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + this.dsBackgroundImage + "',sizingMethod='scale')");
				dojo.query(".dsl_rightside", this.domNode).style("filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + this.dsBackgroundImage + "',sizingMethod='scale')");
				dojo.query(".dsl_rc_bottommiddle", this.domNode).style("filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + this.dsBackgroundImage + "',sizingMethod='scale')");
			}

			if (this.dsCurvedCorners != null && this.dsCurvedCorners == "false")
			{
				dojo.query(".dsl_rc_topleft_corner", this.domNode).style("backgroundImage", "url(" + this.dsBackgroundImage + ")");
				dojo.query(".dsl_rc_topright_corner", this.domNode).style("backgroundImage", "url(" + this.dsBackgroundImage + ")");
				dojo.query(".dsl_rc_bottomleft_corner", this.domNode).style("backgroundImage", "url(" + this.dsBackgroundImage + ")");
				dojo.query(".dsl_rc_bottomright_corner", this.domNode).style("backgroundImage", "url(" + this.dsBackgroundImage + ")");

				dojo.query(".dsl_rc_topleft_corner", this.domNode).style("backgroundRepeat", "repeat-x");
				dojo.query(".dsl_rc_topright_corner", this.domNode).style("backgroundRepeat", "repeat-x");
				dojo.query(".dsl_rc_bottomleft_corner", this.domNode).style("backgroundRepeat", "repeat-x");
				dojo.query(".dsl_rc_bottomright_corner", this.domNode).style("backgroundRepeat", "repeat-x");

				dojo.query(".dsl_rc_topleft_corner", this.domNode).style("backgroundColor", "transparent");
				dojo.query(".dsl_rc_topright_corner", this.domNode).style("backgroundColor", "transparent");
				dojo.query(".dsl_rc_bottomleft_corner", this.domNode).style("backgroundColor", "transparent");
				dojo.query(".dsl_rc_bottomright_corner", this.domNode).style("backgroundColor", "transparent");

				if( dojo.isIE && dojo.isIE < 7 )
				{
					dojo.query(".dsl_rc_topleft_corner", this.domNode).style("filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='',sizingMethod='scale')");
					dojo.query(".dsl_rc_topright_corner", this.domNode).style("filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='',sizingMethod='scale')");
					dojo.query(".dsl_rc_bottomleft_corner", this.domNode).style("filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='',sizingMethod='scale')");
					dojo.query(".dsl_rc_bottomright_corner", this.domNode).style("filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='',sizingMethod='scale')");
				}
			}
		}
	}
});

}

if(!dojo._hasResource["xwt.widget.layout.BaseOverlay"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.layout.BaseOverlay"] = true;
/**
 * @author matander
 */

dojo.provide("xwt.widget.layout.BaseOverlay");










// Singleton Wrapper for the Observer
						 
if (!dojo._hasResource["xwt.widget.layout.OverlayObserverFactory"]) {
  dojo._hasResource["xwt.widget.layout.OverlayObserverFactory"] = true;
  dojo.provide("xwt.widget.layout.OverlayObserverFactory");


  dojo.declare("xwt.widget.layout.OverlayObserverManagerFactorySingleton", null, {

	  // summary:
	  //	Overlay Manager Singleton class
	  //
	  // description:
	  //	Manages the opening/closing of overlays

	  
	  // summary: global counter of how many overlays have been opened in the scope of this document
	  // readonly
	  _overlayOpenCounter : 0,

	   // reference to currently opened overlay
	  _currentOverlay : null,

	  // afford the UI one emergency modal dialog warning if trying to close the current overlay
	  _currentOverlayExceptionOverlay : null,


	  clearOverlayObject : function ( obj ) {
		   if ( obj.isModal ) {
			   this._currentOverlayExceptionOverlay = null;
		   } else {
			   this._currentOverlay = null;
		   }
	  },

	  setOverlayObject : function ( obj ) {
		   if ( obj.isModal ) {
			   this._currentOverlayExceptionOverlay = obj;
		   } else {
			   this._currentOverlay = obj;
		   }

	  },

	   // rule policy 
	  canOpenOverlay : function ( overlay, node, evt ) {

		   // prevent opening same overlay twice..
		   if ( overlay == this._currentOverlay ) {
			   return false;
		   }


		   // if any overlay opened?
	  if ( this._currentOverlay !== null  ) {
		  // go through the process of trying to automatically cancel it			 
		  // if that other overlay could be shut down ( maybe it triggers a modal alert ) then we can show the new requested overlay 
		  var isExceptionFlag = overlay.isModal;			 

		  if ( ! isExceptionFlag ) {
			  //console.log("close the other one if necessary");			 
			  // lets try to autoclose the already opened dialog
			  var _currentOverlay = this._currentOverlay;
				  if ( this.canCloseOverlay ( this._currentOverlay, evt ) ) {
					  //console.log ( " autoclosing ", _currentOverlay );
					  _currentOverlay.hide(evt);
					  this.setOverlayObject ( overlay );
					  return true;
				  }

		  // but if the overlay being opened is a modal.. its an 'emergency' - let it go
		  } else {
			  this.setOverlayObject ( overlay );
			  this._overlayOpenCounter++;
			  return true;
			  } 


		  // this will be the first and only primary overlay
		  } else { 
			  //console.log("bar")
			  this.setOverlayObject ( overlay );
			  this._overlayOpenCounter++;
			  return true; 
		  } 

	  //this._overlayOpenCounter++; 
	  }, 


	  // rule policy
	  canCloseOverlay : function ( overlay, evt ) {

		   if ( ! overlay.isShowingNow  ) {
			   //console.log ("its closed..skipping logic check");
			   return true;
		   }

		   // test if overlay can hide itself
		   var flag = overlay.onBeforeHideEvent( evt );

		   // can close
		   if ( flag ) {
			   // console.log('can close it ', overlay )
			   this.clearOverlayObject ( overlay );

		   }
		   // cannot close..yet
		   /* JSLint fix - nbhattac
		   else {
			  //console.log('cannot close it ')
		   }*/

		   return flag;
	  },

	  // getter for private
	  getLatestOpenCounter : function () { return this._overlayOpenCounter; }

});

// ** Singleton variable
  xwt.widget.layout._OverlayObserverManagerFactory = null;

  xwt.widget.layout.OverlayObserverFactory = function() {
    if (!xwt.widget.layout._OverlayObserverManagerFactory ) {
    	xwt.widget.layout._OverlayObserverManagerFactory = new xwt.widget.layout.OverlayObserverManagerFactorySingleton();
    }
    return ( xwt.widget.layout._OverlayObserverManagerFactory ); // instance
  };
}

dojo.declare("xwt.widget.layout.BaseOverlay",[ dijit.TooltipDialog, xwt.widget.layout.XwtGlobalUtility ], {
	//	summary
	//		A specialized dialog that offers contextual placement. 
	//	description
	//		Supports binding multiple "triggers" and autowiring the event to cause it to open
	// 		Support for a11y via keyboard, special fade effects	//
	// 		Features:
	//		- modal dialog
	// 		- absolute coordinate based positioning, or relative to a trigger node ( default )
	// 		- vertical / horizontal alignment
	// 		- autowiring via tag attributes connectId, connectEvents
	// 

	//
    // positionReferenceNode: 
	// 		id of another point of reference if the overlay should be absolutely positioned 
	// 		RELATIVE to a different viewport
	// 		example is when there are floating elements on the page that act as independent windows. 
	//		set to false if you wish to not show the close button
    // tags:
    //		public
	positionReferenceNode : "",

	//
    // positionStructure: String?
	//	This variable controls the position of dialog. It's an array of strings with the following 
	//	values:
	//
	//		* before: places to the left of the target node/widget, or to the right in
	//		  the case of RTL scripts like Hebrew and Arabic
	//		* after: places to the right of the target node/widget, or to the left in
	//		  the case of RTL scripts like Hebrew and Arabic
	//		* above: goes above target node
	//		* below: goes below target node
	//
	//	The list is positions is tried, in order, until a position is found where the dialog fits
	//	within the viewport.
	//
	//	default: ["after", "before"]
	//
    // 	tags:
    //		public
	positionStructure : dijit.Tooltip.defaultPosition,

	//
    // top: Number?
	// 		Specify a positive value if you wish to absolutely position the overlay 
    // tags:
    //		public
	top: -1,
	
	//
    // left: Number?
	// 		Specify a positive value if you wish to absolutely position the overlay 
    // tags:
    //		public
	left: -1,

	//
    // connectId: String|Array
	//		specify one or more ids of the triggers to connect this dialog to
	//
    // tags:
    //		public
	connectId : [],

	//
    // connectEvents: String|Array
	//		specify one or more event names that will trigger this dialog 
	//
    // tags:
    //		public
	connectEvents : [],

	//
    // isModal: Boolean?
	//		set to true if you wish the dialog to be a modal dialog
	// default: 
	//		false
    // tags:
    //		public
	isModal: false,

	//
    // showCloseButton: Boolean?
	//		set to false if you wish to not show the close button
	// default: 
	//		true
    // tags:
    //		public
	showCloseButton : true,
	
	// calculate coordinates of the overlay based on current Viewport
	viewportPosition : [],

	//
    // positionX: [readonly] String
	//		provides the X position of the overlay
	//
    // tags:
    //		public
	positionX : 0,

	//
    // positionY: [readonly] String
	//		provides the Y position of the overlay
	//
    // tags:
    //		public
	positionY : 0,
	
	//
    // showEffect: String
	//		Transition effect for the overlay show
	//		TODO: list supported values
	//
    // tags:
    //		public
	showEffect : "fade",

	//
    // showEffect: String
	//		Transition effect for the overlay hide
	//		TODO: list supported values
	//
    // tags:
    //		public
	hideEffect : "fade",

	//
    // duration: Number
	//		Milliseconds to fade in/fade out
    // tags:
    //		public
	duration : dijit.defaultDuration + 100,

	widgetsInTemplate : true,

	// tags:
    //		private
	underlay: null,

	// DOM ID of the element to trigger the dialog
	_connectNodes : [],

	
	//readonly
	_showCount : 0,

	open: function( /*String|Object*/node, /*String[]*/ position ) {
	    //
	    // summary:
	    //		shows the overlay after checking with overlay manager if the overlay
		//		can be shown
	    // node: String
		//		id of the node used as reference node
		// position: String[]
		//		TODO
	    //		
	    // returns:
	    //		null
	    // tags:
	    //		public
		var result = this._getObserver().canOpenOverlay( this, node, null );

		if ( result ) {
			var isAbsolutePlacement = ( this.left >= 0 && this.top >= 0 );
			this.show("", node, isAbsolutePlacement ? "absolute" : position);

			// not allowed to open overlay
		} 

	},

	openAtNode : function(node, position) {
	    //
	    // summary:
	    //		shows the overlay with reference to the specified node
	    // node: String
		//		id of the node used as reference node
		// position: String[]
		//		TODO
	    //		
	    // returns:
	    //		null
	    // tags:
	    //		public
		this.open( node, position); // nbhattac - recommend disabling string :: this.open("", node, position);
	},

	show : function(/*String*/innerHTML, /*DomNode*/aroundNode, /*String[]?*/position) {
	    //
	    // summary:
	    //		shows the overlay 
	    // innerHTML: String
		//		
		// aroundNode: String|Object
		//		id or DOM node of the element around which this overlay will show up
		// position: String[]
		//		TODO
	    //		
	    // returns:
	    //		null
	    // tags:
	    //		public

		if (this.aroundNode && this.aroundNode === aroundNode) { return; }

		if (this.animationOut.status() == "playing") {
			// previous tooltip is being hidden; wait until the hide completes then show new one
			this._onDeck = arguments;
			return;
		}
		if (dojo.isIE >= 7) {

			var ref = this.domNode;

			dojo.forEach ( 
					[
					 ".r1",
					 ".r2c1",
					 ".r2c3",
					 ".r3a",
					 ".r2t1r1",
					 ".r2t1r3",
					 ".dsl_leftside", 
					 ".dsl_rightside"
					 ],
					 // hide
					 function (o) { dojo.query( o, ref ).style("visibility", "hidden"); });

		}

		// Firefox bug. when innerHTML changes to be shorter than previous
		// one, the node size will not be updated until it
		// moves.
		this.domNode.style.top = (this.domNode.offsetTop + 1) + "px";


		// make sure each dialog window/underlay is on top of any other dialog windows..
		var layerOrder = 998  + ( this._getObserver().getLatestOpenCounter() * 2);
		dojo.style(this.domNode, { zIndex : layerOrder });
		if ( this.isModal ) { dojo.style(this.underlay.domNode, {	zIndex : layerOrder - 1 });	}

		// position the element and change CSS according to
		// position[] (a list of positions to try)
		var align = {};
		var ltr = this.isLeftToRight();

		// if the element is absolute, change the structure to this syntax
		// helps make the arrows line up much better
		if ( position == "absolute" ) {
			this.positionStructure=['above', 'below'];
		}

		dojo.forEach((this.positionStructure && this.positionStructure.length) ? this.positionStructure : dijit.Tooltip.defaultPosition,
				function(pos) {
			switch (pos) {
			case "after":
				align[ltr ? "BR" : "BL"] = ltr ? "BL" : "BR";
				break;
			case "before":
				align[ltr ? "BL" : "BR"] = ltr ? "BR" : "BL";
				break;
			case "below":
				// first try to align left borders, next try to align right borders (or reverse for RTL mode)
				align[ltr ? "BL" : "BR"] = ltr ? "TL" : "TR";
				align[ltr ? "BR" : "BL"] = ltr ? "TR" : "TL";
				break;
			case "above":
			default:
				// first try to align left borders, next try to align right borders (or reverse for RTL mode)
				align[ltr ? "TL" : "TR"] = ltr ? "BL" : "BR";
			align[ltr ? "TR" : "TL"] = ltr ? "BR" : "BL";
			break;
			}
		});

		// is the dialog to be horizontally aligned?
		this._isHorizontalAlignment = (align["BR"].charAt(0) == "B");
		// show it
		dojo.removeClass(this.domNode, "dijitHidden");
		var pos;

		if ( position == "absolute" ) {

			// to figure out the offset from the arrow's center in relation to its container
			var dialogOffsetX = -14;
			var dialogOffsetY = 5;

//			window placed in absolute coords
			// new ref node is created based upon some preferred point of reference

			var tempBox = dojo.create("DIV",{ }, dojo.body() );
			dojo.style ( tempBox, "position", "absolute" );
			dojo.style ( tempBox, "margin", 0 ); dojo.style ( tempBox, "padding", 0 );

			var whereNode = dojo.byId(this.positionReferenceNode) || dojo.body();
			dijit.placeOnScreenAroundElement ( tempBox, whereNode, align, dojo.hitch( this, this.orient));
			// consider the offset
			var tbc = dojo.coords( tempBox );
			dojo.style ( tempBox, "left", ( tbc.x + this.left + dialogOffsetX ) + "px");
			dojo.style ( tempBox, "top", ( tbc.y + this.top + dialogOffsetY ) + "px");



			pos = dijit.placeOnScreenAroundElement(
					this.domNode, tempBox, align, dojo.hitch( this, this.orient));


			// arrange dialog by centering both top and left.. need two positions
			var vp = this.viewportPosition;
			if (  vp.length == 2) {
				var dialogDimensions = ( dojo.coords ( this.domNode ) );

				var x; var y;

				// left
				switch ( vp[0] ) {
				case "center":
					x = ( dijit.getViewport().w -  dialogDimensions.w ) / 2;
					break;
				default:
					break;
				}

				// top
				switch ( vp[1] ) {
				case "center" :
					y = ( dijit.getViewport().h -  dialogDimensions.h ) / 2;
					break;
				default:
					break;
				}

				// now position overlay
				pos = { x : x, y : y };
				dojo.style( this.domNode, { "left" : pos.x + "px", "top" : pos.y + "px"	});

			}
			// arrange dialog by centering both top and left


			// if the overlay is positioned on the LEFT of the target due to space constraints, reposition it slightly for accurate arrow alignment
			else {
				if(pos.corner == "BR" || pos.corner== "TR" ) {
					dojo.style( this.domNode, "left", ( dojo.coords( this.domNode ).x - ( dialogOffsetX) ) + "px" ) ;
				}
			}


			tempBox.parentNode.removeChild ( tempBox );


			// window placed in context to the aroundNode
		} else {
			pos = dijit.placeOnScreenAroundElement(
					this.domNode, aroundNode, align, dojo.hitch(
							this, this.orient));
		}


		this.positionX = pos.x;
		this.positionY = pos.y;


		// IE6 - do this early, before animation starts
		this._fixTipNodeArrow();

		if (this.animationIn.type == "fade") {
			dojo.style(this.domNode, "opacity", 0);
			this.animationIn.play();
		} else if (this.animationIn.type == "wipe") {
			dojo.style(this.domNode, "height", "1px");
			this.animationIn.play();
		}
		this.isShowingNow = true;
		this.aroundNode = aroundNode;
		// call some cleanup routines
		this._onRendered();
	},

	orient : function(node, aroundCorner, tooltipCorner) {
	    //
	    // summary:
	    //		orients the overlay 
		// node: String|Object
		//		id or DOM node of the element around which this overlay will show up
		// aroundCorner: String
		//		TODO
		// tooltipCorner: String
		//		TODO
	    //		
	    // returns:
	    //		null
	    // tags:
	    //		public

		var cssClasses = "dijitTooltip " + this.baseClass + " " +  {
			"BL-TL" : "dijitTooltipBelow dijitTooltipABLeft",
			"TL-BL" : "dijitTooltipAbove dijitTooltipABLeft",
			"BR-TR" : "dijitTooltipBelow dijitTooltipABRight",
			"TR-BR" : "dijitTooltipAbove dijitTooltipABRight",
			"BR-BL" : "dijitTooltipRight",
			"BL-BR" : "dijitTooltipLeft"
		}[aroundCorner + "-" + tooltipCorner];

		// var cssClasses = [ [ "dijitTooltip", this.baseClass ].join(" ") , "dijitTooltipAB"+(tooltipCorner.charAt(1) == 'L'?"Left":"Right")+" dijitTooltip"+(tooltipCorner.charAt(0) == 'T' ? "Below" : "Above")	].join(" ");
		// set many interfaces for styling the dialog
		node.className = cssClasses;

	},

	onShow : function() {
	    //
	    // summary:
	    //		invoked after the overlay has been rendered on the screen
		//		developer hook to carry out processing after the overlay is rendered.
	    //		
	    // returns:
	    //		null
	    // tags:
	    //		public
	},

	hide : function( evt) {
	    //
	    // summary:
	    //		hide the overlay
		//	evt: TODO
	    //		
	    // returns:
	    //		null
	    // tags:
	    //		public

		// notify observer of a hide action. 
		if ( ! this._getObserver().canCloseOverlay(this, evt) ) {
			return false;
		}

		if (this.isShowingNow && dojo.isIE && dojo.isIE >= 7) {
			dojo.query(".r1", this.domNode).style("visibility","hidden");
			dojo.query(".r2c1", this.domNode).style("visibility", "hidden");
			dojo.query(".r2c3", this.domNode).style("visibility", "hidden");
			dojo.query(".r3a", this.domNode).style("visibility", "hidden");
			dojo.query(".r2t1r1", this.domNode).style("visibility", "hidden");
			dojo.query(".r2t1r3", this.domNode).style("visibility", "hidden");
			dojo.query(".dsl_leftside", this.domNode).style("visibility", "hidden");
			dojo.query(".dsl_rightside", this.domNode).style("visibility", "hidden");
		}
		// summary:return;Hide the tooltip
		if (this.isShowingNow) {
			// this hide request is for the currently displayed tooltip
			this.animationIn.stop();

			this.isShowingNow = false;
			this.aroundNode = null;
			this.animationOut.play();
		}
		return true;
	},

	onHide : function() {
	    //
	    // summary:
	    //		invoked after the overlay has been hidden from the screen
		//		developer hook to carry out processing after the overlay is hidden.
	    //		
	    // returns:
	    //		null
	    // tags:
	    //		public
	},

	onBeforeHideEvent : function( /*Object*/evt ) {
	    //
	    // summary:
	    //		invoked just before hiding the overlay
		//		developer hook to carry out processing just before hiding the overlay.
	    //		
		// evt: Object
		//		TODO
	    // returns:
	    //		null
	    // tags:
	    //		public
		return true;
	},

	setPositionStructure : function(pos) {
	    //
	    // summary:
	    //		sets the position structure to the specified position
	    //
		// pos: String[]
		//		TODO
	    // returns:
	    //		null
	    // tags:
	    //		public
		this.positionStructure = pos;
	},

	initialize : function() {
	    //
	    // summary:
	    //		invoked after the dialog is created and populated (it may still be hidden)
		//		developer hook to carry out processing as soon as dialog nodes become available in the DOM.
		//		TODO: clarigy/confirm
	    //		
	    // returns:
	    //		null
	    // tags:
	    //		public
	},
	
	_isHorizontalAlignment : false,
	_isHorizontalLeftAlignment : false,


	// hardwired direct reference to singleton observer
	_getObserver : function () { return xwt.widget.layout.OverlayObserverFactory(); },

	// cast to array if there is just a single entry

	_setConnectEventsAttr : function(str) {
		this.connectEvents = dojo.isArrayLike(str) ? str : [ str ];
	},

	// _Widget calls this magically when a connectId param is supplied
	_setConnectIdAttr : function(ids) {
		var methodPrefix = "_connectElement";
		this._connectNodes = [];
		this.connectId = dojo.isArrayLike(ids) ? ids : [ ids ];
		dojo.forEach(this.connectId, function(id) {
			var node = dojo.byId(id);
			if (node) {
				this._connectNodes.push(node);
				dojo.forEach(this.connectEvents,function(event) {
					var methodName = [ methodPrefix,event.toLowerCase() ].join("_");
					this.connect(node, event.toLowerCase(),this.handleTriggerEvent,event);
				}, this);
				if (dojo.isIE) {
					// BiDi workaround
					node.style.zoom = 1;
				}
			}
		}, this);
	},

	_setViewportPositionAttr : function (x) {
		// reset absolute coords if we are using position based syntax ( left,right,center ) for aligning overlay
		if ( x.length == 2 ) {
			this.left = 0;
			this.top = 0;
		}

	},

	postCreate : function() {
		this.inherited("postCreate", arguments);


		// define an underlay for when called as a modal
		if ( this.isModal ) {
			var underlayAttrs = {
					dialogId: this.id,
					"class": dojo.map(this["class"].split(/\s/), function(s){ return s+"_underlay"; }).join(" ")
			};
			this.underlay = new dijit.DialogUnderlay(underlayAttrs); 
			dojo.setSelectable( this.underlay.domNode, false );
		}


		if (!this.showCloseButton)
			dojo.removeClass(this.closeButtonNode,"xwtDialogCloseIcon");
		if (!this.showCloseButton && this.title === "") {
			dojo.removeClass(this.titleBar, "tooltiptitle");
		}


		if (dojo.isFF && this.duration <= 0) { this.duration = 1; } // FF needs at least 1

		var showFXAnimationMetadata = {
				node : this.domNode,
				duration : this.duration,
				beforeBegin: function(){
			// show underlay
			var co =  dijit.getEnclosingWidget(this.node);
			if (co.underlay) {
				co.underlay.attr(underlayAttrs);
				co.underlay.show();
			}
		},
		onEnd : dojo.hitch(this, this._onShow )
		};

		var endFXAnimationMetadata = {
				node : this.domNode,
				duration : this.duration,
				onEnd : dojo.hitch(this, this._onHide )
		};


		// Setup fade-in and fade-out functions.

		if (this.showEffect == "fade") {
			this.animationIn = dojo.fadeIn( showFXAnimationMetadata  );
			this.animationIn.type = "fade";

		} else if (this.showEffect == "wipe") {
			this.animationIn = dojo.fx.wipeIn( showFXAnimationMetadata  );
			this.animationIn.type = "wipe";
		}

		if (this.hideEffect == "fade") {
			this.animationOut = dojo.fadeOut( endFXAnimationMetadata  );
			this.animationOut.type = "fade";

		} else if (this.hideEffect == "wipe") {
			this.animationOut = dojo.fx.wipeOut( endFXAnimationMetadata  );
			this.animationOut.type = "wipe";
		}


		this.tipNode = dojo.query(".dijitTooltipConnector",this.domNode)[0];

		// remove this redundant tooltip on the whole container,
		// template accidently injected
		this.containerNode.removeAttribute("title");
		this.domNode.removeAttribute("title");


		// handle canceling the dialog via ESCape key
		this.onCancel = function() {

			var triggerPointNode = this.aroundNode;
			this.inherited("onCancel", arguments);
			this.hide( this.aroundNode ); 
			// restore focus to the node used to trigger dialog
			dijit.focus ( triggerPointNode );
		};



		// client extension
		this.initialize();

	},

	// makes the transparent PNG
	_makeGraphicsIE6Compatible : function () {

		// IE6 needs have transparent PNG assets. a very comprehensive list of elements to modify
		if( dojo.isIE <= 6  ) {

			var sectionsList = [
			             ".dsl_roundedCorners .dsl_rc_topleft_corner",
			                   ".dsl_roundedCorners .dsl_rc_topright_corner",
			                    ".dsl_roundedCorners .dsl_rc_bottomleft_corner",
			                    ".dsl_roundedCorners .dsl_rc_bottomright_corner",

			                    /* black background */
			                    ".dsl_topColor",
			                    ".dsl_bottomColor",
			                    ".dsl_rc_topmiddle",
			                    ".dsl_leftside",
			                    //".dsl_back",
			                    ".dsl_rightside",
			                    ".dsl_rc_bottommiddle",

			                    /* drop shadow large */
			                    ".DropShadowLarge td.r1c1",
			                    ".DropShadowLarge td.r1c2",
			                    ".DropShadowLarge td.r1c3",

			                    ".DropShadowLarge td.r2c1",
			                    ".DropShadowLarge td.r2c3",

			                    ".DropShadowLarge td.r3c1",
			                    ".DropShadowLarge td.r3c2",
			                    ".DropShadowLarge td.r3c3"

			                    ];

			for(var x in sectionsList) {
				var selector = sectionsList[x];
				this._recreateIE6PNG (  dojo.query( selector, this.domNode )[0] );
			}
		}

	},

	startup : function() {
		this.inherited("startup", arguments);
	},



	_onRendered : function() {
		var isAbsolutePlacement = ( this.left >= 0 && this.top >= 0 );
		var refPointNode = isAbsolutePlacement ? this.domNode  : this.aroundNode;
		// calculate best spot for tip node
		this._positionTipNode( refPointNode );
	},

	_positionTipNode : function( refNode) {
		var box = dojo.coords( refNode);

		var iconHeight = 18;
		var connectorVerticalPosition = box.y + (box.h * 0.5) - (iconHeight * 0.5);
		// bounds check
		// some subclasses do not have a decoratorWidget
		if ( ! this.decoratorWidget ) { return; }

		var contentTableInsideWrappedWidget = this.decoratorWidget.decorationWidgetContentPoint;
		var contentTableInsideWrappedWidgetCoords = dojo.coords(contentTableInsideWrappedWidget);
		var cvp_minY = contentTableInsideWrappedWidgetCoords.y;
		var cvp_maxY = cvp_minY + contentTableInsideWrappedWidgetCoords.h;
		// bounds check
		if (connectorVerticalPosition < cvp_minY) {
			connectorVerticalPosition = cvp_minY;
		} else if (connectorVerticalPosition > cvp_maxY) {
			connectorVerticalPosition = cvp_maxY;
		}
		if (this._isHorizontalAlignment) {
			// make position in relative units compared to the link
			connectorVerticalPosition -= contentTableInsideWrappedWidgetCoords.y;
			connectorVerticalPosition += (5 / 2); // add 5 pixel offset then halve it
		}
		// horiz alignment needs the arrow node to line up really well to the trigger node

		// otherwise MUST reset it each invocation
		dojo.style(this.tipNode,"top",(this._isHorizontalAlignment) ? connectorVerticalPosition + "px" : "");
		// re-calculate arrow positioning
		setTimeout(dojo.hitch(this, this._fixTipNodeArrow), 10);
	},


	// if there are any tweaks needed to position the arrow do it here..
	_fixTipNodeArrow : function() {

		// some subclasses do not have a decoratorWidget
		if ( ! this.decoratorWidget ) { return; }

		var contentTableInsideWrappedWidget = this.decoratorWidget.decorationWidgetContentPoint;
		var contentTableInsideWrappedWidgetCoords = dojo.coords(contentTableInsideWrappedWidget);

		// IE6 needs lots of help here..
		if (dojo.isIE <= 6) {

			// clear old arrow and fix arrow image for IE6
			this._recreateIE6PNG ( this.tipNode );

			// if arrow is of the left side
			var connectorHorizontalPosition;
			// the arrow is on the left side of the dialog
			// the arrow is on the right side, pointing right..
			// dialog is LEFT aligned
			if (dojo.hasClass(this.domNode, "dijitTooltipLeft")) {
				connectorHorizontalPosition = contentTableInsideWrappedWidgetCoords.w - 5;
			}
			// the arrow is on the left side, pointing left.. dialog is RIGHT aligned
			else {
				connectorHorizontalPosition = -14;
			}
			// fix the up arrow
			if (dojo.hasClass(this.domNode, "dijitTooltipBelow")) {
				dojo.style(this.tipNode, "top", -12);
			}
			// fix the down arrow
			if (dojo.hasClass(this.domNode, "dijitTooltipAbove")) {
				dojo.style(this.tipNode,"top", (contentTableInsideWrappedWidgetCoords.h + -3 ));
			}
			dojo.style(this.tipNode,"left",(this._isHorizontalAlignment) ? connectorHorizontalPosition + "px" : "");
			this._makeGraphicsIE6Compatible();
		}

	},

	_onShow : function() {
		// summary:
		//		Called at end of fade-in operation
		// tags:
		// protected
		// track how many times it was shown
		this._showCount++;

		if (dojo.isIE ) {
			// the arrow won't show up on a node with opacity filter
			this.domNode.style.filter = "";
		}

		this.inherited("_onShow", arguments);

		if (dojo.isIE && dojo.isIE >= 7) {
			dojo.query(".r1", this.domNode).style("visibility","visible");
			dojo.query(".r2c1", this.domNode).style("visibility", "visible");
			dojo.query(".r2c3", this.domNode).style("visibility", "visible");
			dojo.query(".r3a", this.domNode).style("visibility", "visible");
			dojo.query(".r2t1r1", this.domNode).style("visibility", "visible");
			dojo.query(".r2t1r3", this.domNode).style("visibility", "visible");
			dojo.query(".dsl_leftside", this.domNode).style("visibility", "visible");
			dojo.query(".dsl_rightside", this.domNode).style("visibility", "visible");
		}


		// automatically determine the first focusable object !
		if(this.autofocus){
			var f = this._getFocusItems(this.containerNode);
			dijit.focus(this._firstFocusItem);
		}

	},

	_onHide : function() {



		// summary:
		//		Called at end of fade-out operation
		// tags:
		// protected
		// this.domNode.style.cssText=""; // to position offscreen
		// again
		dojo.addClass(this.domNode, "dijitHidden");


		// dismiss the modal underlay
		if ( this.isModal ) {
			this.underlay.hide();
		}

		if (this._onDeck) {
			// a show request has been queued up; do it now
			this.show.apply(this, this._onDeck);
			this._onDeck = null;
		}
		// call custom client handler...
		this.onHide();
	},
	// connectId -> event management
	handleTriggerEvent : function(e) {
		e.stopPropagation(e);
		e.preventDefault(e); // prevent native context menu
		// logic is to open up dialog at the target point
		var isAbsolutePlacement = ( this.left >= 0 && this.top >= 0 );

		// start to open overlay
		//console.log( e.target)
		this.open(e.target, this.positionStructure);
	},
	// very common events to bind to for auto-wiring the trigger events
	// key
	_connectElement_onkeypress : function(e) {
		this.handleTriggerEvent(e);
		if (this.onKeypress) {
			this.onKeyPress(e);
		}
	},
	// mouse hover
	_connectElement_onmouseenter : function(e) {
		this.handleTriggerEvent(e);
		if (this.onMouseEnter) {
			this.onMouseEnter(e);
		}
	},
	// left click ( mouse)
	_connectElement_onclick : function(e) {
		this.handleTriggerEvent(e);
		if (this.onClick) {
			this.onClick(e);
		}
	},
	// focus ( mouse or keyboard?)
	_connectElement_onfocus : function(e) {
		this.handleTriggerEvent(e);
		if (this.onFocus) {
			this.onFocus(e);
		}
	},
	// right click
	_connectElement_oncontextmenu : function(e) {
		this.handleTriggerEvent(e);

		if (this.onContextMenu) {
			this.onContextMenu(e);
		}
	},
	// double click
	_connectElement_ondblclick : function(e) {
		this.handleTriggerEvent(e);

		if (this.onDblClick) {
			this.onDblClick(e);
		}
	}
});

}

if(!dojo._hasResource["xwt.widget.layout.ContextualOverlay"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.layout.ContextualOverlay"] = true;
// summary:	Context-aware overlay dialog window with content
//
// description: a specialized dialog that offers contextual placement. Supports binding multiple "triggers" and autowiring the event to cause it to open
// support for a11y via keyboard, special fade effects
//
// features:
//
// modal dialog
// accessibility
// absolute coordinate based positioning, or relative to a trigger node ( default )
// vertical / horizontal alignment
// autowiring via tag attributes connectId, connectEvents
// 
// author: Matt Anderson <matander@cisco.com>


dojo.provide("xwt.widget.layout.ContextualOverlay");


dojo.declare("xwt.widget.layout.ContextualOverlay",[ xwt.widget.layout.BaseOverlay ], {
	// summary:
	//		Contextual Overlay 
	// 
	// description:
	//		Implements the contextual overlay visual and interaction behavior
	//		as described in the Kubrick UE Spec
	templateString : dojo.cache("xwt.widget.layout", "templates/ContextualOverlay.html", "<div class=\"dijitTooltip dijitTooltipRight\">\r\n<div dojoType=\"xwt.widget.DropShadowLarge\" dojoAttachPoint=\"decoratorWidget\" dsCurvedCorners=\"true\" dsRepeat=\"repeat\"><div \r\n\tclass=\"dijitTooltipContainer dijitTooltipContents\"><div \r\n\tdojoAttachPoint=\"titleBar\" class=\"tooltiptitle\"><span \r\n\t\tdojoAttachPoint=\"titleNode\">${title}</span><span dojoAttachPoint=\"closeButtonNode\"\r\n\t\t\t\tclass=\"xwtDialogCloseIcon\"\tdojoAttachEvent=\"click:hide\"><span \r\n\tdojoAttachPoint=\"closeText\" class=\"closeText\"></span></span></div><div class=\"tooltipcontentarea dijitTooltipContents\" dojoAttachPoint=\"containerNode\" waiRole=\"alert\"\r\n\t></div><div class=\"dijitTooltipConnector\"\r\n\t></div></div></div></div>\r\n\r\n\r\n\r\n"),
	
	
	titleKey:"",
	//
	// i18nPackage: String
	//		The namespace where application specific i18n packages reside
    // tags:
    //		public
	i18nPackage: "",
	//
	// i18nBundle: String
	//		The name of the bundle to use in the i18nPackage
    // tags:
    //		public
	i18nBundle: "",
	//
	//	i18nMixin: Object
	//		An object of key values used to replace individual i18n strings
    // tags:
    //		public
	i18nMixin: null,
	
	postMixInProperties: function(){
			if (this.i18nPackage !== "" && this.i18nBundle !== "")
			{
				this.i18n = dojo.mixin(dojo.i18n.getLocalization(this.i18nPackage, this.i18nBundle), this.i18nMixin || {});
				this.title = this.i18n[this.titleKey];
				
			}
			
			this.inherited(arguments);
    }

	
	
	
	
});

}

if(!dojo._hasResource["xwt.widget.layout.ProgressBall"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.layout.ProgressBall"] = true;
/*******************************************************************************
 * Copyright (c) 2009-2011 Cisco Systems, Inc. All rights reserved.
 * 
 * @fileoverview The xwt.widget.ProgressBall extends dijit._widget and
 *               dijit._Templated.
 * 
 * The purpose of the ProgressBall widget is to let a user know that something
 * is coming soon or that a process is being executed.
 * 
 * @author Priston SesuMichael psesumic@cisco.com
 */

dojo.provide("xwt.widget.layout.ProgressBall");






dojo.declare("xwt.widget.layout.ProgressBall", [ dijit._Widget, dijit._Templated, xwt.widget._ZIndexMixin], {
	
	// summary:
	//		ProgressBall is a visual indicator that lets a user know that the application is waiting or 
	// that a process is beingexecuted.
	
	// description:
	// This is a visual indicator that lets a user know that the application is
	// waiting or that
	// a process is being executed. It is an indeterminate indicator; that is,
	// it
	// does not provide a measure of how much process has been completed.
	//
	// Usage:
	//
	// HTML Mark up:
	// <div dojoType="xwt.widget.layout.ProgressBall" id="pgballid"
	// imageMode="gray" ballSize="small" targetId ="btn1" position="right"
	// padding="10"></div>
	//
	// Programmatic way:
	// progressBall = new xwt.widget.layout.ProgressBall(
	// {imageMode : "white",ballSize : "small",targetId : "btn1",position :
	// "right",padding : "10"});
	// progressBall.start();
	
	/* templateString : '<div dojoAttachPoint="loadingIndicator" ></div>', */
	templateString:"<div tabIndex=\"0\" class=\"progressBall\" dojoAttachPoint=\"loadingIndicator\">\r\n<span class = \"xwtProgresBallText\" waiRole = \"presentation\" role = \"presentation\" dojoAttachPoint=\"iconTextNode\">In Progress</span>\r\n</div>\r\n",

	/* imageUrl: String
	// Optional user-defined indicator image. This image will override the
	// default indicator.
	imageUrl : "",*/

	// ballSize: String
	// This is the indicator size. Valid ball sizes are:
	// small (16px \* 16px) (default) and extreme (32px \* 32px)
	ballSize : "small",

	// targetId: String
	// The ID of the target Widget or domNode. The ProgressBall indicator
	// appears just
	// adjacent to this node. The location depends on the position parameter.
	targetId : "",

	// position: String
	// Indicates where the ProgressBall will appear on the target node.
	// Valid inputs are "left", "right", "top", "bottom", and "center".
	position : "right",
	

	// padding: Number
	// The padding separating the ProgressBall from the target node.
	// The default value is 9.
	padding : 9,
	
	//_moveUp: Number
	// The amount to move the ProgressBall up relative to the target node when
	// the
	// position parameter's value is "center".
	_moveUp : 0,
	
	// _moveDown: Number
	// The amount to move the ProgressBall down relative to the target node when
	// the
	// position parameter's value is "center".
	_moveDown : 0,
	

	// grabfocus: Boolean
	// Indicates whether the ProgressBall should grab the focus for itself
	// ("true") or not.
	grabfocus :true,
	
	//_targetDomNode domNode
	_targetDomNode : null,
	
	// imageMode: String
	// The ProgressBall image mode: either "image1" or "image2".
	// The default value is "image1" (in earlier versions, it was either "gray"
	// or "white").
	imageMode: "image1",
	
	// i18nPackageName: String
	// To support I18N messages. By default, the value is "xwt". Modify based on
	// your requirements.
    i18nPackageName: "xwt",
    
    // i18nBundlerName: String
    // To support I18N messages. By default, the value is "XMPProperties".
	// Modify based on your requirements.
    i18nBundleName: "XMPProperties",
    
    _messages: null,
    
    iconText:"In-Progress",
	
    iconTextLookup:"pb_text",
	
    postMixInProperties : function(){		
	
		this.attributeMap.iconText = {
				node : "iconTextNode",
				type : "innerHTML"
			};
	
	
		var i18mixin = new xwt.widget.i18nMixin();
		if (this.i18nPackageName && this.i18nBundleName) {
        	i18mixin.addBundle(this.i18nPackageName, this.i18nBundleName);
        	this._messages = dojo.mixin(this._messages, i18mixin._messages);
        	this._useI18 = true;
        } else {
        	this._useI18 = false;
        }
		if (this._messages) {
			if (this.iconTextLookup) {
				this.iconText = this._messages[this.iconTextLookup];
				}
			}
	},
	
	_redrawProgress : function(){	
		if(dojo.hasClass(this.loadingIndicator,"xwtProgressBallShow")) {
			var dim = this._getPosition();
			dojo.style(this.domNode,dim);
		}
	},
	
	postCreate : function() {
		
		this.attr("iconText",this.iconText);
		this.ballSize = this.ballSize === null ? "small" : this.ballSize.toLowerCase();
		this.imageMode = this.imageMode === null ? "gray" : this.imageMode.toLowerCase();
		
		this._getTargetNode();
		if (this._targetDomNode){
			this._connectDestroy = dojo.connect(this._targetDomNode, "destroy",this.destroy);
		}
		
		this._connectResize = dojo.connect(dojo.global, "onresize", this,"_redrawProgress");
		this.hookZIndex();
		
	},
	
	startup : function() {
		/*this.loadingIndicator.style.display = "none";*/
		dojo.removeClass(this.loadingIndicator);
		dojo.addClass(this.loadingIndicator,"xwtProgressBallHide");
	},
	
	_getTargetNode : function(){
		//summary:
		//	To get the TargetNode.
		//
		// description:
		// Gets the target node from the targetId.
	
		if(this.targetId!==null){
			this._refNode = null;
			if(dijit.byId(this.targetId)){
				this._refNode = dijit.byId(this.targetId).domNode;
			}
			this._targetDomNode = this._refNode ? this._refNode : dojo.byId(this.targetId);
			}
		else{ 
			this.targetId = dojo.body();
		}
	},

	_loadClass : function() {
		//summary:
		//To load the style class .
		//
		// description:
		// Loads the appropriate class in the domNode depending
		// on the constructor parameter passed in.
		
		this._removeClass();
	    dojo.addClass(this.loadingIndicator,this._getClassName());
	},

	_removeClass : function() {
		//summary:
		//	To remove style class .
		//
		// description:
		// Removes the class from the domNode.
		// this.loadingIndicator["className"] = "";
		dojo.removeClass(this.loadingIndicator);

	},
	
	setImageMode : function(mode){
		
		// summary:
		//		To set the image mode
		// description:
		// Sets the mode of the ProgressBall image.
		// Valid arguments are "image1" and "image2"; the default is "image1".
		
		this.imageMode = mode!== null && mode.length > 0 ? mode:"image1";		
	},
	
	_getClassName : function() {
		//summary:
		//	To get the class name
		//
		// description:
		// Gets the class name, depending on provided constructor
		// parameters.
		
		var ball,img;
		if(this.ballSize!==null && this.ballSize.length > 0){
			if(this.ballSize=="extreme"){
				ball="extreme";
			}
			else if(this.ballSize == "medium"){
				ball = "medium";
			}
			else{
				ball ="small";
			}
		}else{
			ball = "small";
		}
		
		if(this.imageMode!==null && this.imageMode.length > 0){
			switch(this.imageMode){
			case "white":
				img="white";
				break;
			
			case "gray": 
				img="gray";
				break;
			
			case "image1": 
				img="image1";
				break;
			
			case "image2": 
				img="image2";
				break;
			
			default:
				img="image1";
				break;
							
		}
		/* if(this.imageMode == "white") img ="white";	elseimg = "gray";*/				
		}else{
			img = "image1";
		}		
		return "xwt"+ball+img+"ball";
	},

	_getBallMargin : function(size) {
		
		//summary:
		//	To get the  margin of the ProgressBall.
		//
		// description:
		// Returns the margin object for the ProgressBall (for example:
		// {w:100,h:22,p:5}). The margin depends on the
		// size argument.
		var mBox = null;
	var n = dojo.create("div", {style:{visibility:"hidden"}}, dojo.body());
	if (size == "medium"){
		dojo.addClass(n,"xwtmediumimage2ball");
				mBox = {
				w : dojo.style(n,"width"),
				h : dojo.style(n,"height"),
				p : dojo.style(n,"paddingLeft")
			};

	}
	else if(size == "extreme"){
	dojo.addClass(n,"xwtextremeimage2ball");
	mBox = {
			w : dojo.style(n,"width"),
			h : dojo.style(n,"height"),
			p : dojo.style(n,"paddingLeft")
		};
	
	}
	else{		
		dojo.addClass(n,"xwtsmallimage2ball");
		mBox = {
				w : dojo.style(n,"width"),
				h : dojo.style(n,"height"),
				p : dojo.style(n,"paddingLeft")
			};
		
	}
		dojo.body().removeChild(n);
		
		return mBox;

	},

	_getPosition : function() {
		dim = {};
		
		// summary:
		// To get the position in which to the place the ProgressBall.
		//
		// description:
		// This method will return the position object (for example:
		// {top:100,left:22}) in which to place the
		// ProgressBall around the node (left, right, top, center, bottom).
		
		var targetPos = this._pos(this._targetDomNode,true);
		var mBox = this._getBallMargin(this.ballSize);
		var center ;
		
		if(targetPos.h > mBox.h){
			center = targetPos.y  + ((targetPos.h - mBox.h) / 2);
		}else{
			center = targetPos.y  - ((mBox.h - targetPos.h ) / 2);
		}
		
		switch (this.position.toLowerCase()) {		
		case "left":			
			dim = {
				left:(targetPos.x - mBox.w - this.padding) + "px",
				top:center+"px"
			};
			
			break;
		case "right":
			dim = {
				left:(targetPos.x + targetPos.w + this.padding)+ "px",
				top:center+"px"
			};
			break;
		case "center":
			dim = {
				left:(targetPos.x + (targetPos.w / 2)) - ((mBox.w) / 2)+ "px",
				top:center+"px"
			};
			break;

		case "top":
			dim = {
				left:(targetPos.x + (targetPos.w / 2)) - ((mBox.w) / 2)+ "px",
				top:(targetPos.y - mBox.h - this.padding)+ "px"
			};
			break;
		case "bottom":
			dim = {
				left:(targetPos.x + (targetPos.w / 2)) - ((mBox.w) / 2)+ "px",
				top:(targetPos.y + targetPos.h + this.padding)+ "px"
			};
			break;
		default:
			dim = {
				left:(targetPos.x + targetPos.w + this.padding)+ "px",
				top : center+"px"
			};
			break;
		}
		return dim;
	},

	start : function() {
		
		// summary:
		//	To display the progress ball indicator as per the UX specifications.
		
		// description:
		// This method is invoked to show the ProgressBall indicator.
		// It will make the ProgressBall indicator visible for the given
		// ballSize and targetId
		// by applying the corresponding style classes. If the ballSize or
		// imageMode is not
		// provided, the default ballSize or imageMode will be used.
		//
		// example:
		// progressBall = new xwt.widget.layout.ProgressBall({
		// imageMode : "white",
		// ballSize : "small",
		// targetId : "btn1",
		// position : "right",
		// padding : "10"
		// });
		// progressBall.start();
		
		this._loadClass();
		if (this.targetId !== null) {
			
			this.padding = parseInt(this.padding,10);
			if (isNaN(this.padding)){
				this.padding = 9;
			}
			this._moveUp = parseInt(this._moveUp,10);
			if (isNaN(this._moveUp)){
				this._moveUp = 0;
			}
			this._moveDown = parseInt(this._moveDown,10);
			if (isNaN(this._moveDown)){
				this._moveDown = 0;
			}
			var dim = this._getPosition();
			this.placeAt(dojo.body());
			dojo.style(this.loadingIndicator, dim);
		}
		//this._loadCustomImage();
		var zindex = dojo.style(this._targetDomNode,"zIndex");
		
		if(!isNaN(zindex)){
			if(dojo.isIE == 7){
				zindex+=2;
			}else{			
				zindex+=1;
			}
		}
		else{
			if(dojo.isIE == 7){
				zindex+=2;
			}else{
				zindex=this._getIndex()+1;
			}
		}		
			
		dojo.style(this.loadingIndicator,"zIndex",zindex);
		/* this.loadingIndicator.style.display = "block"; */
		dojo.removeClass(this.loadingIndicator,"xwtProgressBallHide");
		dojo.addClass(this.loadingIndicator,"xwtProgressBallShow");
		/*
		 * if(this.grabfocus) { dijit.focus(this.domNode); }
		 */
		
	},
	
	

	stop : function() {
		// summary:
		//		Hides the ProgressBall indicator.
		//
		// description:
		// Hides the ProgressBall indicator.
		//
		// example:
		// progressBall = new xwt.widget.layout.ProgressBall({
		// imageMode : "white",
		// ballSize : "small",
		// targetId : "btn1",
		// position : "right",
		// padding : "10"
		// });
		// progressBall.start();
		// ...other processing occurs here...
		// progressBall.stop();
		//
		
		this._removeClass();
		/* this.loadingIndicator.style.display = "none"; */
		dojo.removeClass(this.loadingIndicator,"xwtProgressBallShow");
		dojo.addClass(this.loadingIndicator,"xwtProgressBallHide");
	},
	_pos : function(domNode,scroll){
		
		// summary:
		//			Return the position of the target node in the screen.
		//
		// description:
		// Returns the position of the target node in screen.
	
		var db = dojo.body(),dh=db.parentNode,ret;
		domNode = dojo.byId(domNode);
		var cs;
		
		if(domNode.getBoundingClientRect){	
			ret=domNode.getBoundingClientRect();
			ret={x:ret.left,y:ret.top,w:ret.right-ret.left,h:ret.bottom-ret.top};
			if(dojo.isIE){
					var _55 = dojo._getIeDocumentElementOffset();
					ret.x-=_55.x+(dojo.isQuirks?db.clientLeft+db.offsetLeft:0);
					ret.y-=_55.y+(dojo.isQuirks?db.clientTop+db.offsetTop:0);
				}else{
						if(dojo.isFF==3){
								cs = dojo.getComputedStyle(dh);
								ret.x-=this._getPixelValue(dh,cs.marginLeft)+this._getPixelValue(dh,cs.borderLeftWidth);
								ret.y-=this._getPixelValue(dh,cs.marginTop)+this._getPixelValue(dh,cs.borderTopWidth);
						}
				}
	}
	else{
		ret={x:0,y:0,w:domNode.offsetWidth,h:domNode.offsetHeight};
		if(domNode.offsetParent){
			ret.x-=this._getScrollCoords(domNode,"scrollLeft");
			ret.y-=this._getScrollCoords(domNode,"scrollTop");
			var _56=domNode;
			do{
				var n=_56.offsetLeft,t=_56.offsetTop;
				ret.x+=isNaN(n)?0:n;
				ret.y+=isNaN(t)?0:t;
				cs = dojo.getComputedStyle(_56);
				
				if(_56!=domNode){
					if(dojo.isMoz){
						ret.x+=2*this._getPixelValue(_56,cs.borderLeftWidth);
						ret.y+=2*this._getPixelValue(_56,cs.borderTopWidth);
					}else{
						ret.x+=this._getPixelValue(_56,cs.borderLeftWidth);
						ret.y+=this._getPixelValue(_56,cs.borderTopWidth);
					}
				}
				if(dojo.isMoz&&cs.position=="static"){
					var _57=_56.parentNode;
					while(_57!=_56.offsetParent){
						var pcs=getComputedStyle(_57);
						if(pcs.position=="static"){
							ret.x+=getPixelValue(_56,pcs.borderLeftWidth);
							ret.y+=px(_56,pcs.borderTopWidth);
						}
						_57=_57.parentNode;
					}
				}
				_56=_56.offsetParent;
			}
			while((_56!=dh)&&_56);
		}
		else{
			if(domNode.x&&domNode.y){
				ret.x+=isNaN(domNode.x)?0:domNode.x;
				ret.y+=isNaN(domNode.y)?0:domNode.y;
			}
		}
	}
	if(scroll){
		var _58=dojo._docScroll();
		ret.x+=_58.x;
		ret.y+=_58.y;
	}
	return ret;
	},
	_getPixelValue : function (node,parameter){
		// summary:
		//			Returns the numerical pixel value for the argument node and parameter
		//
		// description:
		// Returns the numerical pixel value for the argument
		// node and parameter.
		if(!dojo.isIE){
			return parseFloat(parameter)||0;
		}
		else{
		 if(parameter == "medium"){
			 return 4;
		 }
		}
		if(parameter.slice && parameter.slice(-2) == "px"){
			return parseFloat(parameter);
		}
		with(node){
			var le = style.left;
			var rl  = runtimeStyle.left;
			runtimeStyle.left = currentStyle.left;
			try{
				style.left= parameter;
				parameter = style.pixelLeft;
			}
			catch(e){
				parameter = 0;
			}
			style.left = le;
			runtimeStyle.left= rl;
		}
		return parameter;
	},

	_getScrollCoords : function(node,scrollPosition){
		if(!(node=(node||0).parentNode)){
			return 0;
		}
		var val,_50 = 0, bnode = dojo.body();
		while(node && node.style){
			if(dojo.getComputedStyle(node).position=="fixed"){
				return 0;
			}
			val=node[scrollPosition];
			if(val){
				_50+=val-0;
				if(node == bnode){
					break;
				}
			}
			node = node.parentNode;
		}
		return _50;
	},
	

	_getIndex:function(){		
	    var tar = this._targetDomNode;	    
	     while(tar.parentNode && tar.tagName && tar.tagName.toLowerCase() !="body" ){
	    	 var zindex = dojo.style(tar.parentNode,"zIndex");
	    	 if(!isNaN(zindex)){
	    		 return parseInt(zindex,10);
	    		 }
	    	 tar=tar.parentNode;
	    	 }
	     return 0;
	  },
	destroy:function(){
		// description:
		//		Destroy this widget, but not its descendants. This method will, however, destroy internal widgets such as those used within a template.
		// You should call the ProgressBall's destroy method before deleting or
		// removing the target ID from the memory. Otherwise, the ProgressBall
		// instance will not be cleaned up from the memory.
		if(this._connectDestroy){
			dojo.disconnect(this._connectDestroy);
		}
		if(this._connectResize){
			dojo.disconnect(this._connectResize);
		}
		this.inherited(arguments);
	  }
});

}

if(!dojo._hasResource["xwt.widget.quickview.QuickView"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.quickview.QuickView"] = true;
/*******************************************************************
 *        Copyright (c) 2009-2011 Cisco Systems, Inc.
 *        All rights reserved.
 *
 * @fileoverview
 * Context-aware overlay widget, attempts to intelligently
 * place the popup "close" to a target anchor aroundNode
 *
 *  @author Niloy Battacharya nbhattac@cisco.com
 *  @author Dennis Park denpark@cisco.com
 *  @author Jared Jurkiewicz jjurkiew@cisco.com
 *    
 ********************************************************************/

dojo.provide("xwt.widget.quickview.QuickView");
dojo.provide("xwt.widget.quickview.QuickViewActionItem");









 // viewport




dojo.declare("xwt.widget.quickview.QuickView", [xwt.widget.layout.ContextualOverlay, xwt.widget._ZIndexMixin],{
	// summary:
	//		The QuickView panel is a modeless panel that discloses more
	//		information without forcing the user to leave the current view.
	//
	// description:
	//		The QuickView panel is a modeless panel that discloses more
	//		information without forcing the user to leave the current view.
	//		Please note that QuickView will not destroy any action items you pass to it, 
	//		as they may be shared.  Therefore, you must call the destroy function of the 
	//		action items when you are done with them.
	//
	// example:
	//		To create a QuickView, we create a new QuickView instance and set its content and action items:
	//
	//	|	var qvcontent = new dijit.layout.ContentPane({
	//	|		title: ''
	//	|		...
	//	|	});
	//	|
	//	|   var actionList = [];
	//	|	var qva = new xwt.widget.QuickViewActionItem( {
	//	|		iconClass : "dijitEditorIcon dijitEditorIconPaste",
	//	|		labelText : 'My Action',
	//	|		callback : function() {
	//	|			alert('My Action triggered')
	//	|		}
	//	|	});
	//	|	actionList.push(qva);
	//	|	var quickview = new xwt.widget.quickview.QuickView({ id: "ttp1",
	//	|			title: "Alarms",
	//	|			content: qvcontent,
	//	|			actionItemList: actionList
	//	|			i18nPackageName: "xwt",
	//	|			i18nBundleName: "XMPProperties",
	//	|	});
	//
	// example:
	//	To open the QuickView widget using events:
	//	|		dojo.addOnLoad(function(){
	//	|		....
	//	|		var ttp = dijit.byId("ttp1");
	//	|		//here t1 is the reference to any dom element.
	//	|		ttp.connect(t1, "mouseover", function(evt){
	//	|		ttp.openAtNode(t1);
	//	|		});
	//	|		....
	//	|		});
	//
	// example:
	//	To clean up created action items on destroy of the QuickView if they are not shared:
	//	|	var qvcontent = new dijit.layout.ContentPane({
	//	|		title: ''
	//	|		...
	//	|	});
	//	|
	//	|   var actionList = [];
	//	|	var qva = new xwt.widget.QuickViewActionItem( {
	//	|		iconClass : "dijitEditorIcon dijitEditorIconPaste",
	//	|		labelText : 'My Action',
	//	|		callback : function() {
	//	|			alert('My Action triggered')
	//	|		}
	//	|	});
	//	|	actionList.push(qva);
	//	|	var quickview = new xwt.widget.quickview.QuickView({ id: "ttp1",
	//	|			title: "Alarms",
	//	|			content: qvcontent,
	//	|			actionItemList: actionList
	//	|			i18nPackageName: "xwt",
	//	|			i18nBundleName: "XMPProperties",
	//	|	});
	//  |   var cleanup = dojo.connect(quickview, "destroy", function(){
	//	|		dojo.disconnect(cleanup);
	//	|		dojo.forEach(actionList, function(ai){
	//	|			ai.destroy();
	//	|		});
	//	|	};


	// actionItemList: Object[]
	//	The list of action items as xwt.widget.QuickViewActionItem.
	//	If there are no items in the list, QuickView will not show the Action area.
	actionItemList:[],

	//	templateString: null
	//		Not used as we are using the templatePath, overriding.
	templateString: null,
	//	templatePath: Object[]
	//		The path to the template file, overriding.
	templateString:"<div class=\"dijitTooltip dijitTooltipRight\" id=\"dojoTooltip\">\r\n\t<table class=\"containerTable\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" dojoAttachPoint=\"decoratorWidget\">\r\n\t  <tr>\r\n\t    <td class=\"top-left\"></td>\r\n\t    <td class=\"top-center\"></td>\r\n\t    <td class=\"top-right\"></td>\r\n\t  </tr>\r\n\t  <tr>\r\n\t    <td class=\"middle-left-col\" dojoAttachPoint=\"middleLeftColumn\" >\r\n\t    \t<table class=\"middle-column-table\">\r\n\t \t\t\t<tr class=\"fill-row\">\r\n\t    \t\t\t<td class=\"middle-left\" dojoAttachPoint=\"middleLeft\"></td>\t\t\t\t\r\n\t    \t\t</tr>\r\n\t\t\t\t<tr>\r\n\t\t\t\t\t<td class=\"middle-left-lower\" dojoAttachPoint=\"middleLeftLower\"></td>\r\n\t\t\t\t</tr>\r\n\t    \t</table>\r\n\t    </td>\r\n\t    <td class=\"middle-center\" dojoAttachPoint=\"middleCenterColumn\">\r\n\t\t\t<div class=\"dijitTooltipContainer dijitTooltipContents\" dojoAttachPoint=\"contentAP\">\r\n\t\t\t\t<div dojoAttachPoint=\"titleBar\" class=\"tooltiptitle\">\r\n\t\t\t\t\t<span dojoAttachPoint=\"titleNode\">${title}</span>\r\n\t\t\t\t\t<span dojoAttachPoint=\"closeButtonNode\" class=\"xwtDialogCloseIcon\" dojoAttachEvent=\"click:hide\">\r\n\t\t\t\t\t\t<span dojoAttachPoint=\"closeText\" class=\"closeText\"></span>\r\n\t\t\t\t\t</span>\r\n\t\t\t\t</div>\r\n\t\t\r\n\t\t\t\t\t<div class=\"tooltipcontentarea dijitTooltipContents\" dojoAttachPoint=\"containerNode\" waiRole=\"alert\">\r\n\t\t\t\t\t\t<!-- the content pane-->\r\n\t\t\t\t\t</div>\r\n\t\t\t\t<div dojoAttachPoint=\"actionArea\" class=\"actionarea\" style=\"display:none;\">\r\n\t\t\t\t\t<div class=\"actionDivider \" ></div>\r\n\t\t\t\t\tActions\r\n\t\t\t\t</div>\r\n\t\t\t\t<div dojoAttachPoint=\"actionBar\" class=\"defaultarea\" style=\"display:none;\"></div>\r\n\t\t\t\t<div dojoAttachPoint=\"expandedActionBar\" class=\"expandarea\" style=\"display:none;\"></div>\r\n\t\t\t\t<div class=\"moretools\">\r\n\t\t\t\t\t<span style=\"display:none;\" class=\"moretools\"  dojoAttachPoint=\"moreTools\" dojoAttachEvent=\"click:_toggleExpand\" ></span>\r\n\t\t\t\t</div>\r\n\t\r\n<!--\t\t\t\t\r\n\t\t\t\t<div class=\"dijitTooltipConnector\" dojoAttachPoint='connector'></div>\r\n-->\r\n\t\t\t</div>\r\n\r\n\t\t</td>\r\n\t\t\t\t\r\n\t\t\t    <td class=\"middle-right-col\" dojoAttachPoint=\"middleRightColumn\">\r\n\t\t\t    \t<table class=\"middle-column-table\">\r\n\t\t\t    \t\t<tr class=\"fill-row\">\r\n\t\t\t    \t\t\t<td class=\"middle-right\" dojoAttachPoint=\"middleRight\"></td>\r\n\t\t\t    \t\t</tr>\r\n\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t<td class=\"middle-right-lower\" dojoAttachPoint=\"middleRightLower\"></td>\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t    \t</table>\r\n\t\t\t    \t\r\n\t\t\t    </td>\r\n\t\t\t  </tr>\r\n\t\t\t  <tr>\r\n\t\t\t    <td class=\"bottom-left\"></td>\r\n\t\t\t    <td class=\"bottom-center\"></td>\r\n\t\t\t    <td class=\"bottom-right\"></td>\r\n\t\t\t  </tr>\r\n\t</table>\t\t\t\r\n\t<div class=\"dijitTooltipConnector\" dojoAttachPoint='connector'></div>\r\n\t\r\n</div>\r\n\r\n\r\n\r\n",

	// i18nPackageName: String
	//		Defaults to the XWT package.
	i18nPackageName: "xwt",

	// i18nBundlerName: String
	//		Defaults to the XMPProperties bundle.
	i18nBundleName: "XMPProperties",

	// widget level messages.
	_messages: null,
	// baseClass: [protected] String
	//		The root className to use for the various states of this widget.
	baseClass: "dijitTooltipDialog quickview",

	// enableAnimation: boolean
	//	Indicates whether the QuickView panel should close if the user moves the mouse away from it for more than 700 ms. Not used.
	//	Default value: "false"
	enableAnimation: false,

	// progress indicator for the lazy-load QuickView
	pgball: null,
	// sideAlign : boolean
	//	Indicates whether the QuickView panel needs to be aligned horizontally with (that is, display on the right or left side of)
	//	its launch point. The default value is true, so the QuickView panel is normally aligned horizontally with the launch point.
	//	If set to false, it will try to align vertically, displaying itself below or above the launch point.
	sideAlign: true,

	// destroyOnClose : boolean
	//	Indicates whether the QuickView instance must be destroyed when it is closed or when its hide function is called.
	//	The default value is false, so QuickView will not be destroyed when it is hidden or closed.

	destroyOnClose: false,
	// The height of the QuickView when in the collapsed state (that is, the 'More Tools'
	// indicator is showing at the bottom-right corner). Default is 0.
	collapseHeight: 0,

	// The height of the QuickView when in the expanded state (that is, the 'Less Tools'
	// indicator is showing at the bottom-right corner). Default is 0.
	expandHeight: 0,
	// text string externalization for the "More Tools"
	moreToolsText: "",
	// text string externalization for the "Less Tools"
	lessToolsText: "",

	// onDownloadStartInitWidth number in pixel (500px)
	onDownloadStartInitWidth: "300",

	// onDownloadStartInitHeight number in pixel (250px)
	onDownloadStartInitHeight:"250",

	_isSideAlign:false,
	
	// fadeTime: [public] int
	//		The time to take to fade out the QuickView once the mouse leaves.
	//		Only takes effect if enableAnimation is set to true.
	fadeTime: 700,
	
	// clickOutsideClose: [protected] boolean
	//		Indicates if clicks outside the QuickView should trigger a close.
	_clickOutsideClose: true,
	
	// closeAllTopic: [const] String
	//		Private variable used to control a topic anyone can broadcast to,
	//		to close all open QuickViews.
	closeTopic: "xwt/widget/quickview/close",

	// detachTopic: [const] String
	//		Private variable used to control a topic anyone can broadcast to,
	//		to detach (remove the tail of) a QuickView.
	detachTopic: "xwt/widget/quickview/detach",
	
	displayActionCount :9,
	
	constructor: function(){
		// summary:
		//		Constructor to ensure that everything is instance local.
		this._qvCreatedWidgets = []; // Widgets to destroy on cleanup.
		this.actionItemList = this.actionItemList.slice(0);	
	},
	
	_toggleExpand: function(){
		// summary:
		//		Toggles the QuickView's Action items between the expanded state
		//		and the collapsed state. This function is called when a 
		//		QuickView has more than six Action items to display.
		var temp = dojo.style(this.expandedActionBar, "display");
		var qvA, qvB, qvCB, diffW;
		var newQv = {};

		if(temp == "none"){
			if(this.collapseHeight === 0){
				var tdHeight = dojo.marginBox(this.middleCenterColumn);
				this.collapseHeight = tdHeight.h;
			}
			qvB = dojo.marginBox(this.domNode);
			qvCB = dojo.marginBox(this.connector);

			dojo.style(this.expandedActionBar, "display", "");
			this.moreTools.innerHTML = this.lessToolsText;

			if(this.sideAlign && qvCB.l > 0){
					qvA = dojo.marginBox(this.domNode);
					if(qvB.w < qvA.w){
						diffW = qvA.w - qvB.w;
						newQv.l = qvA.l-diffW;
						dojo.marginBox(this.domNode, newQv);
					}
			}

			this.expandHeight = dojo.coords(this.contentAP).h;
			this._onExpand();
		}else{
			qvB = dojo.marginBox(this.domNode);
			qvCB = dojo.marginBox(this.connector);
			dojo.style(this.expandedActionBar, "display", "none");
			this.moreTools.innerHTML = this.moreToolsText;
			if(this.sideAlign && qvCB.l > 0){
					qvA = dojo.marginBox(this.domNode);
					if(qvB.w > qvA.w){
						diffW = qvB.w - qvA.w;
						newQv.l = qvA.l + diffW;
						dojo.marginBox(this.domNode, newQv);
					}
			}
			this.collapseHeight = dojo.coords(this.contentAP).h;
			this._onCollapse();
		}
	},
	
	setTooltipcontentareaSize: function(width, height){
		// summary:
		//		Sets the tooltip content area size.
		// width:
		//		The new width, as a string.
		// height:
		//		The new height, as a string
		var ttca = dojo.query("div.tooltipcontentarea", this.domNode)[0];
		if (ttca){
			width.replace("px", "");
			height.replace("px", "");
			var newMb = {w: width, h: height};
			dojo.marginBox(ttca, newMb);
		}
	    
	},
	
	postCreate: function(){
		// summary:
		//		Life cycle function for this widget.
		// description:
		//		Overriden widget life-cycle function. QuickView users must
		//		call it once *only* after the content area and action area are both set,
		//		and before the QuickView is shown.
		if (this.onDownloadStartInitWidth) {
			this.onDownloadStartInitWidth=this.onDownloadStartInitWidth.replace("px", "");
		}if (this.onDownloadStartInitHeight) {
			this.onDownloadStartInitHeight=this.onDownloadStartInitHeight.replace("px", "");
		}

	    dojo.place(this.domNode, dojo.body(), "last");
		if(this.href && dojo.trim(this.href).length !== 0){
			this.setTooltipcontentareaSize(this.onDownloadStartInitWidth, this.onDownloadStartInitHeight);
	    }
		
	    //this.connect auto-registers for cleanup.
	    this.connect(dojo.doc, "click", "checkBounds");
	    this.connect(this, "setContent", "customizedSetContentHandler");
	    
		// watch for 700 ms mouse-pointer outside the panel
		if(this.enableAnimation){
			this.connect(this.domNode, "onmouseenter", "onMouseEnter");
			this.connect(this.domNode, "onmouseleave", "onMouseLeave");
		}

		if(dojo.isIE <= 7){
			this.connect(this, 'show', function() {
				dojo.style(this.containerNode, "paddingLeft", "8px");
			});
		}
		
		this.skipUnderlay = true;
		
		// Link up a subscription to allow closing by someone just publishing 
		// to a topic.
		this._topics = [];
		this._topics.push(dojo.subscribe(this.closeTopic, dojo.hitch(this, function() { this.hide(); })));
		this._topics.push(dojo.subscribe(this.closeTopic + "/" + this.id, dojo.hitch(this, function() { this.hide(); })));
		this._topics.push(dojo.subscribe(this.detachTopic, dojo.hitch(this, function() { this.displayPointer(false); })));
		this._topics.push(dojo.subscribe(this.detachTopic + "/" + this.id, dojo.hitch(this, function() { this.displayPointer(false); })));
		this.inherited(arguments);
	},
	
	customizedSetContentHandler: function(){
		// summary:
		//		API hook for users to perform specialized functions after content is set. The application developer should overwrite this function.
		console.log("customizeSetContentHandler");
	},

	startup: function(){
		// summary:
		//		Life cycle function for this widget.
		// description:
		//		Overriden widget life-cycle function. QuickView users must
		//		call it once *only* after the content area and action area are both set,
		//		and before the QuickView is shown.
		if(!this._started){
			this._started = true;
			if(this.actionItemList.length !== 0){
				this.setActionItems();
			}
		}
	},

	setTitle: function(_newTitle){
		// summary:
		//		Sets the QuickView title.
		// description:
		//		Setter method for title of the QuickView.
		this.titleNode.innerHTML = _newTitle;
	},
	
	_setActionItemListAttr: function(ail){
		// summary:
		//		Sets the action items. This will
		//		rebuild the action item list before or after
		//		it has started.  This is a mapping function used
		//		by dijit.attr.
		if(this._started){
			this.setActionItems(ail);
		}else{
			this.actionItemList = ail;
		}
	},
	
	setActionItems: function(_actionItemsList){
		// summary:
		//		Sets the QuickView Action items.  Do not use
		//		this.attr('actionItemList', list); Use this method instead.
		// description:
		//		Setter method for action items in QuickView.  Each time this method
		//		is called the previous set of action items will be cleared.  You
		//		can invoke this method without setting an actionItemList parameter and
		//		it will use this.actionItemList.

		// Reset the state since we're resetting the action items.
		dojo.style(this.expandedActionBar, "display", "none");
		dojo.style(this.moreTools, "display", "none");
		this.moreTools.innerHTML = this.moreToolsText;
		
		if(_actionItemsList){
			this.actionItemList = _actionItemsList || [];
		}

		var totalActions = this.actionItemList.length;

		dojo.style(this.actionArea, "display", "block");
		if(totalActions > this.displayActionCount){
			dojo.style(this.moreTools, "display", "");
		}

		if(totalActions === 0){
			dojo.style(this.actionBar, "display", "none");
			dojo.style(this.moreTools, "display", "none");
			dojo.style(this.actionArea, "display", "none");
			//return;
		}

		this._restructure();
		//Size based off the content attach point, not the table.
		//var tdHeight = dojo.marginBox(this.middleCenterColumn);
		//this.collapseHeight = tdHeight.h;
		var cHeight = dojo.marginBox(this.contentAP);
		this.collapseHeight = cHeight.h;
		this._fixGradient(this.collapseHeight);
	},

	postMixInProperties: function(){
		// summary:
		//      Widget's life-cycle method. Called after all construction
		//      parameters have been added to this instance.
		// description:
		//      This method sets up the QuickView widget for internationalization
		//      and initializes the required attributes.
		// tags:
		//      extension

		// Prepares the widget for internationalization

		var i18mixin = new xwt.widget.i18nMixin();

		if(this.i18nPackageName && this.i18nBundleName){
			i18mixin.addBundle(this.i18nPackageName, this.i18nBundleName);
			this._messages = dojo.mixin(this._messages, i18mixin._messages);
			this._useI18 = true;
		}else{
			this._useI18 = false;
		}

		if(this._messages){
			if(this.moreToolsText === ""){
				this.moreToolsText = this._messages.qv_more_tools_text;
			}
			if(this.lessToolsText === ""){
				this.lessToolsText = this._messages.qv_less_tools_text;
			}
		}
		this.inherited(arguments);
	},

	_onExpand: function(){
		// summary:
		//		Internal event that fires when the QuickView is expanded.
		// tags:
		//		private
		if(this.expandHeight === 0){
			 var tdHeight = dojo.marginBox(this.middleCenterColumn);
			 this.expandHeight = tdHeight.h;
		}
		this._fixGradient(this.expandHeight);

	},

	_onCollapse: function(){
		// summary:
		//		Internal event that fires when the QuickView is collapsed.
		// tags:
		//		private
		this._fixGradient(this.collapseHeight);
	},

	onDownloadStart: function(){
		// summary:
		//		Called before download starts.
		// description:
		//		The string returned by this function will be the HTML
		//		that tells the user we are downloading something.
		//		Override with your own function if you want to change this text.
		// tags:
		//		extension
		//dojo.style(this.actionArea, "display", "block"); // don't display actionArea unless there is actionItem which is in setActionItem() 
		if(this.pgball === null ){
			this.pgball = new xwt.widget.layout.ProgressBall({
				ballSize:"extreme",
				targetId: this.decoratorWidget,
				position:"center",
				grabfocus: false
			});
		}
		this.pgball.isOpen = true;
		if(dojo.isFunction(this.onDownloadStartComplete)){
			this.onDownloadStartComplete();
		}
	},

	onDownloadEnd: function(){
		// summary:
		//		Called when a download is finished.
		// tags:
		//		callback
		if(this.pgball){
			this.pgball.isOpen=false;
			this.pgball.stop();
		}
		if(dojo.isFunction(this.onDownloadEndComplete)){
			this.onDownloadEndComplete();
		}
	},

	onShow:function(){
		// summary:
		//		Event invoked when the QuickView is displayed.
		// tags:
		//		callback..
		this.inherited(arguments);
		if(this.pgball && this.pgball.isOpen === true){
			this.pgball.isOpen=false;
			this.pgball.start();
		}
		setTimeout(dojo.hitch(this, function(){
			this._clickOutsideClose = true;
		}), 100);
	},

	_restructure: function(){
		// summary:
		//		Internal function that handles rebuilding the action area.
		// tags:
		//		private
		
		var len = this.actionItemList.length;
		
		// Clean up previous creates since we are rebuilding the 
		// list/buttons/etc.
		if(this._qvCreatedWidgets){
			dojo.forEach(this._qvCreatedWidgets, function(w){
				w.destroy();
				if(w.actionItem && w.actionItem.button === w){
					delete w.actionItem.button;
				}
			});
			this._qvCreatedWidgets = [];
		}
		
		if(len === 0){ return; }
		if(len < this.displayActionCount + 1 ){
			this._createActions(0, len, "div.defaultarea", "block");
		}else{
			this._createActions(0, this.displayActionCount, "div.defaultarea", "block");
			this._createActions(this.displayActionCount, len, "div.expandarea", "none");
		}
	},


	// xwt.widget.layout.BaseOverlay.js patch
	openAtNode: function(node, position){
		// summary:
		//		Shows the overlay with reference to the specified node.
		// node: String
		//		ID of the node used as reference node.
		// position: String[]
		//		TODO
		//
		// returns:
		//		null
		// tags:
		//		public
		
		if(this.isShowingNow){
			
		
			dojo.style(this.middleLeft, {
				"height": "0px"
			});

			dojo.style(this.middleRight, {
				"height": "0px"
			});

			dojo.style(this.middleLeftLower, {
				"height": "0px"
			});

			dojo.style(this.middleRightLower, {
				"height": "0px"
			});
			
		}
		if(this._positionInterval){
			clearInterval(this._positionInterval);
			delete this._positionInterval;
		}
		if(this._scrollConnect){
			dojo.disconnect(this._scrollConnect);
			delete this._scrollConnect;
		}
		
		if(this.isShowingNow){
			// It's already open, so we just need to 
			// reposition it.
			var align = {};
			var ltr = this.isLeftToRight();
			if(this.sideAlign){
				align[ltr ? "BR" : "BL"] = ltr ? "BL" : "BR";
				align[ltr ? "BL" : "BR"] = ltr ? "BR" : "BL";
			}else{
				align[ltr ? "BL" : "BR"] = ltr ? "TL" : "TR";
				align[ltr ? "BR" : "BL"] = ltr ? "TR" : "TL";
	
				align[ltr ? "TL" : "TR"] = ltr ? "BL" : "BR";
				align[ltr ? "TR" : "TL"] = ltr ? "BR" : "BL";
			}
			dijit.placeOnScreenAroundElement(this.domNode, 
				node, align, dojo.hitch(this, this.orient));
		}
		
		this._clickOutsideClose = false;
		
		var setClickTimer = false;
		if(this.isShowingNow){
			setClickTimer = true;
		}
		
		var eventChecks = dojo.hitch(this, function(){
			// summary:
			//		Internal function to handle checking for movement and scrolling.
			
			// Set up listeners for repositioning when target moves on us
			// Not super-efficient, but such is what it is.
			this._targetNode = node;
			this._positionInterval = setInterval(dojo.hitch(this, this._realign), 100);
			
			// Save states if we need to reposition due to resize/movement.
			this._nPos = dojo.position(node, true);
			this._aPos = dojo.position(this.tipNode, true);
			this._cPos = dojo.position(this.domNode, true);
			
			var n = node.parentNode;
			var scrollable = false;
			while(n && n !== dojo.body()){
				var tgName = n.tagName? n.tagName.toLowerCase(): "";
				if(tgName != "span" && (n.scrollWidth > n.clientWidth || n.scrollHeight > n.clientHeight)){
					var of = dojo.style(n, "overflow");
					var ofx = dojo.style(n, "overflowX");
					var ofy = dojo.style(n, "overflowY");
					if((of && of != "hidden") ||
						(ofx && ofx != "hidden") ||
						(ofy && ofy != "hidden")){	
						scrollable = true;
						break;
					}		
				}
				n = n.parentNode;
			}
			
			if(scrollable){
				this._scrollConnect = dojo.connect(n, "onscroll", this, function(){
					if(this._positionInterval){
						clearInterval(this._positionInterval);
						delete this._positionInterval;
					}
					this.displayPointer(false);
				});
			}
			
			if(setClickTimer){
				setTimeout(dojo.hitch(this, function(){
					this._clickOutsideClose = true;
				}), 100);
			}
		});				
		
		this._openedOnce=true;
		var buttonMb = dojo.position(node, true);
		var viewport = dijit.getViewport();
		//this._contentWidth = dojo.coords(this.decoratorWidget).w;
		if(this.sideAlign || this._isSideAlign){
			var right = viewport.w - buttonMb.x;
			if(right < this._contentWidth && right < buttonMb.x && buttonMb.x < this._contentWidth ){
				this.sideAlign = false;
				this._isSideAlign = true;
			}
			else{
				this.sideAlign = true;
			}
		}

		this.displayPointer(true);
		this.inherited(arguments);
		
		// Move the dropdown so that it centers  on the dropdown button.
		buttonMb = dojo.position(node, true);
		viewport = dijit.getViewport();
		buttonMb.t = buttonMb.y;
		buttonMb.l = buttonMb.x;
		var dropDownMb = dojo.position(this.domNode, true);
		var panelTop = 0;
		var pointerOffset = 0;

		if(this.sideAlign){
			if(this.href === ''){
				if(buttonMb.t !== 0){
					panelTop = (buttonMb.t + (buttonMb.h/2)) - (dropDownMb.h/2);
				}
				if(buttonMb.t === 0){
					panelTop = buttonMb.t + 5; // top
				}
			}else{
				panelTop = buttonMb.t - 50; // place abs wrt launch point
			}
			if(panelTop <= 0){
				panelTop = 5; // top
			}

			// check for bottom
			// should have enough space at bottom
			var temp = viewport.h - buttonMb.t;
			if(viewport.h < (panelTop + dropDownMb.h) && temp > 20){
				//console.debug('panel out of screen');
				var diffh = (panelTop + dropDownMb.h) - viewport.h;
				// take care of the last but one row in table -
				if(temp < 30){
					panelTop = panelTop - diffh + temp+9;
				}else{
					panelTop = panelTop - diffh;
				}
				this.domNode.style.top = panelTop + "px";
				this._alignPointer(buttonMb, panelTop);
				eventChecks();
				return;
			}

			this.domNode.style.top = panelTop + "px";

		}else{
			var centeredLeft = ((buttonMb.l + (buttonMb.w/2)) - (dropDownMb.w/2));
			this.minViewPortPadding = 10;
			if(centeredLeft < this.minViewPortPadding ){
				pointerOffset = (-1 * centeredLeft) + this.minViewPortPadding;
				centeredLeft = this.minViewPortPadding;
			}else if(centeredLeft + dropDownMb.w	> viewport.w ){
				var overflow = (centeredLeft + dropDownMb.w) - viewport.w + this.minViewPortPadding ;
				centeredLeft -= overflow ;
				pointerOffset = -overflow;
			}
			this.domNode.style.left = centeredLeft + "px";
		}

		/** end re-align code **/
	
		// Center the tooltip connector (arrow) on the popup.
		var results = dojo.query(".dijitTooltipConnector", this.domNode);
		if(results && results.length > 0){
			var connector = results[0];
			var mb2 = dojo.position(connector);
			if(mb2.w>0){
				var mbNew ={};
				if(this.sideAlign){
					if(panelTop != 5 && (this.href === '')){
						mbNew.t = (dropDownMb.h/2) - (mb2.h/2) ;
					}else if(this.href !== ''){
						// doesnt refresh the browser when downloading
						mbNew.t = (buttonMb.t)- panelTop;
					}else{
						mbNew.t = (buttonMb.t) - (mb2.h/2);
					}
	
				}else{
					mbNew.l = (dropDownMb.w/2) - (mb2.w/2) - pointerOffset ;
				}
				dojo.marginBox(connector, mbNew);
			}else{
				console.log("Connector width and height is zero");
			}
		}

		/* end arrow align */
		this._checkForContent();
		eventChecks();
	},

	_realign: function(){
		// summary:
		//		Function to realign the QuickView with the target node
		//		should it move.  Checked on interval.
		// tags:
		//		private
		if(this._targetNode && dojo.style(this.tipNode, "display") != "none"){
			var target = dojo.position(this._targetNode, true);	
			if(target.x == this._nPos.x && target.y == this._nPos.y){
				// Nothing moved.
				return;
			}else{
				// It moved, so we need to shift it.
				//if target was all 0, maybe the parent target doesnt exist anymore
				//true for table where the row being hovered on gets deleted -CSCto91637
				//in such a case, just remove the tail and dont move.
				if (!target ||(target.x <= 0 && target.y <= 0 && target.h <= 0 && target.w <= 0) ){
					this.displayPointer(false);
				}
				else {
					this.openAtNode(this._targetNode);
				}
			}
		}
	},

	_checkForContent: function(){
		/* ifcontent changed, call fix gradient */
		if(dojo.style(this.expandedActionBar, "display") == "none"){
			/*if(this.collapseHeight === 0) {
				var tdHeight = dojo.marginBox(this.middleCenterColumn);
				this.collapseHeight = tdHeight.h;
			}*/
			this.moreTools.innerHTML = this.moreToolsText;
			this.collapseHeight = dojo.marginBox(this.middleCenterColumn).h;
			this._fixGradient(this.collapseHeight);
		}else{
			this._fixGradient(this.expandHeight);
		}
	},

	_alignPointer: function(buttonMb, panelTop){
		// summary:
		//		Internal function to align the arrow with the target node.
		// buttonMb:
		//		The target node margin box.
		// panelTop:
		//		The top point of the panel, in pixels.
		// tags:
		//		private.
		var results = dojo.query(".dijitTooltipConnector", this.domNode);
		if(results && results.length > 0){
			var connector = results[0];
			var mb2 = dojo.marginBox(connector);
			mb2.t = (buttonMb.t)- panelTop;
			dojo.marginBox(connector, mb2);
		}
		this._checkForContent();
	},

	_createActions: function (start, end, attachpoint, visible){
		// summary:
		//		Creates the action item areas.
		// start: int
		//		Starting Index within the action items (start here).
		// end: int
		//		Ending Index in the action items (stop here).
		// attachpoint:
		//		DOMNode to which to append the action buttons.
		// visible: boolean
		//		Indicates whether the attach point area should be visible.
		// tags:
		//		private
		
		var actiongroup = dojo.query(attachpoint, this.domNode)[0];
		if(attachpoint == "div.defaultarea"){
			dojo.style(this.actionBar, "display", visible);
		}else if(attachpoint == "div.expandarea"){
			dojo.style(this.expandedActionBar, "display", visible);
		}

		dojo.attr(actiongroup, "align", "center");

		 //remove the existing table if any -
		var results = dojo.query("table.actiontable", actiongroup);
		if(results && results.length > 0){
			var i;
			for(i = 0; i < results.length; i++){
				var result = results[i];
				dojo._destroyElement(result);
			}
		}

		var table = dojo.create("table", {"class": "actiontable"});
		var tabbody = dojo.create("tbody", {"class": "mybody"});
			dojo.place(tabbody, table, "last");

		var curRow = '';
		var itemCount = 0;
		for(var j = start; j < end; j++ ){
			itemCount++;
			if((j+1) % 3 == 1){
				// create a new row in table
				var newRow = dojo.create("tr", {"class": "myrow"});
				dojo.place(newRow, tabbody, "last");
				curRow = newRow;
			}
			var tableData = dojo.create("td", {"class":"mydata"});
			dojo.place(tableData, curRow, "last");
			var data = this.actionItemList[j];
			var action = this._createAction(data);
			dojo.place(action.domNode, tableData, "last");
			
		
			// DE 1054 - start
			/*if( end === 8 && j === 7){
				end = 9;
				// create a dummy data
				var qvai00 = new xwt.widget.quickview.QuickViewActionItem( {
					iconClass : "dijitEditorIcon dijitEditorIconCut",
					labelText : 'Dummy',
					callback : function(){
						alert('Action should not have triggered');
					}
				});
				this.actionItemList.push(qvai00);
				this._qvCreatedWidgets.push(qvai00);
			}
			if(end === 9 && j === 8){
				dojo.style(action.domNode, 'visibility', 'hidden');
			}*/
			// DE 1054 - end -
		}
		if(itemCount==2){
			var tableData = dojo.create("td", {"class":"mydata"});
			dojo.place(tableData, curRow, "last");
		}
		dojo.place(table, actiongroup, "last");
	},

	_createAction: function (data){
		// summary:
		//		Creates buttons for actionItem events.
		// data:
		//		The action item data in the form of:
		//		{
		//			labelText: "someLabel",
		//			iconClass: "someClass",
		//			callback: someFunction,
		//			disable: boolean
		//		}
		var button1 = new dijit.form.Button({
			label: data.labelText,
			iconClass: data.iconClass,
			onClick: data.callback,
			disabled: data.disable,
			baseClass: "quickview"});
		dojo.addClass(button1.domNode, "actionAreaText");
		
		// Circular reference?
		data.button = button1;
		button1.actionItem=data;	
		this._qvCreatedWidgets.push(button1);
		return button1;
	},

	show: function(/*String*/innerHTML, /*DomNode*/aroundNode, /*String[]?*/position){
		// summary:
		//		Sets the height of the outer middle sections of the dialog container.
		// tags:
		//		extension
		
		//	------------Fix for CDETS: CSCtn04054-------
		//	See : https://support.sitepen.com/issues/20952
		//	problem is inherent to dijit popup manager

		xwtPopups.suspendPopups('9999');
		//  --------------------------------------------
		
		var align = {};
		var ltr = this.isLeftToRight();
		// is the dialog to be horizontally aligned?
		// show it
		dojo.removeClass(this.domNode, "dijitHidden");
		var pos;

		if(this.sideAlign){
			align[ltr ? "BR" : "BL"] = ltr ? "BL" : "BR";
			align[ltr ? "BL" : "BR"] = ltr ? "BR" : "BL";
		}else{
			align[ltr ? "BL" : "BR"] = ltr ? "TL" : "TR";
			align[ltr ? "BR" : "BL"] = ltr ? "TR" : "TL";

			align[ltr ? "TL" : "TR"] = ltr ? "BL" : "BR";
			align[ltr ? "TR" : "TL"] = ltr ? "BR" : "BL";
		}

		pos = dijit.placeOnScreenAroundElement(
				this.domNode, aroundNode, align, dojo.hitch(
						this, this.orient));

		this.positionX = pos.x;
		this.positionY = pos.y;

		//console.log(this.positionX);
		//console.log(this.positionY);

		// IE6 - do this early, before animation starts
		this._fixTipNodeArrow();

		if(this.animationIn.type == "fade"){
			dojo.style(this.domNode, "opacity", 0);
			 var fadeArgs = {
					 node: this.domNode,
					 duration: 300
					 };
			 dojo.fadeIn(fadeArgs).play();
			this.animationIn.play();
		}else if(this.animationIn.type == "wipe"){
			dojo.style(this.domNode, "height", "1px");
			this.animationIn.play();
		}
		this.isShowingNow = true;
		this.aroundNode = aroundNode;
		// call some cleanup routines
		this._onRendered();

		var _tdHeight = dojo.marginBox(this.middleCenterColumn);
		this._fixGradient(_tdHeight.h);

		if(!this._contentWidth){
			this._contentWidth = dojo.coords(this.decoratorWidget).w;

			// CDETS:  CSCtn10908.  Setting the minWidth to 50px.
//			dojo.style(this.decoratorWidget, {
//				"minWidth": this._contentWidth+"px"
//			});
			
			dojo.style(this.decoratorWidget, {
				"minWidth": "50px"
			});
			
			// for IE7 table minWidth/min-width wont work,
			// so set the minWidth on the parent div
			if(dojo.isIE == 7){
				var top_div = dojo.query('div.dijitTooltip')[0];
				
				// CDETS:  CSCtn10908.  Setting the minWidth to 50px.
//				dojo.style(top_div, {
//					"minWidth": this._contentWidth+"px"
//				});
				
				dojo.style(top_div, {
					"minWidth": "50px"
				});
				
			}
		}
		// zindex
		this.hookZIndex();
	},
	
	displayPointer: function(display){
		// summary:
		//		Function to display or hide the QuickView pointer It acts as a 'detach', basically.
		// display: Boolean
		//		Indicates whether the pointer should be visible or not.
		if(!display){
			dojo.style(this.tipNode, "display", "none");
		}else{
			dojo.style(this.tipNode, "display", "");
		}
	},

	_fixGradient: function(_height){
		// summary:
		//		Internal function to adjust the height so the gradient lines align
		//		properly.
		// _height: int
		//		The height of the QuickView area.
		// tags:
		//		private
		
		//var tdHeight = dojo.coords(this.middleLeftColumn);
		//console.debug('height: ' + _height);

		// The constant int 85 is the height of the left and right images used
		//	for the border and drop shadow.  These images contain the extent
		//	of the vertical gradient.  The remaining height of the dialog is
		//	white and a separate image is used (of height 1), repeating on the
		//	y axis.  The dialog is a 4 row x 3 column table to achieve the
		//	rounded	corners and gradient effect.
		var height;
		if(_height > 200){
			height = _height - 200;

			dojo.style(this.middleLeft, {
				"height": height + "px"
			});

			dojo.style(this.middleRight, {
				"height": height + "px"
			});

			dojo.style(this.middleLeftLower, {
				"height": "200px"
			});

			dojo.style(this.middleRightLower, {
				"height": "200px"
			});
		}else{
			height = (_height>0)? _height: 0;  //check 0 bound for IE8 from you. CSCtn54010 - IE8- QV hint-Hovering over it second time does not instantiate QV
			dojo.style(this.middleLeft, {
				"height": "0px"
			});

			dojo.style(this.middleRight, {
				"height": "0px"
			});

			dojo.style(this.middleLeftLower, {
				"height": height + "px"
			});

			dojo.style(this.middleRightLower, {
				"height": height + "px"
			});
		}
	},

	close: function (evt){
		//
		// summary:
		//		Calls the hide on the overlay.
		//	evt: TODO
		//
		// returns:
		//		null
		// tags:
		//		public
		
		//	------------Fix for CDETS: CSCtn04054-------
		if(this.isShowingNow){
			xwtPopups.restorePopups();
		}
		//	--------------------------------------------
		
		this.hide(evt);
	},

	_positionTipNode: function(refNode){
		// summary:
		//		This function used to rely on this._isHorizontalAlignment, which is
		//		never set true in QuickView, so does not need to do much at all.
		dojo.style(this.tipNode, "top", "");
	},

	// if there are any tweaks needed to position the arrow do it here..
	_fixTipNodeArrow: function(){
		// summary:
		//		Tweaks the arrow position when needed.
		//		This is a private point where fixes can be implemented.
		// tags:
		//		private
		var contentTableInsideWrappedWidget = this.containerNode;
		var containerPos = dojo.position(contentTableInsideWrappedWidget);

		// IE6 needs lots of help here..
		if(dojo.isIE <= 6){
			// clear old arrow and fix arrow image for IE6
			this._recreateIE6PNG(this.tipNode);
		}
		
		// fix the up arrow
		if(dojo.hasClass(this.domNode, "dijitTooltipBelow")){
			dojo.style(this.tipNode, "top", -12);
		}
		// fix the down arrow
		if(dojo.hasClass(this.domNode, "dijitTooltipAbove")){
			dojo.style(this.tipNode,"top", (containerPos.h + -3 ));
		}
		dojo.style(this.tipNode,"left","");
	},

	// close if clicked outside qv
	checkBounds: function(evt){
		// summary:
		//		Close if the user clicks outside of the widget.
		// evt: event
		//		The Javascript event that triggered the need for a bounds check.
		// returns:
		//		null
		// tags:
		//		public
		if(this._clickOutsideClose && evt && !dojo.isDescendant(evt.target, this.decoratorWidget)){
			this.close(evt);
		}
	},

	onMouseLeave: function(){
		// summary:
		//		General event callback.
		this._timer = setTimeout(dojo.hitch(this, function() {
				this.hide();
				delete this._timer;
		}), this.fadeTime);
	},

	onMouseEnter: function(){
		// summary:
		//		General event callback.
		if(this._timer){
			clearTimeout(this._timer);
			delete this._timer;
		}
	},

	onDestroy: function(){
		// summary:
		//		This method provides the default behavior for destroying the QuickView and its
		//		DOM node when its hide function is called. The function checks for the 'destroyOnClose'
		//		flag and, if that is set to true, destroys the QuickView instance. Subclasses can
		//		override to implement special behavior if required.
		if(!this.destroyOnClose){
			//console.log("destroyOnClose"+this.id);
			return;
		}
		if(this._openedOnce){
			this.destroy();
		}
	},

	destroy: function(){
		// summary:
		//		Overwrite destroy method.
		// Description:
		//		Clean up anything we allocated ourselves.
		if(this.pgball){
			this.pgball.destroy();
		}
		if(this._scrollConnect){
			dojo.disconnect(this._scrollConnect);
			delete this._scrollConnect;
		}
		if(this._targetNode){
			delete this._targetNode;
		}
		if(this._positionInterval){
			clearInterval(this._positionInterval);
			delete this._positionInterval;
		}
		if(this._qvCreatedWidgets){
			dojo.forEach(this._qvCreatedWidgets, function(w){
				w.destroy();
				if(w.actionItem && w.actionItem.button === w){
					delete w.actionItem.button;
				}
			});
			delete this._qvCreatedWidgets;
		}
		dojo.forEach(this._topics, function(t){
			dojo.unsubscribe(t);
		});
		delete this._topics;
		this.destroyRecursive();
		this.inherited(arguments);
	},

	hide: function(evt){
		// summary:
		//		Calls the widget's hide function
		//		and then calls on destroy.
		// evt:
		//		The event that triggered the hide.
		//		Can be null/undefined.
		if(this.pgball){
			this.pgball.isOpen=false;
			this.pgball.stop();
		}
		if(this._positionTimer){
			clearTimeout(this._positionTimer);
			delete this._positionTimer;
		}
		if(this._scrollConnect){
			dojo.disconnect(this._scrollConnect);
			delete this._scrollConnect;
		}
		if(this._targetNode){
			delete this._targetNode;
		}
		this.inherited(arguments);
		this.onDestroy();
	},

	_onHide: function(){
		// summary:
		//		Called at the end of fade-out operation.
		// tags:
		//		protected
		// this.domNode.style.cssText=""; // to position offscreen
		// again
		if(this.domNode){
			dojo.addClass(this.domNode, "dijitHidden");
		}

		// dismiss the modal underlay
		if(this.isModal){
			this.underlay.hide();
		}

		if(this._onDeck){
			// a show request has been queued up; do it now
			this.show.apply(this, this._onDeck);
			this._onDeck = null;
		}
		// call custom client handler...
		this.onHide();
	}
});

dojo.declare("xwt.widget.quickview.QuickViewActionItem", [dijit._Widget], {
	widgetsInTemplate: false,
	iconClass: "",
	labelText: "",
	disable: false,
	callback: function(){
		/* override */
		 alert(this.id);
	},
	destroy:function(){
		// summary:
		//		Overwrite destroy method.
		// Description:
		//		Destroys the internal dijit.Button to release memory.
		if(this.button){
			//console.log("destoy() " + this.button);
			this.button.destroy();
		}
		this.inherited(arguments);
	}
});

}

if(!dojo._hasResource["xwt.widget.table.QuickView"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.table.QuickView"] = true;
/* ************************************************** */
/* Copyright (c) 2009-2011 Cisco Systems, Inc.       */
/* All rights reserved.                               */
/* ************************************************** */

dojo.provide("xwt.widget.table.QuickView");


/*=====
xwt.widget.table.QuickView.__ctorProps = function(widget, onEvent, delay){
	//	summary:
	//		The kwArgs object to be passed to the start method of QuickView.
	//	widget: xwt.widget.quickview.QuickView
	//		The Quick View widget to be used.
	//	onEvent: String?
	//		The event on which this is to be shown.  Should be either "onHover" or "onClick";
	//		"onHover" is the default.
	//	delay: Number?
	//		The amount of time, in milliseconds, to wait before showing the QuickView.
	this.widget = widget;
	this.onEvent = onEvent;
	this.delay = delay;
}
=====*/

xwt.widget.table.QuickView = {
	//	summary:
	//		A QuickView component for a Table.  Like other.Table, this
	//		constructor should be applied directly to a Table.
	//	description:
	//		This pseudo-class (not intended to be instantiated directly) is applied
	//		to an existing xwt.widget.table.Table to add in QuickView capabilities.
	//		As such, it is treated as a "mixin" to a Table.
	//
	//		A reference to the actual widget that displays/formats information in a
	//		QuickView "tooltip" should be passed to the constructor of this function.
	//
	//	example:
	//		Set up a Table for QuickView capabilities:
	//	|	xwt.widget.table.QuickView.apply(myTable, myViewingWidget, hotspot);
	//
	//	_showOn: String
	//		The switch to determine what event will be used to show a QuickView of a row. Options
	//		are "onClick" and "onHover"; "onHover" is the default.
	//	_viewer: dijit._Widget
	//		The actual balloon/tooltip widget that will be shown over a row when the hotspot
	//		is hovered on or clicked on.

	_showOn: "onHover",
	_viewer: null,
	_delay: 0,

	item: null,
	
	
	// quickViewHoverDelay: [public] int
	//		Time in milliseconds that a mouse needs to remain motionless on the
	//		hover hint icon before the QuickView is opened.
	quickViewHoverDisplayDelay: 500,
	
	_qvGetRowFromTarget: function(evt){
		// summary:
		//		Internal function that retrieves the row node from
		//		the target and processes all its cells for QuickView hint
		//		display.
		// evt: Event
		//		The event to inspect.
		// returns:
		//		The row table node.
		if(evt && evt.target){
			var node = evt.target;
			while(node && node != this.tableBody && !dojo.hasClass(node, "row")){
				node = node.parentNode;
			}
			if(node && dojo.hasClass(node, "row")){
				return node;
			}
		}
		return null;
	},
	
	_qvGetCellFromTarget: function(evt){
		// summary:
		//		Internal function that retrieves the cell container node from
		//		the target so we can extract column index and other information.
		// evt: Event
		//		The event to inspect.
		// returns:
		//		The cell container table node.
		if(evt && evt.target){
			var node = evt.target;
			while(node && node != this.tableBody && !dojo.hasClass(node, "cell-container")){
				node = node.parentNode;
			}
			if(node && dojo.hasClass(node, "cell-container")){
				return node;
			}
		}
		return null;
	},
	
	__onmousemove: function(evt){
		// summary:
		//		Event handler for mouse movement within the table.
		// evt: Event
		//		The browser move event.
		// tags:
		//		private.
		//if(this._viewer.isShowingNow){ return; }

		if(this.__qvDismissClick){
			// In the middle of rebuilding stuff, so ignore click
			// triggered onmousemoves.
			return;
		}
		
		var row = this._qvGetRowFromTarget(evt);
		if(!row){ return; }	
		if(this.__isQVLoading){ return; }
				
		var rowNum = dojo.attr(row, 'rowIndex');
		if(this.__qvRowNum === rowNum) { return; }
		
		// Moved rows, so get rid of the last anchor, only really want it 
		//for display.load check on move of current anchor/row.
		delete this.__lastQVAnchor;
		
		// Clean up any old ones.
		this.__cleanupQVHint();

		// Time to build new ones by checking all the cells and adding
		// hints to cells that indicate they are valid.
		this.__qvRow = row;
		this.__qvRowNum = rowNum;
		if(!dojo.hasClass(row, "row-locked") || !dojo.hasClass(row.parentNode, "page")){
			// Allow QV on locked rows in the lock area.
			var cells = dojo.query(".cell." + this._uniqueCssId, row);
			dojo.forEach(cells, function(cell){
				this._checkAndAddQV(row, cell);
			}, this);
		}else{
			this.__qvRowNum = -1;
			this.__qvRow = null;
		}
		return;
	},
	
	__onmouseleave: function(){
		// summary:
		//		Cleans up QuickView hints on leaving a row, etc.
		// tags:
		//		private
		if(this._viewer.isShowingNow){ return; }
		if(this.__isQVLoading){ return; }
		this.__cleanupQVHint();
		this.__qvRowNum = -1;
		this.__qvRow = null;
		this.item = null;
	},

	__cleanupQVHint: function() {
		// summary:
		//		Cleans up previous QuickView displays.
		//		This function will preserve an anchor node if a QuickView is open and pointing to it.
		// tags:
		//		private.
		if(this.__isQVLoading){ return; }
		if(this._qvDisplayTimer){
			clearTimeout(this._qvDisplayTimer);
			delete this._qvDisplayTimer;
		}
		var newQVAnchors = [];
		dojo.forEach(this._qvAnchors, function(c){
			if(c.node != this.__qvActiveAnchor){
				var l = c.connects;
				dojo.forEach(l, function(cc){
					dojo.disconnect(cc);
				});
				dojo.destroy(c.node);
			}else{
				newQVAnchors.push(c);
			}
		}, this);
		this._qvAnchors = newQVAnchors;
	},
	
	openQVFromHint: function(evt) {
		// summary:
		//		Opens a QuickView when a hint is hovered over.
		// evt:
		//		The hover event to activate the QuickView.
		
		// Already displaying this particular QuickView, so just return.
		if(evt && evt.target && this.__qvActiveAnchor == evt.target && this._viewer.isShowingNow) { return; }
		
		var curcell = 0;
		var cellNode = this._qvGetCellFromTarget(evt);
		if(cellNode){
			curcell = dojo.attr(cellNode, "columnIdx");
			if(curcell != null){
				curcell = parseInt(curcell, 10);
			}
		}
		
		// If we're mouse-overing the last cell still, don't reprocess/reset timer.
		//if(this.__qvCell != null && curcell == this.__qvCell) { return; }
		
		// We're in the middle of a load, skip this.
		if(this.__isQVLoading){ return; }
		
		// The item has vanished, so don't open.
		if(!this.item){ return; }
		
		// We need to hault the movemove event so it doesn't
		// flow up.
		dojo.stopEvent(evt);
		
		// Let's try to open only roughly over the image,
		// which is a 12x12 centered area, more or less.
		var box = dojo.position(evt.target);
		var cBox = { min: (box.h/2) - 6, max: (box.h/2) + 6};
		var yPos = evt.layerY;
		if(yPos < cBox.min || yPos > cBox.max){
			// Outside the 'image' area, so just ignore it.
			// Clear the last anchor since we technically left the target.
			// Painful.
			if(this.__lastQVAnchor){
				delete this.__lastQVAnchor;
			}
			return;
		}
		
		// Test to see if we just moved on an anchor we last clicked on.		
		if(this.__lastQVAnchor && !this._viewer.isShowingNow){
			if(this.__lastQVAnchor.indexOf("qvCell-" + curcell) >= 0 && this.__lastQVAnchor.indexOf("qvRow-" + this.__qvRowNum) >= 0){
				return;
			}
		}	
		
		if(this._qvDisplayTimer){
			clearTimeout(this._qvDisplayTimer);
			delete this._qvDisplayTimer;
		}
		
		this._qvDisplayTimer = setTimeout(dojo.hitch(this, function(){	
			
			var displayer = dojo.hitch(this, function(){
				var launchAnchor = evt.target; 
				this.__qvActiveAnchor = launchAnchor;
				
				
				var attrs = this.store.getAttributes(this.item), values = {};
				dojo.forEach(attrs, function(attr){
					values[attr] = this.store.getValue(this.item, attr);
				}, this);
		
				var lc = dojo.connect(this._viewer, "onShow", this, function(){
					dojo.disconnect(lc);
					delete this.__isQVLoading;
				});
				//this._viewer.setValues(values, curcell);
				this._viewer.openAtNode(launchAnchor);
				
				var cellAttr = null;
				var columns = this.getColumns();
				if(columns){
					var col = columns.get(curcell);
					if(col){
						cellAttr = col.attr;
					}
 				}
				
				// Start it on a delay to give the QuickView a little time to open and get width/height.
				setTimeout(dojo.hitch(this, function() { 
					this._viewer.setValues(values, curcell, cellAttr);
					var tdHeight = dojo.marginBox(this._viewer.contentAP);
					this._viewer.collapseHeight = tdHeight.h;
					this._viewer._fixGradient(this._viewer.collapseHeight);
					this._viewer.openAtNode(launchAnchor);
					this.__lastQVAnchor = launchAnchor.className;
				}), 10);
				this.onShowQuickView(this.item);
				this._viewer.isShowingNow = true;
			});
			if(this._viewer.isShowingNow){
				this.__isQVLoading = true;
				var con = dojo.connect(this._viewer, "onHide", this, function(){
					dojo.disconnect(con);
					displayer();
					delete this._movingQuickView;
				});
				this._movingQuickView = true;
				if(this.__qvActiveAnchor){
					// We moved anchors, so go ahead and delete the anchor in use
					// so that it moves clean.
					var row = this._qvGetRowFromTarget({target: this.__qvActiveAnchor});
					if(!row || dojo.attr(row, "rowindex") != this.__qvRowNum){
						dojo.destroy(this.__qvActiveAnchor);
					}
					this.__qvActiveAnchor = evt.target;
				}
				this._viewer.hide(); 
			}else{
				this.__isQVLoading = true;
				displayer();
			}
		}), this.quickViewHoverDisplayDelay);
	},

	__getItemFromTarget: function(row){
		// summary:
		//		Obtains the item from the row hovered.
		// row: DOMNode
		//		The row hovered.
		// tags:
		//		private.
		var id = dojo.attr(row, "item-id");
		if(id){		
			// If a sort/rerender occurred, we need to also check 
			// locked items for the id, on the off chance it isn't in
			// the id to item map now.  It would still be in the locked
			// items cache. - CSCtq00255
			return this._idToItem[id] || this._lockedItems[id];
		}
		return;
	},

	__onrowclick: function(evt){
		// summary:
		//		Handles showing of QuickView on a click instead of mouse 
		//		hovering.  Just calls the same function used for hover.
		// tags:
		//		private.
		if(evt.target && dojo.hasClass(evt.target, "xwtQVHintHover")){
			var box = dojo.position(evt.target);
			var cBox = { min: (box.h/2) - 6, max: (box.h/2) + 6};
			var yPos = evt.layerY;
			if(yPos < cBox.min || yPos > cBox.max){
				// Outside the 'image' area, so just ignore it.
				this.__onmousemove(evt);
			}else if(!this.__isQVLoading){
				// Actually need to show it
				if(this._qvDisplayTimer){
					clearTimeout(this._qvDisplayTimer);
					delete this._qvDisplayTimer;
				}
				
				if(this._viewer.isShowingNow && this.__qvActiveAnchor == evt.target && !this.__isQVLoading){
					// Already showing, so a click should just close it, and make sure
					// the anchors stay by reloading them onto the __lastRow, if any.
					this.__lastQVAnchor = evt.target.className;
					this.__qvDismissClick = true;

					setTimeout(dojo.hitch(this, function(){
						var row = this.__qvRow || this.__lastRow;
						
						if(!row) { return; }

						var rowNum = dojo.attr(row, 'rowIndex');
						// Clean up any old ones.
						this.__cleanupQVHint();
				
						// Time to build new ones by checking all the cells and adding
						// hints to cells that indicate they are valid.
						this.__qvRow = row;
						this.__qvRowNum = rowNum;
						if(!dojo.hasClass(row, "row-locked") || !dojo.hasClass(row.parentNode, "page")){
							// Allow QV on locked rows in the lock area.
							var cells = dojo.query(".cell." + this._uniqueCssId, row);
							dojo.forEach(cells, function(cell){
								this._checkAndAddQV(row, cell);
							}, this);
							
						}else{
							this.__qvRowNum = -1;
							this.__qvRow = null;
						}
						
						// Make sure our flags are gone. 
						delete this.__qvDismissClick;
					}),0);
					delete this.__isQVLoading;
					return;
				}

				var displayer = dojo.hitch(this, function(){
					var launchAnchor = evt.target; 
					this.__qvActiveAnchor = launchAnchor;
					
					curcell = 0;
					var cellNode = this._qvGetCellFromTarget(evt);
					if(cellNode){
						curcell = dojo.attr(cellNode, "columnIdx");
						if(curcell != null){
							curcell = parseInt(curcell, 10);
						}
					}
					var attrs = this.store.getAttributes(this.item), values = {};
					dojo.forEach(attrs, function(attr){
						values[attr] = this.store.getValue(this.item, attr);
					}, this);
			
					var lc = dojo.connect(this._viewer, "onShow", this, function(){
						dojo.disconnect(lc);
						delete this.__isQVLoading;
					});
					//this._viewer.setValues(values, curcell);
					this._viewer.openAtNode(launchAnchor);
					
					// Also generate the attribute of the cell.
					var cellAttr = null;
					var columns = this.getColumns();
					if(columns){
						var col = columns.get(curcell);
						if(col){
							cellAttr = col.attr;
						}
					}
					
					// Start it on a delay to give the QuickView a little time to open and get width/height.
					setTimeout(dojo.hitch(this, function() { 
						this._viewer.setValues(values, curcell, cellAttr);
						var tdHeight = dojo.marginBox(this._viewer.contentAP);
						this._viewer.collapseHeight = tdHeight.h;
						this._viewer._fixGradient(this._viewer.collapseHeight);
						this._viewer.openAtNode(launchAnchor);
						this.__lastQVAnchor = launchAnchor.className;
					}), 10);
					this.onShowQuickView(this.item);
					this._viewer.isShowingNow = true;
				});
				
				if(this._viewer.isShowingNow){
					this.__isQVLoading = true;
					var con = dojo.connect(this._viewer, "onHide", this, function(){
						dojo.disconnect(con);
						displayer();
						delete this._movingQuickView;
					});
					this._movingQuickView = true;
					if(this.__qvActiveAnchor){
						// We moved anchors, so go ahead and delete the anchor in use
						// so that it moves clean.
						var row = this._qvGetRowFromTarget({target: this.__qvActiveAnchor});
						if(!row || dojo.attr(row, "rowindex") != this.__qvRowNum){
							dojo.destroy(this.__qvActiveAnchor);
						}
						this.__qvActiveAnchor = evt.target;
					}
					this._viewer.hide(); 
				}else{
					this.__isQVLoading = true;
					displayer();
				}
			}
		}else{
			this.__onmousemove(evt);
		}
	},

	_checkAndAddQV: function(/* Node */row, /* Node */ cell){
		// summary:
		//		Tests whether or not the QuickView hover hint
		//		should be added to a particular cell.
		// row: DOMNode
		//		The table row hovered on.
		// cell: DOMNode
		//		The table cell to check for QuickView support.
		// tags:
		//		private.
		if(!row && !cell){ return; }
		this.showQuickView(this.__getItemFromTarget(row), cell);
	},

	start: function(props){
		//	summary:
		//		Apply ourselves to the corresponding Table widget and set up the QuickView
		//		capabilities.
		//	props: xwt.widget.table.QuickView.__ctorProps
		//		The kwArgs object that defines the three parameters needed.
		dojo.mixin(this, xwt.widget.table.QuickView);
		this._viewer = props && props.widget || null;
		this._showOn = props && props.onEvent || this._showOn;
		this._delay = props && props.delay || this._delay;
		this.quickViewHoverDisplayDelay = ("quickViewHoverDisplayDelay" in props ? props.quickViewHoverDisplayDelay : this.quickViewHoverDisplayDelay);
		if(this._viewer){
			this.connect(this._viewer, "hide", "hideQuickView");
			this.connect(this.tableBody, "onclick", "__onrowclick");
			this.connect(this.tableRowTopContainer, "onclick", "__onrowclick");
			this.connect(this.tableRowBottomContainer, "onclick", "__onrowclick");
			this.connect(this.tableBody, "onmousemove", "__onmousemove");
			this.connect(this.tableBody, "onmouseleave", "__onmouseleave");
			this.connect(this.tableRowTopContainer, "onmousemove", "__onmousemove");
			this.connect(this.tableRowTopContainer, "onmouseleave", "__onmouseleave");
			this.connect(this.tableRowBottomContainer, "onmousemove", "__onmousemove");
			this.connect(this.tableRowBottomContainer, "onmouseleave", "__onmouseleave");
			this.connect(this._viewer, "onHide", function(){
				delete this.__isQVLoading;
			});

			// Hm, do I need to do this?
			this.connect(this._viewer, "displayPointer", function(display) {
				this.clearAnchor(!display);
			});
		}
		
		// Hook up an event that fires when table is destroyed to 
		// Ensure the QuickView events are cleaned up.
		var cleanup = dojo.connect(this, "destroy", function(){
			dojo.disconnect(cleanup);
			delete this.__qvActiveAnchor;
			delete this.__lastRow;
			delete this.__isQVLoading;
			delete this.__lastShownAnchor;
			this.__cleanupQVHint();
			dojo.forEach(this.actionItemList, function(widget){
				if(widget.destroy){
					widget.destroy();
				}
			});
		});
		
		// Anchors and events we clean up as we move 
		// from row to row.
		this._qvAnchors = [];
	},
	
	clearAnchor: function(clear){
		// summary:
		//		Clears the anchor if the
		//		table scrolls and the pointer is hidden.
		if(!clear) { return ; }
		var newQVAnchors = [];		
		dojo.forEach(this._qvAnchors, function(c){
			if(c.node == this.__qvActiveAnchor){
				var l = c.connects;
				dojo.forEach(l, function(cc){
					dojo.disconnect(cc);
				});
				dojo.destroy(c.node);
			}else{
				newQVAnchors.push(c);
			}
		}, this);
		this._qvAnchors = newQVAnchors;
	},

	showQuickView: function(item, cell){
		//	summary:
		//		Sets our internal viewing widget's values to the specified item and shows it over the table.
		//	item: dojo.data.Item
		//		The item to be used to fill out the data in the QuickView widget.
		//	cell:
		//		The table cell hovered over.
		//	returns:
		//		"this" to allow for function chaining.

		// Already showing, so ignore.
		// if(this._viewer.isShowingNow){ return this; }
		if(!item || !cell ){ return this; }

		if(cell && this._viewer){
			if(this.onEdit && !this.__qvEditBound){
				// If we're swapping to edit, close the QuickView if it is open.
				// Solves issue with click in table to edit not always closing the QuickView.
				// Bind here as the table is fully initialized at this point.
				this.__qvEditBound = true;
				this.connect(this, "onEdit", "_hideQuickView");
			}

			if(cell.parentNode && dojo.hasClass(cell.parentNode, "cell-container")){
				var attrs = this.store.getAttributes(item), values = {};
				dojo.forEach(attrs, function(attr){
					values[attr] = this.store.getValue(item, attr);
				}, this);
				var cellNum = dojo.attr(cell.parentNode,"columnidx");
				
				var cellAttr = null;
				var columns = this.getColumns();
				if(columns){
					var col = columns.get(cellNum);
					if(col){
						cellAttr = col.attr;
					}
				}
				if(this.showQVHint(values, cellNum, cellAttr)) {
					var hhNode = dojo.query(".xwtQVHintHover", cell)[0];
					if(!hhNode || hhNode != this.__qvActiveAnchor){
						if(hhNode){
							dojo.destroy(hhNode);
						}
						var anchor = dojo.create("span", { "class": "xwtQVHintHover"});
						// Store the anchor row/num.  We'll need it later.
						dojo.addClass(anchor, "qvCell-" + cellNum);
						dojo.addClass(anchor, "qvRow-" + this.__qvRowNum);
						dojo.place(anchor, cell); 
						this.item = item;
						var nInfo = {
							node: anchor,
							connects: []
						};
						nInfo.connects.push(dojo.connect(anchor, "onmousemove", this, "openQVFromHint"));
						nInfo.connects.push(dojo.connect(anchor, "onmouseleave", this, "_onQVHintLeave"));
						this._qvAnchors.push(nInfo);
					}
				}
			}
		}
		return this;
	},
	
	_onQVHintLeave: function(evt){
		// summary:
		//		Simple event handler to clear off the delay hook
		//		if present.
		if(this._qvDisplayTimer){
			clearTimeout(this._qvDisplayTimer);
			delete this._qvDisplayTimer;
		}
		// We're mouse-outing, so we don't want this ref to stay
		// as its purpose is to prevent mousemoves on the last anchor
		// shown from redisplaying it.
		if(this.__lastQVAnchor){
			delete this.__lastQVAnchor;
		}
	},

	_hideQuickView: function() {
		// summary:
		//		Forces a close of the QuickView.
		//		This function, by proxy of the call to hide, calls the public
		//		hideQuickView.
		// tags:
		//		private.
		if(this._viewer.isShowingNow){ 
			this._viewer.hide();
		}
	},
	
	hideQuickView: function(){
		//	summary:
		//		Hide the QuickView widget.
		//	returns:
		//		"this" to allow for function chaining.
		this.onHideQuickView();
		if(!this._movingQuickView){
			delete this.__qvActiveAnchor;
			this.__cleanupQVHint();
		}
		this.__lastRow = this.__qvRow || this.__lastRow;
		this.__qvRowNum = -1;
		this.__qvRow = null;
		return this;
	},

	onShowQuickView: function(item){
		//	summary:
		//		Event stub called when a QuickView widget is shown.
		//	item:
		//		The dojo data item that data was extracted from and put in the QuickView.
		//	tags:
		//		callback
	},
	onHideQuickView: function(){
		//	summary:
		//		Event stub called when a QuickView widget is hidden.
		//	tags:
		//		callback
	}
};

}

if(!dojo._hasResource["xwt.widget.table.LoadingIndicator"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.table.LoadingIndicator"] = true;
/* ************************************************** */
/* Copyright (c) 2010-2011  Cisco Systems, Inc.            */
/* All rights reserved.                               */
/* ************************************************** */

dojo.provide("xwt.widget.table.LoadingIndicator");






dojo.declare("xwt.widget.table.LoadingIndicator", [dijit._Widget, dijit._Templated], {
	// summary:
	//	This is a simple loading indicator widget intended to float at the 
	//	top/left viewport location when displayed.
	// templateString: [protected] String
	//	The template to use for the progress indicator.
	templateString: dojo.cache("xwt.widget.table", "templates/LoadingIndicator.html", "<div class=\"xwtTableLoadingIndicator\"><div class=\"xwtTableLoadingIndicatorVisibleContainer\"><table><tbody><tr><td><div class=\"xwtTableLoadingIndicatorImage\"></div></td><td><span class=\"xwtTableLoadingIndicatorText\">${loadingMessage}</span></td></tr></tbody></table></div><div class=\"xwtTableLoadingIndicatorDropShadow\"></div></div>\r\n"),

	// loadingMessage: [public] String
	//	The message to display while loading.
	loadingMessage: "Loading...",

	// shown: [const] Boolean
	//	Boolean indicator if the overlay is currently shown or not.
	shown: false,

	// _showCount [private] int
	//	A count of how many times show has been called.
	_showCount: 0,

	// delay [public] int
	//	How many milliseconds to wait before actually showing the indicator.
	//	Default is 3000 (3 seconds).
	delay: 3000,

	constructor: function(kwArgs) {
		// summary:
		//	Override of the constructor to allow user-configuration
		//	of the message displayed.
		if(kwArgs && "loadingMessage" in kwArgs){
			this.loadingMessage = kwArgs.loadingMessage;
			this._userDefinedLoadingMessage = true;
		}
	},

	postMixInProperties: function(){
		// summary:
		//	Override for postMixInProperties to load in
		//	translated message strings if desired.
		this.inherited(arguments);
		if(!this._userDefinedLoadingMessage){
			var messages = this.l10n = dojo.i18n.getLocalization("xwt.widget.table", "LoadingIndicator");			
			if(messages){
				this.loadingMessage = messages.loadingMessage;
			}
		}
	},

	show: function(){
		// summary:
		//	Method to show the progress indicator.
		// tags:
		//	public
		this._showCount++;
		if(!this.shown){
			this.shown = true;
			this._timeout = setTimeout(dojo.hitch(this, function(){
				if(this._showCount){
					dojo.style(this.domNode, "display", "block");
					this.onShow();
				}
				clearTimeout(this._timeout);
				delete this._timeout;
			}),this.delay);
		}
	},

	hide: function(){
		// summary:
		//	Method to hide the progress indicator.
		// tags: 
		//	public.
		this._showCount--;
		if(this.shown && !this._showCount){
			if(this._timeout){
				clearTimeout(this._timeout);
				delete this._timeout;
			}
			this.shown = false;
			dojo.style(this.domNode, "display", "none");
			this.onHide();
		}
	},

	onShow: function(){
		// summary:
		//	Event that executes when the progress indicator 
		//	finishes showing.
		// tags:
		//	public
	},

	onHide: function(){
		// summary:
		//	Event that executes when the progress indicator 
		//	finishes hiding.
		// tags:
		//	public
	},

	destroy: function(){
		// summary:
		//	Override of destroy for custom cleanup, if necessary.
		if(this._timeout){
			clearTimeout(this._timeout);
			delete this._timeout;
		}
		this._showCount = 0;
		dojo.style(this.domNode, "display", "none");
		this.inherited(arguments);
	}
});

}

if(!dojo._hasResource["dojo.DeferredList"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.DeferredList"] = true;
dojo.provide("dojo.DeferredList");
dojo.declare("dojo.DeferredList", dojo.Deferred, {
	constructor: function(/*Array*/ list, /*Boolean?*/ fireOnOneCallback, /*Boolean?*/ fireOnOneErrback, /*Boolean?*/ consumeErrors, /*Function?*/ canceller){
		// summary:
		//		Provides event handling for a group of Deferred objects.
		// description:
		//		DeferredList takes an array of existing deferreds and returns a new deferred of its own
		//		this new deferred will typically have its callback fired when all of the deferreds in
		//		the given list have fired their own deferreds.  The parameters `fireOnOneCallback` and
		//		fireOnOneErrback, will fire before all the deferreds as appropriate
		//
		//	list:
		//		The list of deferreds to be synchronizied with this DeferredList
		//	fireOnOneCallback:
		//		Will cause the DeferredLists callback to be fired as soon as any
		//		of the deferreds in its list have been fired instead of waiting until
		//		the entire list has finished
		//	fireonOneErrback:
		//		Will cause the errback to fire upon any of the deferreds errback
		//	canceller:
		//		A deferred canceller function, see dojo.Deferred
		this.list = list;
		this.resultList = new Array(this.list.length);

		// Deferred init
		this.chain = [];
		this.id = this._nextId();
		this.fired = -1;
		this.paused = 0;
		this.results = [null, null];
		this.canceller = canceller;
		this.silentlyCancelled = false;

		if(this.list.length === 0 && !fireOnOneCallback){
			this.callback(this.resultList);
		}

		this.finishedCount = 0;
		this.fireOnOneCallback = fireOnOneCallback;
		this.fireOnOneErrback = fireOnOneErrback;
		this.consumeErrors = consumeErrors;

		dojo.forEach(this.list, function(d, index){
			d.addCallback(this, function(r){ this._cbDeferred(index, true, r); return r; });
			d.addErrback(this, function(r){ this._cbDeferred(index, false, r); return r; });
		}, this);
	},

	_cbDeferred: function(index, succeeded, result){
		// summary:
		//	The DeferredLists' callback handler

		this.resultList[index] = [succeeded, result]; this.finishedCount += 1;
		if(this.fired !== 0){
			if(succeeded && this.fireOnOneCallback){
				this.callback([index, result]);
			}else if(!succeeded && this.fireOnOneErrback){
				this.errback(result);
			}else if(this.finishedCount == this.list.length){
				this.callback(this.resultList);
			}
		}
		if(!succeeded && this.consumeErrors){
			result = null;
		}
		return result;
	},

	gatherResults: function(deferredList){
		// summary:	
		//	Gathers the results of the deferreds for packaging
		//	as the parameters to the Deferred Lists' callback

		var d = new dojo.DeferredList(deferredList, false, true, false);
		d.addCallback(function(results){
			var ret = [];
			dojo.forEach(results, function(result){
				ret.push(result[1]);
			});
			return ret;
		});
		return d;
	}
});

}

if(!dojo._hasResource["xwt.widget.table.Table"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.table.Table"] = true;
/* ************************************************** */
/* Copyright (c) 2009-2011 Cisco Systems, Inc.       */
/* All rights reserved.                               */
/* ************************************************** */

dojo.provide("xwt.widget.table.Table");





















//	HACK/TODO: connect to dijit.showTooltip and force the body to have the xwtNotification class.
dojo.connect(dijit, "showTooltip", function(){
	if(!dojo.hasClass(dojo.body(), "xwtNotification")){
		dojo.addClass(dojo.body(), "xwtNotification");
	}
});

/*=====
xwt.widget.table.__mapArgs = function(data, type, returnData, returnType, deferred){
//	summary:
//		Arguments to map from one type of data to another.
//	data: dojo.data.item[] | NodeList | Number[] | dojo.data.item | Node | Number
//		The original data to map from.  If an array, the returned mapping will be an array or NodeList.
//	type: String?
//		The type of data that was passed.  Can be "item", "node" or "number".  If not passed,
//		the type will be inferred, either by the first item in the array or the item itself.
//	returnData: dojo.data.item[] | NodeList | Number[] | dojo.data.item | Node | Number
//		Set after the mapping is complete; this is the return data we are interested in.
//	returnType: String
//		The type of data to be returned from the map.  Can be "item", "node" or "number".
//	deferred: dojo.Deferred?
//		If you want to use a pre-existing dojo.Deferred object, pass it here.
this.data = data;
this.type = type;
this.returnData = returnData;
this.returnType = returnType;
this.deferred = deferred;
}
=====*/

dojo.declare("xwt.widget.table.Table", [ dijit.layout._LayoutWidget, dijit._Templated ], {
	//	summary:
	//		The base table widget for Cisco Tables.
	//	description:
	//		The Table widget is used for displaying large amounts of data.  Similar to the
	//		DojoX Grid, this is a from-scratch implementation that implements the Cisco
	//		Tables Basic and Viewing/Scrolling specifications.
	//
	//		Note that to have a table do filtering or editing, you will need to
	//		include the Filter or Edit components (see xwt.widget.components).
	//
	//		The Table widget will replace (not fill in) a given DOM structure. This is
	//		important to know because if you attempt to use something like dojo.query
	//		to get a handle to the domNode property, you will not get a result if you
	//		use an expression like dojo.query("table#myTable");.
	//
	//		Memory Notes:
	//		For widgets that you pass in, such as 'detailWidget', 'dialogEditor' and
	//		quickViewer: These are not destroyed when table.destroy() is called, as it is
	//		assumed they may be shared.  You must call the destroy on them yourself.  
	//		If you want them to be destroyed at table destruction time, then do something like the following:
	//	
	//		|	table.connect(table, "destroy", function() { detailWidget.destroy(); });
	//
	//	store: [private] dojo.data.Store
	//		A reference to the underlying data store used to feed data in this widget.
	//	_columns: [private] xwt.widget.Columns
	//		An ordered list of the columns in this table.  See xwt.widget.Columns for details.
	//	_css: [readonly private] Object
	//		A hashmap of the CSS class names used for various parts of the table.
	//	displayLoadingIndicator: [public] boolean
	//		A flag indicating if a loading indicator should display when data is loading.
	//	loadingIndicatorMessage: [public] string
	//		A message, if any, to put in the loading indicator in place of the default.
	//	loadingIndicatorDelay: [public] int
	//		The delay time for a store request to exceed before displaying the loading indicator, in milliseconds.
	//		The default is 3000 milliseconds (three seconds);

	displayLoadingIndicator: true, 
	loadingIndicatorMessage: "",
	loadingIndicatorDelay: 3000,
	store: null,
	_columns: null,
	_css: {
		headContainer: "table-header-container",
		head: "table-header",
		container: "table-container",
		body: "table-body",
		footContainer: "table-footer-container",
		foot: "table-footer",
		rowLockedContainer: "table-row-locked-container",
		row: "row",
		rowTable: "row-table",
		odd: "row-odd",
		even: "row-even",
		hover: "hover",
		rowDivider: "row-divided",
		cell: "cell",
		cellContainer: "cell-container",
		groupCell: "group-cell",
		groupCellContainer: "group-cell-container",
		groupCellContainerLast: "group-cell-container-last",
		groupLabel: "group-label",
		groupLabelContainer: "group-label-container",
		hidden: "hidden",
		ellipsis: "ellipsis",
		ellipsisNotDone: "ellipsis-not-done",
		resizing: "table-column-resizing",
		readonly: "not-editable",
		selected: "selected",
		focused: "focused",
		columnBorders: "col-borders",
		columnLastBorder: "col-last-border",
		rowBorders: "row-borders",
		rowLastBorder: "row-last-border"
	},

	//	l10n:
	//		An object containing localized strings.	
	l10n: null,

	templateString:"<div class=\"table\" dojoAttachEvent=\"onkeydown: _onKeyDown, onclick: _onClick\">\r\n\t<div dojoAttachPoint=\"tableHeadNodeContainer\" class=\"table-head-node-container\" style=\"overflow:hidden;width:100%;\">\r\n\t\t<div dojoAttachPoint=\"tableHeadContainer\" style=\"overflow:hidden;\">\r\n\t\t\t<div dojoAttachPoint=\"tableLockedHeadInnerContainer\" style=\"display:none;\"></div>\r\n\t\t\t<div dojoAttachPoint=\"tableHeadInnerContainer\"></div>\r\n\t\t</div>\r\n\t</div>\r\n\t<div class=\"clear\"></div>\r\n\t<div dojoAttachPoint=\"tableRowTopNodeContainer\" style=\"overflow:hidden;width:100%;display:none;\">\r\n\t\t<div dojoAttachPoint=\"tableRowTopContainer\" style=\"overflow:hidden;\">\r\n\t\t\t<div dojoAttachPoint=\"tableLockedRowTopInnerContainer\" style=\"display:none;\"></div>\r\n\t\t\t<div dojoAttachPoint=\"tableRowTopInnerContainer\"></div>\r\n\t\t</div>\r\n\t</div>\r\n\t<div dojoAttachPoint=\"tableContainer\" style=\"overflow:auto;\" dojoAttachEvent=\"onscroll:_onContentScroll\">\r\n\t\t<div dojoAttachPoint=\"tableLockedColumnBody\" style=\"display: none;\"></div>\r\n\t\t<div dojoAttachPoint=\"tableBody\"></div>\r\n\t</div>\r\n\t<div dojoAttachPoint=\"tableRowBottomNodeContainer\" style=\"overflow:hidden;width:100%;display:none;\">\r\n\t\t<div dojoAttachPoint=\"tableRowBottomContainer\" style=\"overflow:hidden;\">\r\n\t\t\t<div dojoAttachPoint=\"tableLockedRowBottomInnerContainer\" style=\"display:none;\"></div>\r\n\t\t\t<div dojoAttachPoint=\"tableRowBottomInnerContainer\"></div>\r\n\t\t</div>\r\n\t</div>\r\n\t<div dojoAttachPoint=\"tableFootNodeContainer\" class=\"table-foot-node-container\" style=\"overflow:hidden;width:100%;display:none;\">\r\n\t\t<div dojoAttachPoint=\"tableFootContainer\" style=\"overflow:hidden;\">\r\n\t\t\t<div dojoAttachPoint=\"tableLockedFootInnerContainer\" style=\"display:none;\"></div>\r\n\t\t\t<table dojoAttachPoint=\"tableFoot\" style=\"overflow:hidden;\"\r\n\t\t\t\tcellpadding=\"0\" cellspacing=\"0\" border=\"0\"\r\n\t\t\t\t><tbody><tr dojoAttachPoint=\"tableFootRow\"></tr></tbody></table>\r\n\t\t</div>\r\n\t</div>\r\n</div>\r\n",

	columns: [],

	// scrollFetchDelay [public]: int
	//		A parameter to adjust how long to wait after a scroll stop before calling a fetch.
	//		The delay is specified in milliseconds; the default is 1/3 of a second.  Do not change this unless
	//		you understand the ramifications of faster or slower calls to fault in data pages.
	scrollFetchDelay: 333,

	// dojo.data
	query: {},
	queryOptions: {},
	_sortAttributes: null,

	// paging
	rowsPerPage: 25,
	pagesToKeep: 4,
	rowScrollThreshold: -1,
	
	//maximum number of rows that table can handle. Default value is 200,000.
	//This is different than the rowsPerPage in that this is the total rows and not rows in one page.
	maxRows: 200000,
	_rowsOverflow:false,

	// private
	_lastScrollLeft: 0,
	_lastScrollTop: 0,
	_avgRowHeight: -1,
	_totalRows: -1,
	_visibleLockedContainer: null,	//	Which container is being used for locked rows.
	_showIndex: false,				//	Show the "index" column.

	// maps
	_indexToItem: [],
	_idToIndex: {},
	_lockedItems: {},

	//	Focus information.
	_focusedNode: null,

	//	Refresh information.
	_lastRefresh: null,
	
	// _cssInvalidSelectorRegExp [private] RegExp
	//		This regexp is used to identify characters in a selector which
	//		are invalid.  This is used to sanitize identities when used as a selector.
	_cssInvalidSelectorRegExp: /([~!@\$%\^&\*()\+=,\.\/';:"\?\>\<\[\]\\\{\}|`#\s]){1}/g,
	
	constructor: function(kwArgs){
		//	summary:
		//		Initialize some instance vars.
		this.currentIndex=0;
		this._visibleRows=null;
		this._pageStack = [];
		this.columns = [];
		this.query = {};
		this.queryOptions = {};
		this._indexToItem = [];
		this._idToIndex = {};
		this._idToItem = {};
		this._lockedItems = {};
		if(kwArgs && kwArgs.index){
			this._showIndex = true;
		}
		if(kwArgs && kwArgs.detailWidget){
			this._detail = kwArgs.detailWidget;
		}
		if(kwArgs && kwArgs.structure){
			kwArgs.columns = kwArgs.structure;
		}

		// Creating a unique class selector to attach to things, so that when we are querying we 
		// don't grab children inside the widget-holder or the like.
		this._uniqueCssId = dijit.getUniqueId("xwtTable_" + (new Date()).getTime());

		this._lastRefresh = new Date();
		this._scrollLoadingPage = {};
	},
	
	_santizeIdentityForCss: function(id){
		// summary:
		//		Function to take an item identity and make sure it is sanitized and
		//		can be used in the CSS selector lookups.
		// id:
		//		The identity to process.  Cannot be null/undefined.
		// tags:
		//		private
		id = id + "";
		return id.replace(this._cssInvalidSelectorRegExp, function(c){
			return "_x" + c.charCodeAt(0) + "_";
		});
	},

	postMixInProperties: function(){
		this.inherited(arguments);
		this.l10n = dojo.i18n.getLocalization("xwt.widget.table", "Table");

		// Do some sanity checks before we render.  We need at least 2 pages to do 
		// virtual scrolling.  Layout may update this again to make sure
		// we have enough pages to handle the viewport (fill it completely with pages +
		// one extra one so scrolling is smooth).
		if(!this.pagesToKeep){
			this.pagesToKeep = 4;
		}else if(this.pagesToKeep < 2){
			this.pagesToKeep = 2;
		}
		if(!this.rowsPerPage){ 
			this.rowsPerPage = 25; 
		}else if(this.rowsPerPage < 5){
			this.rowsPerPage = 5;
		}
		
		//we know there are issues with scrollbar when too many rows, so cap the max rows
		//check for maxRows limit - at minimum it should be equal to rowsPerPage
		if(!this.maxRows){ 
			this.maxRows = 200000; 
		}else if(this.maxRows < this.rowsPerPage){
			this.maxRows = this.rowsPerPage;
		}
	},

	// Getters / Setters for .attr()
	_setQueryAttr: function(query){
		query = query ? query : {};
		this.query = query;
		this._preFilterQuery = this.query;
		if(this._started){
			if(!this._populating){
				if(dojo.isFunction(this.clearSelections)){
					this.clearSelections();
				}
				this.render();
			}
		}
	},

	setQuery: function(query){
		// summary:
		//	Reset the 'query' of the table to another value,
		//	thus altering its 'global' scope to which filters apply, or changing
		//	non-table-cell-related query parameters the service requires.
		// query:
		//	The scoping 'query' to set, which should be a Javascript object of
		//	key/value pairs to be translated into URI query parameters.
		this.attr("query", query);
	},

	_setColumnsAttr: function(columns){
		if(columns){
			var columns = columns.slice(0), self = this;

			//*
			if(this._detail && !(xwt.widget.table.TreeTable && this instanceof xwt.widget.table.TreeTable)){
				columns.unshift({
					columnType: xwt.widget.table.ColumnTypes.EXPANDER,
					widget: this._detail
				});
			}
			//	*/

			//if(this.select && this.select.model == "input"){
			if(this.select){
				//	FIXME: allow for the use of a widget for selection as opposed to a standard HTML input.
				columns.unshift({
					columnType: xwt.widget.table.ColumnTypes.SELECTOR,
					selectOptions: self.select
				});
			}
			if(this._showIndex){
				//	show the index column
				columns.unshift({
					columnType: xwt.widget.table.ColumnTypes.INDEX
				});
			}

			if(this._columns_conn){
				dojo.forEach(this._columns_conn, dojo.disconnect);
			}
			var conn = this._columns_conn = [];

			this._createColumns(columns);

			conn.push(dojo.connect(this._columns, "onResize", this, "_onColumnResize"));
			conn.push(dojo.connect(this._columns, "onMove", this, "_onColumnMove"));
			conn.push(dojo.connect(this._columns, "onShow", this, "_onColumnShowOrHide"));
			conn.push(dojo.connect(this._columns, "onHide", this, "_onColumnShowOrHide"));
			
			var hasSortable = false,
				sortColumn = -1,
				sortDirection = "",
				checkSortable = function(column){
					if(column.children){
						column.children.forEach(checkSortable);
					}else if(column.sortable){
						hasSortable = true;
						if(column.sorted){
							if(!sortDirection){
								sortColumn = column._index;
								sortDirection = column.sorted;
							}else{
								column.sorted = false;
							}
						}
					}
				};
			this._columns.forEach(checkSortable);

			if(hasSortable){
				if(!sortDirection){
					xwt.widget.table.Sort.start.call(this);
				}else{
					xwt.widget.table.Sort.start.call(this, this._columns.get(sortColumn));
				}
			}else{
				this._sortable = false;
			}

			this._resetColumns();
		}
	},

	//	Stub method, should be overridden with the Edit plugin.
	editing: function(){ return false; },

	//	Stub method, should be overridden if there's an expander column.
	expandable: function(){ return false; },
	
	buildRendering: function(){
		//	summary:
		//		Creates the widget's DOM structure.  Any nodes passed to this will
		//		be swapped out for the revised DOM structure, so do not count on
		//		being able to hit anything directly using something like dojo.query().
		//		Build rendering does the construction of the widget's DOM.  We grab a reference
		//		to the srcNode ref to pull out and table rows used to define the list
		//		declaratively.  After the inherited (_Templated) build rendering runs,
		//		the structure definition is used to set up the list's table.

		// _Templated
		this.inherited(arguments);
		this._resetColumns();
	},

	postCreate: function(){
		//	summary:
		//		Called after the widget is initialized. This is where the store will
		//		be set and the query called to populate the widget with data.
		this.inherited(arguments);

		if(this.rowScrollThreshold < 0){
			this.rowScrollThreshold = Math.floor(this.rowsPerPage / 3);
		}

		var css = this._css;
		dojo.addClass(this.tableHead, css.head);
		dojo.addClass(this.tableHeadContainer, css.headContainer);
		dojo.addClass(this.tableContainer, css.container);
		dojo.addClass(this.tableBody, css.body);
		dojo.addClass(this.tableFoot, css.foot);
		dojo.addClass(this.tableFootContainer, css.footContainer);
		dojo.addClass(this.tableRowTopContainer, css.rowLockedContainer);
		dojo.addClass(this.tableRowTopContainer, css.rowLockedContainer + "-top");
		dojo.addClass(this.tableRowBottomContainer, css.rowLockedContainer);
		dojo.addClass(this.tableRowBottomContainer, css.rowLockedContainer + "-bottom");

		dojo.setSelectable(this.tableBody, false);

		dojo.attr(this.tableHeadNodeContainer, 'role', 'presentation');
		dojo.attr(this.tableHeadContainer, 'role', 'row');
		dojo.attr(this.tableHead, 'role', 'presentation');
		dojo.attr(this.tableContainer, 'role', 'presentation');
		dojo.attr(this.tableBody, 'role', 'presentation');
		dojo.attr(this.tableRowTopNodeContainer, 'role', 'presentation');
		dojo.attr(this.tableRowTopContainer, 'role', 'row');
		dojo.attr(this.tableRowBottomNodeContainer, 'role', 'presentation');
		dojo.attr(this.tableRowBottomContainer, 'role', 'row');

		if(this.select){
			this._applySelect();
		}
		if(this.filters){
			xwt.widget.table.Filter.start.call(this, this.filters);
		}
		if(this.edit){
			xwt.widget.table.Edit.start.call(this, this.edit);
		}
		if(this.quickview){
			xwt.widget.table.QuickView.start.call(this, this.quickview);
		}

		this._source = new xwt.widget.table._ColumnMover(this.tableHeadInnerContainer, { table: this, singular: true });
		this._source.startup();

		//	Set up our row dragging events, if the underlying store supports them.
		this._setupDragEvents();

		this.connect(this.tableHeadInnerContainer, 'onclick', '_onHeaderClick');

		//	Hook up notification events.
		this._setupNotificationEvents();

		// Create our loading indicator if it is enabled.
		if(this.displayLoadingIndicator){
			var props = {};
			if(this.loadingIndicatorMessage){
				props.loadingMessage = this.loadingIndicatorMessage;
			}
			if(this.loadingIndicatorDelay > 0){
				props.delay = this.loadingIndicatorDelay;
			}
			this._loadingIndicator = new xwt.widget.table.LoadingIndicator(props);
			dojo.style(this._loadingIndicator.domNode, "display", "none");
			dojo.place(this._loadingIndicator.domNode, this.tableBody);
			this._loadingIndicator.startup();
			this.connect(this._loadingIndicator, "onShow", function(){
				this._liTimer = setInterval(dojo.hitch(this, function(){
					try {
						var pos = dojo.position(this.tableContainer);
						dojo.style(this._loadingIndicator.domNode, "width", pos.w);
						if (!this._overflowY) {
							dojo.style(this._loadingIndicator.domNode, "width", pos.w + "px");
						}else {
							var sDims = this._getScrollBarDims();
							dojo.style(this._loadingIndicator.domNode, "width", (pos.w - (sDims.w)) + "px");
						}
					} 
					catch (e) {
						/* ignore.  IE sometimes has weird issues with dojo.position. */
					}
				}),100);
			});
			this.connect(this._loadingIndicator, "onHide", function(){
				if(this._liTimer){
					clearInterval(this._liTimer);
					delete this._liTimer;
				}
			});
		}

		if(!this._emptyTableHScrollControl){
			// Place a node we can use to force horizontal
			// scrolling, even when the table is empty.
			this._emptyTableHScrollControl = dojo.create("div", {"class": "xwtEmptyTableHScrollControl"});
			dojo.place(this._emptyTableHScrollControl, this.tableBody);
		}

		if(dojo.style(this.tableBody, "MozUserSelect") == "none"){
			// Mozilla's MozUserSelect is annoying, it doesn't work properly in that
			// resetting it on child nodes won't enable selection.  It needs to be set to -moz-none.
			dojo.style(this.tableBody, "MozUserSelect", "-moz-none");
		}

		// Check and set the default filter if it was defined.		
		var qfDefault = this.quickFilterDefault || "All";
		if(qfDefault != "All" && this.filters){
			var i;
			for(i = 0; i < this.filters.length; i++){
				if(qfDefault == this.filters[i].name){
					this._currentFilter = this.filters[i];
					//lets take care of the query also - otherwise if only default filter is defined and the applications use query
					//it causes problems - CSCtn08721
					this._preFilterQuery = dojo.mixin({}, this.query || {}); 
					var q = this._filterEngine._functions.toDojoQuery(this.filters[i].expressions,this.filterOnServer); 
					this.query = dojo.mixin({}, this._preFilterQuery, q); 	
					break;
				}
			}
		}
		
	},

	_applySelect: function(){
		xwt.widget.table.Select.start.call(this, this.select);
	},

	startup: function(){
		//	summary:
		//		Called on widget startup.
		if (this._started) { return; }
		this._resize();

		this.inherited(arguments);

		this._adjustSizes();
		this.layout();

		//	Let anyone know that we started.
		dojo.publish(this.id + "-startup", [ this ]);

		xwt.widget.table.ellipsizeCells && xwt.widget.table.ellipsizeCells(this, this.tableBody);
	},

	getChildren: function(){
		return [];
	},


	layout: function(){
		//	summary:
		//		Called by the Dijit rendering system when this is a child
		//		widget of any Dijit layout widgets.
		if (!this._started){return;}
		this.onLayout();
		var contentWidth = this._contentBoxWidth;
		var contentHeight = this._contentBoxHeight;
		var borders = dojo._getBorderExtents(this.domNode);

		// Account for CSS borders on height (bottom border, for example).
		var adjustedHeight = contentHeight - borders.h;
		var adjustedWidth = contentWidth - borders.w;
		if(adjustedHeight < 0){
			adjustedHeight = 0;
		}
		if(adjustedWidth < 0){
			adjustedWidth = 0;
		}

		// Size the header, footer, and content containers,
		// as well as the top and bottom row containers.

		// Relates to CSCth58657
		dojo.style(this.tableContainer, {
			width: adjustedWidth + "px",
			height: adjustedHeight + "px"
		});

		// Also make sure to size the outer div width, sometimes
		// browser doesn't size it right in auto.
		dojo.style(this.domNode, "width", adjustedWidth + "px");

		dojo.style(this.tableHeadNodeContainer, "width", adjustedWidth + "px");
		dojo.style(this.tableFootNodeContainer, "width", adjustedWidth + "px");
		if(this.tableRowTopNodeContainer){
			dojo.style(this.tableRowTopNodeContainer, "width", adjustedWidth + "px");
		}
		if(this.tableRowBottomNodeContainer){
			dojo.style(this.tableRowBottomNodeContainer, "width", adjustedWidth + "px");
		}
		
		// Now we have to make the headers and such huge so they scroll.
		// This used to be set in CSS, but it caused strange table size init issues.
		// So resizing it after all the initial sizing has been handled to avoid it.
		// CDETS: CSCth90606
		dojo.style(this.tableHeadContainer, "width", "9000em");
		dojo.style(this.tableFootContainer, "width", "9000em");
		dojo.style(this.tableRowTopContainer, "width", "9000em");		
		dojo.style(this.tableRowBottomContainer, "width", "9000em");

		if(this._pageHeights != null){
			//Reset all heights if resize was called, just in case.
			this._invalidatePageHeights();
		}
		this._adjustSizes(true);

		// Let's check pageSize and approximate if we have enough.
		var dims;
		if(this.tableBody){
			dims = dojo.position(this.tableContainer);
		}
		if(dims && dims.h > 0){
			// Rows * num of pages * avg row height, which us around 22px.
			var currentDataHeight = this.rowsPerPage * this.pagesToKeep * 22;
			var pageHeight = this.rowsPerPage * 22;
			var sizeDiff = dims.h - currentDataHeight;
			if(sizeDiff < 0){
				// Viewport is smaller, but is it at least 1 page smaller?
				sizeDiff = Math.abs(sizeDiff);
				if(sizeDiff < pageHeight){
					// Not quite one page off, so add a page to be safe.
					// Otherwise we're keeping enough pages that we should be OK.
					this.pagesToKeep++;
				}
			}else{
				// Viewport is greater than our current rows per page setup, so let's increase it
				// to one (or at least one) more page than our viewport.
				this.pagesToKeep += Math.ceil(sizeDiff/pageHeight) + 1; 
			}
		}

		if(dojo.query('.page.' + this._uniqueCssId, this.tableBody).length<1 ||
			dojo.query('.' + this._css.row + "." + this._uniqueCssId, this.tableBody).length<1){
			if(!this._populating){
				this._populating = true;
				var def = this._fetch(0);
				def.addCallback(dojo.hitch(this, function(){
					delete this._populating;
				}));
				def.addErrback(dojo.hitch(this, function(){
					delete this._populating;
				}));
			}
		}

		if (this._overflowY) {
			var newScrollHeight = this._totalRows * this._avgRowHeight;	
			if (this.scrollHeight != newScrollHeight){
				this.scrollHeight = newScrollHeight;
			}
		}

		// Check the scrollLeft, in case it is off.  Sometimes it is in IE.
		if(this._lastScrollLeft != this.tableContainer.scrollLeft){
			var scrollLeft = this.tableContainer.scrollLeft;
			this.tableHeadNodeContainer.scrollLeft = scrollLeft;
			this.tableFootContainer.scrollLeft = scrollLeft;
			this.tableRowTopNodeContainer.scrollLeft = scrollLeft;
			this.tableRowBottomNodeContainer.scrollLeft = scrollLeft;
			this._lastScrollLeft = scrollLeft;
			if(dojo.isIE < 8){
				// Work around IE7 render glitch on scrollers for the
				// top/bottom containers. CSCth90800
				if(dojo.style(this.tableRowTopNodeContainer, "display") != "none"){
					this.tableRowTopNodeContainer.className = this.tableRowTopNodeContainer.className;
				}
                                
				if(dojo.style(this.tableRowBottomNodeContainer, "display") != "none"){
					// For some reason, touching the lower row has a perf hit, so put this in a timeout.
					// May just be due to being lower down in the doc under a complex set of nodes.
					if(this._ie7BottomRowFix){
						clearTimeout(this._ie7BottomRowFix);
					}
					this._ie7BottomRowFix = setTimeout(dojo.hitch(this, function(){
						this.tableRowBottomNodeContainer.className = this.tableRowBottomNodeContainer.className;
					}), 10);
				}
			}
		}
	},

	_onNew: function(item, parent){	
		this.onAdd(item, parent);
		if(!this.editing()){
			//check for editor;
			//it's possible that this came from adding to the store
			//and there is no editor defined.
			var tmpl;
			if (this._editor) {
				tmpl = this._editor.addRequested;
			}
			var matches = false;
			if(tmpl){
				var idAttrs = this.store.getIdentityAttributes(item),
					store = this.store;
				var numAttrsMatching = 0;
				for(var i=0, len=idAttrs.length; i<len; i++){
					if(tmpl[idAttrs[i]] == store.getValue(item, idAttrs[i])){
						numAttrsMatching++;
					}
				}
				if(numAttrsMatching == idAttrs.length){
					matches = true;
				}
			}
			if(matches){
				this.clearSelections();
				this.select(item);
			}
			var def = this.render(this._totalRows>0);
			if(matches){
				var self = this;
				def.addCallback(function(){
					// Add a scroll to the last row, and make sure it is flagged to forcibly
					// re-render the page, to be safe.
					self.scrollToRow(self._totalRows, true).addCallback(function(){
						setTimeout(function(){
							var idx = self._idToIndex[self.store.getIdentity(item)];
							if(idx){
								self._focus(idx);
							}
							self.edit(item);
						},100);
					}).addErrback(function(ex){
						console.warn(ex);
					});
				});
			}
			if (this._editor) {
				this._editor.addRequested = null;
			}
		}
	},

	onAdd: function(item, parent){
		// summary:
		//	This is a callback/attach point for when the attached store's onNew fires, 
		//	creating a point where people can catch a new item, irrespective of whether it goes into
		//	edit mode or not.
		// item:
		//	The item added to the underlying data store.
		// parent:
		//	The parent item of the item.  For the normal cases of table, this will be null or undefined.
		// tags:
		//	callback
	},

	__throttle: null,
	_onDelete: function(item){
		if(!this.editing() && !this.deleting){
			if(this.selected){
				this.deselect(item);
			}
			if(this.__throttle){ clearTimeout(this.__throttle); }
			this.__throttle = setTimeout(dojo.hitch(this, function(){
				this.render(true); 
			}), 50);
		}
	},

	_onSet: function(item, attr, oldvalue, newvalue){
		if(!this.editing()){
			if(this.__throttle){ clearTimeout(this.__throttle); }
			this.__throttle = setTimeout(dojo.hitch(this, function(){ 
				this.render(true); 
			}), 50);
		}
	},

	_onRevert: function(){
		if(!this.editing()){
			if(this.__throttle){ clearTimeout(this.__throttle); }
			this.__throttle = setTimeout(dojo.hitch(this, function(){ 
				this.render(true); 
			}), 50);
		}
	},

	_onMoveTo: function(items, before, after){
		if(!this.editing()){
			if(this.__throttle){ clearTimeout(this.__throttle); }
			this.__throttle = setTimeout(dojo.hitch(this, function(){ 
				this.render(true); 
			}), 50);
		}
	},

	_setupNotificationEvents: function(){
		if(this.store.onSet){
			//	TODO: better feature detection? Not needed, events just don't fire if they don't exist
			this.connect(this.store, "onNew", "_onNew");
			this.connect(this.store, "onDelete", "_onDelete");
			this.connect(this.store, "onSet", "_onSet");
			this.connect(this.store, "revert", "_onRevert");
		}

		this.connect(this.store, "moveTo", "_onMoveTo");
	},

	/////////////////////////////////////////////////////////////////////////////////////////////////////
	//	BEGIN ROW DRAGGING
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	_dragger: {
		item: null,				//	the item being dragged (dojo.data.Item)
		row: null,				//	the row being dragged (DOMNode)
		placeholder: null,		//	a placeholder for the old row (DOMNode)
		target: null,			//	the target row (DOMNode)
		startingDrag: false,	//	if a drag operation is beginning (mousedown + first mousemove)
		isDragging: false,		//	if we are in the process of dragging
		targetOverHandle: null,	//	handle for doing target operations (add border below)
		dragHandle: null,		//	handle for the mousemove operations
		dragEndHandle: null,	//	handle for when a drag is complete
		trueDragStartHandle: null,	//	prevent a real dragstart op
		selectStartHandle: null,	//	prevent a real select text op
		containerBox: null,		//	the coords of this.tableContainer at the time of drag
		bodyBox: null,			//	the coords of this.tableBody at the time of drag
		rowBox: null,			//	the coords of the original row being dragged (Y is altered)
		position: null,			//	the current Y position of the mouse
		scrollTimer: null,		//	the timeout object if we are in autoscroll mode
		SCROLL_THRESHOLD: 22,	//	how many pixels from top or bottom to trigger scrolling
		SCROLL_INTERVAL: 100,	//	how fast we are to scroll
		SCROLL_BY: 40			//	how far to scroll per timer fire, in pixels
	},

	_setupDragEvents: function(){
		if(this.store.orderAttribute && this.store.moveTo){
			//	we always connect once for the drag start operation.
			this.connect(this.tableContainer, "onmousedown", "_onDragStart");
		}
	},

	_resetDragger: function(){
		//	summary:
		//		Reset our dragger object.
		var d = this._dragger;
		dojo.disconnect(d.targetOverHandle);
		dojo.disconnect(d.dragHandle);
		dojo.disconnect(d.dragEndHandle);
		dojo.disconnect(d.trueDragStartHandle);
		dojo.disconnect(d.selectStartHandle);
		dojo.destroy(d.placeholder);
		if(dojo.hasClass(d.row, "dragging")){
			// Only desroy the row if we happened to
			// have started dragging it.
			// Otherwise it was just a click
			// on the handle, so we do not want to 
			// delete the row!
			dojo.destroy(d.row);
		}
		d.startingDrag = false;
		d.isDragging = false;
		d.item = null;
		d.row = null;
		d.placeholder = null;
		if(d.target) { dojo.removeClass(d.target, "targetOver"); }
		dojo.style(this.tableContainer, "cursor", "inherit");
		d.target = null;
		d.containerBox = null;
		d.bodyBox = null;
		d.pageBox = null;
		d.rowBox = null;
		d.position = null;
		d.scrollTimer && clearTimeout(d.scrollTimer);
		d.scrollTimer = null;
	},

	_onDragStart: function(e){
		//	summary:
		//		Prepare our dragger but do not do anything other than set up our events.
		if(!dojo.hasClass(e.target, "dojoDndHandle")){ return; }
		if(this._totalRows <= 1){ return; }
		var d = this._dragger,
			row = this._rowFromTarget(e);
		if(!row){ return; }

		// Cache the starting page.
		// We need this info later.
		d.currentPage = dojo.attr(row.parentNode, "pageindex");
		if(dojo.isString(d.currentPage)){
			d.currentPage = parseInt(d.currentPage, 10);
		}

		//	set up our handlers.
		d.startingDrag = true;
		d.targetOverHandle = dojo.connect(this.tableBody, "onmouseover", this, "_onTargetOver");
		d.dragHandle = dojo.connect(dojo.doc, "onmousemove", this, "_onDrag");
		d.dragEndHandle = dojo.connect(dojo.doc, "onmouseup", this, "_onDragEnd");
		d.trueDragStartHandle = dojo.connect(dojo.doc, "ondragstart", dojo.stopEvent);
		d.selectStartHandle = dojo.connect(dojo.body(), "onselectstart", dojo.stopEvent);

		//	The row node, set a reference to it.
		d.row = row;
		d.containerBox = dojo.coords(this.tableContainer);
		d.bodyBox = dojo.coords(this.tableBody);
		d.pageBox = dojo.coords(row.parentNode);
		d.rowBox = dojo.coords(row);
		d.position = e.pageY;
	},

	_onTargetOver: function(e){
		//	summary:
		//		Switch our target when needed, and make sure there is a visual indicator.
		var d = this._dragger,
			row = this._rowFromTarget(e);
		if(!row){ return; }
		if(!d.target || d.target != row){
			if(d.target){
				dojo.removeClass(d.target, "targetOver");
			}
			d.target = row;
			dojo.addClass(d.target, "targetOver");
		}	
	},

	_onDrag: function(e){
		//	summary:
		//		The actual drag operation.  If this is the first time fired after mousedown,
		//		create our avatar and get a reference to the item it represents.
		var d = this._dragger;
		if(d.startingDrag){
			d.startingDrag = false;
			d.isDragging = true;

			//	Create the placeholder div.
			d.placeholder = dojo.create("div", {
				"class": "xwtTableDndPlaceholder" 
			});
			dojo.place(d.placeholder, d.row, "after");

			//	get the item
			d.item = this._indexToItem[parseInt(dojo.attr(d.row, "rowindex"), 10)];

			//	create the avatar
			dojo.addClass(d.row, "dragging");
			dojo.style(d.row, {
				height: Math.max(d.rowBox.h, 22) + "px"
			});
			dojo.place(d.row, this.tableContainer);
			dojo.style(this.tableContainer, "cursor", "move");
			if(d.currentPage != null){
				var page = this._pages[d.currentPage];
				var newHeight = this._calculatePageHeight(page);
				this._updatePageHeight(d.currentPage, newHeight, true);
				this._repositionPages();
			}
		}

		//	move the row, vertically only
		//	TODO: constrain to the boundaries of this.tableContainer.
		var dy = e.pageY - d.position;
		d.rowBox.t += dy;
		dojo.style(d.row, {
			top: d.rowBox.t + d.pageBox.t + "px",
			left: (e.pageX - d.containerBox.x + 2) + "px"
		});
		d.position = e.pageY;

		//	Check to see if we are in a scrolling threshold.
		if(d.position < d.containerBox.y + d.SCROLL_THRESHOLD){
			//	begin autoscroll UP
			d.scrollTimer && clearInterval(d.scrollTimer);
			d.scrollTimer = setInterval(dojo.hitch(this, function(){
				var delta = this._lastScrollTop - d.SCROLL_BY;
				if(delta >= 0){
					this.tableContainer.scrollTop = delta;
					d.rowBox.t -= d.SCROLL_BY;
					dojo.style(d.row, { top: d.rowBox.t + "px" });
				} else {
					clearInterval(d.scrollTimer);
				}
			}), d.SCROLL_INTERVAL);
		} 
		else if(d.position > (d.containerBox.y + d.containerBox.h) - d.SCROLL_THRESHOLD){
			//	begin autoscroll DOWN.
			d.scrollTimer && clearInterval(d.scrollTimer);
			d.scrollTimer = setInterval(dojo.hitch(this, function(){
				var delta = this._lastScrollTop + d.SCROLL_BY;
				if(delta <= (d.bodyBox.h - d.containerBox.h)){
					this.tableContainer.scrollTop = delta;
					d.rowBox.t += d.SCROLL_BY;
					dojo.style(d.row, { top: d.rowBox.t + "px" });
				} else {
					clearInterval(d.scrollTimer);
				}
			}), d.SCROLL_INTERVAL);
		} 
		else {
			//	If we started autoscrolling, time to stop it now.
			d.scrollTimer && clearInterval(d.scrollTimer);
		}
	},

	_onDragEnd: function(e){
		//	summary:
		//		Find our final target item, remove any sort and move our item to the new spot.
		if(!this._dragger.item || !this._dragger.row){
			this._resetDragger();
			return;
		}
		var d = this._dragger,
			id = this.store.getIdentity(d.item),
			target = d.target,
			idx = parseInt(dojo.attr(target, "rowindex"), 10);
		var afterItem = this._indexToItem[idx];

		if(this._sortedColumn){
			this._sortedColumn.sorted = false;
			delete this._sortedColumn;
		}
		this.store.moveTo([ d.item ], this._indexToItem[idx], this._indexToItem[idx + 1]);
		this.render(true);
		this._resetDragger();
	},

	/////////////////////////////////////////////////////////////////////////////////////////////////////
	//	END ROW DRAGGING
	/////////////////////////////////////////////////////////////////////////////////////////////////////

	_fetch: function(start, deltaY, forceRefresh){
		var def = new dojo.Deferred();
		
		// Some users change the store out from under the table, which may break filters.
		// So let's check to see if we need to re-wrap the store.
		if(this.filters && !this.store.__checkedForWrap && xwt.widget.table.Filters && xwt.widget.table.Filters.FilteringWrapperStore){
			if(dojo.isFunction(xwt.widget.table.Filters.canFilterWrapStore)){
				if(xwt.widget.table.Filters.canFilterWrapStore(this.store)){
					this.store = new xwt.widget.table.Filters.FilteringWrapperStore(this.store);
				}
			}
			this.store.__checkedForWrap = true;
		}
	
		// Create a map to store in-flight fetches;
		// we may need to clean them up later in a destroy.
		if(!this._fetchMap){
			this._fetchMap = {};
		}
		var pageNum = start / this.rowsPerPage;
		var page = this._getPage(pageNum, deltaY);
/*
		if(pageNum >= this._numPages){
			def.callback(); 
			return def; 
		}
*/
		// Display the loading indicator, if available.
		if(this._loadingIndicator){
			this._loadingIndicator.show();
			def.addCallback(dojo.hitch(this, function(){
				this._loadingIndicator.hide();
			}));
			def.addErrback(dojo.hitch(this, function(){
				this._loadingIndicator.hide();
			}));
		}

		// Start tracking load requests so events fire 
		// appropriately.
		this._onLoadStart();
		def.addCallback(dojo.hitch(this, function(){
			this._onLoadEnd();
		}));
		def.addErrback(dojo.hitch(this, function(error){
			this._onLoadEnd();
			this._onLoadError(error);
		}));
		
		if(page && page.firstChild && dojo.attr(page.firstChild, 'rowindex') == start && !forceRefresh){
			dojo.style(page, "visibility", "visible");
			def.callback();
			return def;
		}

		if(this._currentFilter){
			this._currentFilter.preFilterQuery = this._preFilterQuery;
		}
		
		var req = this.store.fetch({
			query: this.query,
			filter: this._currentFilter,
			sort: this._sortable ? this._getSortProps() : null,
			start: start,
			count: this.rowsPerPage,
			queryOptions: this.queryOptions,
			completeDeferred: def,
			pageNum: pageNum,
			onBegin: dojo.hitch(this, "_onFetchBegin"),
			onComplete: dojo.hitch(this, "_onFetchComplete"),
			onError: function(error){
				def.errback(error);
			}
		});
		this._fetchMap[pageNum] = {storeRequest: req, deferred: def};
		def.addCallback(dojo.hitch(this, function(){
			// Make sure we get rid of the map.
			if(this._fetchMap){
				delete this._fetchMap[pageNum];
			}
		}));
		def.addErrback(dojo.hitch(this, function(){
			// Make sure we get rid of the map.
			if(this._fetchMap){
				delete this._fetchMap[pageNum];
			}
		}));
		return def;
	},

	_onFetchBegin: function(count, request){
		if(count==-1){ return; }

		if(!this._numPages || count != this._totalRows){
			
			if (count > this.maxRows) {
				count = this.maxRows;
				this._rowsOverflow=true;
			}
			else{
				//we need to reset whenever fetch is called
				this._rowsOverflow=false;
			}
			this._totalRows=count;
			this._numPages = Math.ceil(count / this.rowsPerPage);
		}
		this.onRowCountUpdate(count);

		//var widthUsed = dojo.marginBox(this.tableHead).w,
		// Use position if possible, much cheaper.
		var widthUsed = dojo.position(this.tableHead).w
		var  sb = this._getScrollBarDims(),
			scroll = this._contentBoxWidth - sb.w;

		if(this._avgRowHeight > -1){
			var tableHeight = this._avgRowHeight * count;
			if(tableHeight > this._contentBoxHeight){
				if(widthUsed > scroll){
					this.tableBody.style.width = widthUsed + 'px';
				}else{
					this.tableBody.style.width = scroll + 'px';
				}
			}else{
				if(widthUsed > this._contentBoxWidth){
					this.tableBody.style.width = widthUsed + 'px';
				}else{
					this.tableBody.style.width = this._contentBoxWidth + 'px';
				}
			}
			this.tableBody.style.height = tableHeight + 'px';
		}
	},

	_onFetchComplete: function(items, request){
		var def = request.completeDeferred;

		if(this._numPages == 0 && request.count > 0 && !items.length){
			var page = this._getPage(0);
			if(page){
				// In the case of a destroyed table and the fetch actually calls
				// after, then only update if you actually get a page.  Destroyed
				// tables may return null for a page.

				// Adjust the scroll of the viewport to move back to the top/left.
				this._lastScrollTop = 0;
				this.tableContainer.scrollTop = 0;
				this.tableContainer.scrollLeft = 0;

				// Gotta remove detail widgets before wiping the dom.
				dojo.query(".row-editor-expandPane", page).orphan();

				page.innerHTML = this.l10n.noData;
				dojo.addClass(page, 'no-results');
				window.setTimeout(dojo.hitch(this, function(){
					try {
						//var pmb = dojo.marginBox(page),
						// Try using the cheaper dojo.position, as marginBox is expensive.
						var height = dojo.position(page).h;
						// Set the page to page top 0, since that is the basic page position
						// request.
						var pt = this._getPageTop(0);
						this._pageHeights[0] = height;
						this._pageTops[1] = pt + height;
						page.style.top = pt + "px";
						dojo.style(page, "visibility", "visible");
						this._calculateRowHeights();
						def.callback();
						page = null;
					}
					catch(e){
						/* ignore.  IE sometimes has weird issues with dojo.position. */
						//but we need to call deferred to complete the process
						//otherwise loading indicator never goes away
						//CSCto57096
						def.callback();
					}
				}), 0);
			}
			return;
		}

		for(var i = 0; i < items.length; i++){
			var item = items[i];
			this._indexToItem[i + request.start] = item;
			var id = this.store.getIdentity(item);
			this._idToItem[id] = item;

			if((this._selectAllHardLimit < 0 || this.__allowFetchSelect) && this._selected && this._selected.allSelected && this.isSelectable(item) && !this._selectedIds[id]){
				var except = this._selected.allSelected.except();
				var selected = true; 
				var j;
				for(j = 0; j < except.length; j++){
					if(id == this.store.getIdentity(except[j])){
						selected = false;
						break;
					}
				}
				if(selected){
					if(!this._selectedIds[id] && this.isSelectable(item)){
						this._selected.push(item);
						this._selectedIds[id] = true;
						if(dojo.isFunction(this.onSelect)){
							this.onSelect(item);
						}
					}
				}
			}
			this._idToIndex[id] = i + request.start;
		}

		if(dojo.indexOf(this._pageStack, request.pageNum)==-1){
			def.callback();
			return;
		}

		var page = this._getPage(request.pageNum);
		if(page){
			// In the case of a destroyed table and the fetch actually calls
			// after, then only update if you actually get a page.  Destroyed
			// tables may return null for a page.
			var startIndex = request.start;
			if(!page.firstChild){
				this._columns._createRows(page, items, startIndex);
			}else{
				try{
					// Gotta remove detail widgets before wiping the dom.
					dojo.query(".row-editor-expandPane", page).orphan();

					page.innerHTML = "";
					this._columns._createRows(page, items, startIndex);
					// Replace is slower than create for large tables.  
					// This is due to reflow triggers _replaceRows causes 
					// due to className touching. 
					//this._columns._replaceRows(page, items, startIndex);
				}catch(e){
					console.warn(e);
				} 
			}
    
			window.setTimeout(dojo.hitch(this, function(){
				var height = this._calculatePageHeight(page);
				
				// Removed to use page height calc above.
				//var pmb = dojo.marginBox(page);
				// Try using dojo.position, as it is cheaper.  Pages are not likely to
				// have margins on top/bottom.
				//var pmb = dojo.position(page);

				var pt = this._getPageTop(request.pageNum);

				this._pageHeights[request.pageNum] = height;
				if(request.pageNum < (this._numPages - 1)){
					this._pageTops[request.pageNum+1] = pt + height;
				}
				page.style.top = pt + "px";
				this._calculateRowHeights();
				var fdef = null;
				if((pt + height) < this._contentBoxHeight && (request.pageNum < (this._numPages - 1))){
 					fdef = this._fetch(request.start + this.rowsPerPage)
					if(fdef){
						fdef.addCallback(function(){
							def.callback();
						});
 					}
				}
				// Make sure page is visible.  It's possible getPage may have
				// hidden it as it was 'reused'.  Reused pages are hidden to avoid appearance
				// of wrapping of 'slow loads.' 
				dojo.style(page, "visibility", "visible");
				page = null;
				if(!fdef){
					def.callback();
				}
 			}), 0);
		}
	},

	_calculatePageHeight: function(page){
		// summary:
		//	Workaround function for Firefox's stupid fractional pixel issue, which causes 
		//	page height calculations and sometimes forces overlapping to occur.
		var height = 0;
		if(page){
			var node = page.firstChild;
			while(node){
				height += dojo.position(node).h;
				node = node.nextSibling;
			}
		}
		return Math.ceil(height);
	},

	_invalidatePageHeights: function(){
		//	summary:
		//		Recalculates the page heights within the table.
		var stack = {};
		for(var i=0, len=this._pageStack.length; i<len; i++){
			stack[this._pageStack[i]] = true;
		}
		for(var i=0, len=this._pageHeights.length; i<len; i++){
			if(!(i in stack)){
				this._pageHeights[i] = undefined;
			}
		}
		this._pageTops = [0];

		var h = 0,
			numRows = 0,
			maxPageIndex = this._numPages - 1,
			leftover = this._totalRows % this.rowsPerPage;
		for(var i in stack){
			//h += this._pageHeights[i] = dojo.marginBox(this._pages[i]).h;
			h += this._pageHeights[i] = this._calculatePageHeight(this._pages[i]);
			numRows += (i == maxPageIndex && leftover > 0 ? leftover : this.rowsPerPage);
		}
		var oldScrollFactor = this.tableContainer.scrollTop / this._avgRowHeight;
		this._calculateRowHeights(h, numRows);
		var avgPageHeight = this._avgRowHeight * this.rowsPerPage,
			lastPageHeight = (leftover > 0 ? this._avgRowHeight * leftover : avgPageHeight);
		for(var i=0, len=this._pageStack.length; i<len; i++){
			var pageNum = this._pageStack[i],
				page = this._pages[pageNum];
			page.style.top = this._getPageTop(pageNum) + 'px';
			page = null;
		}
		this.tableContainer.scrollTop = oldScrollFactor * this._avgRowHeight;
	},

	_calculateRowHeights: function(h, numRows){
		//	summary:
		//		Calculates the row height average and adjusts the
		//		table body height.
		var h = h||0,
			numRows = numRows||0;
		if(h<=0){
			var maxPageIndex = this._numPages - 1,
				leftover = this._totalRows % this.rowsPerPage;
			for(var i=0, len=Math.min(this._pageHeights.length, this._numPages); i<len; i++){
				var height = this._pageHeights[i];
				if(typeof height == 'undefined'){ continue; }
				numRows += (i == maxPageIndex && leftover > 0 ? leftover : this.rowsPerPage);
				h += height;
			}
		}
		var rowHeight = this._avgRowHeight = Math.ceil(h / numRows);
		this._bottomRowAvg = this._contentBoxHeight / rowHeight;
		var bodyHeight = ((rowHeight * (this._totalRows - numRows)) + h);

		var _editor = this._editor;
		if(this.editing() && _editor && _editor.detail &&
			_editor.detail.domNode.style.display != "none"){
			bodyHeight += dojo.marginBox(_editor.inline).h - (_editor.row_height ? _editor.row_height : rowHeight);
		}
		if(dojo.isIE && this.editing() && _editor && _editor.inline){
			// We need to add on more for the save/cancel area on IE
			// Otherwise we can't see it.  Ugh.
			var rowActions = dojo.query(".rowActions", _editor.inline)[0];
			if(rowActions && dojo.style(rowActions, "display") !== "none"){
				var rb = dojo.position(rowActions);
				bodyHeight += rb.h;
			}
		}
		if(bodyHeight < 0 || isNaN(bodyHeight)){
			bodyHeight = 0;
		}
		this.tableBody.style.height =  bodyHeight + "px";
		this._adjustSizes();
	},

	_updatePageHeight: function(page, newHeight, updateHeightCache){
		//	summary:
		//		Updates one page height, adjusts the page tops of any pages
		//		below it, and updates the height of the table body.
		var ph = this._pageHeights[page],
			tops = this._pageTops,
			pageDelta = newHeight - ph;

		for(var i=page+1, len=tops.length; i<len; i++){
			if(typeof tops[i] == 'undefined'){
				continue;
			}
			tops[i] += pageDelta;
		}
		if(updateHeightCache){
			this._pageHeights[page] = newHeight;
		}
		var tbh = dojo.contentBox(this.tableBody).h,
			bodyHeight = tbh + pageDelta;
		this.tableBody.style.height = bodyHeight + "px";

		this._adjustSizes();
	},

	_repositionPages: function(){
		//	summary:
		//		Repositions the rendered pages based on the page top
		//		stored in the cache.
		var self = this,
			attr = dojo.attr,
			pageTops = this._pageTops;
		dojo.query('.page' + "." + this._uniqueCssId, this.tableBody).forEach(function(n){
			var idx = attr(n, 'pageIndex'),
				top = pageTops[idx];
			if(top >= 0){
				n.style.top = top + "px";
			}
		});
	},

	_invalidatePageNode: function(pageNum){
		//	summary:
		//		Removes and returns the page node at index `pageNum` from the
		//		list of page nodes.
		var page = this._pages[pageNum];
		if(page){
			delete this._pages[pageNum];
		}
		return page; /* DOMNode */
	},

	_preparePage: function(pageNum, deltaY){
		//	summary:
		//		Create or invalidate and re-use a page node for index
		//		`pageNum`.
		this._pageStack.push(pageNum);
		this._pageStack.sort(function(a, b){
			return a - b;
		});
		var stackLen = this._pageStack.length,
			reuse = this.pagesToKeep && (stackLen > this.pagesToKeep);

		if(reuse){
			var rPageNum;
			var indexOf = dojo.indexOf(this._pageStack, pageNum);
			if(deltaY>0){ // moving down
				if(indexOf == stackLen-1){ // last element, normal
					rPageNum = this._pageStack.shift();
				}else{ // extraneous elements at the end
					rPageNum = this._pageStack.pop();
				}
			}else{ // moving up
				if(indexOf == 0){ // first element, normal
					rPageNum = this._pageStack.pop();
				}else{ // extraneous elements at the beginning
					rPageNum = this._pageStack.shift();
				}
			}
			var page = dojo.query(".page-"+rPageNum+"."+this._uniqueCssId, this.tableBody)[0];
			this._invalidatePageNode(rPageNum);

			// Hide any 'reused' pages.  Fetch will restore visibility after update.
			// This avoids any appearance of wrapping.
			dojo.style(page, "visibility", "hidden");
		}else{
			var page = this._createPage(pageNum);
		}

		if(this._avgRowHeight>0){
			page.style.top = this._getPageTop(pageNum) + 'px';
		}
		page.className = "page page-" + pageNum + " " + this._uniqueCssId;
		dojo.attr(page, 'pageindex', pageNum);

		if(!page.parentNode){
			this.tableBody.appendChild(page);
			if(this._loadingIndicator){
				// If we have a loading indicator, always make sure it is last in the list so 
				// it will overlay the others.
				this.tableBody.removeChild(this._loadingIndicator.domNode);
				dojo.place(this._loadingIndicator.domNode, this.tableBody);
			}
		}

		return page; /* DOMNode */
	},

	_getPageTop: function(pageNum){
		//	summary:
		//		Returns the cached top position of the page node at index `pageNum`.
		//		If no cached top position exists, it will be calculated, cached, and returned.
		var pts = this._pageTops,
			top = pts[pageNum],
			h = 0,
			avgPageHeight = this._avgRowHeight * this.rowsPerPage;

		if(typeof top != 'undefined' && !isNaN(top)){
			return top;
		}
		var top = 0;
		for(var i=pageNum; i>0; i--){
			if(typeof pts[i] == 'undefined'){
				if(this._pageHeights[i-1] > 0){
					top += this._pageHeights[i-1];
				}else{
					top += avgPageHeight;
				}
			}else{
				top += pts[i];
				break;
			}
		}
		return top; /* Number */
	},

	_getPage: function(pageNum, deltaY){
		//	summary:
		//		Get or prepare the page node at index `pageNum`.
		if(!this._pages){
			this._pages = [];
			this._pageHeights = [];
		}
		if(!this._pageTops){
			this._pageTops = [0];
		}
		if(dojo.indexOf(this._pageStack, pageNum) == -1){
			var page = this._preparePage(pageNum, deltaY);
		}else if(this.tableBody){
			// Only query if table body isn't null, if it is, you
			// end up querying the whole DOM, which can grab pages 
			// from other tables.  This may happen in the case of a fetch
			// returning after a table is destroyed.
			var page = dojo.query(".page-" + pageNum+"." + this._uniqueCssId, this.tableBody)[0];
		}
		this._pages[pageNum] = page;
		return page; /* DOMNode */
	},

	_createPage: function(pageNum){
		//	summary:
		//		Create a page.
		var page = dojo.create('div', {
			role: 'presentation',
			style: {
				position: 'absolute',
				left: "0px"
			}
		});
		/*if(this._avgRowHeight>0){
			page.style.height = (this._avgRowHeight * this.rowsPerPage) + 'px';
		}*/
		return page; /* DOMNode */
	},

	render: function(/* Boolean? */ keepPages){
		//	summary:
		//		Render the table contents.
		//	keepPages: Boolean?
		//		Indicates whether to re-render the pages in the page stack. This will be the
		//		last `this.pagesToKeep` pages rendered.
		//	returns:
		//		A dojo.Deferred that will fire once all rendering has finished.
		if(!this._started){return;}
		//this.onRender();
		this._resetColumns();
		this._idToIndex = {};
		this._indexToItem = [];
		this._idToItem = {};
		this._reindexRemovedRow = 0;
		this._scrollLoadingPage = {};
		if(keepPages){
			var defs = [];
			var ps = this._pageStack.slice(0);
			for(var i=0, len=ps.length; i<len; i++){
				var pageIdx = ps[i],
					page = this._pages[pageIdx];

				// Gotta remove detail widgets before wiping the dom.
				dojo.query(".row-editor-expandPane", page).orphan();
				page.innerHTML = '';
				var def = this._fetch(pageIdx*this.rowsPerPage);
				if(def){
					defs.push(def);
				}
				page = null;
			}
			if(defs.length){
				defs[defs.length-1].addCallback(dojo.hitch(this, function(){
					this.onRender();
				}));
				return new dojo.DeferredList(defs);
			}else{
				var def = new dojo.Deferred();
				def.addCallback(dojo.hitch(this, function(){
					this.onRender();
				}));
				def.callback();
				return def;
			}
		}

		var aph = this._avgRowHeight * this.rowsPerPage;
		for(var i=0, len=this._pages.length; i<len; i++){
			var page = this._pages[i];
			if(typeof page == 'undefined'){
				continue;
			}
			this._invalidatePageNode(i);
			// Need to orphan expand area before destroy
			// or IE will delete the DOM for the expandPage.
			dojo.query(".row-editor-expandPane", page).orphan();
			dojo.destroy(page);
			page = null;
		}

		this._pageStack = [];
		delete this._numPages;
		var def = this.scrollTo(this._lastScrollTop);
		def.addCallback(dojo.hitch(this, function(){
			this.onRender();
		}));
		return def;	/* dojo.Deferred */
	},

	_getPadBorderWidth: (function(){
		//	summary:
		//		Convenience function to calculate and return the padding
		//		and border width only.
		//	returns:
		//		Number
		var gcs = dojo.getComputedStyle,
			px = dojo._toPixelValue,
			ne = 'none';
		return function(n){
			var s= gcs(n),
				be = ((s.borderLeftStyle != ne ? px(n, s.borderLeftWidth) : 0) +
					  (s.borderRightStyle!= ne ? px(n, s.borderRightWidth) : 0)),
				w = px(n, s.paddingLeft) + px(n, s.paddingRight) + be;
				s = n = null;
			return w; /* Number */
		};

		gcs = px = null;
	})(),

	_adjustSizes: function(layout){
		if(!this._started){ return; }

		var scrollBar = this._getScrollBarDims();
			
			//containerBox = dojo.marginBox(this.tableContainer),
			// Use position if possible, cheaper.
		var containerBox = dojo.position(this.tableContainer),
			box = dojo.marginBox(this.domNode),
			contentMinusScrollbar = this._contentBoxWidth - scrollBar.w,
			css = this._css;

		var headerCells = dojo.query('> td', this.tableHeadRow),
			gpbw = this._getPadBorderWidth;

		this._columns.forEach(function(column, i){
			var node = headerCells[i].firstChild;
			if(column._pwidth){
				column.width = containerBox.w * column._pwidth;
			}

			if(column.children){
				var groupCells = dojo.query('.group-row .' + css.groupCellContainer, node);
				var column_width = 0;
				column.children.forEach(function(gcolumn, j){
					if(gcolumn._pwidth){
						gcolumn.width = containerBox.w * gcolumn._pwidth;
					}
					var node = groupCells[j].firstChild,
						cw = gcolumn._contentWidthDifference = gpbw(node),
						diff = gcolumn.width - cw;
					if(diff > 0){
						node.style.width = diff + 'px';
					}

					column_width += (gcolumn.width + gpbw(groupCells[j]));
				});
				if(!column.width){
					column.width = column_width;
				}
			}
			var cw = column._contentWidthDifference = gpbw(node),
				diff = column.width - cw;
			if(!isNaN(column.width) && diff > 0){
				node.style.width = diff + 'px';
			}
			if(column._pwidth){
				dojo.query(".cell-" + i + "." + this._uniqueCssId, this.domNode).style("width", column.width + "px");
			}
			node = null;
		}, this);
		//var widthUsed = dojo.marginBox(this.tableHead).w;
		// Use position if possible, much cheaper.
		var widthUsed = dojo.position(this.tableHead).w;

		this._overflowY = this.tableBody.clientHeight > this._contentBoxHeight;

		if(!this._overflowY){
			if(widthUsed > this._contentBoxWidth){
				this.tableBody.style.width = widthUsed + 'px';
				this._overflowX = true;
			}else{
				this.tableBody.style.width = this._contentBoxWidth + 'px';
				this._overflowX = false;
			}
			dojo.style(this.tableContainer, {
				overflowX: "auto",
				overflowY: "hidden"
			});
		}else{
			if(widthUsed > contentMinusScrollbar){
				this.tableBody.style.width = widthUsed + 'px';
				this._overflowX = true;
			}else{
				this.tableBody.style.width = contentMinusScrollbar + 'px';
				this._overflowX = false;
			}
			dojo.style(this.tableContainer, {
				overflowX: "auto",
				overflowY: "scroll"
			});

			// Set the loader indicator width, if present.
			if(this._loadingIndicator){
				try{
					var contentWidth = dojo.style(this.tableContainer, "width");
					if(!this._overflowY){
						dojo.style(this._loadingIndicator.domNode, "width", contentWidth + "px");
					}else{
						var sDims = this._getScrollBarDims();
						dojo.style(this._loadingIndicator.domNode, "width", (contentWidth - (sDims.w)) + "px");
					}
				}catch(e) { /* ignore.  IE sometimes throws on shutdown. */}
			}
		}
		if(this._emptyTableHScrollControl && this.tableHeadRow){
			// Style the width on the scroll control to match the headers, this will 'force'
			// scrolling, even if the table is empty (and allows locked rows to scroll in
			// that case.
			var hrw = dojo.position(this.tableHeadRow).w;
			if(hrw > 0){
				dojo.style(this._emptyTableHScrollControl, "width", hrw + "px");
			}
		}
	},

	resize: function(changeSize, resultSize){
		this._resize(changeSize, resultSize);
  		// Callback for widget to adjust size of its children.
		this.layout();
	},

	_resize: function(changeSize, resultSize){
		// Use position if posible, much cheaper.
		//var thcmb = dojo.marginBox(this.tableHeadNodeContainer),
		//	tfcmb = dojo.marginBox(this.tableFootContainer),
		//	rltmb = dojo.marginBox(this.tableRowTopNodeContainer),
		//	rlbmb = dojo.marginBox(this.tableRowBottomNodeContainer),

                var thcmb = dojo.position(this.tableHeadNodeContainer),
                        tfcmb = dojo.position(this.tableFootContainer),
                        rltmb = dojo.position(this.tableRowTopNodeContainer),
                        rlbmb = dojo.position(this.tableRowBottomNodeContainer);

			// Use position over contentBox, as contentBox may include scrollers and
			// cause weird sizing outside of a container.  Scrollers are calced off
			// later anyway in _adjustSizes.
			// dcb = dojo.position(this.domNode),
		var dcb = dojo.position(this.domNode);
		var addedHeight = 0;

		//	Figure out if we are a child of a layout and if so, also grab the heights of the children.
		var p = this.getParent();
		if(p && p.isLayoutContainer){
			//	we are a child of a layout container.
			dcb = p._contentBox || dcb;
			dojo.forEach(p.getChildren(), function(child){
				if (child != this){
					var style = child.domNode.style;
					if ( !(style && style.display == 'none'))
						addedHeight += dojo.marginBox(child.domNode).h;
				}
			}, this);
		}
		this._contentBoxWidth = dcb.w;
		this._contentBoxHeight = Math.max(0, dcb.h - thcmb.h - tfcmb.h - rltmb.h - rlbmb.h - addedHeight);
		if(this._avgRowHeight>0){
			this._bottomRowAvg = this._contentBoxHeight / this._avgRowHeight;
		}

		this._adjustSizes();
	},

	// utilities
	getColumns: function(){
		//	summary:
		//		Get a reference to the internal Columns object for this table.
		return this._columns; 	//	xwt.widget.table.Columns
	},

	_createColumns: function(/* Object[]|xwt.widget.table.Column[] */ columns_def){
		//	summary:
		//		Creates the internal Columns structure for this table.
		this._columns=new xwt.widget.table.Columns(columns_def, this);

		return this; // xwt.widget.table.Table
	},

	_getScrollBarDims: function(){
		// getScrollbar metrics node
		if (this._scrollDims){
			return this._scrollDims;
		}
		try{
			var scroll = {};
			var n=dojo.doc.createElement("div");
			n.style.cssText = "top:0;left:0;width:100px;height:100px;overflow:scroll;position:absolute;visibility:hidden;";
			dojo.body().appendChild(n);
			scroll.w = (n.offsetWidth - n.clientWidth) || 15;
			scroll.h = (n.offsetHeight - n.clientHeight) || 15;
			dojo.body().removeChild(n);
			delete n;
		}catch(e){console.warn(e);}

		this._scrollDims = scroll;
		return scroll;
	},

	_resetColumns: function(){
		var thead = this.tableHeadInnerContainer,
			table = this;
		dojo.query("*", thead).orphan();
		var cols = this.getColumns();
		var cells = new dojox.string.Builder('<table style="overflow:hidden;" cellpadding="0" cellspacing="0" border="0" role="presentation"><tbody><tr>');

		if(cols && cols.columns && cols.columns.length>0){
			cols.forEach(function(column){
				column._createCell(-1, cells, table);
			});
		}
		cells.append('</tr></tbody></table>');

		thead.innerHTML = cells.toString();
		this.tableHead = this.tableHeadInnerContainer.firstChild;
		this.tableHeadRow = dojo.query("tr", this.tableHeadInnerContainer)[0];

		var css = this._css;
		dojo.addClass(this.tableHead, css.head);
		dojo.attr(this.tableHead, 'role', 'presentation');
		//	Check for locked rows, and reset those as well.
		if(this._hasLockedRows()){
			var sb = new dojox.string.Builder(), i=0;
			for(var id in this._lockedItems){
				cols._createRow(null, sb, i++, this._lockedItems[id]);
			}
			var c = (this._visibleLockedContainer == "top" ? "Top" : "Bottom"),
				inner = this["tableRow" + c + "InnerContainer"];

			inner.innerHTML = sb.toString();

			//	Post-process
			dojo.query("." + this._css.row, inner).forEach(function(node){
				// CSCth63766:
				// Clear the selection when lock applied.
				var item = this._lockedItems[id];
				dojo.removeClass(node, this._css.row + "-" + dojo.attr(node, "rowindex"));
				dojo.removeClass(node, this._css.row + "-even");
				dojo.removeClass(node, this._css.row + "-odd");

				var indexes = dojo.query(".row-index", node);
				dojo.forEach(indexes, function(node){
					dojo.attr(node, "title", "");
					var cellTitles = dojo.query(".cell", node);
					dojo.forEach(cellTitles, function(cell){
						dojo.attr(cell, "title", "");
					});
				});
 
				// Leave locked rows selectable and such.
                                // CSCth63766 related.
				//dojo.removeClass(node, "selected");
				//var inputs = dojo.query("input.selection-input", node);
				//inputs.attr("disabled", true);
				//inputs.attr("checked", false);
			}, this);
			xwt.widget.table.ellipsizeCells && xwt.widget.table.ellipsizeCells(this, inner, true);
		}

		if(this._source){
			this._source.sync();
		}

		xwt.widget.table.ellipsizeCells && xwt.widget.table.ellipsizeCells(this, thead, true);
	},

	scrollTo: function(top, deltaY, forceRefresh){
		//	summary:
		//		Calculates and loads pages as the user scrolls.  NOTE: This does not
		//		actually scroll the table, it only loads paged data.
		//	top: Number
		//		The location to scroll to, in pixels.
		//	deltaY: Number
		//		The distance along the Y axis that was traversed.
		//	forceRefresh: Boolean
		//		A 'privateish' variable used to indicate if a page should be forcibly 
		//		reloaded or not, even if in cache.  Used by Table APIs.  
		//		Generally not for public use.
		//	returns:
		//		A dojo.Deferred or dojo.DeferredList which fires when rendering is complete.
		var defs = [],
			def = null;

		if(!this._avgRowHeight || this._avgRowHeight < 22){
			this._avgRowHeight = 22;
		}
		
		var topViewRowAvg = top / this._avgRowHeight,
			bottomViewRowAvg = (top + this._contentBoxHeight) / this._avgRowHeight;

		var pageThreshold = this.rowScrollThreshold;
		var topPageNum = Math.floor(Math.max(topViewRowAvg - pageThreshold,0) / this.rowsPerPage),
			topPage = this._pages[topPageNum];
		if(!topPage || !topPage.firstChild || dojo.attr(topPage, 'pageindex') != topPageNum){
			//console.log('fetch top', topPageNum);
			// Make sure we're not already in the middle of a page load for the noted page.
			if(!this._scrollLoadingPage[topPageNum]){
				this._scrollLoadingPage[topPageNum] = true;
				def = this._fetch(topPageNum*this.rowsPerPage, deltaY, forceRefresh);
				if(def){
					def.addCallback(dojo.hitch(this, function() { delete this._scrollLoadingPage[topPageNum]; }));
					def.addErrback(dojo.hitch(this, function() { delete this._scrollLoadingPage[topPageNum]; }));
					defs.push(def);
				}else{
					delete this._scrollLoadingPage[topPageNum];
				}
			}
		}

		var pageNum = Math.min(Math.floor(Math.min(bottomViewRowAvg + pageThreshold,this._totalRows) / this.rowsPerPage), (this._numPages || 1) - 1);
		var pageDiff = pageNum - topPageNum,
			fetchedPageDiffs = pageDiff > 1;

		while(pageDiff > 1){
			pageDiff--;
			var diffPage = pageNum-pageDiff;
			if(!this._pages[diffPage]){
				//console.log('fetch diff', diffPage);
				// If we are scrolling up and don't have a top page, we don't
				// want to pass a negative delta or that page will be replaced
				// and repositioned.
				def = this._fetch(diffPage*this.rowsPerPage, (deltaY<0 && !topPage) ? 1 : deltaY, forceRefresh);
				if(def){
					defs.push(def);
				}
			}
		}

		if(pageNum >= 0 && pageNum <= this._numPages){
			var bottomPage = this._pages[pageNum];
			if(!bottomPage || !bottomPage.firstChild || dojo.attr(bottomPage, 'pageindex') != pageNum){
				// Make sure we're not already in the middle of a page load for the noted page.
				if(!this._scrollLoadingPage[pageNum]){
					// If we are scrolling up and do not have a top page or
					// had to fetch pages inbetween, we don't want to pass
					// a negative delta or that page will be replaced
					// and repositioned.
					this._scrollLoadingPage[pageNum] = true;
					def = this._fetch(pageNum*this.rowsPerPage, (deltaY<0 && (!topPage || fetchedPageDiffs)) ? 1 : deltaY, forceRefresh);
					if(def){
						def.addCallback(dojo.hitch(this, function() { delete this._scrollLoadingPage[pageNum]; }));
						def.addErrback(dojo.hitch(this, function() { delete this._scrollLoadingPage[pageNum]; }));
						defs.push(def);
					}else{
						delete this._scrollLoadingPage[pageNum];
					}
				}
			}
		}

		if(defs.length){
			return new dojo.DeferredList(defs);
		}else{
			var def = new dojo.Deferred();
			if(forceRefresh){
				// Okay, we're probably at the bottom, should we force the refresh?
				this._scrollLoadingPage[pageNum] = true;
				def = this._fetch(pageNum*this.rowsPerPage, 1, forceRefresh);
				def.addCallback(dojo.hitch(this, function() { delete this._scrollLoadingPage[pageNum]; }));
				def.addErrback(dojo.hitch(this, function() { delete this._scrollLoadingPage[pageNum]; }));
			}else{
				def.callback();
			}
			return def;
		}
	},

	scrollToRow: function(rowIndex, forceRefresh){
		//	summary:
		//		Scrolls the table to `rowIndex`.
		//	rowIndex: Number
		//		The row to scroll to.
		//	forceRefresh: boolean
		//		A 'private' boolean to indicate if the page containing the row should be 
		//		forcibly reloaded or not.  Used by Table APIs.  Generally not for public use.
		//	returns:
		//		A dojo.Deferred or dojo.DeferredList which fires when rendering is complete.
		var scrollTop;
		if(rowIndex >= this._totalRows){
			scrollTop = dojo.marginBox(this.tableBody).h - this._contentBoxHeight;
			scrollTop = scrollTop < 0 ? 0 : scrollTop;
		}else{
			var node = dojo.query('.' + this._css.row + '-' + rowIndex + "." + this._uniqueCssId, this.tableBody)[0];
			if(node){
				scrollTop = dojo.marginBox(node).t + dojo.marginBox(node.parentNode).t;
			}else{
				var pageNum = Math.floor(rowIndex/this.rowsPerPage),
					// Removed, may be causing issues.
					//page = this._getPage(pageNum),
					rowsToPage = pageNum * this.rowsPerPage,
					pageTop = this._getPageTop(pageNum);
				if(rowsToPage == rowIndex){
					scrollTop = pageTop;
				}else{
					scrollTop = (pageTop + ((rowIndex - rowsToPage) * this._avgRowHeight));
				}
			}
		}
		
		var oldST = this._lastScrollTop;
		this._lastScrollTop = scrollTop;
		var self = this;
		var def = new dojo.Deferred();
		this.scrollTo(scrollTop, scrollTop - oldST, forceRefresh).addCallback(function(){
			// Give browser some pause/render time before moving.
			setTimeout(function() {
				self.tableContainer.scrollTop = scrollTop; 
				setTimeout(function(){
					// Pause to allow for rendering.
					def.callback();
				},0);
			},0);
		});
		return def;
	},

	_clearDisplay: function(){
		dojo.query("." + this._uniqueCssId + " [tabIndex=" + this.tabIndex + "]", this.tableBody).attr("tabIndex", "-1");
		dojo.query("." + this._css.focused + "." + this._uniqueCssId, this.tableBody).removeClass(this._css.focused);
		dojo.query("." + this._css.selected + "." + this._uniqueCssId, this.tableBody).removeClass(this._css.selected);
	},
	
	_gotoRow: function(rowIndex){
		return this.scrollToRow(rowIndex);
	},

	_getFocusedItem: function(){
		if(this._focusedNode){
			return this._indexToItem[dojo.attr(this._focusedNode, "rowindex")];
		}
		return null;
	},

	_focus: function(idx){
        //    The index to focus on.  This should probably be the index of an item
        //    within our store.
        //console.log("Focusing on index: ", idx);
        if(idx === undefined){ return; }
        var pageNum = Math.floor(idx/this.rowsPerPage),
            //Removed:  May be causing issues.
            //page = this._getPage(pageNum),
            rowsToPage = pageNum * this.rowsPerPage,
            startRow = rowsToPage, endRow = rowsToPage + this.rowsPerPage;
        if(idx < rowsToPage || idx > endRow){
            this.scrollToRow(idx);
        }
        var item = this._indexToItem[idx];
        var f;
        if(item){
            // Locating by index tends to work better.
            var id = this.store.getIdentity(item);
            f = dojo.query("." + this._css.row + "-itemid-" + this._santizeIdentityForCss(id) + "." + this._uniqueCssId, this.tableBody)[0];
        }else{
            f = dojo.query("." + this._css.row + "-" + idx + "." + this._uniqueCssId, this.tableBody)[0];
        }
        
        if(f && this._focusedNode != f){
            if(this._focusedNode) { dojo.removeClass(this._focusedNode, this._css.focused); }
            this._focusedNode = f;
            dojo.addClass(this._focusedNode, this._css.focused);
            dijit.focus(f);
        }
    },

	_rowFromTarget: function(e){
		var node = e.target;
		while(node && !dojo.attr(node, "item-id") && node != this.tableBody){
			node = node.parentNode;
		}
		return node;
	},

	/* nbhattac - QVHint start */
	_cellNumFromTarget: function(e){
		// summary:
		//	Tries to detect what cell number we happen to be in while hovering over the row.
		// e: event
		//	The DOM hover event.
		// returns:
		//	A number indicating the cell index, or null if not in a cell.
		// tags:
		//	Private
		if(!e) {return;}
		var cell = e.target;
		while(cell && !dojo.hasClass(cell, "page") && !dojo.hasClass(cell, "cell-container") && cell != this.tableBody){
			cell = cell.parentNode;
		}		
		if(cell && dojo.hasClass(cell, "cell-container")){
			return dojo.attr(cell, "columnidx");	
		}
		return null;
	},
	/* nbhattac - QVHint end */
	
	_columnFromTarget: function(e){
		var node = e.target;
		while(node && !dojo.attr(node, "columnIdx") && node != this.tableBody){
			node = node.parentNode;
		}
		return node ? this.getColumns().getByNode(node) : null;
	},

	_onClick: function(e){
		//	get the row this belongs to.
		var node = this._rowFromTarget(e);
		if(node){
			var itemId = dojo.attr(node, "item-id");
			if(itemId != null){
				if(this._lockedItems){
					if(this._lockedItems[itemId]){
						// CSCth63766 related
						// Locked row, ignore the click
						// no focus change, just indicate click.
						this.onClick(this._lockedItems[itemId]);
						return;
					}
				}
			}

			var idx = dojo.attr(node, "rowindex"),
				item = this._indexToItem[idx];
			if(this.editing()){
				var col = this._columnFromTarget(e);
				
				/*
				if(col && col.columnType == xwt.widget.table.ColumnTypes.COLUMN && item){
					this.edit(item);
				}
				*/
			}
			this._focus(dojo.attr(node, "rowindex"));
			if(item){
				this.onClick(item);
			}
		}
	},

	_onKeyDown: function(e){
		switch(e.keyCode){
			case dojo.keys.ESCAPE:
				if(this.editing()){
					//	kick us out of edit mode.
					this.cancelEdit();
				}
				if(this._focusedNode){
					var idx = dojo.attr(this._focusedNode, "rowindex");
					this._focus(idx);
				}
				dojo.stopEvent(e);
				break;
			case dojo.keys.HOME:
				//	behavior: reset the focus to the first row.
				if(this.editing()){
					// Do nothing in edit mode.
					return;
				}
				this._focus(0);
				dojo.stopEvent(e);
				break;
			case dojo.keys.END:
				//	behavior: reset the focus to the last row.
				if(this.editing()){
					// Do nothing in edit mode.
					return;
				}
				this._focus(this._totalRows - 1);
				dojo.stopEvent(e);
				break;
			case dojo.keys.PAGE_UP:
				//	behavior: move up one full page.
				if(this.editing()){
					// Do nothing in edit mode.
					return;
				}
				if(this._focusedNode){
					var idx = parseInt(dojo.attr(this._focusedNode, "rowindex")),
						idxTo = Math.max(idx - this.rowsPerPage, 0);
					this._focus(idxTo);
					if(this.editing()){
						var item = this._indexToItem[idxTo];
						if(item){ this.edit(item); }
					}
				}
				dojo.stopEvent(e);
				break;
			
			case dojo.keys.PAGE_DOWN:
				if(this.editing()){
					// Do nothing in edit mode.
					return;
				}
				//	behavior: move down one full page.				
				if(this._focusedNode){
					var idx = parseInt(dojo.attr(this._focusedNode, "rowindex")),
						idxTo = Math.min(idx + this.rowsPerPage, this._totalRows -1);
					this._focus(idxTo);
					if(this.editing()){
						var item = this._indexToItem[idxTo];
						if(item){ this.edit(item); }
					}
				}
				dojo.stopEvent(e);
				break;
			
			case dojo.keys.UP_ARROW:
				//	behavior: if not in edit mode, move the focus up one row.  Intercept in edit mode.
				if(this.editing()){
					// Do nothing in edit mode.
					return;
				}
				if(this._focusedNode){
					var idx = parseInt(dojo.attr(this._focusedNode, "rowindex"));
					if(idx == 0){ break; }
					this._focus(idx - 1);
				}
				dojo.stopEvent(e);
				break;
			
			case dojo.keys.DOWN_ARROW:
				//	behavior: if not in edit mode, move the focus one row down. Intercept in edit mode.
				if(this.editing()){
					// Do nothing in edit mode.
					return;
				}
				if(this._focusedNode){
					var idx = parseInt(dojo.attr(this._focusedNode, "rowindex"));
					if(idx + 1 >= this._totalRows){ break; }
					this._focus(idx + 1);
				}
				dojo.stopEvent(e);
				break;
			case dojo.keys.ENTER:
		//	case dojo.keys.SPACE:	//	TODO: reimplement but ignore if the actual focus is an edit widget.
				//	Behavior if not in edit mode and select is available: select the row.
				//	Note that we're doing it onkeyup because neither Safari or Firefox fire these keys with
				//	onkeypress.
				if(this._focusedNode){
					var idx = dojo.attr(this._focusedNode, "rowindex"),
						item = this._indexToItem[idx];
					if(this.editing()){
						// Do nothing in edit mode.
						return;
					}else if(this.selectByIndex && item){
						this[(this.isSelected(item)?"deselect":"select")](item);
						dojo.stopEvent(e);
					}
				}
				break;
		}
	},

	borders: function(/* Boolean */show, /* Boolean? */last){
		//	summary:
		//		Turn row borders on or off.
		//	show: Boolean
		//		Turn the borders on or off.
		//	last: Boolean?
		//		Whether or not to show the last border (bottom-most row).  Defaults to true.
		//	returns:
		//		'this' to allow for functional chaining.
		//	this._columns.borders(show, last);
		var css = this._css;
		dojo.toggleClass(this.tableBody, css.rowBorders, show);
		dojo.toggleClass(this.tableBody, css.rowLastBorder, !!last);
		return this;	//	xwt.widget.table.Table
	},

	//	Row locking.
	//	Private methods to deal with a range of rows, to prevent constant table rendering.
	_lockRange: function(items){
		var show = false,
			locked = false,
			c = (this._visibleLockedContainer == "top" ? "Top" : "Bottom"),
			container = this["tableRow" + c + "NodeContainer"],
			inner = this["tableRow" + c + "InnerContainer"];

		dojo.forEach(items, function(item, i){
			var id = this.store.getIdentity(item),
				idx = this._idToIndex[id];
			if(this._lockedItems[id]){ return; }
			if(!show){ show = true; }
			this._lockedItems[id] = item;
			var row = dojo.query("." + this._css.row + "-" + idx + "." + this._uniqueCssId, this.tableBody)[0];
			if(row){
				// CSCth63766
				// De-select the item/row.
				this.deselect(item);
				dojo.removeClass(row, this._css.row + "-" + idx);
				dojo.removeClass(row, this._css.row + "-even");
				dojo.removeClass(row, this._css.row + "-odd");

				// Leave locked rows selectable and such.
				// CSCth63766-related, but go ahead and clear the selection off it.
				//dojo.removeClass(row, "selected");
				//var inputs = dojo.query("input.selection-input", row);
				//inputs.attr("disabled", true);
				//inputs.attr("checked", false);
				dojo.place(row, inner);
				if(!locked){ locked = true; }
			}
		}, this);

		//	Check to make sure this isn't already locked.
		if(show){
			dojo.style(container, "display", "");
		}

		xwt.widget.table.ellipsizeCells && xwt.widget.table.ellipsizeCells(this, container, true);
		return locked;
	},
	_unlockRange: function(items){
		// summary:
		//	Unlocks a series of items.
		if(!items){
			items = [];
		}
		var c = this._visibleLockedContainer == "top" ? "Top" : "Bottom",
			container = this["tableRow" + c + "InnerContainer"];
                dojo.forEach(items, function(item){
			if(this.isLocked(item)){
				var id = this.store.getIdentity(item);
				this.deselect(item);
				delete this._lockedItems[id];
				dojo.query("." + this._css.row + "-itemid-" + this._santizeIdentityForCss(id) + "." + this._uniqueCssId + ".row-locked", container).orphan();
				var rows = dojo.query("." + this._css.row + "-itemid-" + this._santizeIdentityForCss(id) + "." + this._uniqueCssId + ".row-locked", this.tableBody);
				dojo.forEach(rows, function(row){
					dojo.removeClass(row, "row-locked");
				});
			} 
                },this);
		return true;
	},
	_hasLockedRows: function(){
		return this._visibleLockedContainer != null;
	},

	lock: function(/* dojo.data.item|dojo.data.item[] */items, /* Boolean? */lockToTop){
		//	summary:
		//		Lock the rows that are representing an item or items.
		//	items: dojo.data.item|dojo.data.item[]
		//		The item(s) to be locked.
		//	lockToTop: Boolean?
		//		Whether or not to lock this row to the top or bottom of the table.
		//		Defaults to false (lock to bottom).  Note that if there is already
		//		a row that is locked, this will be ignored and the new locked row
		//		will be placed at the same position as existing rows.
		//
		//	example:
		//		Lock a row to the bottom of a Table:
		//	|	myTable.lock(myTable.selected());
		//
		//	returns:
		//		'this' to allow for functional chaining.
		if(!items){ return this; }
		if(this.expanded && this.expanded()){
			this.getExpander()._collapseRow();
		}
		if(!this._visibleLockedContainer){
			//	Neither container is being used yet, so set that now and deal with showing it.
			this._visibleLockedContainer = (lockToTop ? "top":"bottom");
		}
		if(!dojo.isArray(items)){ items = [ items ]; }
		var locked = this._lockRange(items);
		if(locked){
			//	only re-render and resize if something actually happened.
			var self = this;
			this.render(true);
			this.resize();
			this.onLock(items);
		}
		return this;	//	xwt.widget.Table
	},
	unlock: function(items){
		//	summary:
		//		Unlocks the items specified. If no item is specified, 
		//		it unlocks all the items.
		//	items:
		//		The list of items to unlock.
		//	example:
		//		Unlock all locked rows and lock another to the top of the table.
		//	|	myTable.unlock().lock(myOtherItem, true);
		//	
		//	returns:
		//		'this' to allow for functional chaining.

		//	pass this along to _unlockRange.
		if(!items){
			items = this.lockedItems();
		}
		var unlocked = this._unlockRange(items);
		if(unlocked){
			var c = this._visibleLockedContainer == "top" ? "Top" : "Bottom",
				container = this["tableRow" + c + "NodeContainer"];
			if(container){
				var lockedRows = dojo.query(".row." + this._uniqueCssId, container);  
				if(!lockedRows || !lockedRows.length){
					dojo.style(container, "display", "none");
					this._visibleLockedContainer = null;
				}
				this.render(true);
				this.resize();
				this.onUnlock();
			}
		}
		return this;	//	xwt.widget.table.Table
	},
	lockedItems: function() {
		// summary:
		//	Returns the items that are locked or fixed in the table.
		// tags:
		//	public
		var lockedItems = [];
		if(this._lockedItems){
			var id;
			for(id in this._lockedItems){
				lockedItems.push(this._lockedItems[id]);
			}
		}
		return lockedItems;
	},
	isLocked: function(item){
		// summary:
		//	Determines if an item is a locked item (locked to top or bottom).
		// item: Item
		//	A datastore item.
		if(this._lockedItems && this.store.isItem(item) && this._lockedItems[this.store.getIdentity(item)]){
			return true;
		}
		return false;
	},

	//	private mapping methods; always assume an array, and let map make it "not an array".
	_mapRowsToItems: function(rows){
		return dojo.map(rows, function(row){
			return this._indexToItem[dojo.attr(row, "rowindex")];
		}, this);
	},
	_mapRowsToIndexes: function(rows){
		return dojo.map(rows, function(row){
			return dojo.attr(row, "rowindex");
		}, this);
	},
	_mapItemsToIndexes: function(items){
		return dojo.map(items, function(item){
			return this._idToIndex[this.store.getIdentity(item)];
		}, this);
	},
	_mapItemsToRows: function(items){
		var idxs = this._mapItemsToIndexes(items),
			qs = dojo.map(idxs, function(idx){
				return ".row-" + idx + "." + this._uniqueCssId;
			});
		return dojo.query(qs.join(","), this.domNode);
	},
	_mapIndexesToItems: function(arr){
		return dojo.map(arr, function(idx){
			return this._indexToItem[idx];
		}, this);
	},
	_mapIndexesToRows: function(arr){
		var qs = dojo.map(arr, function(idx){
			return ".row-" + idx + "." + this._uniqueCssId;
		});
		return dojo.query(qs.join(","), this.domNode);
	},

	//	Generic methods for dealing with data
	map: function(/* xwt.widget.table.Table.__mapArgs */args){
		//	summary:
		//		Given arg, return the corresponding type.  The Type can be "item",
		//		"row" or "index".  If arg is an array, it is assumed that it is
		//		"typed" (i.e., it is all Nodes, all Numbers, etc.), and an array will be
		//		returned.  Otherwise, a single item will be returned.
		//	
		//	example:
		//		For a NodeList of rows, get the corresponding items:
		//	|	myTable.map({
		//	|		data: dojo.query(".row", this.domNode),
		//	|		type: "node",
		//	|		returnType: "item"
		//	|	}).addCallback(function(items){
		//	|		console.log(items);
		//	|	}).addErrback(function(err){
		//	|		console.warn(err);
		//	|	});
		//
		//	returns:
		//		A dojo.Deferred so that callback functions to handle the mapping can
		//		be added (in case there are items that are not yet fetched, etc.).
		if(!args.type || !args.returnType || (args.type == args.returnType)){
			throw new Error("xwt.widget.table.Table.map: you must define the incoming and outgoing types, and they must be different.");
		}
		var dfd = args.deferred || new dojo.Deferred(),
			inputIsArray = dojo.isArray(args.data),
			results, err;
		this.onMap(args);
		try {
			switch(args.type){
				case "item": {
					if(args.returnType == "number"){
						results = this._mapItemsToIndexes(inputIsArray?args.data:[args.data]);
					}
					else if(args.returnType == "node"){
						results = this._mapItemsToRows(inputIsArray?args.data:[args.data]);
					}
					break;
				}
				case "node": {
					if(args.returnType == "number"){
						results = this._mapRowsToIndexes(inputIsArray?args.data:[args.data]);
					}
					else if(args.returnType == "item"){
						results = this._mapRowsToItems(inputIsArray?args.data:[args.data]);
					}
					break;
				}
				case "number": {
					if(args.returnType == "item"){
						results = this._mapIndexesToItems(inputIsArray?args.data:[args.data]);
					}
					else if(args.returnType == "node"){
						results = this._mapIndexesToRows(inputIsArray?args.data:[args.data]);
					}
					break;
				}
			}
		} catch(ex) {
			err = ex;
		}

		if(results){
			args.returnData = inputIsArray ? results : results[0];
		}
		window.setTimeout(function(){
			if(err){
				dfd.errback(err);
			} else {
				dfd.callback(args.returnData);
			}
		}, 10);
		return dfd;	//	dojo.Deferred
	},
	
	moveUp: function(){
		return this._move(true);
	},
	
	moveDown: function(){
		return this._move(false);
	},
	
	_move: function(up){
		//	summary:
		//		Move the selected item.
		//	tags:
		//		callback
		var self = this;

		//	We want to find the smallest selected item index.
		var endIndex = Math[up?"min":"max"].apply(null, dojo.map(this.selected(), function(item){
			return self._idToIndex[self.store.getIdentity(item)];
		}));
		if(up ? endIndex > 0 : self._indexToItem.length - 1 > endIndex){
			var index = endIndex + (up ? -1 : 1);
			return this.moveTo(index, up);
		}

		//	If we got here, the index was invalid so return a deferred that does nothing.
		var dfd = new dojo.Deferred();
		dfd.callback();
		return dfd;
	},
	
	moveTo: function(index, up){
		index = Number(index);
		if(this._sortedColumn){
			this._sortedColumn.sorted = false;
			delete this._sortedColumn;
		}
		var selectedBeforeIndex = 0;
		var self = this;
		var selected = this.selected();
		if(up){
			dojo.forEach(selected, function(item){
				var selectedIndex = self._idToIndex[self.store.getIdentity(item)];
				if(selectedIndex < index){
					selectedBeforeIndex++;
				}
			});
		}else{
			selectedBeforeIndex = 1;
		}
		index += selectedBeforeIndex;

		return this._fetch(Math.floor((index - 1) / this.rowsPerPage) * this.rowsPerPage, 1).addCallback(function(){
			if(!self._indexToItem[index - 1] && !self._indexToItem[index]){
				throw new Error("Target moveTo location does not exist");
			}
			self.scrollToRow(Math.max(0, index - (up ? selectedBeforeIndex : selected.length)));
			self.store.moveTo(self.selected(), self._indexToItem[index - 1], self._indexToItem[index]);
			self.render(true);
			self.onMove(index);
		});
	},

	//	manual refresh
	refresh: function(){
		//	summary:
		//		Force a render on the table and keep track of when it happened.
		this.render(true);
		this._lastRefresh = new Date();
		this.onRefresh(this._lastRefresh);
		return this._lastRefresh;	//	Date
	},

	//	base table events
	onMap: function(/* xwt.widget.table.Table.__mapArgs */args){
		//	summary:
		//		Event stub called when a call to this.map is made.
		//	tags:
		//		callback
	},
	onLayout: function(){
		//	summary:
		//		Event stub called when a table has been resized or re-layed out.
		//	tags:
		//		callback
	},
	onRender: function(){
		//	summary:
		//		Event stub called when the table is rendered.
		//	tags:
		//		callback
	},
	onHover: function(/* dojo.data.item */item){
		//	summary:
		//		Event stub called when a row is hovered over.
		//	tags:
		//		callback
	},
	onClick: function(/* dojo.data.item */item){
		//	summary:
		//		Event stub called when a row is clicked on.
		//	tags:
		//		callback
	},

	onScroll: function(/* Event */event, /* Number */deltaY, /* Number */deltaX){
		//	summary:
		//		Event stub called when the table's contents are scrolled.
		//	tags:
		//		callback
	},
	onLock: function(/* Node[] */row){
		//	summary:
		//		Event stub called when a row is locked.
		//	tags:
		//		callback
	},
	onUnlock: function(){
		//	summary:
		//		Event stub called when a row is unlocked.
		//	tags:
		//		callback
	},
	onMove: function(){
		//	summary:
		//		Event stub called when a row is moved.
		//	tags:
		//		callback
	},
	onRefresh: function(/* Date */dt){
		//	summary:
		//		Event stub called when table is manually refreshed.
		//	tags:
		//		callback
	},

	showQVHint: function(/* Node */ row, /* Node */ cell) {
		// summary:
		//		Called to check if the cell can display QuickViewHint.
		// tags:
		// 		callback
	},

	_closeQuickView: function(event)
	{
		if (this.quickview)
		{
			this.quickview.widget.close(event);
		}

	},
	_onContentScroll: function(event){
		//If a QuickView was provided and is open, scrolling should close it - CSCth98814
		if(this.quickview){
			// New behavior, disconnect the pointer, which will
			// clear the anchor and such.
			//this.quickview.widget.displayPointer(false);
			//newer behavior: close the quickview on user scroll - CSCto91637
			this._closeQuickView(event);
		}
		
		if(document.activeElement){
			var elem = document.activeElement;
			if(elem && elem.nodeType == 1){
				if(elem != dojo.body()){
					elem.blur();
				}
			}
		}
	
		var scrollLeft = event.target.scrollLeft,
			scrollTop = event.target.scrollTop,
			deltaX = scrollLeft - this._lastScrollLeft,
			deltaY = scrollTop - this._lastScrollTop;
		if(deltaX != 0){
			this.tableHeadNodeContainer.scrollLeft = scrollLeft;
			this.tableFootContainer.scrollLeft = scrollLeft;
			this.tableRowTopNodeContainer.scrollLeft = scrollLeft;
			this.tableRowBottomNodeContainer.scrollLeft = scrollLeft;
			this._lastScrollLeft = scrollLeft;
			if(dojo.isIE < 8){
				// Work around IE7 render glitch on scrollers for the
				// top/bottom containers. CSCth90800.
				if(dojo.style(this.tableRowTopNodeContainer, "display") != "none"){
					this.tableRowTopNodeContainer.className = this.tableRowTopNodeContainer.className;
				}
				if(dojo.style(this.tableRowBottomNodeContainer, "display") != "none"){
					// For some reason, touching the lower row has a perf hit, so put this in a timeout.
					// May just be due to being lower down in the doc under a complex set of nodes.
					if(this._ie7BottomRowFix){
						clearTimeout(this._ie7BottomRowFix);
					}	
					this._ie7BottomRowFix = setTimeout(dojo.hitch(this, function(){
						this.tableRowBottomNodeContainer.className = this.tableRowBottomNodeContainer.className; 
					}), 10);
				}
			}
		}

		if(this._scrollTimeout){
			window.clearTimeout(this._scrollTimeout);
			this._scrollTimeout = null;
		}

		var self = this;
		this._scrollTimeout = window.setTimeout(function(){
			if(deltaY != 0){
				self.scrollTo(scrollTop, deltaY);
				self._lastScrollTop = scrollTop;
			}
			self.onScroll(event, deltaY, deltaX);
			this._scrollTimeout = null;
		},this.scrollFetchDelay);
	},

	destroy: function(){
		if(this._liTimer){
			clearInterval(this._liTimer);
			delete this._liTimer;
		}
		if(this._loadingIndicator){
			this._loadingIndicator.destroy();	
			delete this._loadingIndicator
		}
		try{
			if(this._fetchMap){
				// Clean up any in-flight store requests,
				// if possible.
				for(fetchNum in this._fetchMap){
					var entry = this._fetchMap[fetchNum];
					if(entry){
						var f = entry.storeRequest;
						if(f && dojo.isFunction(f.abort)){
							f.abort();
						}
					}
				}
				delete this._fetchMap;
			}
		}catch(e){
			console.log("error in stopping fetches: " + e);
			/* Squelch errors.*/
		}

		this.inherited(arguments);

		// Clean up the references to the page nodes.
		if (this._pages) {
			for (var i = 0, len = this._pages.length; i < len; i++) {
				this._pages[i] = null;
			}
		}

		dojo.forEach(this._columns_conn, dojo.disconnect);

		this._source.destroy();
		this._overTargetBox = this._currentOverColumnNode = null;

		// If we're using the wrapper custom store in Filter.js, we need to do some
		// cleanup too, as it has connects to disconnect.
		if(this.store && this.store.declaredClass == "xwt.widget.table.Filters.FilteringWrapperStore"){
			if(this.store.destroy){
				this.store.destroy();
			}
		}
	},

	_onColumnResize: function(column){
		this._adjustSizes(false);
		this._invalidatePageHeights();
	},

	_onColumnMove: function(column, oldIndex, newIndex){
		this.render(true);
	},

	_onColumnShowOrHide: function(){
		this._invalidatePageHeights();
	},

	_onFocus: function(e){
		dojo.addClass(this.domNode, "focused");
		this.onFocus(e);
	},

	onFocus: function(e){
		//this.log(this.id,'onFocus(), shiftKey:', this._shiftKeyDown);
	},

	_onBlur: function(){
		this._shiftKeyDown=false;
		dojo.query(".focused" + "." + this._uniqueCssId, this.domNode).removeClass('focused');
		dojo.removeClass(this.domNode, "focused");
		this.onBlur();
	},

	onBlur: function(){
	},

	onDoubleClick: function(item,t,itemIndex,e){
		//this.log('onDoubleClick', arguments);
	},

	_onHeaderClick: function(e){
		//this.log("onHeaderClick(): ", arguments, this.sortAttributes)
		var column = this._columns.getByNode(e.target);
		if(!column){
			return;
		}

		if(this._sortable){
			var direction = column.sorted;
			if(!direction||direction=='descending'){
				this.sort(column, 'ascending');
			}else{
				this.sort(column, 'descending');
			}
		}
	},

	onLoadStart: function(){
		// summary:
		//	An event that fires when a new load of data begins.
		// tags:
		//	public
	},

	_onLoadStart: function(){
		// summary:
		//	Internal function that keeps track of when a load has actually 'started'.
		// tags:
		//	private
		if(!this._loadingPageCount){
			this._loadingPageCount = 1;
			this.onLoadStart();
		}else{
			this._loadingPageCount++;
		}
	},

	onLoadEnd: function() {
		// summary:
		//	An event that fires when the loading of data ends 
		//	(the current set of 'pages' being loaded).
		// tags:
		//	public
	},

	_onLoadEnd: function(){
		// summary:
		//	Internal function to track if page loading is in process or not.
		// tags:
		//	private
		if(this._loadingPageCount > 0){
			this._loadingPageCount--;
		}
		if(!this._loadingPageCount){
			this.onLoadEnd();
		}
	},

	_onLoadError: function(error){
		// summary:
		// tags:
		//	private
		
		console.log("error in getting data");
		var page = this._getPage(0);
		if(page){
			// In the case of a destroyed table and the fetch actually calls
			// after, then only update if you actually get a page.  Destroyed
			// tables may return null for a page.

			// Adjust the scroll of the viewport to move back to the top/left.
			this._lastScrollTop = 0;
			this.tableContainer.scrollTop = 0;
			this.tableContainer.scrollLeft = 0;

			// Gotta remove detail widgets before wiping the dom.
			dojo.query(".row-editor-expandPane", page).orphan();

			page.innerHTML = this.l10n.noData;
			dojo.addClass(page, 'no-results');
			window.setTimeout(dojo.hitch(this, function(){
				//var pmb = dojo.marginBox(page),
				// Try using the cheaper dojo.position, as marginBox is expensive.
				var height = dojo.position(page).h;
				// Set the page to page top 0, since that is the basic page position
				// request.
				var pt = this._getPageTop(0);
				this._pageHeights[0] = height; 
				this._pageTops[1] =  pt + height;
				page.style.top = pt + "px";
				dojo.style(page, "visibility", "visible");
				this._calculateRowHeights();
				page = null;
			}), 0);
		}
		this.onLoadError(error);
	},
	
	onLoadError: function(error){
		// summary:
		//	An event that fires when the loading of data has error 
		//	(the current set of 'pages' being loaded).
		// tags:
		//	public
	},

	onRowCountUpdate: function(count){
		// summary:
		//	Stub function that is called when the row count in the table changes, 
		//	as per the store querying.
		// count: int
		//	The new row count.
		// tags:
		//	public
	},
	onRowExpand: function (item, row)
	{
		//	summary:
		//		Stub function for when a row expand pane is expanded.
		//	item: dojo.data.Item
		//		The item which is being expanded.
		//	row: DOMNode
		//		The row which is being expanded.
	},
	onRowCollapse: function(item, row){
		//	summary:
		//		Stub function for when a row expand pane is collapsed.
		//	item: dojo.data.Item
		//		The item which is being collapsed.
		//	row: DOMNode
		//		The row which is being collapsed.
	}
});

xwt.widget.table.Table.markupFactory = function(props, node, ctor, column_func){
	var attr = dojo.attr,
		trim = dojo.trim,
		boolProp = function(node, property, column){
			var value = attr(node, property);
			if(value == 'true'){
				column[property] = true;
			}else if(value == 'false'){
				column[property] = false;
			}
		},
		createColumn = function(th, idx, fromGroup){
			var column_def = {
				width: parseInt(attr(th, 'width'),10)
			};

			var labelNode = null;
			for(var i=0, node; node=th.childNodes[i]; i++){
				if(node.nodeType == 3){
					labelNode = node;
					break;
				}
			}
			node = null;
			if(labelNode){
				column_def.label = trim(labelNode.nodeValue);
				column_def.attr = trim(attr(th, 'attr')||'')||null;
			}

			boolProp(th, 'locked', column_def);
			boolProp(th, 'hidden', column_def);
			boolProp(th, 'sortable', column_def);
			boolProp(th, 'filterable', column_def);
			boolProp(th, 'editable', column_def);
			boolProp(th, 'wrapping', column_def);

			var title = trim(attr(th, 'title')||'');
			if(title){
				column_def.title = title;
			}

			var editWidget = attr(th, 'editWidget');
			if(editWidget){
				column_def.editWidget = dijit.byId(editWidget);
			}

			var sorted = trim(attr(th, 'sorted')||'');
			if(sorted == 'ascending' || sorted == 'descending'){
				column_def.sorted = sorted;
			}else if(sorted == 'false'){
				column_def.sorted = false;
			}

			var filterType = trim(attr(th, 'filterType')||'');
			if(filterType){
				column_def.filterType = filterType;
			}

			var alignment = trim(attr(th, 'align')||'');
			if(alignment == 'left' || alignment == 'center' || alignment == 'right'){
				column_def.alignment = alignment;
			}

			var valign = trim(attr(th, 'valign')||'');
			if(valign == 'top' || valign == 'middle' || valign == 'bottom'){
				column_def.vAlignment = valign;
			}

			var formatter = attr(th, 'formatter');
			if(formatter){
				column_def.formatter = dojo.getObject(formatter);
			}

			if(column_func){
				column_func(th, idx, fromGroup, column_def);
			}

			if(!fromGroup){
				var childNodes = dojo.query('> div', th);
				if(childNodes.length){
					column_def.children = childNodes.map(function(div, idx){
						return createColumn(div, idx, true);
					});
				}
			}
			return column_def;
		};

	//	If a columns property was not passed, look for a structure attribute,
	//	otherwise parse the thread of the given declarative table.
	if(!props.columns){
		var structure = attr(node, 'structure');
		if(structure){
			props.columns = dojo.getObject(structure);
		}
		else if(node.nodeName.toLowerCase() == 'table'){
			props.columns = dojo.query("thead > tr > th", node).map(function(th, idx){
				return createColumn(th, idx, false);
			});
		}
	}	

	var showIndex = attr(node, 'showIndex');
	if(showIndex && showIndex == 'true'){
		props.index = true;
	}

	var detailWidget = attr(node, 'detailWidget');
	if(detailWidget){
		props.detailWidget = dijit.byId(detailWidget);
	}

    //Before we create editors, let's check if any of the columns are actually marked editable - Alka. For CSCth37468
	//Need to know abt editing before setting selection properties, since we cannot allow "row" selection if table is editable.
	//hence moving this check before selection.
	var isInlineEditable = false;
    dojo.forEach(props.columns, function(col){
        if (col.editable) {
            if (col.editable === true) {
                isInlineEditable = true;
                return;
            }
        }
    });

	//console.log(props);
	//	SELECT PLUGIN DEFINITIONS
	var selectMultiple = attr(node, 'selectMultiple'),
		selectAllOption = attr(node, 'selectAllOption'),
		selectModel = attr(node, 'selectModel'),
		disableSelectAllMessage = attr(node, "disableSelectAllMessage"),
		disableSelectAllHardLimitMessage = attr(node, "disableSelectAllHardLimitMessage"),
		disableShiftSelectWarning = attr(node, "disableShiftSelectWarning"),
		selectAllLimit = attr(node, "selectAllLimit");
		selectAllHardLimit = attr(node, "selectAllHardLimit");

	if(selectMultiple||selectModel||selectAllOption){
		var select = props.select = {};
		if(selectMultiple == 'true'){
			select.multiple = true;
		}else if(selectMultiple == 'false'){
			select.multiple = false;
		}
		if(selectAllOption == 'true'){
			select.selectAllOption = true;
		}else if(selectAllOption == 'false'){
			select.selectAllOption = false;
		}

		//XMPGUI-44 removed check for selectModel.Null handled by select.js
		if (isInlineEditable) {
			//if table is editable, doesnt matter what the user set
			//selection model will be "input"
			selectModel = select.model = "input";
		}
		else 
		{
			select.model = selectModel;
		}
		
		if(selectAllLimit) { selectAllLimit = parseInt(selectAllLimit, 10); }
		if(selectAllLimit) { select.selectAllLimit = selectAllLimit; }
		if(selectAllHardLimit) { selectAllHardLimit = parseInt(selectAllHardLimit, 10); }
		if(selectAllHardLimit) { select.selectAllHardLimit = selectAllHardLimit; }
		
		if(disableSelectAllMessage) { select.disableSelectAllMessage = (disableSelectAllMessage.toLowerCase() == "true" ? true : false); }
		if(disableSelectAllHardLimitMessage) { select.disableSelectAllHardLimitMessage = (disableSelectAllHardLimitMessage.toLowerCase() == "true" ? true : false); }
		if(disableShiftSelectWarning) { select.disableShiftSelectWarning = (disableShiftSelectWarning.toLowerCase() == "true" ? true : false); }
	}

	//	EDIT PLUGIN DEFINITIONS
		var editImmediate = attr(node, 'immediateCommit'), editDefault = attr(node, 'defaultItem'), editDialog = attr(node, 'dialogEditor');
		//If there are no editable rows, immediate is meaningless, so we just ignore it,
		//but we need others.
		if (!isInlineEditable) {
			editImmediate = null;
		}
		if (isInlineEditable) {
			//there is no more immediate=true mode, but for backward compatiblity, if someone does set it to true, we make it false here
			//TOOD cleanup later in 1.6.x
			editImmediate = 'false';
			
			if (editImmediate || editDefault || editDialog) {
				var edit = props.edit = {};
				if (editImmediate == 'true') {
					edit.immediate = true;
				}
				if (editDefault) {
					edit.itemTemplate = dojo.getObject(editDefault);
				}
				if (editDialog) {
					edit.dialog = dijit.byId(editDialog);
				}
				
			}
		}
	//	PRESET FILTERS, if available
	var filters = attr(node, 'filters');
	if(filters){
		var filters = props.filters = dojo.getObject(filters);
		if(!filters){
			// Nothing provided, so set to empty.
			filters = [];
			props.filters = [];
		}
	}
	//	FILTER DELAY
	var filterDelay = attr(node, 'filterDelay');
	if(filterDelay){
		props.filterDelay = parseInt(filterDelay, 10);
	}

	//	FILTER ON SERVER
	var filterOnServer = attr(node, 'filterOnServer');
	if(filterOnServer){
		props.filterOnServer = filterOnServer;
	}
	
	var quickFilterDefault = attr(node, 'quickFilterDefault') || "All";
	if(quickFilterDefault){
		props.quickFilterDefault = quickFilterDefault;
	}
	
	//Query Options
	var qOptions = attr(node, 'queryOptions');
	 if (qOptions) {
	 	try {
	 		props.qOptions = dojo.getObject(qOptions) || dojo.fromJson(qOptions);
	 	} 
	 	catch (e) {
	 		console.warn(e);
	 	}
	 }

	//	QUICK VIEW PLUGIN
	var quickviewer = attr(node, 'quickViewer');
	if(quickviewer){
		var qv = props.quickview = { };
		qv.widget = dijit.byId(quickviewer);
		var evt = attr(node, 'quickViewEvent');
		if(evt){
			qv.onEvent = evt;
		}
		var delay = attr(node, 'quickViewDelay');
		if(delay){
			qv.delay = !isNaN(parseInt(delay,10)) && parseInt(delay, 10);
		}
        
		var quickViewHoverDisplayDelay = attr(node, "quickViewHoverDisplayDelay");
		if(quickViewHoverDisplayDelay) { 
			quickViewHoverDisplayDelay = parseInt(quickViewHoverDisplayDelay, 10);
			if(!isNaN(quickViewHoverDisplayDelay)) { 
				qv.quickViewHoverDisplayDelay = quickViewHoverDisplayDelay; 
			}
		}
	}
	return new ctor(props, node);
};

}

if(!dojo._hasResource["dojo.data.ItemFileWriteStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.ItemFileWriteStore"] = true;
dojo.provide("dojo.data.ItemFileWriteStore");


dojo.declare("dojo.data.ItemFileWriteStore", dojo.data.ItemFileReadStore, {
	constructor: function(/* object */ keywordParameters){
		//	keywordParameters: {typeMap: object)
		//		The structure of the typeMap object is as follows:
		//		{
		//			type0: function || object,
		//			type1: function || object,
		//			...
		//			typeN: function || object
		//		}
		//		Where if it is a function, it is assumed to be an object constructor that takes the 
		//		value of _value as the initialization parameters.  It is serialized assuming object.toString()
		//		serialization.  If it is an object, then it is assumed
		//		to be an object of general form:
		//		{
		//			type: function, //constructor.
		//			deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
		//			serialize:	function(object) //The function that converts the object back into the proper file format form.
		//		}

		// ItemFileWriteStore extends ItemFileReadStore to implement these additional dojo.data APIs
		this._features['dojo.data.api.Write'] = true;
		this._features['dojo.data.api.Notification'] = true;
		
		// For keeping track of changes so that we can implement isDirty and revert
		this._pending = {
			_newItems:{}, 
			_modifiedItems:{}, 
			_deletedItems:{}
		};

		if(!this._datatypeMap['Date'].serialize){
			this._datatypeMap['Date'].serialize = function(obj){
				return dojo.date.stamp.toISOString(obj, {zulu:true});
			};
		}
		//Disable only if explicitly set to false.
		if(keywordParameters && (keywordParameters.referenceIntegrity === false)){
			this.referenceIntegrity = false;
		}

		// this._saveInProgress is set to true, briefly, from when save() is first called to when it completes
		this._saveInProgress = false;
	},

	referenceIntegrity: true, //Flag that defaultly enabled reference integrity tracking.  This way it can also be disabled pogrammatially or declaratively.

	_assert: function(/* boolean */ condition){
		if(!condition){
			throw new Error("assertion failed in ItemFileWriteStore");
		}
	},

	_getIdentifierAttribute: function(){
		var identifierAttribute = this.getFeatures()['dojo.data.api.Identity'];
		// this._assert((identifierAttribute === Number) || (dojo.isString(identifierAttribute)));
		return identifierAttribute;
	},
	
	
/* dojo.data.api.Write */

	newItem: function(/* Object? */ keywordArgs, /* Object? */ parentInfo){
		// summary: See dojo.data.api.Write.newItem()

		this._assert(!this._saveInProgress);

		if(!this._loadFinished){
			// We need to do this here so that we'll be able to find out what
			// identifierAttribute was specified in the data file.
			this._forceLoad();
		}

		if(typeof keywordArgs != "object" && typeof keywordArgs != "undefined"){
			throw new Error("newItem() was passed something other than an object");
		}
		var newIdentity = null;
		var identifierAttribute = this._getIdentifierAttribute();
		if(identifierAttribute === Number){
			newIdentity = this._arrayOfAllItems.length;
		}else{
			newIdentity = keywordArgs[identifierAttribute];
			if(typeof newIdentity === "undefined"){
				throw new Error("newItem() was not passed an identity for the new item");
			}
			if(dojo.isArray(newIdentity)){
				throw new Error("newItem() was not passed an single-valued identity");
			}
		}
		
		// make sure this identity is not already in use by another item, if identifiers were 
		// defined in the file.  Otherwise it would be the item count, 
		// which should always be unique in this case.
		if(this._itemsByIdentity){
			this._assert(typeof this._itemsByIdentity[newIdentity] === "undefined");
		}
		this._assert(typeof this._pending._newItems[newIdentity] === "undefined");
		this._assert(typeof this._pending._deletedItems[newIdentity] === "undefined");
		
		var newItem = {};
		newItem[this._storeRefPropName] = this;		
		newItem[this._itemNumPropName] = this._arrayOfAllItems.length;
		if(this._itemsByIdentity){
			this._itemsByIdentity[newIdentity] = newItem;
			//We have to set the identifier now, otherwise we can't look it
			//up at calls to setValueorValues in parentInfo handling.
			newItem[identifierAttribute] = [newIdentity];
		}
		this._arrayOfAllItems.push(newItem);

		//We need to construct some data for the onNew call too...
		var pInfo = null;
		
		// Now we need to check to see where we want to assign this thingm if any.
		if(parentInfo && parentInfo.parent && parentInfo.attribute){
			pInfo = {
				item: parentInfo.parent,
				attribute: parentInfo.attribute,
				oldValue: undefined
			};

			//See if it is multi-valued or not and handle appropriately
			//Generally, all attributes are multi-valued for this store
			//So, we only need to append if there are already values present.
			var values = this.getValues(parentInfo.parent, parentInfo.attribute);
			if(values && values.length > 0){
				var tempValues = values.slice(0, values.length);
				if(values.length === 1){
					pInfo.oldValue = values[0];
				}else{
					pInfo.oldValue = values.slice(0, values.length);
				}
				tempValues.push(newItem);
				this._setValueOrValues(parentInfo.parent, parentInfo.attribute, tempValues, false);
				pInfo.newValue = this.getValues(parentInfo.parent, parentInfo.attribute);
			}else{
				this._setValueOrValues(parentInfo.parent, parentInfo.attribute, newItem, false);
				pInfo.newValue = newItem;
			}
		}else{
			//Toplevel item, add to both top list as well as all list.
			newItem[this._rootItemPropName]=true;
			this._arrayOfTopLevelItems.push(newItem);
		}
		
		this._pending._newItems[newIdentity] = newItem;
		
		//Clone over the properties to the new item
		for(var key in keywordArgs){
			if(key === this._storeRefPropName || key === this._itemNumPropName){
				// Bummer, the user is trying to do something like
				// newItem({_S:"foo"}).  Unfortunately, our superclass,
				// ItemFileReadStore, is already using _S in each of our items
				// to hold private info.  To avoid a naming collision, we 
				// need to move all our private info to some other property 
				// of all the items/objects.  So, we need to iterate over all
				// the items and do something like: 
				//    item.__S = item._S;
				//    item._S = undefined;
				// But first we have to make sure the new "__S" variable is 
				// not in use, which means we have to iterate over all the 
				// items checking for that.
				throw new Error("encountered bug in ItemFileWriteStore.newItem");
			}
			var value = keywordArgs[key];
			if(!dojo.isArray(value)){
				value = [value];
			}
			newItem[key] = value;
			if(this.referenceIntegrity){
				for(var i = 0; i < value.length; i++){
					var val = value[i];
					if(this.isItem(val)){
						this._addReferenceToMap(val, newItem, key);
					}
				}
			}
		}
		this.onNew(newItem, pInfo); // dojo.data.api.Notification call
		return newItem; // item
	},
	
	_removeArrayElement: function(/* Array */ array, /* anything */ element){
		var index = dojo.indexOf(array, element);
		if(index != -1){
			array.splice(index, 1);
			return true;
		}
		return false;
	},
	
	deleteItem: function(/* item */ item){
		// summary: See dojo.data.api.Write.deleteItem()
		this._assert(!this._saveInProgress);
		this._assertIsItem(item);

		// Remove this item from the _arrayOfAllItems, but leave a null value in place
		// of the item, so as not to change the length of the array, so that in newItem() 
		// we can still safely do: newIdentity = this._arrayOfAllItems.length;
		var indexInArrayOfAllItems = item[this._itemNumPropName];
		var identity = this.getIdentity(item);

		//If we have reference integrity on, we need to do reference cleanup for the deleted item
		if(this.referenceIntegrity){
			//First scan all the attributes of this items for references and clean them up in the map 
			//As this item is going away, no need to track its references anymore.

			//Get the attributes list before we generate the backup so it 
			//doesn't pollute the attributes list.
			var attributes = this.getAttributes(item);

			//Backup the map, we'll have to restore it potentially, in a revert.
			if(item[this._reverseRefMap]){
				item["backup_" + this._reverseRefMap] = dojo.clone(item[this._reverseRefMap]);
			}
			
			//TODO:  This causes a reversion problem.  This list won't be restored on revert since it is
			//attached to the 'value'. item, not ours.  Need to back tese up somehow too.
			//Maybe build a map of the backup of the entries and attach it to the deleted item to be restored
			//later.  Or just record them and call _addReferenceToMap on them in revert.
			dojo.forEach(attributes, function(attribute){
				dojo.forEach(this.getValues(item, attribute), function(value){
					if(this.isItem(value)){
						//We have to back up all the references we had to others so they can be restored on a revert.
						if(!item["backupRefs_" + this._reverseRefMap]){
							item["backupRefs_" + this._reverseRefMap] = [];
						}
						item["backupRefs_" + this._reverseRefMap].push({id: this.getIdentity(value), attr: attribute});
						this._removeReferenceFromMap(value, item, attribute);
					}
				}, this);
			}, this);

			//Next, see if we have references to this item, if we do, we have to clean them up too.
			var references = item[this._reverseRefMap];
			if(references){
				//Look through all the items noted as references to clean them up.
				for(var itemId in references){
					var containingItem = null;
					if(this._itemsByIdentity){
						containingItem = this._itemsByIdentity[itemId];
					}else{
						containingItem = this._arrayOfAllItems[itemId];
					}
					//We have a reference to a containing item, now we have to process the
					//attributes and clear all references to the item being deleted.
					if(containingItem){
						for(var attribute in references[itemId]){
							var oldValues = this.getValues(containingItem, attribute) || [];
							var newValues = dojo.filter(oldValues, function(possibleItem){
								return !(this.isItem(possibleItem) && this.getIdentity(possibleItem) == identity);
							}, this);
							//Remove the note of the reference to the item and set the values on the modified attribute.
							this._removeReferenceFromMap(item, containingItem, attribute); 
							if(newValues.length < oldValues.length){
								this._setValueOrValues(containingItem, attribute, newValues, true);
							}
						}
					}
				}
			}
		}

		this._arrayOfAllItems[indexInArrayOfAllItems] = null;

		item[this._storeRefPropName] = null;
		if(this._itemsByIdentity){
			delete this._itemsByIdentity[identity];
		}
		this._pending._deletedItems[identity] = item;
		
		//Remove from the toplevel items, if necessary...
		if(item[this._rootItemPropName]){
			this._removeArrayElement(this._arrayOfTopLevelItems, item);
		}
		this.onDelete(item); // dojo.data.api.Notification call
		return true;
	},

	setValue: function(/* item */ item, /* attribute-name-string */ attribute, /* almost anything */ value){
		// summary: See dojo.data.api.Write.set()
		return this._setValueOrValues(item, attribute, value, true); // boolean
	},
	
	setValues: function(/* item */ item, /* attribute-name-string */ attribute, /* array */ values){
		// summary: See dojo.data.api.Write.setValues()
		return this._setValueOrValues(item, attribute, values, true); // boolean
	},
	
	unsetAttribute: function(/* item */ item, /* attribute-name-string */ attribute){
		// summary: See dojo.data.api.Write.unsetAttribute()
		return this._setValueOrValues(item, attribute, [], true);
	},
	
	_setValueOrValues: function(/* item */ item, /* attribute-name-string */ attribute, /* anything */ newValueOrValues, /*boolean?*/ callOnSet){
		this._assert(!this._saveInProgress);
		
		// Check for valid arguments
		this._assertIsItem(item);
		this._assert(dojo.isString(attribute));
		this._assert(typeof newValueOrValues !== "undefined");

		// Make sure the user isn't trying to change the item's identity
		var identifierAttribute = this._getIdentifierAttribute();
		if(attribute == identifierAttribute){
			throw new Error("ItemFileWriteStore does not have support for changing the value of an item's identifier.");
		}

		// To implement the Notification API, we need to make a note of what
		// the old attribute value was, so that we can pass that info when
		// we call the onSet method.
		var oldValueOrValues = this._getValueOrValues(item, attribute);

		var identity = this.getIdentity(item);
		if(!this._pending._modifiedItems[identity]){
			// Before we actually change the item, we make a copy of it to 
			// record the original state, so that we'll be able to revert if 
			// the revert method gets called.  If the item has already been
			// modified then there's no need to do this now, since we already
			// have a record of the original state.						
			var copyOfItemState = {};
			for(var key in item){
				if((key === this._storeRefPropName) || (key === this._itemNumPropName) || (key === this._rootItemPropName)){
					copyOfItemState[key] = item[key];
				}else if(key === this._reverseRefMap){
					copyOfItemState[key] = dojo.clone(item[key]);
				}else{
					copyOfItemState[key] = item[key].slice(0, item[key].length);
				}
			}
			// Now mark the item as dirty, and save the copy of the original state
			this._pending._modifiedItems[identity] = copyOfItemState;
		}
		
		// Okay, now we can actually change this attribute on the item
		var success = false;
		
		if(dojo.isArray(newValueOrValues) && newValueOrValues.length === 0){
			
			// If we were passed an empty array as the value, that counts
			// as "unsetting" the attribute, so we need to remove this 
			// attribute from the item.
			success = delete item[attribute];
			newValueOrValues = undefined; // used in the onSet Notification call below

			if(this.referenceIntegrity && oldValueOrValues){
				var oldValues = oldValueOrValues;
				if(!dojo.isArray(oldValues)){
					oldValues = [oldValues];
				}
				for(var i = 0; i < oldValues.length; i++){
					var value = oldValues[i];
					if(this.isItem(value)){
						this._removeReferenceFromMap(value, item, attribute);
					}
				}
			}
		}else{
			var newValueArray;
			if(dojo.isArray(newValueOrValues)){
				var newValues = newValueOrValues;
				// Unfortunately, it's not safe to just do this:
				//    newValueArray = newValues;
				// Instead, we need to copy the array, which slice() does very nicely.
				// This is so that our internal data structure won't  
				// get corrupted if the user mucks with the values array *after*
				// calling setValues().
				newValueArray = newValueOrValues.slice(0, newValueOrValues.length);
			}else{
				newValueArray = [newValueOrValues];
			}

			//We need to handle reference integrity if this is on. 
			//In the case of set, we need to see if references were added or removed
			//and update the reference tracking map accordingly.
			if(this.referenceIntegrity){
				if(oldValueOrValues){
					var oldValues = oldValueOrValues;
					if(!dojo.isArray(oldValues)){
						oldValues = [oldValues];
					}
					//Use an associative map to determine what was added/removed from the list.
					//Should be O(n) performant.  First look at all the old values and make a list of them
					//Then for any item not in the old list, we add it.  If it was already present, we remove it.
					//Then we pass over the map and any references left it it need to be removed (IE, no match in
					//the new values list).
					var map = {};
					dojo.forEach(oldValues, function(possibleItem){
						if(this.isItem(possibleItem)){
							var id = this.getIdentity(possibleItem);
							map[id.toString()] = true;
						}
					}, this);
					dojo.forEach(newValueArray, function(possibleItem){
						if(this.isItem(possibleItem)){
							var id = this.getIdentity(possibleItem);
							if(map[id.toString()]){
								delete map[id.toString()];
							}else{
								this._addReferenceToMap(possibleItem, item, attribute); 
							}
						}
					}, this);
					for(var rId in map){
						var removedItem;
						if(this._itemsByIdentity){
							removedItem = this._itemsByIdentity[rId];
						}else{
							removedItem = this._arrayOfAllItems[rId];
						}
						this._removeReferenceFromMap(removedItem, item, attribute);
					}
				}else{
					//Everything is new (no old values) so we have to just
					//insert all the references, if any.
					for(var i = 0; i < newValueArray.length; i++){
						var value = newValueArray[i];
						if(this.isItem(value)){
							this._addReferenceToMap(value, item, attribute);
						}
					}
				}
			}
			item[attribute] = newValueArray;
			success = true;
		}

		// Now we make the dojo.data.api.Notification call
		if(callOnSet){
			this.onSet(item, attribute, oldValueOrValues, newValueOrValues); 
		}
		return success; // boolean
	},

	_addReferenceToMap: function(/*item*/ refItem, /*item*/ parentItem, /*string*/ attribute){
		//	summary:
		//		Method to add an reference map entry for an item and attribute.
		//	description:
		//		Method to add an reference map entry for an item and attribute. 		 //
		//	refItem:
		//		The item that is referenced.
		//	parentItem:
		//		The item that holds the new reference to refItem.
		//	attribute:
		//		The attribute on parentItem that contains the new reference.
		 
		var parentId = this.getIdentity(parentItem);
		var references = refItem[this._reverseRefMap];

		if(!references){
			references = refItem[this._reverseRefMap] = {};
		}
		var itemRef = references[parentId];
		if(!itemRef){
			itemRef = references[parentId] = {};
		}
		itemRef[attribute] = true;
	},

	_removeReferenceFromMap: function(/* item */ refItem, /* item */ parentItem, /*strin*/ attribute){
		//	summary:
		//		Method to remove an reference map entry for an item and attribute.
		//	description:
		//		Method to remove an reference map entry for an item and attribute.  This will
		//		also perform cleanup on the map such that if there are no more references at all to 
		//		the item, its reference object and entry are removed.
		//
		//	refItem:
		//		The item that is referenced.
		//	parentItem:
		//		The item holding a reference to refItem.
		//	attribute:
		//		The attribute on parentItem that contains the reference.
		var identity = this.getIdentity(parentItem);
		var references = refItem[this._reverseRefMap];
		var itemId;
		if(references){
			for(itemId in references){
				if(itemId == identity){
					delete references[itemId][attribute];
					if(this._isEmpty(references[itemId])){
						delete references[itemId];
					}
				}
			}
			if(this._isEmpty(references)){
				delete refItem[this._reverseRefMap];
			}
		}
	},

	_dumpReferenceMap: function(){
		//	summary:
		//		Function to dump the reverse reference map of all items in the store for debug purposes.
		//	description:
		//		Function to dump the reverse reference map of all items in the store for debug purposes.
		var i;
		for(i = 0; i < this._arrayOfAllItems.length; i++){
			var item = this._arrayOfAllItems[i];
			if(item && item[this._reverseRefMap]){
				console.log("Item: [" + this.getIdentity(item) + "] is referenced by: " + dojo.toJson(item[this._reverseRefMap]));
			}
		}
	},
	
	_getValueOrValues: function(/* item */ item, /* attribute-name-string */ attribute){
		var valueOrValues = undefined;
		if(this.hasAttribute(item, attribute)){
			var valueArray = this.getValues(item, attribute);
			if(valueArray.length == 1){
				valueOrValues = valueArray[0];
			}else{
				valueOrValues = valueArray;
			}
		}
		return valueOrValues;
	},
	
	_flatten: function(/* anything */ value){
		if(this.isItem(value)){
			var item = value;
			// Given an item, return an serializable object that provides a 
			// reference to the item.
			// For example, given kermit:
			//    var kermit = store.newItem({id:2, name:"Kermit"});
			// we want to return
			//    {_reference:2}
			var identity = this.getIdentity(item);
			var referenceObject = {_reference: identity};
			return referenceObject;
		}else{
			if(typeof value === "object"){
				for(var type in this._datatypeMap){
					var typeMap = this._datatypeMap[type];
					if(dojo.isObject(typeMap) && !dojo.isFunction(typeMap)){
						if(value instanceof typeMap.type){
							if(!typeMap.serialize){
								throw new Error("ItemFileWriteStore:  No serializer defined for type mapping: [" + type + "]");
							}
							return {_type: type, _value: typeMap.serialize(value)};
						}
					} else if(value instanceof typeMap){
						//SImple mapping, therefore, return as a toString serialization.
						return {_type: type, _value: value.toString()};
					}
				}
			}
			return value;
		}
	},
	
	_getNewFileContentString: function(){
		// summary: 
		//		Generate a string that can be saved to a file.
		//		The result should look similar to:
		//		http://trac.dojotoolkit.org/browser/dojo/trunk/tests/data/countries.json
		var serializableStructure = {};
		
		var identifierAttribute = this._getIdentifierAttribute();
		if(identifierAttribute !== Number){
			serializableStructure.identifier = identifierAttribute;
		}
		if(this._labelAttr){
			serializableStructure.label = this._labelAttr;
		}
		serializableStructure.items = [];
		for(var i = 0; i < this._arrayOfAllItems.length; ++i){
			var item = this._arrayOfAllItems[i];
			if(item !== null){
				var serializableItem = {};
				for(var key in item){
					if(key !== this._storeRefPropName && key !== this._itemNumPropName && key !== this._reverseRefMap && key !== this._rootItemPropName){
						var attribute = key;
						var valueArray = this.getValues(item, attribute);
						if(valueArray.length == 1){
							serializableItem[attribute] = this._flatten(valueArray[0]);
						}else{
							var serializableArray = [];
							for(var j = 0; j < valueArray.length; ++j){
								serializableArray.push(this._flatten(valueArray[j]));
								serializableItem[attribute] = serializableArray;
							}
						}
					}
				}
				serializableStructure.items.push(serializableItem);
			}
		}
		var prettyPrint = true;
		return dojo.toJson(serializableStructure, prettyPrint);
	},

	_isEmpty: function(something){
		//	summary: 
		//		Function to determine if an array or object has no properties or values.
		//	something:
		//		The array or object to examine.
		var empty = true;
		if(dojo.isObject(something)){
			var i;
			for(i in something){
				empty = false;
				break;
			}
		}else if(dojo.isArray(something)){
			if(something.length > 0){
				empty = false;
			}
		}
		return empty; //boolean
	},
	
	save: function(/* object */ keywordArgs){
		// summary: See dojo.data.api.Write.save()
		this._assert(!this._saveInProgress);
		
		// this._saveInProgress is set to true, briefly, from when save is first called to when it completes
		this._saveInProgress = true;
		
		var self = this;
		var saveCompleteCallback = function(){
			self._pending = {
				_newItems:{}, 
				_modifiedItems:{},
				_deletedItems:{}
			};

			self._saveInProgress = false; // must come after this._pending is cleared, but before any callbacks
			if(keywordArgs && keywordArgs.onComplete){
				var scope = keywordArgs.scope || dojo.global;
				keywordArgs.onComplete.call(scope);
			}
		};
		var saveFailedCallback = function(err){
			self._saveInProgress = false;
			if(keywordArgs && keywordArgs.onError){
				var scope = keywordArgs.scope || dojo.global;
				keywordArgs.onError.call(scope, err);
			}
		};
		
		if(this._saveEverything){
			var newFileContentString = this._getNewFileContentString();
			this._saveEverything(saveCompleteCallback, saveFailedCallback, newFileContentString);
		}
		if(this._saveCustom){
			this._saveCustom(saveCompleteCallback, saveFailedCallback);
		}
		if(!this._saveEverything && !this._saveCustom){
			// Looks like there is no user-defined save-handler function.
			// That's fine, it just means the datastore is acting as a "mock-write"
			// store -- changes get saved in memory but don't get saved to disk.
			saveCompleteCallback();
		}
	},
	
	revert: function(){
		// summary: See dojo.data.api.Write.revert()
		this._assert(!this._saveInProgress);

		var identity;
		for(identity in this._pending._modifiedItems){
			// find the original item and the modified item that replaced it
			var copyOfItemState = this._pending._modifiedItems[identity];
			var modifiedItem = null;
			if(this._itemsByIdentity){
				modifiedItem = this._itemsByIdentity[identity];
			}else{
				modifiedItem = this._arrayOfAllItems[identity];
			}
	
			// Restore the original item into a full-fledged item again, we want to try to 
			// keep the same object instance as if we don't it, causes bugs like #9022.
			copyOfItemState[this._storeRefPropName] = this;
			for(key in modifiedItem){
				delete modifiedItem[key];
			}
			dojo.mixin(modifiedItem, copyOfItemState);
		}
		var deletedItem;
		for(identity in this._pending._deletedItems){
			deletedItem = this._pending._deletedItems[identity];
			deletedItem[this._storeRefPropName] = this;
			var index = deletedItem[this._itemNumPropName];

			//Restore the reverse refererence map, if any.
			if(deletedItem["backup_" + this._reverseRefMap]){
				deletedItem[this._reverseRefMap] = deletedItem["backup_" + this._reverseRefMap];
				delete deletedItem["backup_" + this._reverseRefMap];
			}
			this._arrayOfAllItems[index] = deletedItem;
			if(this._itemsByIdentity){
				this._itemsByIdentity[identity] = deletedItem;
			}
			if(deletedItem[this._rootItemPropName]){
				this._arrayOfTopLevelItems.push(deletedItem);
			}
		}
		//We have to pass through it again and restore the reference maps after all the
		//undeletes have occurred.
		for(identity in this._pending._deletedItems){
			deletedItem = this._pending._deletedItems[identity];
			if(deletedItem["backupRefs_" + this._reverseRefMap]){
				dojo.forEach(deletedItem["backupRefs_" + this._reverseRefMap], function(reference){
					var refItem;
					if(this._itemsByIdentity){
						refItem = this._itemsByIdentity[reference.id];
					}else{
						refItem = this._arrayOfAllItems[reference.id];
					}
					this._addReferenceToMap(refItem, deletedItem, reference.attr);
				}, this);
				delete deletedItem["backupRefs_" + this._reverseRefMap]; 
			}
		}

		for(identity in this._pending._newItems){
			var newItem = this._pending._newItems[identity];
			newItem[this._storeRefPropName] = null;
			// null out the new item, but don't change the array index so
			// so we can keep using _arrayOfAllItems.length.
			this._arrayOfAllItems[newItem[this._itemNumPropName]] = null;
			if(newItem[this._rootItemPropName]){
				this._removeArrayElement(this._arrayOfTopLevelItems, newItem);
			}
			if(this._itemsByIdentity){
				delete this._itemsByIdentity[identity];
			}
		}

		this._pending = {
			_newItems:{}, 
			_modifiedItems:{}, 
			_deletedItems:{}
		};
		return true; // boolean
	},
	
	isDirty: function(/* item? */ item){
		// summary: See dojo.data.api.Write.isDirty()
		if(item){
			// return true if the item is dirty
			var identity = this.getIdentity(item);
			return new Boolean(this._pending._newItems[identity] || 
				this._pending._modifiedItems[identity] ||
				this._pending._deletedItems[identity]).valueOf(); // boolean
		}else{
			// return true if the store is dirty -- which means return true
			// if there are any new items, dirty items, or modified items
			if(!this._isEmpty(this._pending._newItems) || 
				!this._isEmpty(this._pending._modifiedItems) ||
				!this._isEmpty(this._pending._deletedItems)){
				return true;
			}
			return false; // boolean
		}
	},

/* dojo.data.api.Notification */

	onSet: function(/* item */ item, 
					/*attribute-name-string*/ attribute, 
					/*object | array*/ oldValue,
					/*object | array*/ newValue){
		// summary: See dojo.data.api.Notification.onSet()
		
		// No need to do anything. This method is here just so that the 
		// client code can connect observers to it.
	},

	onNew: function(/* item */ newItem, /*object?*/ parentInfo){
		// summary: See dojo.data.api.Notification.onNew()
		
		// No need to do anything. This method is here just so that the 
		// client code can connect observers to it. 
	},

	onDelete: function(/* item */ deletedItem){
		// summary: See dojo.data.api.Notification.onDelete()
		
		// No need to do anything. This method is here just so that the 
		// client code can connect observers to it. 
	},

	close: function(/* object? */ request){
		 // summary:
		 //		Over-ride of base close function of ItemFileReadStore to add in check for store state.
		 // description:
		 //		Over-ride of base close function of ItemFileReadStore to add in check for store state.
		 //		If the store is still dirty (unsaved changes), then an error will be thrown instead of
		 //		clearing the internal state for reload from the url.

		 //Clear if not dirty ... or throw an error
		 if(this.clearOnClose){
			 if(!this.isDirty()){
				 this.inherited(arguments);
			 }else{
				 //Only throw an error if the store was dirty and we were loading from a url (cannot reload from url until state is saved).
				 throw new Error("dojo.data.ItemFileWriteStore: There are unsaved changes present in the store.  Please save or revert the changes before invoking close.");
			 }
		 }
	}
});

}

if(!dojo._hasResource["dijit.form.NumberTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.NumberTextBox"] = true;
dojo.provide("dijit.form.NumberTextBox");




/*=====
dojo.declare(
	"dijit.form.NumberTextBox.__Constraints",
	[dijit.form.RangeBoundTextBox.__Constraints, dojo.number.__FormatOptions, dojo.number.__ParseOptions], {
	// summary:
	//		Specifies both the rules on valid/invalid values (minimum, maximum,
	//		number of required decimal places), and also formatting options for
	//		displaying the value when the field is not focused.
	// example:
	//		Minimum/maximum:
	//		To specify a field between 0 and 120:
	//	|		{min:0,max:120}
	//		To specify a field that must be an integer:
	//	|		{fractional:false}
	//		To specify a field where 0 to 3 decimal places are allowed on input,
	//		but after the field is blurred the value is displayed with 3 decimal places:
	//	|		{places:'0,3'}
});
=====*/

dojo.declare("dijit.form.NumberTextBoxMixin",
	null,
	{
		// summary:
		//		A mixin for all number textboxes
		// tags:
		//		protected

		// Override ValidationTextBox.regExpGen().... we use a reg-ex generating function rather
		// than a straight regexp to deal with locale (plus formatting options too?)
		regExpGen: dojo.number.regexp,

		/*=====
		// constraints: dijit.form.NumberTextBox.__Constraints
		//		Despite the name, this parameter specifies both constraints on the input
		//		(including minimum/maximum allowed values) as well as
		//		formatting options like places (the number of digits to display after
		//		the decimal point).   See `dijit.form.NumberTextBox.__Constraints` for details.
		constraints: {},
		======*/

		// value: Number
		//		The value of this NumberTextBox as a javascript Number (ie, not a String).
		//		If the displayed value is blank, the value is NaN, and if the user types in
		//		an gibberish value (like "hello world"), the value is undefined
		//		(i.e. attr('value') returns undefined).
		//
		//		Symetrically, attr('value', NaN) will clear the displayed value,
		//		whereas attr('value', undefined) will have no effect.
		value: NaN,

		// editOptions: [protected] Object
		//		Properties to mix into constraints when the value is being edited.
		//		This is here because we edit the number in the format "12345", which is
		//		different than the display value (ex: "12,345")
		editOptions: { pattern: '#.######' },

		/*=====
		_formatter: function(value, options){
			// summary:
			//		_formatter() is called by format().   It's the base routine for formatting a number,
			//		as a string, for example converting 12345 into "12,345".
			// value: Number
			//		The number to be converted into a string.
			// options: dojo.number.__FormatOptions?
			//		Formatting options
			// tags:
			//		protected extension

			return "12345";		// String
		},
		 =====*/
		_formatter: dojo.number.format,

		postMixInProperties: function(){
			var places = typeof this.constraints.places == "number"? this.constraints.places : 0;
			if(places){ places++; } // decimal rounding errors take away another digit of precision
			if(typeof this.constraints.max != "number"){
				this.constraints.max = 9 * Math.pow(10, 15-places);
			}
			if(typeof this.constraints.min != "number"){
				this.constraints.min = -9 * Math.pow(10, 15-places);
			}
			this.inherited(arguments);
		},

		_onFocus: function(){
			if(this.disabled){ return; }
			var val = this.attr('value');
			if(typeof val == "number" && !isNaN(val)){
				var formattedValue = this.format(val, this.constraints);
				if(formattedValue !== undefined){
					this.textbox.value = formattedValue;
				}
			}
			this.inherited(arguments);
		},

		format: function(/*Number*/ value, /*dojo.number.__FormatOptions*/ constraints){
			// summary:
			//		Formats the value as a Number, according to constraints.
			// tags:
			//		protected

			if(typeof value != "number"){ return String(value); }
			if(isNaN(value)){ return ""; }
			if(("rangeCheck" in this) && !this.rangeCheck(value, constraints)){ return String(value) }
			if(this.editOptions && this._focused){
				constraints = dojo.mixin({}, constraints, this.editOptions);
			}
			return this._formatter(value, constraints);
		},

		/*=====
		parse: function(value, constraints){
			// summary:
			//		Parses the string value as a Number, according to constraints.
			// value: String
			//		String representing a number
			// constraints: dojo.number.__ParseOptions
			//		Formatting options
			// tags:
			//		protected

			return 123.45;		// Number
		},
		=====*/
		parse: dojo.number.parse,

		_getDisplayedValueAttr: function(){
			var v = this.inherited(arguments);
			return isNaN(v) ? this.textbox.value : v;
		},

		filter: function(/*Number*/ value){
			// summary:
			//		This is called with both the display value (string), and the actual value (a number).
			//		When called with the actual value it does corrections so that '' etc. are represented as NaN.
			//		Otherwise it dispatches to the superclass's filter() method.
			//
			//		See `dijit.form.TextBox.filter` for more details.
			return (value === null || value === '' || value === undefined) ? NaN : this.inherited(arguments); // attr('value', null||''||undefined) should fire onChange(NaN)
		},

		serialize: function(/*Number*/ value, /*Object?*/options){
			// summary:
			//		Convert value (a Number) into a canonical string (ie, how the number literal is written in javascript/java/C/etc.)
			// tags:
			//		protected
			return (typeof value != "number" || isNaN(value)) ? '' : this.inherited(arguments);
		},

		_setValueAttr: function(/*Number*/ value, /*Boolean?*/ priorityChange, /*String?*/formattedValue){
			// summary:
			//		Hook so attr('value', ...) works.
			if(value !== undefined && formattedValue === undefined){
				if(typeof value == "number"){
					if(isNaN(value)){ formattedValue = '' }
					else if(("rangeCheck" in this) && !this.rangeCheck(value, this.constraints)){
						formattedValue = String(value);
					}
				}else if(!value){ // 0 processed in if branch above, ''|null|undefined flow thru here
					formattedValue = '';
					value = NaN;
				}else{ // non-numeric values
					formattedValue = String(value);
					value = undefined;
				}
			}
			this.inherited(arguments, [value, priorityChange, formattedValue]);
		},

		_getValueAttr: function(){
			// summary:
			//		Hook so attr('value') works.
			//		Returns Number, NaN for '', or undefined for unparsable text
			var v = this.inherited(arguments); // returns Number for all values accepted by parse() or NaN for all other displayed values

			// If the displayed value of the textbox is gibberish (ex: "hello world"), this.inherited() above
			// returns NaN; this if() branch converts the return value to undefined.
			// Returning undefined prevents user text from being overwritten when doing _setValueAttr(_getValueAttr()).
			// A blank displayed value is still returned as NaN.
			if(isNaN(v) && this.textbox.value !== ''){
				if(this.constraints.exponent !== false && /\de[-+]?|\d/i.test(this.textbox.value) && (new RegExp("^"+dojo.number._realNumberRegexp(dojo.mixin({}, this.constraints))+"$").test(this.textbox.value))){	// check for exponential notation that parse() rejected (erroneously?)
					var n = Number(this.textbox.value);
					return isNaN(n) ? undefined : n; // return exponential Number or undefined for random text (may not be possible to do with the above RegExp check)
				}else{
					return undefined; // gibberish
				}
			}else{
				return v; // Number or NaN for ''
			}
		},

		isValid: function(/*Boolean*/ isFocused){
			// Overrides dijit.form.RangeBoundTextBox.isValid to check that the editing-mode value is valid since
			// it may not be formatted according to the regExp vaidation rules
			if(!this._focused || this._isEmpty(this.textbox.value)){
				return this.inherited(arguments);
			}else{
				var v = this.attr('value');
				if(!isNaN(v) && this.rangeCheck(v, this.constraints)){
					if(this.constraints.exponent !== false && /\de[-+]?\d/i.test(this.textbox.value)){ // exponential, parse doesn't like it
						return true; // valid exponential number in range
					}else{
						return this.inherited(arguments);
					}
				}else{
					return false;
				}
			}
		}
	}
);

dojo.declare("dijit.form.NumberTextBox",
	[dijit.form.RangeBoundTextBox,dijit.form.NumberTextBoxMixin],
	{
		// summary:
		//		A TextBox for entering numbers, with formatting and range checking
		// description:
		//		NumberTextBox is a textbox for entering and displaying numbers, supporting
		//		the following main features:
		//
		//			1. Enforce minimum/maximum allowed values (as well as enforcing that the user types
		//				a number rather than a random string)
		//			2. NLS support (altering roles of comma and dot as "thousands-separator" and "decimal-point"
		//				depending on locale).
		//			3. Separate modes for editing the value and displaying it, specifically that
		//				the thousands separator character (typically comma) disappears when editing
		//				but reappears after the field is blurred.
		//			4. Formatting and constraints regarding the number of places (digits after the decimal point)
		//				allowed on input, and number of places displayed when blurred (see `constraints` parameter).
	}
);

}

if(!dojo._hasResource["dojox.data.AndOrReadStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.data.AndOrReadStore"] = true;
dojo.provide("dojox.data.AndOrReadStore");





dojo.declare("dojox.data.AndOrReadStore", null,{
	//	summary:
	//		AndOrReadStore uses ItemFileReadStore as a base, modifying only the query (_fetchItems) section.
	//		Supports queries of the form: query:"id:1* OR dept:'Sales Department' || (id:2* && NOT dept:S*)"
	//		Includes legacy/widget support via:  
	//			query:{complexQuery:"id:1* OR dept:'Sales Department' || (id:2* && NOT dept:S*)"}
	//		The ItemFileReadStore implements the dojo.data.api.Read API and reads
	//		data from JSON files that have contents in this format --
	//		{ items: [
	//			{ name:'Kermit', color:'green', age:12, friends:['Gonzo', {_reference:{name:'Fozzie Bear'}}]},
	//			{ name:'Fozzie Bear', wears:['hat', 'tie']},
	//			{ name:'Miss Piggy', pets:'Foo-Foo'}
	//		]}
	//		Note that it can also contain an 'identifer' property that specified which attribute on the items 
	//		in the array of items that acts as the unique identifier for that item.
	//
	constructor: function(/* Object */ keywordParameters){
		//	summary: constructor
		//	keywordParameters: {url: String}
		//	keywordParameters: {data: jsonObject}
		//	keywordParameters: {typeMap: object)
		//		The structure of the typeMap object is as follows:
		//		{
		//			type0: function || object,
		//			type1: function || object,
		//			...
		//			typeN: function || object
		//		}
		//		Where if it is a function, it is assumed to be an object constructor that takes the 
		//		value of _value as the initialization parameters.  If it is an object, then it is assumed
		//		to be an object of general form:
		//		{
		//			type: function, //constructor.
		//			deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
		//		}
	
		this._arrayOfAllItems = [];
		this._arrayOfTopLevelItems = [];
		this._loadFinished = false;
		this._jsonFileUrl = keywordParameters.url;
		this._ccUrl = keywordParameters.url;
		this.url = keywordParameters.url;
		this._jsonData = keywordParameters.data;
		this.data = null;
		this._datatypeMap = keywordParameters.typeMap || {};
		if(!this._datatypeMap['Date']){
			//If no default mapping for dates, then set this as default.
			//We use the dojo.date.stamp here because the ISO format is the 'dojo way'
			//of generically representing dates.
			this._datatypeMap['Date'] = {
											type: Date,
											deserialize: function(value){
												return dojo.date.stamp.fromISOString(value);
											}
										};
		}
		this._features = {'dojo.data.api.Read':true, 'dojo.data.api.Identity':true};
		this._itemsByIdentity = null;
		this._storeRefPropName = "_S"; // Default name for the store reference to attach to every item.
		this._itemNumPropName = "_0"; // Default Item Id for isItem to attach to every item.
		this._rootItemPropName = "_RI"; // Default Item Id for isItem to attach to every item.
		this._reverseRefMap = "_RRM"; // Default attribute for constructing a reverse reference map for use with reference integrity
		this._loadInProgress = false; //Got to track the initial load to prevent duelling loads of the dataset.
		this._queuedFetches = [];

		if(keywordParameters.urlPreventCache !== undefined){
			this.urlPreventCache = keywordParameters.urlPreventCache?true:false;
		}
		if(keywordParameters.hierarchical !== undefined){
			this.hierarchical = keywordParameters.hierarchical?true:false;
		}
		if(keywordParameters.clearOnClose){
			this.clearOnClose = true;
		}
	},
	
	url: "", // use "" rather than undefined for the benefit of the parser (#3539)

	//Internal var, crossCheckUrl.  Used so that setting either url or _jsonFileUrl, can still trigger a reload
	//when clearOnClose and close is used.
	_ccUrl: "",

	data: null, //Make this parser settable.

	typeMap: null, //Make this parser settable.

	//Parameter to allow users to specify if a close call should force a reload or not.
	//By default, it retains the old behavior of not clearing if close is called.  But
	//if set true, the store will be reset to default state.  Note that by doing this,
	//all item handles will become invalid and a new fetch must be issued.
	clearOnClose: false,

	//Parameter to allow specifying if preventCache should be passed to the xhrGet call or not when loading data from a url.  
	//Note this does not mean the store calls the server on each fetch, only that the data load has preventCache set as an option.
	//Added for tracker: #6072
	urlPreventCache: false,

	//Parameter to indicate to process data from the url as hierarchical 
	//(data items can contain other data items in js form).  Default is true 
	//for backwards compatibility.  False means only root items are processed 
	//as items, all child objects outside of type-mapped objects and those in 
	//specific reference format, are left straight JS data objects.
	hierarchical: true,

	_assertIsItem: function(/* item */ item){
		//	summary:
		//		This function tests whether the item passed in is indeed an item in the store.
		//	item: 
		//		The item to test for being contained by the store.
		if(!this.isItem(item)){ 
			throw new Error("dojox.data.AndOrReadStore: Invalid item argument.");
		}
	},

	_assertIsAttribute: function(/* attribute-name-string */ attribute){
		//	summary:
		//		This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.
		//	attribute: 
		//		The attribute to test for being contained by the store.
		if(typeof attribute !== "string"){ 
			throw new Error("dojox.data.AndOrReadStore: Invalid attribute argument.");
		}
	},

	getValue: function(	/* item */ item, 
						/* attribute-name-string */ attribute, 
						/* value? */ defaultValue){
		//	summary: 
		//		See dojo.data.api.Read.getValue()
		var values = this.getValues(item, attribute);
		return (values.length > 0)?values[0]:defaultValue; // mixed
	},

	getValues: function(/* item */ item, 
						/* attribute-name-string */ attribute){
		//	summary: 
		//		See dojo.data.api.Read.getValues()

		this._assertIsItem(item);
		this._assertIsAttribute(attribute);
		return item[attribute] || []; // Array
	},

	getAttributes: function(/* item */ item){
		//	summary: 
		//		See dojo.data.api.Read.getAttributes()
		this._assertIsItem(item);
		var attributes = [];
		for(var key in item){
			// Save off only the real item attributes, not the special id marks for O(1) isItem.
			if((key !== this._storeRefPropName) && (key !== this._itemNumPropName) && (key !== this._rootItemPropName) && (key !== this._reverseRefMap)){
				attributes.push(key);
			}
		}
		return attributes; // Array
	},

	hasAttribute: function(	/* item */ item,
							/* attribute-name-string */ attribute){
		//	summary: 
		//		See dojo.data.api.Read.hasAttribute()
		this._assertIsItem(item);
		this._assertIsAttribute(attribute);
		return (attribute in item);
	},

	containsValue: function(/* item */ item, 
							/* attribute-name-string */ attribute, 
							/* anything */ value){
		//	summary: 
		//		See dojo.data.api.Read.containsValue()
		var regexp = undefined;
		if(typeof value === "string"){
			regexp = dojo.data.util.filter.patternToRegExp(value, false);
		}
		return this._containsValue(item, attribute, value, regexp); //boolean.
	},

	_containsValue: function(	/* item */ item, 
								/* attribute-name-string */ attribute, 
								/* anything */ value,
								/* RegExp?*/ regexp){
		//	summary: 
		//		Internal function for looking at the values contained by the item.
		//	description: 
		//		Internal function for looking at the values contained by the item.  This 
		//		function allows for denoting if the comparison should be case sensitive for
		//		strings or not (for handling filtering cases where string case should not matter)
		//	
		//	item:
		//		The data item to examine for attribute values.
		//	attribute:
		//		The attribute to inspect.
		//	value:	
		//		The value to match.
		//	regexp:
		//		Optional regular expression generated off value if value was of string type to handle wildcarding.
		//		If present and attribute values are string, then it can be used for comparison instead of 'value'
		return dojo.some(this.getValues(item, attribute), function(possibleValue){
			if(possibleValue !== null && !dojo.isObject(possibleValue) && regexp){
				if(possibleValue.toString().match(regexp)){
					return true; // Boolean
				}
			}else if(value === possibleValue){
				return true; // Boolean
			}
		});
	},

	isItem: function(/* anything */ something){
		//	summary: 
		//		See dojo.data.api.Read.isItem()
		if(something && something[this._storeRefPropName] === this){
			if(this._arrayOfAllItems[something[this._itemNumPropName]] === something){
				return true;
			}
		}
		return false; // Boolean
	},

	isItemLoaded: function(/* anything */ something){
		//	summary: 
		//		See dojo.data.api.Read.isItemLoaded()
		return this.isItem(something); //boolean
	},

	loadItem: function(/* object */ keywordArgs){
		//	summary: 
		//		See dojo.data.api.Read.loadItem()
		this._assertIsItem(keywordArgs.item);
	},

	getFeatures: function(){
		//	summary: 
		//		See dojo.data.api.Read.getFeatures()
		return this._features; //Object
	},

	getLabel: function(/* item */ item){
		//	summary: 
		//		See dojo.data.api.Read.getLabel()
		if(this._labelAttr && this.isItem(item)){
			return this.getValue(item,this._labelAttr); //String
		}
		return undefined; //undefined
	},

	getLabelAttributes: function(/* item */ item){
		//	summary: 
		//		See dojo.data.api.Read.getLabelAttributes()
		if(this._labelAttr){
			return [this._labelAttr]; //array
		}
		return null; //null
	},

	_fetchItems: function(	/* Object */ keywordArgs, 
							/* Function */ findCallback, 
							/* Function */ errorCallback){
		//	summary: 
		//		See dojo.data.util.simpleFetch.fetch()
		//		filter modified to permit complex queries where
		//			logical operators are case insensitive:  
		//			, NOT AND OR ( ) ! && ||
		//			Note:  "," included for quoted/string legacy queries. 
		var self = this;
		var filter = function(requestArgs, arrayOfItems){
			var items = [];
			if(requestArgs.query){
				//Complete copy, we may have to mess with it.
				//Safer than clone, which does a shallow copy, I believe.
				var query = dojo.fromJson(dojo.toJson(requestArgs.query));
				//Okay, object form query, we have to check to see if someone mixed query methods (such as using FilteringSelect
				//with a complexQuery).  In that case, the params need to be anded to the complex query statement.
				//See defect #7980
				if(typeof query == "object" ){
					var count = 0;
					var p;
					for(p in query){
						count++;
					}
					if(count > 1 && query.complexQuery){
						var cq = query.complexQuery;
						var wrapped = false;
						for(p in query){
							if(p !== "complexQuery"){ 
								//We should wrap this in () as it should and with the entire complex query
								//Not just part of it.
								if(!wrapped){
									cq = "( " + cq + " )";
									wrapped = true;
								}
								//Make sure strings are quoted when going into complexQuery merge.
								var v = requestArgs.query[p];
								if(dojo.isString(v)){
									v = "'" + v + "'";
								}
								cq += " AND " + p + ":" + v;
								delete query[p];
								
							}
						}
						query.complexQuery = cq;
					}
				}

				var ignoreCase = requestArgs.queryOptions ? requestArgs.queryOptions.ignoreCase : false; 
				//for complex queries only:  pattern = query[:|=]"NOT id:23* AND (type:'test*' OR dept:'bob') && !filed:true"
				//logical operators are case insensitive:  , NOT AND OR ( ) ! && ||  // "," included for quoted/string legacy queries.
				if(typeof query != "string"){
					query = dojo.toJson(query);	
					query = query.replace(/\\\\/g,"\\"); //counter toJson expansion of backslashes, e.g., foo\\*bar test.
				}
				query = query.replace(/\\"/g,"\"");   //ditto, for embedded \" in lieu of " availability.
				var complexQuery = dojo.trim(query.replace(/{|}/g,"")); //we can handle these, too.
				var pos2, i;
				if(complexQuery.match(/"? *complexQuery *"?:/)){ //case where widget required a json object, so use complexQuery:'the real query'
					complexQuery = dojo.trim(complexQuery.replace(/"?\s*complexQuery\s*"?:/,""));
					var quotes = ["'",'"'];
					var pos1,colon;
					var flag = false;
					for(i = 0; i<quotes.length; i++){
						pos1 = complexQuery.indexOf(quotes[i]);
						pos2 = complexQuery.indexOf(quotes[i],1);
						colon = complexQuery.indexOf(":",1);
						if(pos1 === 0 && pos2 != -1 && colon < pos2){
							flag = true;
							break;
						} //first two sets of quotes don't occur before the first colon.	
					}	
					if(flag){	//dojo.toJson, and maybe user, adds surrounding quotes, which we need to remove.
						complexQuery = complexQuery.replace(/^\"|^\'|\"$|\'$/g,"");
					}
				} //end query="{complexQuery:'id:1* || dept:Sales'}" parsing (for when widget required json object query).
				var complexQuerySave = complexQuery;
				//valid logical operators.
				var begRegExp = /^,|^NOT |^AND |^OR |^\(|^\)|^!|^&&|^\|\|/i; //trailing space on some tokens on purpose.
				var sQuery = ""; //will be eval'ed for each i-th candidateItem, based on query components.
				var op = "";
				var val = "";
				var pos = -1;
				var err = false;
				var key = "";
				var value = "";
				var tok = "";
				pos2 = -1;
				for(i = 0; i < arrayOfItems.length; ++i){
					var match = true;
					var candidateItem = arrayOfItems[i];
					if(candidateItem === null){
						match = false;
					}else{
						//process entire string for this i-th candidateItem.
						complexQuery = complexQuerySave; //restore query for next candidateItem.
						sQuery = "";
						//work left to right, finding either key:value pair or logical operator at the beginning of the complexQuery string.
						//when found, concatenate to sQuery and remove from complexQuery and loop back.
						while(complexQuery.length > 0 && !err){
							op = complexQuery.match(begRegExp);
							
							//get/process/append one or two leading logical operators.
							while(op && !err){ //look for leading logical operators.
								complexQuery = dojo.trim(complexQuery.replace(op[0],""));
								op = dojo.trim(op[0]).toUpperCase();
								//convert some logical operators to their javascript equivalents for later eval.
								op = op == "NOT" ? "!" : op == "AND" || op == "," ? "&&" : op == "OR" ? "||" : op; 
								op = " " + op + " ";
								sQuery += op;
								op = complexQuery.match(begRegExp);
							}//end op && !err
							
							//now get/process/append one key:value pair.
							if(complexQuery.length > 0){
								pos = complexQuery.indexOf(":");
								if(pos == -1){
									err = true;
									break;
								}else{
									key = dojo.trim(complexQuery.substring(0,pos).replace(/\"|\'/g,""));
									complexQuery = dojo.trim(complexQuery.substring(pos + 1));
									tok = complexQuery.match(/^\'|^\"/);	//quoted?
									if(tok){
										tok = tok[0];
										pos = complexQuery.indexOf(tok);
										pos2 = complexQuery.indexOf(tok,pos + 1);
										if(pos2 == -1){
											err = true;
											break;
										}	
										value = complexQuery.substring(pos + 1,pos2);
										if(pos2 == complexQuery.length - 1){ //quote is last character
											complexQuery = "";
										}else{
											complexQuery = dojo.trim(complexQuery.substring(pos2 + 1));
										}
										sQuery += self._containsValue(candidateItem, key, value, dojo.data.util.filter.patternToRegExp(value, ignoreCase));
									}
									else{ //not quoted, so a space, comma, or closing parens (or the end) will be the break.
										tok = complexQuery.match(/\s|\)|,/);
										if(tok){
											var pos3 = new Array(tok.length);
											for(var j = 0;j<tok.length;j++){ 
												pos3[j] = complexQuery.indexOf(tok[j]);
											}
											pos = pos3[0];
											if(pos3.length > 1){
												for(var j=1;j<pos3.length;j++){
													pos = Math.min(pos,pos3[j]);													
												}
											}
											value = dojo.trim(complexQuery.substring(0,pos));
											complexQuery = dojo.trim(complexQuery.substring(pos));
										}else{ //not a space, so must be at the end of the complexQuery.
											value = dojo.trim(complexQuery);
											complexQuery = "";
										} //end  inner if(tok) else
										sQuery += self._containsValue(candidateItem, key, value, dojo.data.util.filter.patternToRegExp(value, ignoreCase));
									} //end outer if(tok) else
								} //end found ":"
							} //end if(complexQuery.length > 0)
						} //end while complexQuery.length > 0 && !err, so finished the i-th item.
						match = eval(sQuery);
					} //end else is non-null candidateItem.
					if(match){
						items.push(candidateItem);
					}
				} //end for/next of all items.
				if(err){
					//soft fail.
					items = [];
					console.log("The store's _fetchItems failed, probably due to a syntax error in query.");
				}
				findCallback(items, requestArgs);
			}else{
				// No query...
				// We want a copy to pass back in case the parent wishes to sort the array. 
				// We shouldn't allow resort of the internal list, so that multiple callers 
				// can get lists and sort without affecting each other.  We also need to
				// filter out any null values that have been left as a result of deleteItem()
				// calls in ItemFileWriteStore.
				for(var i = 0; i < arrayOfItems.length; ++i){
					var item = arrayOfItems[i];
					if(item !== null){
						items.push(item);
					}
				}
				findCallback(items, requestArgs);
			} //end if there is a query.
		}; //end filter function

		if(this._loadFinished){
			filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions));
		}else{
			if(this._jsonFileUrl !== this._ccUrl){
				dojo.deprecated("dojox.data.AndOrReadStore: ", 
								"To change the url, set the url property of the store," +
								" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
				this._ccUrl = this._jsonFileUrl;
				this.url = this._jsonFileUrl;
			}else if(this.url !== this._ccUrl){
				this._jsonFileUrl = this.url;
				this._ccUrl = this.url;
			}
			//See if there was any forced reset of data.
			if(this.data != null && this._jsonData == null){
				this._jsonData = this.data;
				this.data = null;
			}
			if(this._jsonFileUrl){
				//If fetches come in before the loading has finished, but while
				//a load is in progress, we have to defer the fetching to be 
				//invoked in the callback.
				if(this._loadInProgress){
					this._queuedFetches.push({args: keywordArgs, filter: filter});
				}else{
					this._loadInProgress = true;
					var getArgs = {
							url: self._jsonFileUrl, 
							handleAs: "json-comment-optional",
							preventCache: this.urlPreventCache
						};
					var getHandler = dojo.xhrGet(getArgs);
					getHandler.addCallback(function(data){
						try{
							self._getItemsFromLoadedData(data);
							self._loadFinished = true;
							self._loadInProgress = false;
							
							filter(keywordArgs, self._getItemsArray(keywordArgs.queryOptions));
							self._handleQueuedFetches();
						}catch(e){
							self._loadFinished = true;
							self._loadInProgress = false;
							errorCallback(e, keywordArgs);
						}
					});
					getHandler.addErrback(function(error){
						self._loadInProgress = false;
						errorCallback(error, keywordArgs);
					});
					
					//Wire up the cancel to abort of the request
					//This call cancel on the deferred if it hasn't been called
					//yet and then will chain to the simple abort of the
					//simpleFetch keywordArgs
					var oldAbort = null;
					if(keywordArgs.abort){
						oldAbort = keywordArgs.abort;
					}
					keywordArgs.abort = function(){
						var df = getHandler;
						if(df && df.fired === -1){
							df.cancel();
							df = null;
						}
						if(oldAbort){
							oldAbort.call(keywordArgs);
						}
					};
				}
			}else if(this._jsonData){
				try{
					this._loadFinished = true;
					this._getItemsFromLoadedData(this._jsonData);
					this._jsonData = null;
					filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions));
				}catch(e){
					errorCallback(e, keywordArgs);
				}
			}else{
				errorCallback(new Error("dojox.data.AndOrReadStore: No JSON source data was provided as either URL or a nested Javascript object."), keywordArgs);
			}
		} //end deferred fetching.
	}, //end _fetchItems

	_handleQueuedFetches: function(){
		//	summary: 
		//		Internal function to execute delayed request in the store.
		//Execute any deferred fetches now.
		if(this._queuedFetches.length > 0){
			for(var i = 0; i < this._queuedFetches.length; i++){
				var fData = this._queuedFetches[i];
				var delayedQuery = fData.args;
				var delayedFilter = fData.filter;
				if(delayedFilter){
					delayedFilter(delayedQuery, this._getItemsArray(delayedQuery.queryOptions)); 
				}else{
					this.fetchItemByIdentity(delayedQuery);
				}
			}
			this._queuedFetches = [];
		}
	},

	_getItemsArray: function(/*object?*/queryOptions){
		//	summary: 
		//		Internal function to determine which list of items to search over.
		//	queryOptions: The query options parameter, if any.
		if(queryOptions && queryOptions.deep){
			return this._arrayOfAllItems; 
		}
		return this._arrayOfTopLevelItems;
	},

	close: function(/*dojo.data.api.Request || keywordArgs || null */ request){
		//	summary: 
		//		See dojo.data.api.Read.close()
		if(this.clearOnClose &&
			this._loadFinished &&
			!this._loadInProgress){
			 //Reset all internalsback to default state.  This will force a reload
			 //on next fetch.  This also checks that the data or url param was set 
			 //so that the store knows it can get data.  Without one of those being set,
			 //the next fetch will trigger an error.

			 if(((this._jsonFileUrl == "" || this._jsonFileUrl == null) && 
				 (this.url == "" || this.url == null)
				) && this.data == null){
				 console.debug("dojox.data.AndOrReadStore: WARNING!  Data reload " +
					" information has not been provided." + 
					"  Please set 'url' or 'data' to the appropriate value before" +
					" the next fetch");
			 }
			 this._arrayOfAllItems = [];
			 this._arrayOfTopLevelItems = [];
			 this._loadFinished = false;
			 this._itemsByIdentity = null;
			 this._loadInProgress = false;
			 this._queuedFetches = [];
		 }
	},

	_getItemsFromLoadedData: function(/* Object */ dataObject){
		//	summary:
		//		Function to parse the loaded data into item format and build the internal items array.
		//	description:
		//		Function to parse the loaded data into item format and build the internal items array.
		//
		//	dataObject:
		//		The JS data object containing the raw data to convery into item format.
		//
		// 	returns: array
		//		Array of items in store item format.
		
		// First, we define a couple little utility functions...
		
		var self = this;
		function valueIsAnItem(/* anything */ aValue){
			// summary:
			//		Given any sort of value that could be in the raw json data,
			//		return true if we should interpret the value as being an
			//		item itself, rather than a literal value or a reference.
			// example:
			// 	|	false == valueIsAnItem("Kermit");
			// 	|	false == valueIsAnItem(42);
			// 	|	false == valueIsAnItem(new Date());
			// 	|	false == valueIsAnItem({_type:'Date', _value:'May 14, 1802'});
			// 	|	false == valueIsAnItem({_reference:'Kermit'});
			// 	|	true == valueIsAnItem({name:'Kermit', color:'green'});
			// 	|	true == valueIsAnItem({iggy:'pop'});
			// 	|	true == valueIsAnItem({foo:42});
			var isItem = (
				(aValue !== null) &&
				(typeof aValue === "object") &&
				(!dojo.isArray(aValue)) &&
				(!dojo.isFunction(aValue)) &&
				(aValue.constructor == Object) &&
				(typeof aValue._reference === "undefined") && 
				(typeof aValue._type === "undefined") && 
				(typeof aValue._value === "undefined") &&
				self.hierarchical
			);
			return isItem;
		}
		
		function addItemAndSubItemsToArrayOfAllItems(/* Item */ anItem){
			self._arrayOfAllItems.push(anItem);
			for(var attribute in anItem){
				var valueForAttribute = anItem[attribute];
				if(valueForAttribute){
					if(dojo.isArray(valueForAttribute)){
						var valueArray = valueForAttribute;
						for(var k = 0; k < valueArray.length; ++k){
							var singleValue = valueArray[k];
							if(valueIsAnItem(singleValue)){
								addItemAndSubItemsToArrayOfAllItems(singleValue);
							}
						}
					}else{
						if(valueIsAnItem(valueForAttribute)){
							addItemAndSubItemsToArrayOfAllItems(valueForAttribute);
						}
					}
				}
			}
		}

		this._labelAttr = dataObject.label;

		// We need to do some transformations to convert the data structure
		// that we read from the file into a format that will be convenient
		// to work with in memory.

		// Step 1: Walk through the object hierarchy and build a list of all items
		var i;
		var item;
		this._arrayOfAllItems = [];
		this._arrayOfTopLevelItems = dataObject.items;

		for(i = 0; i < this._arrayOfTopLevelItems.length; ++i){
			item = this._arrayOfTopLevelItems[i];
			addItemAndSubItemsToArrayOfAllItems(item);
			item[this._rootItemPropName]=true;
		}

		// Step 2: Walk through all the attribute values of all the items, 
		// and replace single values with arrays.  For example, we change this:
		//		{ name:'Miss Piggy', pets:'Foo-Foo'}
		// into this:
		//		{ name:['Miss Piggy'], pets:['Foo-Foo']}
		// 
		// We also store the attribute names so we can validate our store  
		// reference and item id special properties for the O(1) isItem
		var allAttributeNames = {};
		var key;

		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i];
			for(key in item){
				if(key !== this._rootItemPropName){
					var value = item[key];
					if(value !== null){
						if(!dojo.isArray(value)){
							item[key] = [value];
						}
					}else{
						item[key] = [null];
					}
				}
				allAttributeNames[key]=key;
			}
		}

		// Step 3: Build unique property names to use for the _storeRefPropName and _itemNumPropName
		// This should go really fast, it will generally never even run the loop.
		while(allAttributeNames[this._storeRefPropName]){
			this._storeRefPropName += "_";
		}
		while(allAttributeNames[this._itemNumPropName]){
			this._itemNumPropName += "_";
		}
		while(allAttributeNames[this._reverseRefMap]){
			this._reverseRefMap += "_";
		}

		// Step 4: Some data files specify an optional 'identifier', which is 
		// the name of an attribute that holds the identity of each item. 
		// If this data file specified an identifier attribute, then build a 
		// hash table of items keyed by the identity of the items.
		var arrayOfValues;

		var identifier = dataObject.identifier;
		if(identifier){
			this._itemsByIdentity = {};
			this._features['dojo.data.api.Identity'] = identifier;
			for(i = 0; i < this._arrayOfAllItems.length; ++i){
				item = this._arrayOfAllItems[i];
				arrayOfValues = item[identifier];
				var identity = arrayOfValues[0];
				if(!this._itemsByIdentity[identity]){
					this._itemsByIdentity[identity] = item;
				}else{
					if(this._jsonFileUrl){
						throw new Error("dojox.data.AndOrReadStore:  The json data as specified by: [" + this._jsonFileUrl + "] is malformed.  Items within the list have identifier: [" + identifier + "].  Value collided: [" + identity + "]");
					}else if(this._jsonData){
						throw new Error("dojox.data.AndOrReadStore:  The json data provided by the creation arguments is malformed.  Items within the list have identifier: [" + identifier + "].  Value collided: [" + identity + "]");
					}
				}
			}
		}else{
			this._features['dojo.data.api.Identity'] = Number;
		}

		// Step 5: Walk through all the items, and set each item's properties 
		// for _storeRefPropName and _itemNumPropName, so that store.isItem() will return true.
		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i];
			item[this._storeRefPropName] = this;
			item[this._itemNumPropName] = i;
		}

		// Step 6: We walk through all the attribute values of all the items,
		// looking for type/value literals and item-references.
		//
		// We replace item-references with pointers to items.  For example, we change:
		//		{ name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
		// into this:
		//		{ name:['Kermit'], friends:[miss_piggy] } 
		// (where miss_piggy is the object representing the 'Miss Piggy' item).
		//
		// We replace type/value pairs with typed-literals.  For example, we change:
		//		{ name:['Nelson Mandela'], born:[{_type:'Date', _value:'July 18, 1918'}] }
		// into this:
		//		{ name:['Kermit'], born:(new Date('July 18, 1918')) } 
		//
		// We also generate the associate map for all items for the O(1) isItem function.
		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i]; // example: { name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
			for(key in item){
				arrayOfValues = item[key]; // example: [{_reference:{name:'Miss Piggy'}}]
				for(var j = 0; j < arrayOfValues.length; ++j){
					value = arrayOfValues[j]; // example: {_reference:{name:'Miss Piggy'}}
					if(value !== null && typeof value == "object"){
						if(("_type" in value) && ("_value" in value)){
							var type = value._type; // examples: 'Date', 'Color', or 'ComplexNumber'
							var mappingObj = this._datatypeMap[type]; // examples: Date, dojo.Color, foo.math.ComplexNumber, {type: dojo.Color, deserialize(value){ return new dojo.Color(value)}}
							if(!mappingObj){ 
								throw new Error("dojox.data.AndOrReadStore: in the typeMap constructor arg, no object class was specified for the datatype '" + type + "'");
							}else if(dojo.isFunction(mappingObj)){
								arrayOfValues[j] = new mappingObj(value._value);
							}else if(dojo.isFunction(mappingObj.deserialize)){
								arrayOfValues[j] = mappingObj.deserialize(value._value);
							}else{
								throw new Error("dojox.data.AndOrReadStore: Value provided in typeMap was neither a constructor, nor a an object with a deserialize function");
							}
						}
						if(value._reference){
							var referenceDescription = value._reference; // example: {name:'Miss Piggy'}
							if(!dojo.isObject(referenceDescription)){
								// example: 'Miss Piggy'
								// from an item like: { name:['Kermit'], friends:[{_reference:'Miss Piggy'}]}
								arrayOfValues[j] = this._itemsByIdentity[referenceDescription];
							}else{
								// example: {name:'Miss Piggy'}
								// from an item like: { name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
								for(var k = 0; k < this._arrayOfAllItems.length; ++k){
									var candidateItem = this._arrayOfAllItems[k];
									var found = true;
									for(var refKey in referenceDescription){
										if(candidateItem[refKey] != referenceDescription[refKey]){ 
											found = false; 
										}
									}
									if(found){ 
										arrayOfValues[j] = candidateItem; 
									}
								}
							}
							if(this.referenceIntegrity){
								var refItem = arrayOfValues[j];
								if(this.isItem(refItem)){
									this._addReferenceToMap(refItem, item, key);
								}
							}
						}else if(this.isItem(value)){
							//It's a child item (not one referenced through _reference).  
							//We need to treat this as a referenced item, so it can be cleaned up
							//in a write store easily.
							if(this.referenceIntegrity){
								this._addReferenceToMap(value, item, key);
							}
						}
					}
				}
			}
		}
	},

	_addReferenceToMap: function(/*item*/ refItem, /*item*/ parentItem, /*string*/ attribute){
		 //	summary:
		 //		Method to add an reference map entry for an item and attribute.
		 //	description:
		 //		Method to add an reference map entry for an item and attribute. 		 //
		 //	refItem:
		 //		The item that is referenced.
		 //	parentItem:
		 //		The item that holds the new reference to refItem.
		 //	attribute:
		 //		The attribute on parentItem that contains the new reference.
		 
		 //Stub function, does nothing.  Real processing is in ItemFileWriteStore.
	},

	getIdentity: function(/* item */ item){
		//	summary: 
		//		See dojo.data.api.Identity.getIdentity()
		var identifier = this._features['dojo.data.api.Identity'];
		if(identifier === Number){
			return item[this._itemNumPropName]; // Number
		}else{
			var arrayOfValues = item[identifier];
			if(arrayOfValues){
				return arrayOfValues[0]; // Object || String
			}
		}
		return null; // null
	},

	fetchItemByIdentity: function(/* Object */ keywordArgs){
		//	summary: 
		//		See dojo.data.api.Identity.fetchItemByIdentity()

		// Hasn't loaded yet, we have to trigger the load.
		if(!this._loadFinished){
			var self = this;
			if(this._jsonFileUrl !== this._ccUrl){
				dojo.deprecated("dojox.data.AndOrReadStore: ", 
								"To change the url, set the url property of the store," +
								" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
				this._ccUrl = this._jsonFileUrl;
				this.url = this._jsonFileUrl;
			}else if(this.url !== this._ccUrl){
				this._jsonFileUrl = this.url;
				this._ccUrl = this.url;
			}
			//See if there was any forced reset of data.
			if(this.data != null && this._jsonData == null){
				this._jsonData = this.data;
				this.data = null;
			}
			if(this._jsonFileUrl){

				if(this._loadInProgress){
					this._queuedFetches.push({args: keywordArgs});
				}else{
					this._loadInProgress = true;
					var getArgs = {
							url: self._jsonFileUrl, 
							handleAs: "json-comment-optional",
							preventCache: this.urlPreventCache
					};
					var getHandler = dojo.xhrGet(getArgs);
					getHandler.addCallback(function(data){
						var scope = keywordArgs.scope?keywordArgs.scope:dojo.global;
						try{
							self._getItemsFromLoadedData(data);
							self._loadFinished = true;
							self._loadInProgress = false;
							var item = self._getItemByIdentity(keywordArgs.identity);
							if(keywordArgs.onItem){
								keywordArgs.onItem.call(scope, item);
							}
							self._handleQueuedFetches();
						}catch(error){
							self._loadInProgress = false;
							if(keywordArgs.onError){
								keywordArgs.onError.call(scope, error);
							}
						}
					});
					getHandler.addErrback(function(error){
						self._loadInProgress = false;
						if(keywordArgs.onError){
							var scope = keywordArgs.scope?keywordArgs.scope:dojo.global;
							keywordArgs.onError.call(scope, error);
						}
					});
				}

			}else if(this._jsonData){
				// Passed in data, no need to xhr.
				self._getItemsFromLoadedData(self._jsonData);
				self._jsonData = null;
				self._loadFinished = true;
				var item = self._getItemByIdentity(keywordArgs.identity);
				if(keywordArgs.onItem){
					var scope = keywordArgs.scope?keywordArgs.scope:dojo.global;
					keywordArgs.onItem.call(scope, item);
				}
			} 
		}else{
			// Already loaded.  We can just look it up and call back.
			var item = this._getItemByIdentity(keywordArgs.identity);
			if(keywordArgs.onItem){
				var scope = keywordArgs.scope?keywordArgs.scope:dojo.global;
				keywordArgs.onItem.call(scope, item);
			}
		}
	},

	_getItemByIdentity: function(/* Object */ identity){
		//	summary:
		//		Internal function to look an item up by its identity map.
		var item = null;
		if(this._itemsByIdentity){
			item = this._itemsByIdentity[identity];
		}else{
			item = this._arrayOfAllItems[identity];
		}
		if(item === undefined){
			item = null;
		}
		return item; // Object
	},

	getIdentityAttributes: function(/* item */ item){
		//	summary: 
		//		See dojo.data.api.Identity.getIdentifierAttributes()
		 
		var identifier = this._features['dojo.data.api.Identity'];
		if(identifier === Number){
			// If (identifier === Number) it means getIdentity() just returns
			// an integer item-number for each item.  The dojo.data.api.Identity
			// spec says we need to return null if the identity is not composed 
			// of attributes 
			return null; // null
		}else{
			return [identifier]; // Array
		}
	},
	
	_forceLoad: function(){
		//	summary: 
		//		Internal function to force a load of the store if it hasn't occurred yet.  This is required
		//		for specific functions to work properly.  
		var self = this;
		if(this._jsonFileUrl !== this._ccUrl){
			dojo.deprecated("dojox.data.AndOrReadStore: ", 
							"To change the url, set the url property of the store," +
							" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
			this._ccUrl = this._jsonFileUrl;
			this.url = this._jsonFileUrl;
		}else if(this.url !== this._ccUrl){
			this._jsonFileUrl = this.url;
			this._ccUrl = this.url;
		}
		//See if there was any forced reset of data.
		if(this.data != null && this._jsonData == null){
			this._jsonData = this.data;
			this.data = null;
		}
		if(this._jsonFileUrl){
				var getArgs = {
					url: self._jsonFileUrl, 
					handleAs: "json-comment-optional",
					preventCache: this.urlPreventCache,
					sync: true
				};
			var getHandler = dojo.xhrGet(getArgs);
			getHandler.addCallback(function(data){
				try{
					//Check to be sure there wasn't another load going on concurrently 
					//So we don't clobber data that comes in on it.  If there is a load going on
					//then do not save this data.  It will potentially clobber current data.
					//We mainly wanted to sync/wait here.
					//TODO:  Revisit the loading scheme of this store to improve multi-initial
					//request handling.
					if(self._loadInProgress !== true && !self._loadFinished){
						self._getItemsFromLoadedData(data);
						self._loadFinished = true;
					}else if(self._loadInProgress){
						//Okay, we hit an error state we can't recover from.  A forced load occurred
						//while an async load was occurring.  Since we cannot block at this point, the best
						//that can be managed is to throw an error.
						throw new Error("dojox.data.AndOrReadStore:  Unable to perform a synchronous load, an async load is in progress."); 
					}
				}catch(e){
					console.log(e);
					throw e;
				}
			});
			getHandler.addErrback(function(error){
				throw error;
			});
		}else if(this._jsonData){
			self._getItemsFromLoadedData(self._jsonData);
			self._jsonData = null;
			self._loadFinished = true;
		} 
	}
});
//Mix in the simple fetch implementation to this class.
dojo.extend(dojox.data.AndOrReadStore,dojo.data.util.simpleFetch);



}

if(!dojo._hasResource["xwt.widget.table.Filter"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.table.Filter"] = true;
/* ************************************************** */
/* Copyright (c) 2009-2011 Cisco Systems, Inc.       */
/* All rights reserved.                               */
/* ************************************************** */

dojo.provide("xwt.widget.table.Filter");





/*
The following (for reference) would be an example object structure that might be
saved to a server application that looks to do cross-session quick filtering.

var exampleFilters = [
	{
		name: "Local routers",
		conjunction: "and",
		editable: true,
		expressions: [
			{
				op: "contains",
				attr: "ip_address",
				value: "10.0.0"
			},
			{
				op: "starts-with",
				attr: "name",
				"Router"
			}
		]
	},
	{
		name: "Routers added after 1/1/2009",
		conjunction: "and",
		editable: false,
		expressions: [
			{
				op: "starts-with",
				attr: "name",
				"Router"
			},
			{
				op: "greater-than",
				attr: "added",
				value: new Date(2009, 0, 1)
			}
		]
	}
];
 */

/*=====
xwt.widget.table.__FilterExpression = function(op, attr, value){
	//	summary:
	//		The basic structure of a FilterExpression.
	//	op: String
	//		The name of the function to be run, such as "contains", "starts-with", etc.
	//	attr: String
	//		The dojo.data.Item name to run the op against.
	//	value: Object?
	//		The value to be used to evaluate the expression.
	this.op = op;
	this.attr = attr;
	this.value = value;
};

xwt.widget.table.__Filter = function(name, conjunction, editable, expressions){
	//	summary:
	//		A collection of xwt.widget.table.__FilterExpressions, plus
	//		two additional values, that make up a complete Filter.
	//	name: String
	//		The name of the Filter.  This is the human-readable name when saved.
	//	conjunction: String?
	//		The conjunction op to be used with the set of FilterExpressions.
	//		Valid values are "and" and "or"; "and" is the default.
	//	editable: Boolean?
	//		Whether or not the filter is editable.  Will be set to false by default.
	//	expressions: xwt.widget.table.__FilterExpression[]
	//		The set of FilterExpressions that make up the functionality of this Filter.
	this.name = name;
	this.conjunction = conjunction;
	this.editable = editable;
	this.expressions = expressions;
};
=====*/

dojo.declare("xwt.widget.table.Filters", null, {
	//	summary:
	//		The collection of possible functions to be used for filtering,
	//		including a special map that will return a human-readable name
	//		for the function.

	_store: null,
	_qOptions:null,

	constructor: function(/* dojo.data.api.Read */store, qOptions){
		this._store = store;
		this._qOptions = qOptions;
		this.map = dojo.i18n.getLocalization("xwt.widget.table", "Filter");
	},

	//	the map list, and the filter function getter.
	map:  null,

	get: function(/* String */name){
		//	summary:
		//		Returns the function instance given the human-readable name.
		//	name: String
		//		The name used in the user interface to describe a function.
		//	returns: Function
		//		The function used for filtering.
		for(var f in this.map){
			if(this.map[f] == name && (f in this)){
				return this[f];
			}
		}
		return null;
	},
	toDojoQuery: function(/* xwt.widget.table.__FilterExpression[] */expressions, /*filtering on server */server){
		//	summary:
		//		Take the given filter function (fn) and an optional input, and
		//		create a standard dojo.data query object out of it.  For more on standard
		//		dojo.data, see 
		//		the [dojo.data.ItemFileReadStore query examples](http://dojotoolkit.org/reference-guide/dojo/data/ItemFileReadStore.html#query-examples)
		var q = {};
		var bServer = server;
		
		var addToQuery = function(q, attr, val){
			// summary:
			//		Internal function to add to the query object, or make it multivalued
			//		if necessary.
			// q: object
			//		The query object.
			// attr: String
			//		The attribute in the query to update.
			// val: String
			//		The value to insert.
			if(attr in q){
				var v = q[attr];
				if(!dojo.isArray(v)){
					q[attr] = [v];
				}
				q[attr].push(val);
			}else{
				q[attr] = val;	
			}
		}
		
		dojo.forEach(expressions, function(expression){
			var fn = expression.op;
			switch(fn){
				case "contains": {
					addToQuery(q, expression.attr, "*" + expression.value + "*");
					break;
				}
				case "starts-with": {
					addToQuery(q, expression.attr, expression.value + "*");
					break;
				}
				case "ends-with": {
					addToQuery(q, expression.attr, "*" + expression.value);
					break;
				}
				case "is-empty": {
					addToQuery(q, expression.attr, "");	
					break;
				}
				case "is-not-empty": {
					addToQuery(q, expression.attr, "*?");
					break;
				}
				case "equals": {
					addToQuery(q, expression.attr, expression.value);	
					break;
				}
				/*
					"not-contains": {}
					"not-equals": {}
					"greater-than": {}
					"less-than": {}
					"greater-equals": {}
					"less-equals": {}
					"is-true": {}
					"is-false": {}
				*/
				//For Advanced Server Side Filtering
				case "not-contains": {
					if(bServer){
						addToQuery(q, expression.attr, "^ " + expression.value);
					}
					break;
				}
				case "not-equals": {
					if(bServer){
						addToQuery(q, expression.attr, "ne " + expression.value);
					}
					break;
				}
				case "greater-than": {
					if(bServer){
						addToQuery(q, expression.attr, "gt" + expression.value);
					}
					break;
				}
				case "less-than": {
					if(bServer){
						addToQuery(q, expression.attr, "lt" + expression.value);
					}
					break;
				}
				case "greater-equals": {
					if(bServer){
						addToQuery(q, expression.attr, "ge" + expression.value);
					}
					break;
				}
				case "less-equals": {
					if(bServer){
						addToQuery(q, expression.attr, "le" + expression.value);
					}
					break;
				}
				case "is-true": {
					if(bServer){
						addToQuery(q, expression.attr, "is-true");
					}
					break;
				}
				case "is-false": {
					if(bServer){
						addToQuery(q, expression.attr, "is-false");
					}
					break;
				}				
			}
		});
		return q;	//	Object
	},

	//	the actual filter functions.  Note that for some functions, the value
	//	is implied (for instance, "is-empty") but the function signature is
	//	always to be defined this way.
	"contains": function(data, attr, value){
		//	summary:
		//		Returns a filtered array where each item's attr contains the value.
		//	data: Array
		//		An array of objects.
		//	attr: String
		//		The property to look up against.
		//	value: String
		//		The value to test for.
		//	returns: Array
		//		The filtered array of items.
		
		// Define once, not every loop.
		var rExp = null;
		if(this._qOptions){
			rExp = dojo.data.util.filter.patternToRegExp("*" + value + "*", this._qOptions.ignoreCase);
		}			
		return dojo.filter(data, function(item){	//	Array
			var contains = false;
			if(this._store.hasAttribute(item, attr)){
				if(rExp){
					contains = rExp.test("" + this._store.getValue(item, attr));
				}else{
					contains = ("" + this._store.getValue(item, attr)).indexOf(value) > -1;
				}
			}
			return contains;
		}, this);
	},
	"not-contains": function(data, attr, value){
		//	summary:
		//		Returns a filtered array where each item's attr does not contain the value.
		//	data: Array
		//		An array of objects.
		//	attr: String
		//		The property to look up against.
		//	value: String
		//		The value to test for.
		//	returns: Array
		//		The filtered array of items.
		var rExp = null;
		if(this._qOptions){
			rExp = dojo.data.util.filter.patternToRegExp("*" + value + "*", this._qOptions.ignoreCase);
		}			
		return dojo.filter(data, function(item){	//	Array
			var contains = false;
			if(this._store.hasAttribute(item, attr)){
				if(rExp){
					contains = (rExp.test("" + this._store.getValue(item, attr)));
					contains = !contains;
				}else{
					contains = ("" + this._store.getValue(item, attr)).indexOf(value) == -1;
				}
			}
			return contains;
		}, this);
	},
	"starts-with":  function(data, attr, value){
		//	summary:
		//		Returns a filtered array where each item's attr starts with the value.
		//	data: Array
		//		An array of objects.
		//	attr: String
		//		The property to look up against.
		//	value: String
		//		The value to test for.
		//	returns: Array
		//		The filtered array of items.
		var rExp = null;
		if(this._qOptions){
			rExp = dojo.data.util.filter.patternToRegExp(value + "*", this._qOptions.ignoreCase);
		}			
		return dojo.filter(data, function(item){	//	Array
			var contains = false;
			if(this._store.hasAttribute(item, attr)){
				if(rExp){
					contains = rExp.test("" + this._store.getValue(item, attr));
				}else{
					contains = (("" + this._store.getValue(item, attr)).indexOf(value) == 0);
				}
			}
			return contains;
		}, this);	
	},
	"ends-with":  function(data, attr, value){
		//	summary:
		//		Returns a filtered array where each item's attr ends with the value.
		//	data: Array
		//		An array of objects.
		//	attr: String
		//		The property to look up against.
		//	value: String
		//		The value to test for.
		//	returns: Array
		//		The filtered array of items.
		var rExp = null;
		if(this._qOptions){
			rExp = dojo.data.util.filter.patternToRegExp("*" + value, this._qOptions.ignoreCase);
		}			
		return dojo.filter(data, function(item){	//	Array
			var contains = false;
			if(this._store.hasAttribute(item, attr)){
				if(rExp){
					contains = rExp.test("" + this._store.getValue(item, attr));
				}else{
					var v = "" + this._store.getValue(item, attr);
					contains = (v.lastIndexOf(value) == (v.length - value.length));
				}
			}
			return contains;
		}, this);
	},
	"is-empty":  function(data, attr, value){
		//	summary:
		//		Returns a filtered array where each item's attr is empty or is missing from the store
		//	data: Array
		//		An array of objects.
		//	attr: String
		//		The property to look up against.
		//	value: String
		//		The value to test for.
		//	returns: Array
		//		The filtered array of items.
		return dojo.filter(data, function(item){	//	Array
			return !(this._store.hasAttribute(item, attr)) ||  ("" + this._store.getValue(item, attr)).length == 0;
		}, this);
	},
	"is-not-empty":  function(data, attr, value){
		//	summary:
		//		Returns a filtered array where each item's attr contains a value.
		//	data: Array
		//		An array of objects.
		//	attr: String
		//		The property to look up against.
		//	value: String
		//		The value to test for.
		//	returns: Array
		//		The filtered array of items.
		return dojo.filter(data, function(item){	//	Array
			return (this._store.hasAttribute(item, attr)) && ("" + this._store.getValue(item, attr)).length > 0;
		}, this);
	},
	"equals":  function(data, attr, value){
		//	summary:
		//		Returns a filtered array where each item's attr is the same as the value.
		//	data: Array
		//		An array of objects.
		//	attr: String
		//		The property to look up against.
		//	value: String
		//		The value to test for.
		//	returns: Array
		//		The filtered array of items.
		return dojo.filter(data, function(item){	//	Array
			var isEqual = false;
			if(this._store.hasAttribute(item, attr)){
				var sValue = this._store.getValue(item, attr);
				var isEqual = (sValue == value);
				if(!isEqual && !dojo.isObject(sValue) && !dojo.isObject(value) && (typeof sValue != typeof value)){
					// Do a string comparison.  Needed to check boolean true/false
					sValue += "";
					value += "";
					isEqual = (sValue == value);
				}
			}
			return isEqual;
		}, this);
	},
	"not-equals":  function(data, attr, value){
		//	summary:
		//		Returns a filtered array where each item's attr is not the same as the value.
		//	data: Array
		//		An array of objects.
		//	attr: String
		//		The property to look up against.
		//	value: String
		//		The value to test for.
		//	returns: Array
		//		The filtered array of items.
		return dojo.filter(data, function(item){	//	Array
			var isNotEqual = true;
			if(this._store.hasAttribute(item, attr)){
				var sValue = this._store.getValue(item, attr);
				var isNotEqual = (sValue != value);
				if(!isNotEqual && !dojo.isObject(sValue) && !dojo.isObject(value) && (typeof sValue != typeof value)){
					// Do a string comparison.  Needed to check boolean true/false
					sValue += "";
					value += "";
					isNotEqual = (sValue != value);
				}
			}
			return isNotEqual;
		}, this);
	},
	"greater-than":  function(data, attr, value){
		//	summary:
		//		Returns a filtered array where each item's attr is greater than the value.
		//	data: Array
		//		An array of objects.
		//	attr: String
		//		The property to look up against.
		//	value: String
		//		The value to test for.
		//	returns: Array
		//		The filtered array of items.
		return dojo.filter(data, function(item){	//	Array
			return (this._store.hasAttribute(item, attr)) && this._store.getValue(item, attr) > value;
		}, this);
	},
	"less-than":  function(data, attr, value){
		//	summary:
		//		Returns a filtered array where each item's attr is less than the value.
		//	data: Array
		//		An array of objects.
		//	attr: String
		//		The property to look up against.
		//	value: String
		//		The value to test for.
		//	returns: Array
		//		The filtered array of items.
		return dojo.filter(data, function(item){	//	Array
			return (this._store.hasAttribute(item, attr)) && this._store.getValue(item, attr) < value;
		}, this);
	},
	"greater-equals":  function(data, attr, value){
		//	summary:
		//		Returns a filtered array where each item's attr is greater than or equal to the value.
		//	data: Array
		//		An array of objects.
		//	attr: String
		//		The property to look up against.
		//	value: String
		//		The value to test for.
		//	returns: Array
		//		The filtered array of items.
		return dojo.filter(data, function(item){	//	Array
			return (this._store.hasAttribute(item, attr)) && this._store.getValue(item, attr) >= value;
		}, this);
	},
	"less-equals":  function(data, attr, value){
		//	summary:
		//		Returns a filtered array where each item's attr is less than or equal to the value.
		//	data: Array
		//		An array of objects.
		//	attr: String
		//		The property to look up against.
		//	value: String
		//		The value to test for.
		//	returns: Array
		//		The filtered array of items.
		return dojo.filter(data, function(item){	//	Array
			return (this._store.hasAttribute(item, attr)) && this._store.getValue(item, attr) <= value;
		}, this);
	},
	"is-true":  function(data, attr, value){
		//	summary:
		//		Returns a filtered array where each item's attr evaluates to true.
		//	data: Array
		//		An array of objects.
		//	attr: String
		//		The property to look up against.
		//	value: String
		//		The value to test for.
		//	returns: Array
		//		The filtered array of items.
		return dojo.filter(data, function(item){	//	Array
			return (this._store.hasAttribute(item, attr)) && Boolean(this._store.getValue(item, attr)) === true;
		}, this);
	},
	"is-false":  function(data, attr, value){
		//	summary:
		//		Returns a filtered array where each item's attr evaluates to false.
		//	data: Array
		//		An array of objects.
		//	attr: String
		//		The property to look up against.
		//	value: String
		//		The value to test for.
		//	returns: Array
		//		The filtered array of items.
		return dojo.filter(data, function(item){	//	Array
			return (this._store.hasAttribute(item, attr)) && Boolean(this._store.getValue(item, attr)) === false;
		}, this);
	}
});

// Fetch implementation that can be used with in-memory stores to extend them
// with full filtering capabilities
xwt.widget.table.Filters.filteringFetch = function(args){
	if(this._features){
		// Try to make this filtering fetch noted, if possible.
		this._features["xwt.widget.table.Filters.filteringFetch"] = true;
	}
	if(args.filter){
		var sortString = dojo.toJson(args.sort);
		var qString = "";
		if(args.filter && args.filter.preFilterQuery){
			var pfq = args.filter.preFilterQuery;
			if(dojo.isObject(pfq) || dojo.isArray(pfq)){
				qString = "_" + dojo.toJson(pfq);	
			}else{
				qString = "_" + pfq;
			}	
		}
		var results;
		// var results = args.filter["_cached" + sortString + qString];
		if(!results){
			var engine = new xwt.widget.table.FilterEngine(this, null,args.queryOptions);
			var self = this;
			var bridge = {};
			var serverCount = 0;
			/*
			var invalidateCache = function(){
				for(var i in args.filter){
					if(i.substring(0,7) == "_cached"){
						delete args.filter[i];
					}
				}
			}
			*/
			if(this.filterOnServer){
				bridge.query = args.query;
				bridge.sort = args.sort;
			}else if(args.filter.preFilterQuery){
				bridge.query = args.filter.preFilterQuery; 
			}
			if(this.pageOnServer){
				bridge.start = args.start;
				bridge.count = args.count;
			}

			bridge.onBegin = function(count, req){
				serverCount = count;
			};
			bridge.onComplete = function(items, req){
				if(this.filterOnServer){
					results = items || [];
				}else{
					results = engine.evaluate(items, args.filter);
					if (args.sort) {
						results = results.sort(dojo.data.util.sorter.createSortFunction(args.sort, self));
					}
				}

				// Now issue callbacks.
				if(args.onBegin){
					try{
						var actualCount = results.length;
						if(this.pageOnServer){
							actualCount = serverCount;
						}
						args.onBegin(actualCount, args);
					}catch(e){
						console.log("onBegin error: ", e);
					}
				}

				// Slice down if we need to.
				if(args.count && !this.pageOnServer){
					results = results.slice(args.start, args.count + args.start);
				}
				if(args.onComplete){
					try{
						args.onComplete(results, args);
					}catch(e){
						console.log("onComplete error: ", e);
					}
				}
			};
			/*
			if(args.filter._cacheInvalidatingListener){
				dojo.connect(this, "onSet", invalidateCache);
				dojo.connect(this, "onNew", invalidateCache);
				dojo.connect(this, "onDelete", invalidateCache);
				dojo.connect(this, "moveTo", invalidateCache);
				args.filter._cacheInvalidatingListener = true;
			}
			*/
			return this.inherited("fetch", arguments, [bridge]);
		}else{
			if(args.onBegin){
				args.onBegin.call(scope, results.length, args);
			}
			if(args.onComplete){
				results = results.slice(args.start, args.count + args.start);
				args.onComplete.call(scope, results, args);
			}
		}
	}else{
		return this.inherited("fetch", arguments);
	}

};

// A list of stores that 'canFilterWrapStore' should return true for.
xwt.widget.table.Filters._wrappbleStores = {
	"dojo.data.ItemFileReadStore": true,
	"dojo.data.ItemFileWriteStore": true,
	"dojox.data.AndOrReadStore": true,
	"dojox.data.AndOrWriteStore": true,
	"dojox.data.CsvStore": true,
	"dojox.data.KeyValueStore": true,
	"dojox.data.HtmlStore": true,
	"dojox.data.AppStore": true,
	"dojox.data.OpmlStore": true
};

xwt.widget.table.Filters.canFilterWrapStore = function(store){
	// summary:
	//	Function to try and determine if a datastore can be wrapped by FilteringWrapperStore
	//	to get the basics of the built-in 'in memory' filtering.

	var canWrap = false;
	if(store){
		var cls = store.declaredClass;
		var features = store.getFeatures() || {};
		if(cls && !features["xwt.widget.table.Filters.filteringFetch"] && xwt.widget.table.Filters._wrappbleStores[cls]){
			canWrap = true;
		}
	}
	return canWrap;
};

dojo.declare("xwt.widget.table.Filters.FilteringWrapperStore", null,{
	// summary:
	//		This class is designed to take any particular in-memory data store and wrap around it.
	//		It customizes the fetch behavior to include the filteringFetch processing.  Note this
	//		only works with in-memory 'sync-like' stores.

	//The datastore referenced and used by this store.
	_store: null,

	constructor: function(store) {
		// summary:
		//		Builds the Filtering Wrapper store.
		//
		// store:
		//		The datastore to use.
		if(store){
			this._myConnects = [];
			this._store = store;
			this._buildMapperFunctions();
			this._customizeFetch();
			var f = this.getFeatures();
			if(f["dojo.data.api.Notification"]){
				this._bindNotifications();
			}
		}else{
			throw new Error("Data store not provided.");
		}
	},

	_buildMapperFunctions: function(){
		// summary:
		//		Constructs the mapper functions to the data store.
		//		Loops through all public functions on the store and builds calls to them.
		//		Skips internal functions as well as the getFeatures function, since it is 
		//		augmented differently.
		var i;
		for(i in this._store){
			if(i.toString().charAt(0) !== '_' && i !== "getFeatures" && i !== "fetch"){
				var member = this._store[i];
				//Check that all the 'Read' defined functions exist on the test store.
				if(dojo.isFunction(member)){
					this[i] = this._createFunction(i);
				}
			}
		}
	},

	_customizeFetch: function(){
		// summary:
		//		This function builds a custom fetch function, which overrides 
		//		some of the data store behaviors  to get page table mode.	 
		//		Effectively, it just usurps the callbacks callback and controls start/count.
		var self = this;
		this.fetch = function(args){
			var scope = args.scope || dojo.global;
			if(args.filter){
				var sortString = dojo.toJson(args.sort);
				var qString = "";
				if(args.filter && args.filter.preFilterQuery){
					var pfq = args.filter.preFilterQuery;
					if(dojo.isObject(pfq) || dojo.isArray(pfq)){
						qString = "_" + dojo.toJson(pfq);	
					}else{
						qString = "_" + pfq;
					}	
				}
				
				var results;
				/*
				var results = args.filter["_cached" + sortString + qString];
				var invalidateCache = function(){
					for(var i in args.filter){
						if(i.substring(0,7) == "_cached"){
							delete args.filter[i];
						}
					}
				};
				*/
				if(!results){
					var engine = new xwt.widget.table.FilterEngine(this, args.filters, args.queryOptions);
					var onComplete = args.onComplete;
					var onBegin = args.onBegin;
					var start = args.start;
					var count = args.count;
					delete args.start;
					delete args.count;
			
					//For CSCtj09267
					if(!self._store.filterOnServer){
						if(args.filter.preFilterQuery){
							args.query = args.filter.preFilterQuery;
						}else{
							// We're not serverside filtering, let the expression engine handle it.
							delete args.query;
						}
					}
					// Replace the callbacks with customized ones to behave like a
					// filtering fetch store.
					args.onBegin = function(count, req) {};
					args.onComplete = function(results, request){
						if(!self._store.filterOnServer){
							results = engine.evaluate(results, args.filter);
							if(args.sort){
								results = results.sort(dojo.data.util.sorter.createSortFunction(args.sort, self._store));
							}
							//args.filter["_cached" + sortString + qString] = results; 
						}
						/*
						if(!args.filter._cacheInvalidatingListener){
							self._myConnects.push(dojo.connect(self, "onSet", invalidateCache));
							self._myConnects.push(dojo.connect(self, "onNew", invalidateCache));
							self._myConnects.push(dojo.connect(self, "onDelete", invalidateCache));
							self._myConnects.push(dojo.connect(self, "moveTo", invalidateCache));
							args.filter._cacheInvalidatingListener = true;
						}
						*/
						// Now call the original handlers in proper sequence.
						args.start = start;
						args.count = count;
						if(onBegin){
							args.onBegin = onBegin;
							args.onBegin.call(scope, results.length, args);
							args.onBegin = onBegin;
						}
						if(onComplete){
							results = results.slice(args.start, args.count + args.start);
							args.onComplete = onComplete;
							args.onComplete.call(scope, results, args);
						}
					};
					return self._store.fetch(args);
                                
				}else{
					// We have already filtered the results, so just use them.
					if(args.onBegin){
						args.onBegin.call(scope, results.length, args);
					}
					if(args.onComplete){
						results = results.slice(args.start, args.count + args.start);
						args.onComplete.call(scope, results, args);
					}
				}
			}else{
				return self._store.fetch(args);
			}
		};
	},

	_createFunction: function(name){
		//	summary:
		//		Creator function to generate a mapper to the actual store function.
		//	name:
		//		The name of the function to map to on the store.
		var self = this;
		return function(){
			return self._store[name].apply(self._store, arguments);
		};
	},

	_bindNotifications: function(){
		//	summary:
		//		Function to connect up notification events,
		//		as mappers do not work for them.
		this.onNew = function(){};
		this.onDelete = function(){};
		this.onSet = function(){};
		
		if(!this._myConnects) {
			this._myConnects = [];
		}
		this._myConnects.push(dojo.connect(this._store, "onNew", this, "onNew"));
		this._myConnects.push(dojo.connect(this._store, "onDelete", this, "onDelete"));
		this._myConnects.push(dojo.connect(this._store, "onSet", this, "onSet"));
	},

	getFeatures: function(){
		// summary:
		//	Over-ride of getFeatures to denote that the store has been 'augmented' 
		//	with the filtering fetch ability.
		var f = this._store.getFeatures() || {};
		f["xwt.widget.table.Filters.filteringFetch"] = true;
		return f;
	},

	destroy: function(){
		//	summary:
		//		Nonstandard API function for dojo.data (but mimics widget.destroy)
		//		for cleaning up connections and such.
		if(this._myConnects){
			dojo.forEach(this._myConnects, function(c){
				dojo.disconnect(c);
			});
		}
	}
});

dojo.declare("xwt.widget.table.FilterEngine", null, {
	//	summary:
	//		The actual filter engine that underlies the Advanced Filtering for
	//		xwt.widget.table.Table.
	//	
	//	description:
	//		The FilterEngine is an expression evaluator and descriptor to
	//		allow for the generic construction of filtering statements,
	//		including the ability to load and save expressions.  See
	//		xwt.widget.table.__Filter for the JSON structure of a set of
	//		expressions.
	//
	//	_filters: [private] Array
	//		The array of filters currently defined.
	//	_filterMap: [private] Object
	//		The dictionary to get a filter by name or ID.
	//	_functions: [private] xwt.widget.table.Filters

	_filters: [],
	_filterMap: {},
	_functions: null,
	_qOptions:null,

	constructor: function(/* dojo.data.api.Read */store, /* xwt.widget.table.__Filter[]? */filters, /*queryOptions*/qOptions){
		//	summary:
		//		The constructor for this engine.  Pass in an optional set of
		//		xwt.widget.table.__Filter to "pre-seed" the engine.
		//	filters: Object?
		//		An optional JSON definition of defined functions for filtering.
		this._qOptions = qOptions;
		this._functions = new xwt.widget.table.Filters(store,qOptions);
		if(filters !== undefined){
			this.load(filters);
		}
	},

	get: function(name){
		//	summary:
		//		Given the name of the filter, return the filter.
		//	name: String
		//		The name of the filter as defined in the "name" property.
		for(var i=0, l=this._filters.length; i<l; i++){
			if(this._filters[i].name == name){
				return this._filters[i];	//	xwt.widget.table.__Filter
			}
		}
		return null;	//	xwt.widget.table.__Filter
	},

	add: function(filter){
		//	summary:
		//		Add the passed filter to the internal storage.  If the filter
		//		already existed, it will be replaced with the passed filter.
		if(this._filterMap[filter.name]){
			this._filterMap[filter.name] = filter;
			for(var i=0; i<this._filters.length; i++){
				if(this._filters[i].name == filter.name){
					filter.editable = true;
					this._filters[i] = filter;
					break;
				}
			}
			this.onAdd(filter);
			return this;	//	xwt.widget.table.FilterEngine
		}
		//	If we got here, it's a new filter, so make sure it's editable.
		filter.editable = true;
		this._filters.push(filter);
		this._filterMap[filter.name] = filter;
		this.onAdd(filter);
		return this;	//	xwt.widget.table.FilterEngine
	},
	remove: function(filter){
		//	summary:
		//		Remove the filter from the internal storage.
		if(this._filterMap[filter.name]){
			delete this._filterMap[filter.name];
			for(var idx=-1, i=0; i<this._filters.length; i++){
				if(this._filters[i].name == filter.name){
					idx = i;
					break;
				}
			}
			if(idx > -1){
				this._filters.splice(idx, 1);
			}
		}
		this.onRemove(filter);
		return this;	//	xwt.widget.table.FilterEngine
	},
	load: function(filters){
		//	summary:
		//		Load in a set of filter definitions.  Note that this WILL remove any
		//		existing filter definitions.
		//	filters: Object
		//		The JSON filter set definition.
		this._filters = filters;
		this._filterMap = {};
		dojo.forEach(this._filters, function(item){
			this._filterMap[item.name] = item;
			if(!item.editable){ item.editable = false; }
		}, this);
		this.onLoad(this._filters);
		return this;	//	xwt.widget.table.FilterEngine
	},
	save: function(){
		//	summary:
		//		Save any internal filter definitions.
		
		//	TODO: implementation.
		this.onSave(this._filters);
		return this;	//	xwt.widget.table.FilterEngine
	},
	evaluate: function(data, filter){
		//	summary:
		//		Run the given filter on the passed data, and return the filtered data.
		//	data: Array
		//		The array of data to run the set of filters on.
		//	filter: xwt.widget.table.__Filter
		//		The filter to use on the array.

		var d = data, progressive = (filter.conjunction != "or"), out = progressive ? d : [];
		for(var i=0; i < filter.expressions.length; i++){
			var fn = this._functions[filter.expressions[i].op];
			if(fn){
				var tmp = fn.call(this._functions, (progressive ? out : d), filter.expressions[i].attr, filter.expressions[i].value || null);
				out = (progressive ? tmp : out.concat(tmp));
			}
		}

		//	make the list unique if this was an "or" operation but preserve the order.
		if(!progressive){
			var ids = {};
			out = dojo.filter(out, function(item, idx){
				var id = this._functions._store.getIdentity(item);
				var first = !ids[id];
				ids[id] = true;
				return first;
			}, this);
			ids = null;
		}
		this.onEvaluate(out);
		return out;	//	Array
	},

	onAdd: function(filter){
		//	summary:
		//		Stub to connect to when a filter is added to the Engine.
	},
	onRemove: function(filter){
		//	summary:
		//		Stub to connect to when a filter is removed from the Engine.
	},
	onLoad: function(filters){
		//	summary:
		//		Stub to connect to when a set of filters is loaded into the Engine.
	},
	onSave: function(filters){
		//	summary:
		//		Stub to connect to when a set of filters is saved.
	},
	onEvaluate: function(data){
		//	summary:
		//		Stub to connect to when a set of filters is applied to an array of data.
		//	data: Array
		//		An array of items that the filter set has been applied to.
	}
});

xwt.widget.table.Filter = {
	//	summary:
	//		Adds in the ability to filter the contents of a Table.
	//		Like the other.Table, this should be applied by the
	//		Table constructor and not called directly.
	//	description:
	//		Like the other.Table for an xwt.widget.table.Table, this
	//		component should never be constructed directly but rather
	//		should be applied, at instantiation time, to an xwt.widget.table.Table.
	//
	//		The Filter component allows a table to be filtered by any number
	//		of mechanisms. For instance, a separate QuickFilter widget can 
	//		send a filter message to a table via the .filter function.
	//
	//	example:
	//		Apply the filter component to a Table.
	//	|	xwt.widget.table.Filter.start.call(myTable);
	//
	//	_currentFilter: [private] xwt.widget.table.__Filter
	//		The current filter used on the Table.
	//	_preFilterQuery: [private] Object
	//		The query used on the Table before the filter.
	//	_filtering: [private] Boolean
	//		Whether or not we are in the state of filtering.  Used internally
	//		by the table.
	//	_filterEngine: [private] xwt.widget.table.FilterEngine
	//		A reference to the filter engine that is used for doing actual
	//		item filtering.
	//	filterDelay: Number
	//		Delay in milliseconds before a FilterByExample search widget begins searching.

	_currentFilter: null,
	_filtering: false,
	_filterEngine: null,
	filterDelay: 750,
	filterOnServer:false,
	qOptions:null,

	start: function(/* Object? */options){
		//	summary:
		//		An initializer that prepares the table that this is mixed into.
		var fd = this.filterDelay || 750;
		var server = this.filterOnServer;
		var qOptions = this.qOptions;
		dojo.mixin(this, xwt.widget.table.Filter);
		this.filterDelay = fd;
		this.filterOnServer = server;
		this.qOptions = qOptions;
		this._filterEngine = new xwt.widget.table.FilterEngine(this.store, this.filters, this.qOptions);
		this._filtering = false;
		this._currentFilter = null;

		// Wrap the store with the filtering fetch style wrapper, if possible.
		if(this.store && xwt.widget.table.Filters.canFilterWrapStore(this.store)){
			this.store = new xwt.widget.table.Filters.FilteringWrapperStore(this.store,this.qOptions);
		}
	},

	filtering: function(){
		//	summary:
		//		Indicates whether the table is in the process of filtering.
		return this._filtering;	//	Boolean
	},

	filter: function(filterObject){
		//	summary:
		//		Use the provided filtering function to perform filtering
		//		on a Table.  The filter is applied to the entire dataset,
		//		not an existing filtered set.
		//	filterObject: xwt.widget.table.__Filter
		//		The filter object that contains all the expressions to use
		//		for filtering.
		//	returns:
		//		'this' to allow for functional chaining.
		//	example:
		//	|	myTable.filter(myFilterObject);

		//	TODO: need to force the underlying store to fetch *all* of it's data,
		//	then intercept the onComplete to allow us to perform manual filtering on it.
		
		if(this._currentFilter == filterObject) { return; }
		
		//collapse any expanded rows - CSCtk53547
		if(this.expandable && this.expandable() && this.expanded && this.expanded()){
			this.getExpander()._collapseRow();
		}
		
		this._currentFilter = filterObject;
		if(typeof this['_preFilterQuery'] == 'undefined'){
			this._preFilterQuery = this.query||null;
		}
		this._filtering = true;
		if(this._selected){
			var allSelected = this._selected.allSelected;
			var newSelected = this._filterEngine.evaluate(this._selected, filterObject);
			if(allSelected){
				newSelected.allSelected = allSelected;
			}
			this._selected = newSelected;
			var store = this.store;
			var ids = this._selectedIds = {};
			dojo.forEach(newSelected, function(item){
				ids[store.getIdentity(item)] = true;
			});
		}

		var q = this._filterEngine._functions.toDojoQuery(filterObject.expressions,this.filterOnServer);
		filterObject.preFilterQuery = this._preFilterQuery;

		this.query = dojo.mixin({}, this._preFilterQuery, q);
                        
		// Reset scroll position, as it may be massively changed.
		this._lastScrollTop = 0;
		this.tableContainer.scrollTop = 0;
		this.tableContainer.scrollLeft = 0;
		
		var def = this.render();
		def.addCallback(dojo.hitch(this, function(){
			this._filtering = false;
			this.onFilter(filterObject);
		}));
		return this;	//	xwt.widget.table.Table
	},
	applyFilter: function(filterObject){
		//	summary:
		//		Apply the given filter function to an existing filtered dataset.
		//		This is slightly different from filter in that it does not operate
		//		on the entire dataset, just on whatever is already filtered.
		//	filterObject: xwt.widget.table.__Filter
		//		The filter object that contains all the expressions to use
		//		for filtering.
		//	returns:
		//		'this' to allow for functional chaining.
		//	example:
		//	|	myTable.applyFilter(myFilterObject);
		this.filter(this._currentFilter ? {
				name: this._currentFilter.name,
				conjunction: this._currentFilter.conjunction,
				expressions: this._currentFilter.expressions.concat(filterObject.expressions)
			} : filterObject);
		return this;	//	xwt.widget.table.Table
	},
	clearFilter: function(){
		//	summary:
		//		Clear out all filtering performed on a Table.
		//	returns:
		//		'this' to allow for functional chaining.
		if(this._currentFilter){
			this._currentFilter = null;
			if(dojo.isFunction(this.clearSelections)){
				this.clearSelections();
			}
			this.query = this._preFilterQuery;
			
			//collapse any expanded rows - CSCtk53547
			if(this.expandable && this.expandable() && this.expanded && this.expanded()){
				this.getExpander()._collapseRow();
			}

			if(this._fetchMap){
				// Clean up any 'in flight' store requests,
				// if possible.
				for(fetchNum in this._fetchMap){
					var entry = this._fetchMap[fetchNum];
					if(entry){
						var f = entry.storeRequest;
						if(f && dojo.isFunction(f.abort)){
							try{
        							f.abort();
							}catch(e){
								console.warn(e);
							}
						}
        				}
					delete this._fetchMap[fetchNum];
        			}
        			delete this._fetchMap;
        		}
			// Reset scroll position, as it may be massively changed.
			this._lastScrollTop = 0;
			this.tableContainer.scrollTop = 0;
			this.tableContainer.scrollLeft = 0;	
			
			var def = this.render();
			def.addCallback(dojo.hitch(this, function(){
				this.onClearFilter();
			}));
		}
		return this;	//	xwt.widget.table.Table
	},
	onFilter: function(filterObject){
		//	summary:
		//		Event stub fired when a filter is applied to a Table.
		//	filterObject: xwt.widget.table.__Filter
		//		The filter object that contains all the expressions to use
		//		for filtering.
		//	tags:
		//		callback
	},
	
	onClearFilter: function(){
		//	summary:
		//		Event stub fired when a filter is cleared from the Table.
		//	tags:
		//		callback
	},
	
	getCurrentFilterInfo: function(){
		// summary:
		//		Obtains the filter details of the current filter applied on the table 
		// returns:
		//		The current filter object xwt.widget.table.__Filter, if any or null.
		// tags:
		//		public
		
		if (this._currentFilter) {
			return dojo.fromJson(dojo.toJson(this._currentFilter));
		}
		else 
		{
			return null;
		}
	}
};

}

if(!dojo._hasResource["dijit.form.DropDownButton"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.DropDownButton"] = true;
dojo.provide("dijit.form.DropDownButton");



}

if(!dojo._hasResource["xwt.widget.table.Ribbon"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.table.Ribbon"] = true;
/* ************************************************** */
/* Copyright (c) 2009-2011 Cisco Systems, Inc.       */
/* All rights reserved.                               */
/* ************************************************** */

dojo.provide("xwt.widget.table.Ribbon");



dojo.declare("xwt.widget.table.Ribbon", [ dijit.layout._LayoutWidget, dijit._Templated ], {
	//	summary:
	//		A Ribbon is used much like a Toolbar, except that a Ribbon will show or 
	//		hide an indicator to the right if there are more items in the ribbon than can
	//		be seen. Clicking on the indicator will open a menu with the hidden items in it.
	//
	//	description:
	//		xwt.widget.Ribbon is a toolbar-like widget, used as a container, that will detect
	//		when items in it cannot be viewed; all items that can't be viewed due to size will
	//		be hidden and a menu will be enabled for those hidden items.
	//
	//		Note that even though it might seem like a Ribbon should be a top-level type of 
	//		element (as a Toolbar is), it is really not. It can be placed inside of an
	//		element, so that other things that are not supposed to be hidden will be shown.
	//
	//		Note also that, unlike with a dijit.Toolbar, you *cannot* add or remove Ribbon items
	//		on the fly. This is because any menu items to be created from existing widgets
	//		are run only on initialization and not on resize (this is for performance reasons).
	//		However, you *should* be able to hide any existing widgets by adding the CSS class
	//		"dijitHidden" to the widget's domNode.
	//
	//	example:
	//		Place a Ribbon in a div, along with an anchored element to the right side of the div:
	//
	//	|	<div style="position:relative; width: 100%;">
	//	|		<div dojoType="xwt.widget.Ribbon">
	//	|			<div dojoType="dijit.form.Button">Cut</div>
	//	|		</div>
	//	|	</div>

	templateString: '<div><div dojoAttachPoint="containerNode" class="xwtRibbonWrapper"></div></div>',
	baseClass: "xwtRibbon",
	_menuItems: [],
	_menuItemMap: {},
	_menu: null,
	_overflowNode: null,
	_overflowButton: null,
	_threshold: 0,
	_childBoxes: null,

	_getNewDijitId: function(cls){
		//	summary:
		//		Return a unique ID in the same way that Dijit does it.
		return dijit.getUniqueId(cls.replace(/\./g, "_"));	//	String
	},

	_cloneMenu: function(menu){
		//	summary:
		//		Given a menu, correctly clone all elements in that menu
		//		and return a new one that has no connection to the original.
		var m = new dijit.Menu({}),
			c = menu.getChildren();
		dojo.forEach(c, function(item){
			m.addChild(this._makeMenuItem(item));
		}, this);
		m.startup();
		return m;	//	dijit.Menu
	},

	_setupMenuItem: function(widget){
		var item = this._makeMenuItem(widget);
		if(item){
			item.attr("disabled", widget.attr("disabled"));
			this._menuItems.push(item);
			this._menuItemMap[widget.attr("id")] = item;
		}
		// Establish event link between disabling of the menu button,
		// and the state of the menu item in the ribbon.
		this.connect(widget, "attr", function(arg, val){
			if(arg == "disabled"){
				if (item) //check for item, not available when dropdown contains non menu-items. 
				{ 
					item.attr(arg, val);
				}
			}
		});
	},

	_makeMenuItem: function(widget){
		//	summary:
		//		Given a widget on a Ribbon, create a dijit.MenuItem from it.
		//	description:
		//		This private method is used when the Ribbon is first created, to take any kind of
		//		button functionality and create a dijit.MenuItem out of it.  For the most common
		//		dijit widgets, this method will create a MenuItem from it automatically; however,
		//		if you provide a special "toMenuItem" method with your custom widgets, this method
		//		will default to using it.
		if(widget.toMenuItem){
			return widget.toMenuItem();
		}

		//	Assume some sort of Button for now, and no other kind of form element (like select).
		var cls = widget.declaredClass;

		//	TODO: I don't know that there's a better way to do this for now, TRT.
		switch(cls){
			case "dijit.MenuItem": {
				return new dijit.MenuItem({
					onClick: widget.onClick,
					label: widget.attr("label"),
					iconClass: widget.attr("iconClass")
				});
			}
			case "dijit.MenuSeparator": {
				return new dijit.MenuSeparator({});
			}
			case "dijit.CheckedMenuItem": {
				return new dijit.CheckedMenuItem({
					label: widget.attr("label"),
					onChange: widget.onChange,
					checked: widget.attr("checked")
				});
			}
			case "dijit.PopupMenuItem": {
				return new dijit.PopupMenuItem({
					popup: this._cloneMenu(widget.popup),
					label: widget.attr("label"),
					iconClass: widget.attr("iconClass")
				});
			}
			case "dijit.ToolbarSeparator":{
				//	dijit.MenuSeparator
				return new dijit.MenuSeparator({ });
			}
			case "dijit.form.Button":{
				//	dijit.MenuItem
				return new dijit.MenuItem({
					onClick: widget.onClick,
					label: widget.attr("label"),
					iconClass: widget.attr("iconClass")
				});
			}
			case "dijit.form.ToggleButton":{
				//	CheckedMenuItem
				var w = new dijit.CheckedMenuItem({
					label: widget.attr("label")
				});

				//	Hook up the checkbox with the button.
				widget.connect(w, "onChange", function(){
					widget._onClick(); 
				});
				return w;
			}
			case "dijit.form.DropDownButton":
			case "dijit.form.ComboButton":{
				var m = widget.dropDown;
				if(m.declaredClass != "dijit.Menu"){
					return null;
				}

				//	dijit.PopupMenuItem
				return new dijit.PopupMenuItem({
					popup: this._cloneMenu(m),
					label: widget.attr("label"),
					iconClass: widget.attr("iconClass")
				});
			}
			default: return null;
		}
	},

	getChildren: function(){
		return dijit.findWidgets(this.containerNode);
	},

	startup: function(){
		//	summary:
		//		Finish the initialization of the Ribbon by creating any menu
		//		items from the widgets that are in our Ribbon, and also set
		//		up some measurements.
		this.inherited(arguments);
		this._menu = new dijit.Menu({ }),
			this._menuItems = [],
			this._menuItemMap = {};
		dojo.forEach(this.getChildren(), function(widget){
			this._setupMenuItem(widget);
		}, this);

		//	Create the overflow menu.
		this._overflowNode = dojo.create("div", {
			className: "xwtRibbonOverflowButton"
		}, this.domNode);
		this._overflowButton = new dijit.form.DropDownButton({
			id: this.id + "_overflowButton",
			value: "Show hidden options",
			dropDown: this._menu
		});
		this._overflowNode.appendChild(this._overflowButton.domNode);

		//	FIXME: not sure what's going on here in terms of timing, but for
		//	some reason when this is part of a larger widget, the child widgets
		//	don't get a chance to render.
		setTimeout(dojo.hitch(this, function(){ this.layout(); }), 10);
	},

	layout: function(){
		if(!this._started){ return; }
		var b = dojo.contentBox(this.domNode),
			testWidth = b.w - (dojo.isIE == 7 ? 16 : 8);	//	give ourselves a little padding

		//	Pull the items out of the menu.
		if(!this._menu){ return; }

		if(this._overflowButton && this._overflowButton._opened){
			// Close it, we're moving and the menu will probably change.
			// _opened is private and may change, so recheck later.
			this._overflowButton.toggleDropDown();
		}

		var children = this._menu.getChildren();
		for(var i=0, l=children.length; i<l; i++){
			this._menu.removeChild(children[i]);
		}

		//	unhide any widgets, get current measurements.
		var m = this._childBoxes || {}, furthest = this._threshold || 0;
		dojo.forEach(this.getChildren(), function(w){
			dojo.removeClass(w.domNode, "dijitHidden");
			if(!this._childBoxes){
				var box = dojo.marginBox(w.domNode);
				m[w.attr("id")] = box;	//	keep the measurements
				furthest = Math.max(furthest, box.l + box.w);	//	find the rightmost dimension
			}
		});

		//	Cache it.
		this._childBoxes = this._childBoxes || m;
		this._threshold = this._threshold || furthest;

		//*
		if(!dojo.hasClass(this._overflowNode, "dijitHidden")){
			testWidth -= dojo.marginBox(this._overflowNode).w;
		}
		// */

		//	Check to see if our ribbon is smaller than our content.
		if(testWidth <= furthest){
			//	start walking our buttons and see what we need to hide.
			var desc = this.getChildren(), widgetsToHide = [], current, start = null;
			for(var i=0, l=desc.length; i<l; i++){
				current = m[desc[i].attr("id")];
				if(!current){ continue; }
				if(current.l + current.w < testWidth){ continue; }
				widgetsToHide.push(desc[i]);
				start = start || i;
			}

			//	If there's a separator just before what we have to hide, add it to the list.
			if(start && start > 0 && desc[start - 1].declaredClass == "dijit.ToolbarSeparator"){
				widgetsToHide.unshift(desc[start - 1]);
			}

			//	A little pre-processing; hide anything in widgetsToHide.
			dojo.forEach(widgetsToHide, function(w){
				dojo.addClass(w.domNode, "dijitHidden");
			});

			//	Pull any separators at the beginning and end of widgetsToHide.
			while(widgetsToHide.length && widgetsToHide[0].declaredClass == "dijit.ToolbarSeparator"){
				widgetsToHide.shift();
			}
			while(widgetsToHide.length && widgetsToHide[widgetsToHide.length-1].declaredClass == "dijit.ToolbarSeparator"){
				widgetsToHide.pop();
			}

			//	Add the menu items to the menu and hide the widget itself.
			var count = 0;
			for(var w, i=0, l=widgetsToHide.length; i < l; i++){
				//	hide the widget.
				if(!this._menuItemMap[widgetsToHide[i].attr("id")]){
					continue;
				}
				w = widgetsToHide[i];
				var item = this._menuItemMap[w.attr("id")];
				this._menu.addChild(item);
				count++;
			}

			//	Finally, if there are children in the menu, show the dropdown.
			if(count){
				dojo.removeClass(this._overflowNode, "dijitHidden");
			}
		} else {
			dojo.addClass(this._overflowNode, "dijitHidden");
		}
	},

	destroy: function(){
		if(this._menu){
			this._menu.destroy();
		}
		if(this._overflowButton){
			this._overflowButton.destroy();
		}
		if(this._menuItemMap){
			var id;
			for(id in this._menuItemMap){
				this._menuItemMap[id].destroyRecursive();
			}
		}
		this.inherited(arguments);
	}
});

}

if(!dojo._hasResource["xwt.widget.table.Toolbar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.table.Toolbar"] = true;
/* ************************************************** */
/* Copyright (c) 2009-2011, 2011 Cisco Systems, Inc. */
/* All rights reserved.                               */
/* ************************************************** */

dojo.provide("xwt.widget.table.Toolbar");


























dojo.declare("xwt.widget.table.Toolbar", [ dijit._Widget, dijit._Templated ], {
	//	summary:
	//		The base class for any toolbars to be used in the xwt.widget.table.Table project.

	//	l10n:
	//		An object containing localized strings.	
	l10n: null,

	startup: function(){
		//	summary:
		//		Basic startup function; if you override this, make sure you are firing onStartup.
		if(this._started){ return; }
		this.inherited(arguments);
		this.onStartup();
	},

	postMixInProperties: function(){
		this.inherited(arguments);

		this.l10n = dojo.i18n.getLocalization("xwt.widget.table", "Toolbar");
	},

	onStartup: function(){
		//	summary:
		//		Stub function that should be fired on startup for initialization things,
		//		such as setting the states of buttons and the like.
	}
});

dojo.declare("xwt.widget.table.GlobalToolbar", [ xwt.widget.table.Toolbar ], {
	//	summary:
	//		The widget representing the Global Toolbar (as per the Cisco TABLES specification).
	//	
	//	description:
	//		The Global Toolbar is to be used in conjunction with a Table widget.  However, it 
	//		is deliberately written so that the application author should be the one hooking
	//		up the code to specific actions performed on the Toolbar; i.e., you should be hooking up
	//		your code to the click events available on the Toolbar.

	//	templatePath: String
	//		The path to the template that creates the widget.
	templateString:"<div class=\"xwtGlobalToolbar\" wairole=\"menubar\">\r\n\t<div class=\"xwtGlobalToolbarTitle\" dojoAttachPoint=\"titleNode\">${title}</div>\r\n\t<div class=\"xwtGlobalToolbarActions\" dojoAttachPoint=\"iconsNode\">\r\n\t\t<span class=\"xwtGlobalToolbarTotalRecords\" dojoAttachPoint=\"countLabel\"><span dojoAttachPoint=\"selectionCountLabel\" class=\"selectionCountLabel\"></span><span class=\"countSeparator\" dojoAttachPoint=\"countSeparator\"><span class=\"countSeparatorBorder\"><img src=\"${_blankImage}\"></span></span><span dojoAttachPoint=\"totalCountLabel\" class=\"totalCountLabel\"></span></span>\r\n\t\t<div id=\"${tableId}_xwtTableGlobalToolbar_refreshButton\" dojoType=\"dijit.form.Button\" dojoAttachPoint=\"refreshButton\" dojoAttachEvent=\"onClick: _refreshClick\" iconClass=\"xwtGlobalToolbarIcon xwtGlobalRefresh\" showLabel=\"false\">${!l10n.refresh}</div>\r\n\t\t<div id=\"${tableId}_xwtTableGlobalToolbar_printButton\" dojoType=\"dijit.form.Button\" dojoAttachPoint=\"printButton\" dojoAttachEvent=\"onClick: _printClick\" iconClass=\"xwtGlobalToolbarIcon xwtGlobalPrint\" showLabel=\"false\">${!l10n.print}</div>\r\n\t\t<div id=\"${tableId}_xwtTableGlobalToolbar_exportButton\" dojoType=\"dijit.form.Button\" dojoAttachPoint=\"exportButton\" dojoAttachEvent=\"onClick: _exportClick\" iconClass=\"xwtGlobalToolbarIcon xwtGlobalExport\" showLabel=\"false\">${!l10n.export}</div>\r\n\t\t<div id=\"${tableId}_xwtTableGlobalToolbar_settingsButton\" dojoType=\"dijit.form.DropDownButton\" dojoAttachPoint=\"settingsButton\" iconClass=\"xwtGlobalToolbarIcon xwtGlobalSettings\" showLabel=\"false\">\r\n\t\t\t<span>${!l10n.settings}</span>\r\n\t\t\t<div id=\"${tableId}_xwtTableGlobalToolbar_settingsMenu\" dojoType=\"dijit.Menu\" class=\"dijitRTL\" dojoAttachPoint=\"settingsMenu\" dir=\"rtl\" style=\"display:none;\">\r\n\t\t\t\t<div id=\"${tableId}_xwtTableGlobalToolbar_columnsMenu\" dojoType=\"dijit.PopupMenuItem\" class=\"xwtTableColumnsMenuItem\">\r\n\t\t\t\t\t<span>${_i18n.columns}</span>\r\n\t\t\t\t\t<div dojoType=\"dijit.Menu\" dojoAttachPoint=\"columnsMenu\" style=\"display:none;\">\r\n\t\t\t\t\t\t<!-- programmatically add all columns as a CheckedMenuItem here. -->\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t\t<!--\r\n\t\t\t\t<div dojoType=\"dijit.PopupMenuItem\">\r\n\t\t\t\t\t<span>Fix Column</span>\r\n\t\t\t\t\t<div dojoType=\"dijit.Menu\" dojoAttachPoint=\"fixColumnMenu\" style=\"display:none;\"></div>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div dojoType=\"dijit.PopupMenuItem\">\r\n\t\t\t\t\t<span>Detach Column</span>\r\n\t\t\t\t\t<div dojoType=\"dijit.Menu\" dojoAttachPoint=\"detachColumnMenu\" style=\"display:none;\"></div>\r\n\t\t\t\t</div>\r\n\t\t\t\t-->\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t</div>\r\n</div>\r\n",

	//	widgetsInTemplate: Boolean
	//		Indicates whether the dijit parser is to look for widgets defined in the template.
	widgetsInTemplate: true,

	//	showButtons: String?
	//		A comma-delimited list of buttons to show.  If empty, all buttons are shown; if the value
	//		is "none", then nothing is shown.
	showButtons: "",

	//	iconClass: String?
	//		An option iconClass that will be applied to the title node.
	iconClass: "",

	//	tableId: String
	//		A reference to the table this toolbar belongs with.
	tableId: "",

	//	disableFixedRowsMenu: [public] boolean
	//		Indicates if the fixed rows option in the menu should be disabled or not.
	//		The default is false.
	disableFixedRowsMenu: false,

	//	displayTotalRecords: [public] boolean
	//		Boolean flag to display the total records available to the table.
	displayTotalRecords: false,

	//	i18n: [private] Object
	//		The translation object for translatable strings.
	_i18n: null,

	//	_blankImage: [private] String
	//		A URL to a blank image used for spacing.
	_blankImage: dojo.moduleUrl("xwt", "widget/table/resources/blank.gif").toString(),

	_showRefresh:true, 
	_showExport:true,
	_showPrint:true,
	_hasSettings: true,
	_colsOriginalHiddenState: { },

	destroy: function(){
		this.inherited(arguments);
		
		if(this._selLabelUpdateTimer){
			clearTimeout(this._selLabelUpdateTimer);
			delete this._selLabelUpdateTimer;
		}
	},

	postMixInProperties: function(){
		this._i18n = dojo.i18n.getLocalization("xwt.widget.table", "Toolbar");
	},
	
	postCreate: function(){
		//	summary:
		//		If we have a reference to a table, read in the columns, set up our settings
		//		menu items, and set up which buttons are shown.
		this.inherited(arguments);

		if(this.iconClass){
			//	Grab the contents of iconClass and add it to our CSS definition.
			this.titleNode.className += " " + this.iconClass;
		}

		if(this.showButtons.length){
			//	We were passed a comma-delimited string. Go through it and hide the buttons that aren't there.
			var s = this.showButtons.toLowerCase();
			if(s == "none" || s.indexOf("refresh") == -1){ dojo.style(this.refreshButton.domNode, "display", "none"); this._showRefresh=false;}
			if(s == "none" || s.indexOf("print") == -1){ dojo.style(this.printButton.domNode, "display", "none"); this._showPrint=false;}
			if(s == "none" || s.indexOf("export") == -1){ dojo.style(this.exportButton.domNode, "display", "none"); this._showExport=false;}
			if(s == "none" || s.indexOf("settings") == -1){ 
				dojo.style(this.settingsButton.domNode, "display", "none");
				this._hasSettings = false;
			}
		}

		if(this.tableId){
			if(this.table()){
				//	See if our table has been created yet.
				this._setupMenuItems();
			} else {
				this.subscribe(this.tableId + "-startup", "_setupMenuItems");
			}
		}
	},

	_setupMenuItems: function(){
		if(this.table()){
			if (dojo.isIE < 8) {	
				// We need to connect to table's resize event as well as 
				// handle sizing ourselves initially.
				// This is to work around strange IE autosizing issues,
				// where the scroller vanishes for some odd reason.
				var tBox = dojo.position(this.table().tableContainer);
				dojo.style(this.domNode, "width", tBox.w + "px");
				this.connect(this.table(), "resize", function(dims){
					var b;
					if(dims){
						b = dims
					}else{
						var b = dojo.position(this.table().tableContainer);
					}
				});
			}

			// Only compress the global toolbar as far as the buttons and title will
			// allow.  CSCth88215
			var titleNodeBox = dojo.position(this.titleNode);
			var actionsBox = dojo.position(this.iconsNode);
			// Determine size + a small buffer.
			var contentWidth = Math.ceil(actionsBox.w + titleNodeBox.w + 16);
			dojo.style(this.domNode, "minWidth", contentWidth + "px");
		}
		
		if(this.table() && this.displayTotalRecords && this.countLabel){
			// Determine if we're single or multi-select.
			var selectMultiple = this.table()._multiple
			if(!selectMultiple){
				dojo.style(this.selectionCountLabel, "display", "none");
				dojo.style(this.countSeparator, "display", "none");
			}else{
				//check whether table has selection - CSCtn27035
				if (this.table().selected) {
					var selected = this.table().selected();
					var sc = 0;
					if (selected) {
						sc = selected.length;
					}
					this.selectionCountLabel.innerHTML = dojo.string.substitute(this._i18n.selectCount + "", {
						0: sc
					});
				}
				else
				{
				dojo.style(this.selectionCountLabel, "display", "none");
				dojo.style(this.countSeparator, "display", "none");
				}
			}
	
			var selUpdate = function() {
				// summary:
				//	Hitches to the toolbar that fires on
				//	select and deselect.  Sets a timer so that only the last select 
				//	after 0.25 second updates the label.  This avoids spamming updates
				//	with a selectAll and the like.
				if(this._selLabelUpdateTimer){
					clearTimeout(this._selLabelUpdateTimer);
					delete this._selLabelUpdateTimer;
				}
				this._selLabelUpdateTimer = setTimeout(dojo.hitch(this, function() {
					delete this._selLabelUpdateTimer;
					//check whether table has selection - CSCtn27035 
					if (this.table().selected)
					{
					var s = this.table().selected();
					var c = 0;
					if(s){
						c = s.length;	
					};
					this.selectionCountLabel.innerHTML = dojo.string.substitute(this._i18n.selectCount + "", {0: c});
					}
				}), 250);
			}
			this.connect(this.table(), "select", selUpdate);
			this.connect(this.table(), "deselect", selUpdate);
			this.connect(this.table(), "onLoadEnd", selUpdate);

			// Now show the the count labels and link to the row update calls.
			dojo.style(this.countLabel, "display", "inline-block");
			//this.totalCountLabel.innerHTML = dojo.string.substitute(this._i18n.rowCount + "", {0: 0});
			this.totalCountLabel.innerHTML = dojo.string.substitute(this._i18n.rowCount + "", {0: this.table()._totalRows > 0 ? this.table()._totalRows : 0});
			if (this.table()._rowsOverflow)
			{
				this.totalCountLabel.innerHTML+="+";
				this.totalCountLabel.title=dojo.string.substitute(this._i18n.maxCountTitle + "", {0: this.table().maxRows});
			}
			else
			{
				this.totalCountLabel.title="";
			}

			this.connect(this.table(), "onRowCountUpdate", function(count){
				this.totalCountLabel.innerHTML = dojo.string.substitute(this._i18n.rowCount + "", {0: count});
				if (this.table()._rowsOverflow)
				{
					this.totalCountLabel.innerHTML+="+";
					this.totalCountLabel.title=dojo.string.substitute(this._i18n.maxCountTitle + "", {0: this.table().maxRows});
					
				}
				else
				{
					this.totalCountLabel.title="";
				}
			});
		}
	
		if(this.table() && this._hasSettings){
			//	set up our menu items.
			var t = this.table(), c = t._columns;
			dojo.forEach(c.columns, function(col){
				//	don't do any ops if this is a select mechanism column.
				if(col.columnType != xwt.widget.table.ColumnTypes.COLUMN){ return; }

				//we need to see if a title is provided. Use the title also, otherwise use the label
				//useful when column label is an icon - CSCti46809
				var displayStr;
				if (col.title)
				{
					displayStr = col.label + ' ' + col.title;
				}
				else{
					displayStr = col.label;
				}

				//	set up the show/hide menu
				var cmi = new dijit.CheckedMenuItem({
					label: displayStr,
					checked: !col.hidden,
					column: col,
					onChange: function(checked){ 
						//	show or hide the given column
						c[checked?"show":"hide"](this.column);

						//	add or pull the menu item from the fix columns list
						
					}
				});
				this.columnsMenu.addChild(cmi);
				this._colsOriginalHiddenState[displayStr] = !col.hidden;

				//	Set up the fix/detach columns menu
				/*
				var mi = new dijit.MenuItem({
					label: col.label,
					column: col,
					onClick: function(){
						console.log("Freezing column: ", this.column.label);
						c.freeze(this.column);
					}
				});
				this.fixColumnMenu.addChild(mi);
				var mi = new dijit.MenuItem({
					label: col.label,
					column: col,
					onClick: function(){
						console.log("Unfreezing column: ", this.column.label);
						c.unfreeze(this.column);
					}
				});
				this.detachColumnMenu.addChild(mi);
				*/
			}, this);

			//	Set up the fix rows menu.
			if(this.table() && this.table().selected && !this.disableFixedRowsMenu){
				//	Create the fix rows/detach rows menu items.
				this.fixRowsTop = new dijit.MenuItem({
					label: this._i18n.fixToTop
				});
				this.fixRowsBottom = new dijit.MenuItem({
					label: this._i18n.fixToBottom
				});
				this.fixRowsMenu = new dijit.Menu({ });
				this.fixRowsMenu.domNode.style.display = "none";
				this.fixRowsMenu.addChild(this.fixRowsTop);
				this.fixRowsMenu.addChild(this.fixRowsBottom);
				
				// Try to figure out which way the menu opened and 'point' at it.
				this.connect(this.fixRowsMenu, "onOpen", function(){
					var menu = dojo.position(this.fixRowsMenu.domNode, true);
					var from = dojo.position(this.fixRowsMenu.from_item.domNode.parentNode.parentNode, true);
					// Try to determine l/r open.
					if(menu.x < from.x){
						// Opened on the left, lets flip the arrow.
						dojo.addClass(this.fixRowsMenu.from_item.domNode, "xwtTableSettingsFixedRowMenuPointLeft");
					}
				});
				this.connect(this.fixRowsMenu, "onClose", function(){
					dojo.removeClass(this.fixRowsMenu.from_item.domNode, "xwtTableSettingsFixedRowMenuPointLeft");
					this._ignoreResizeEvents = true;
				});
				
				this.fixRowsMenuItem = new dijit.PopupMenuItem({
					label: this._i18n.fixRow,
					popup: this.fixRowsMenu
				});
			
				this.settingsMenu.addChild(this.fixRowsMenuItem);
				dojo.addClass(this.settingsMenu.domNode, "xwtTableSettingsMenu");

				this.detachRows = new dijit.MenuItem({
					label: this._i18n.detachRow,
					disabled: true
				});
				this.settingsMenu.addChild(this.detachRows);

				//	Deal with the rows menus.
				this.connect(this.fixRowsTop, "onClick", function(){
					this.table().lock(this.table().selected(), true).clearSelections();
				});
				this.connect(this.fixRowsBottom, "onClick", function(){
					this.table().lock(this.table().selected()).clearSelections();
				});

				this.connect(this.detachRows, "onClick", function(){
					var tbl = this.table();
					var lockedItems = tbl.lockedItems();	
					if(lockedItems && lockedItems.length){
						var unlockItems = [];
						dojo.forEach(lockedItems, function(item){
							if(tbl.isSelected(item)){
								unlockItems.push(item);
							}	
						});
						this.table().unlock(unlockItems);
					}
				});

				var detachRowState = function(){
					if(this.__detachTimer){
						clearTimeout(this.__detachTimer);
						delete this.__detachTimer;
					}
					this.__detachTimer = setTimeout(dojo.hitch(this, function(){
						if(this.__detachTimer){
							delete this.__detachTimer;
							var lItems = this.table().lockedItems();
							if(lItems && lItems.length){
								var i;
								var state = true;
								for(i = 0; i < lItems.length; i++){
									if(this.table().isSelected(lItems[i])){
										state = false;
										break;
									}
								}
								this.detachRows.attr("disabled", state);
							}else{
								this.detachRows.attr("disabled", true);
							}
						}
					}), 100);
				};

				// Check for select/deselect events, and update accordingly.
				this.detachRows.attr("disabled", true); // Initial state is disabled.
				this.connect(this.table(), "onSelect", detachRowState);
				this.connect(this.table(), "onDeselect", detachRowState);
				
				//	Deal with table events.
				this.connect(this.table(), "onLock", function(items){
					var table = this.table();
					if(table._hasLockedRows()){
						var test = table._visibleLockedContainer;
						if(test == "top"){
							this.fixRowsBottom.attr("disabled", true);
						} else {
							this.fixRowsTop.attr("disabled", true);
						}
						this.detachRows.attr("disabled", false);
					}else{
						this.fixRowsBottom.attr("disabled", false);
						this.fixRowsTop.attr("disabled", false);
					}
				});
				this.connect(this.table(), "onUnlock", function(items){
					var table = this.table();
					if(!table._hasLockedRows()){
						this.fixRowsTop.attr("disabled", false);
						this.fixRowsBottom.attr("disabled", false);
						this.detachRows.attr("disabled", true);
					}
				});

				this.connect(this.table(), "onSelect", function(){
					this.fixRowsMenuItem.attr("disabled", false);
				});

				this.connect(this.table(), "onClearSelections", function(){
					this.fixRowsMenuItem.attr("disabled", true);
				});

				if(!this.table().selected().length){
					this.fixRowsMenuItem.attr("disabled", true);
				}
			}
				
				// We need to tweak columnsMenu behavior to prevent closing.
				this.columnsMenu.onItemClick = function(item, evt){
					// summary:
					//		Handle clicks on an item.
					//		This is a modified version to prevent menu closure.
					// tags:
					//		private
					if(item.disabled){ return false; }
			
					// this can't be done in _onFocus since the _onFocus events occurs asynchronously
					if(typeof this.isShowingNow == 'undefined'){ // non-popup menu
						this._markActive();
					}
			
					this.focusChild(item);
					item.onClick(evt);
				};
				
				dojo.addClass(this.columnsMenu.domNode, "xwtTableColumnsMenu");
				
				// Create early, we may need this for teams to link to.
				var bHolder = this;
				this.__columnResetButton = new xwt.widget.form.TextButton({
					label: this._i18n.resetColumnsMenu,
					onClick: dojo.hitch(this, "_resetColumnsToDefault"),
					id: this.table().id + "_xwtTableGlobalToolbar_columnsMenu_reset"
				});
				this.__columnResetButton.connect(this.columnsMenu, "destroy", function(){
					bHolder.__columnResetButton.destroy();
					delete bHolder.__columnResetButton;
				});
				this.__columnCloseButton = new xwt.widget.form.TextButton({
					label: this._i18n.closeColumnsMenu,
					baseClass: "defaultButton",
					onClick: dojo.hitch(this, function(){
						this.settingsButton.toggleDropDown();
					}),
					id: this.table().id + "_xwtTableGlobalToolbar_columnsMenu_close"
				});
				this.__columnCloseButton.connect(this.columnsMenu, "destroy", function(){
					bHolder.__columnCloseButton.destroy();
					delete bHolder.__columnCloseButton;
				});
				
				this.connect(this.columnsMenu, "onOpen", function(){
					this._ignoreResizeEvents = true;
							
					// Since the menu can open 'up' which we don't want, we'll reposition it.
					// Look at the menu that opened the columns menu, as that is what we'll 
					// align with an can use for height calc.  Note, we don't factor scrolling, 
					// as we want it viewport relative.
					var mPos = dojo.position(this.columnsMenu.from_item.domNode.parentNode.parentNode);						
					var vp = dijit.getViewport();
					// Determine the height, we need to remove a small buffer to help lessen 
					// overlap of scroll and the bottom toolbar.
					var maxHeight = vp.h - (mPos.y + 60);
					if(maxHeight < 0){
						maxHeight = 0;
					}
					var height = Math.ceil(Math.min(maxHeight, dojo.style(this.columnsMenu.containerNode, "height")));
					height += 2; // Add a little to account for hover borders.

					// Swizzle.  The menu is a table, which doesn't honor height settings.
					// So we adapt it so we can.
					if(this.columnsMenu.domNode.tagName == "TABLE" 
						&& !this.columnsMenu._scrollContainer){
						var tBody = dojo.create("tbody");
						var tr = dojo.create("tr", null, tBody);
						var td = dojo.create("td", {"class": "xwtColumnsMenuHolder"}, tr);
						var div = dojo.create("div", {"class": "columnsContainerDiv", style: {"zoom": 1, "position": "relative"}}, td);
						var table = dojo.create("table", {
							style: {
								"borderCollapse": "collapse",
								"borderSpacing": 0,
								"padding": 0,
								"margin": 0,
								"zoom": 1,
								"width": "100%"
							}
						}, div);
						dojo.style(div, {
							"overflowX": "hidden",
							"overflowY": "auto"
						});
						tr = dojo.create("tr", null, tBody);
						td = dojo.create("td", {"class": "xwtTableColumnsFooterSeparator"}, tr);
						var sepDiv = dojo.create("div", {"class": "xwtTableColumnsFooterSeparatorDiv"}, td);
						tr = dojo.create("tr", null, tBody);
						td = dojo.create("td", {"class": "xwtTableColumnsMenuFooter"}, tr);
						td.appendChild(this.__columnCloseButton.domNode);
						td.appendChild(dojo.create("span", {"class": "xwtTableColumnsMenuButtonSpacer"}));
						td.appendChild(this.__columnResetButton.domNode);
						dojo.place(this.columnsMenu.containerNode, table);
						dojo.place(tBody, this.columnsMenu.domNode);
						this.columnsMenu._scrollContainer = div;
						this.__columnResetButton.startup();
					}
					if(this.columnsMenu._scrollContainer){
						dojo.style(this.columnsMenu._scrollContainer, "paddingRight", "0px");
						dojo.style(this.columnsMenu._scrollContainer, "height", height + "px");
						var scrollHeight = Math.ceil(this.columnsMenu._scrollContainer.scrollHeight);;
						if(scrollHeight > height){
							var sDims = this.table()._getScrollBarDims();
							dojo.addClass(this.columnsMenu._scrollContainer.parentNode, "xwtColumnsMenuHolderScroller");
							if(!dojo.isIE || dojo.isIE > 7){
								var addWidth = dojo.isWebKit? sDims.w * 2 : sDims.w;
								dojo.style(this.columnsMenu._scrollContainer, "width", dojo.style(this.columnsMenu._scrollContainer, "width") + addWidth + "px");
							}
						}
						var menu = dojo.position(this.columnsMenu.domNode, true);
						var from = dojo.position(this.columnsMenu.from_item.domNode.parentNode.parentNode, true);
						// Try to determine l/r open.
						if(menu.x < from.x){
							// Opened on the left, so we need to shift.
							var borders = dojo._getBorderExtents(this.columnsMenu.domNode);
							var left = dojo.style(this.columnsMenu.domNode.parentNode, "left");
							dojo.style(this.columnsMenu.domNode.parentNode, "left", (left - ((menu.x + menu.w) - (from.x + borders.l)  )) + "px");
							dojo.addClass(this.columnsMenu.from_item.domNode, "xwtTableSettingsColumnsMenuPointLeft");
						}
						// Make sure top edge is aligned.
						dojo.style(this.columnsMenu.domNode.parentNode, "top", (from.y) + "px");
					}
					setTimeout(dojo.hitch(this, function() { delete this._ignoreResizeEvents; }), 50);
				});

				this.connect(this.columnsMenu, "onClose", function(){
					if(this.columnsMenu._scrollContainer){
						dojo.removeClass(this.columnsMenu._scrollContainer.parentNode, "xwtColumnsMenuHolderScroller");
						dojo.style(this.columnsMenu._scrollContainer, "width", "");
						dojo.removeClass(this.columnsMenu.from_item.domNode, "xwtTableSettingsColumnsMenuPointLeft");
					}
				});


			}
			
			//disable global toolbar actions when editing
			if("onEdit" in this.table()){
				this.connect(this.table(), "onEdit", function(){
					if (this._showRefresh){
						this.refreshButton.attr("disabled", true);
					}
					if (this._showPrint){
						this.printButton.attr("disabled", true);
					}
					if (this._showExport){
						this.exportButton.attr("disabled", true);
					}	
					if (this._hasSettings){						
						this.settingsButton.attr("disabled", true);
					}
				});
				this.connect(this.table(), "onEditorClose", function(){
					if (this._showRefresh){
						this.refreshButton.attr("disabled", false);
					}
					if (this._showPrint){
						this.printButton.attr("disabled", false);
					}
					if (this._showExport){
						this.exportButton.attr("disabled", false);
					}	
					if (this._hasSettings){						
						this.settingsButton.attr("disabled", false);
					}
				});
			}

			this.connect(this.table(), "onRefresh", function(dt){
				dojo.attr(this.refreshButton.titleNode, "title", "Last updated: " + dojo.date.locale.format(dt, {}));
			});

			//	Set our inital refresh date.
			dojo.attr(this.refreshButton.titleNode, "title", "Last updated: " + dojo.date.locale.format(this.table()._lastRefresh, {}));
		
	},
	
	resize: function(){
		// summary:
		//		Toggle the button if it is open and the menu bar resizes.  Keeps
		//		it from looking misaligned.
		if(!this._ignoreResizeEvents && this.settingsButton && this.settingsButton.attr("state") == "Opened"){
			this.settingsButton.toggleDropDown();
		}
		this.inherited(arguments);
	},

	_refreshClick: function(){
		if(!this.table()){
			return;
		}
		this.table().refresh();
		this.onRefreshClick();
	},
	_printClick: function(){
		this.onPrintClick();
	},

	_exportClick: function(){
		this.onExportClick();
	},
	_resetColumnsToDefault: function(){
		if(!this.table()){
			return;
		}
		dojo.forEach(this.columnsMenu.getChildren(), function(item){
			if(item.attr("label") in this._colsOriginalHiddenState){
				var b = this._colsOriginalHiddenState[item.attr("label")];
				if(item.attr("checked") != b){
					this.table()._columns[b?"show":"hide"](item.column);
				}
				item.attr("checked", b);
			}
		}, this);
		this.onColumnsResetClick();
	},

	table: function(){
		//	summary:
		//		Get the table reference for this toolbar.
		if(this.tableId){
			return dijit.byId(this.tableId);
		}
		return null;
	},

	setTitle:function(title, iconClass)
	{
		//	summary:
		//		Use this function to change the title in table's global toolbar
		//	title: String
		//		The new title 
		//	iconClass: String
		//		The new icon class for the title icon 

		//change title if present
		if (title !=null) {
			this.titleNode.innerHTML = title;
		}
		
		//change icon if present
		if(iconClass){
			//	Grab the contents of iconClass and add it to our CSS definition.
			this.titleNode.className += " " + iconClass;
		}
		
		console.log("Table title changed.");
	},
	
	onRefreshClick: function(){
		//	summary:
		//		Connect to this to listen for a click for refresh.
		console.log("The refresh button was clicked.");
	},
	onPrintClick: function(){
		//	summary:
		//		Connect to this to listen for a click to print the table's contents.
		console.log("The print button was clicked.");
	},
	onExportClick: function(){
		//	summary:
		//		Connect to this to listen for a click to export a table's contents.
		console.log("The export button was clicked.");
	},

	//	TODO: Settings menu items
	onColumnsResetClick: function(){
		//	summary:
		//		Action to take if the user clicked on "Columns > Reset to Default".
	}
});

dojo.declare("xwt.widget.table._MoveToRowDropdown", [ dijit._Widget, dijit._Templated ], {
	templateString:"<div class=\"xwtContextualMoveToDropdown\">\r\n\t<span class=\"xwtContextualMoveToLabel\">${moveToDropdownLabel}</span>\r\n\t<input dojoAttachPoint=\"moveToRowInput\" dojoAttachEvent=\"onkeydown: _onKeyDown, onpaste: _onPaste\" class=\"xwtContextualMoveToValue\" type=\"text\" value=\"\" />\r\n</div>\r\n",
	table: null,
	moveToDropdownLabel: "Row #: ",
	_valRegExp: /^\d+$/,
	_onKeyDown: function(e){
		if(e.keyCode == dojo.keys.ENTER){
			var v = this.moveToRowInput.value;
			// Verify the input is a valid number of 0 to many digits.
			if(this._valRegExp.test(v)){
				v = parseInt(v, 10);
				if(this.table){
					var index = Math.min(this.table._totalRows - 1, Math.max(v - 1, 0));
					var up = this._isMoveUp(index);
					this.table.moveTo(index, up);
				}
				this.moveToRowInput.value = "";
				this._lastValue = "";
				dojo.stopEvent(e);
				this.onChange(v);
			}
		}else if(e.keyCode == dojo.keys.DELETE || e.keyCode == dojo.keys.BACKSPACE){
			// Allow this to do normal behavior.
			setTimeout(dojo.hitch(this, function(){
				this._lastValue = this.moveToRowInput.value;
			}), 0);
			return true;
		}else if(!e.shiftKey && !e.metaKey && !e.ctrlKey){
			// We know it's not the enter key, so check to see
			// if the pressed key is a number or not, and clear if it isn't.
			var code = String.fromCharCode(e.keyCode);
			if(this._valRegExp.test(code)){
				if(e.keyCode > 31 && isNaN(parseInt(code, 10))){
					if(this.moveToRowInput.value.length){
						this.moveToRowInput.value = "" + parseInt(this.moveToRowInput.value, 10);
					}
					this._lastValue = this.moveToRowInput.value;
					dojo.stopEvent(e);
				}else{
					// Let bubble, then grab.
					setTimeout(dojo.hitch(this, function(){
						this._lastValue = this.moveToRowInput.value;
					}), 0);
				}	
			}else{
				dojo.stopEvent(e);
			}
		}else{
			dojo.stopEvent(e);
		}
	},

	_isMoveUp: function(index){
		// summary:
		//	Internal function to determine if the move is up or down.
		// index:
		//	The index to move to.
		var selected = this.table.selected();
		var up = true;
		var i;
		for(i = 0; i < selected.length; i++){
			var idx = this.table._idToIndex[this.table.store.getIdentity(selected[i])];
			if(idx < index){
				up = false;
				break;
			}
		}
		return up;
	},
	
	_onPaste: function(e){
		// summary:
		//	Function to check paste events (IE, FF, Safari)
		//	and make sure they are just numeric pastes.
		setTimeout(dojo.hitch(this, function(){
			var v = this.moveToRowInput.value;
			if(this._valRegExp.test(v)){
				this._lastValue = v;
			}else{	
				this.moveToRowInput.value = this._lastValue;
			}
		}), 0);
	},

	_onValueChange: function(){
		//	TODO: proper offset for row number, and numeric validation?
		var v = this.moveToRowInput.value;
		if(this.table){
			var index = Math.min(this.table._totalRows - 1, Math.max(v - 1, 0));
			var up = this._isMoveUp(index);
			this.table.moveTo(index, up);
		}
		this.moveToRowInput.value = "";
		this.onChange(v);
	},
	onChange: function(value){
		//	summary:
		//		Event stub for when the value of the dropdown changes.
		//	value: String
		//		The new value entered into the dropdown.
		//	tags:
		//		callback
	}
});

dojo.declare("xwt.widget.table._DeleteConfirm", xwt.widget.notification.Alert, {
	_createButtons: function(){
		var tg = this.buttonGroup;
		var self = this;

		if(!this._ourButtonConnects){
			this._ourButtonConnects = [];
		}

		//console.log (tg.getChildren());
		dojo.forEach(this.buttons, function(button){
			if(button && button.label){
				var widget = new xwt.widget.form.TextButton({label: button.label, baseClass:button.baseClass});
				self._ourButtonConnects.push(
					dojo.connect(widget, "onClick", function(){
						self.updateOptions();
						if(button.onClick){
							button.onClick();
						}
						self.hide();
						//self.destroyRecursive();
					})
				);
				tg.addChild(widget);
			}
		});
		if(this.messageNumber){
			dojo.create("div",{
				className: "xwtMessageNumber",
				innerHTML: "Message Number: " + "<span>" + this.messageNumber + "</span>"
			},tg.domNode);
		}
	},

	uninitialize: function(){
		// summary:
		//	Override to handle some cleanup.
		//	This is called by destroy.
		if(this._ourButtonConnects){
			dojo.forEach(this._ourButtonConnects, function(cn){
				dojo.disconnect(cn);
			});
			delete this._ourButtonConnects;
		}
		this.inherited(arguments);
	}
});

dojo.declare("xwt.widget.table.ContextualButtonGroup", [ dijit._Widget ], {
	//	summary:
	//		A preset group of buttons that can be dropped into a Contextual Toolbar that is
	//		table-specific (but not application-specific).  Use this widget as a single group
	//		within a Contextual Toolbar so that application-specific buttons can be arranged
	//		before and after this grouping.

	//	showButtons: String?
	//		A comma-delimited list of buttons to show.  If empty, all buttons are shown; if the value
	//		is "none", then nothing is shown.  Possible values are "filter", "move", "add", "delete",
	//		"edit", "all", "none".  The "all" and "none" are expected to be single values; the others
	//		can be part of a comma-delimited list.
	showButtons: "",

	//	deleteConfirm: xwt.widget.notification.Alert
	//		The Alert dialog to be used if the Delete button is enabled.
	deleteConfirm: null,

	//	editLabel: String
	//		The label for the Edit button. Defined for the purpose of i18ln.
	editLabel: "Edit",
	//	deleteLabel: String
	//		The label for the Delete button. Defined for the purpose of i18ln.
	deleteLabel: "Delete",
	//	moveToLabel: String
	//		The label for the Move To dropdown.  Defined for the purpose of i18ln.
	moveToLabel: "Move to",
	//	moveDownLabel: String
	//		The label for the Move Down button.  Defined for the purpose of i18ln.
	moveDownLabel: "Move down",
	//	moveUpLabel: String
	//		The label for the Move Up button.  Defined for the purpose of i18ln.
	moveUpLabel: "Move up",
	//	addRowLabel: String
	//		The label for the Add Row button.  Defined for the purpose of i18ln.
	addRowLabel: "Add Row",

	//	editButton: dijit.form.ToggleButton
	//		The button representing the edit functionality.
	editButton: null,

	//	deleteButton: dijit.form.Button
	//		The button representing the delete functionality.
	deleteButton: null,

	//	moveToButton: dijit.form.DropDownButton
	//		The button representing the "move to" functionality.
	moveToButton: null,

	//	moveUpButton: dijit.form.Button
	//		The button representing the "move up" functionality.
	moveUpButton: null,

	//	moveDownButton: dijit.form.Button
	//		The button representing the "move down" functionality.
	moveDownButton: null,

	//	separator: dijit.ToolbarSeparator
	//		The separator between the first and second groups.
	separator: null,

	//	addRowButton: dijit.form.Button
	//		The button representing the "add row" functionality.
	addRowButton: null,

	//	_toolbar: xwt.widget.table.ContextualToolbar?
	//		A private reference to the containing toolbar so that we can hook up
	//		our buttons to table actions.
	_toolbar: null,

	startup: function(){
		//	summary:
		//		Create our button widgets and place them within our parent (should be
		//		a Ribbon widget), directly after our domNode, then pull our domNode out
		//		of the document.
		if(this._started){ return; }
		this.inherited(arguments);

		var toolbarNode = this.domNode.parentNode.parentNode.parentNode.parentNode;
		var toolbar = this._toolbar = dijit.getEnclosingWidget(toolbarNode);
		var tableId = toolbar && toolbar.tableId;
		this.tableId = tableId;

		//	Subscribe to the table if it's there to handle our states when needed.
		if(toolbar && toolbar.table()){
			this._onTableStartup();
		} else {
			if(tableId){
				this.subscribe(tableId + "-startup", "_onTableStartup");
			}
		}
	},
	
	_createDeleteAlert: function(table){
		this.deleteConfirm = new xwt.widget.table._DeleteConfirm({
			messageType: "warning",
			dontShowAgainOption: true,
			buttons: [
				{ 
					label: "OK",
					baseClass:"defaultButton",
					onClick: function(){
						table.deleting = true;
						if(table._selected.allSelected && table.store.deleteAllItems){
							if(table.expandable() && table.expanded()){
								table.getExpander()._collapseRow();
							}
							table.store.deleteAllItems();
						} else {
							var s = table.selected(), test = table.expandable() && table.expanded();
							// CSCth63766
							// Locked item can't be deleted.
							dojo.forEach(s, function(item){
								if(table.store.isItem(item) && !table.isLocked(item)){
									if(test && table.getExpander()._item == item){
										table.getExpander()._collapseRow();
									}
									table.store.deleteItem(item);
								}
							});
						}
						// CSCth63766
						// Wait until the save completes to render.
						table.store.save({
							onComplete: function() {
								table.clearSelections();
								table.render(true);
								delete table.deleting;
							},
							onError: function(e){
								console.warn(e);
								table.clearSelections();
								table.render(true);
								delete table.deleting;
							}
						});
					}
				},
				{ 
					label: "Cancel",
					baseClass:"xwt-TextButton",
					onClick: dojo.hitch(this, function(){
						this.deleteConfirm.hide();
					})
				}
			]
		});

		this.deleteConfirm.setDialogContent('<div>Are you sure you would like to delete the selected item(s)?</div>');
		/*
		 * nbhattac - sitepen ticket 20700 - dijit dialog always attaches to body
		dojo.place(this.deleteConfirm.domNode, table.tableContainer);
		*/
	},

	_onTableStartup: function(){
		var table = this._toolbar && this._toolbar.table();
		if(!table){ return; }	//	bug out.
		var toolbar = this._toolbar;
		var tableId = toolbar && toolbar.tableId;
		var disabled = table && table.selected && !table.selected().length;

		var quickFilterDefault = table.quickFilterDefault || "All";
		
		this.connect(toolbar, "destroy", this.destroy);

		if(this.showButtons.length){
			this.showButtons = this.showButtons.toLowerCase();
		}

		//	Why someone would do this, I don't know.  But we'll support it anyway.
		if(this.showButtons == "none"){ return; }

		//	set up our switches based on showButtons.
		var 
			showAdd = true,
			showMove = true,
			showDelete = true,
			showEdit = true;
		if(this.showButtons.length && this.showButtons != "all"){
				
				showAdd = this.showButtons.indexOf("add")>-1;
				showMove = this.showButtons.indexOf("move")>-1;
				showDelete = this.showButtons.indexOf("delete")>-1;
				showEdit = this.showButtons.indexOf("edit")>-1;
		}

		//	We set things up backward to get the right order in the toolbar.
		var isTreeTable = (xwt.widget.table.TreeTable && table instanceof xwt.widget.table.TreeTable);

		if(showAdd && table && table.edit && !isTreeTable){
			this.addRowButton = new dijit.form.Button({
				id: this.tableId + "_xwtTableContextualToolbar_addRowButton",
				label: this.addRowLabel,
				iconClass: "xwtContextualIcon xwtContextualAddRow",
				showLabel: true,
				onClick: function(){
					if(table && table.edit){
						if(table.editing()){
							table.cancelEdit();
						}
						var tmpl = table._editor.addRequested = table._templateForItem();
						var ni = table.store.newItem(tmpl);
					}
				}
			});
			dojo.place(this.addRowButton.domNode, this.domNode, "after");
		}

		if((showAdd ) && table && (table.filter || (table.edit && !isTreeTable))){
			//if add or filter is there but no other table defined button in front, dont show the seperator
			if((showMove && table && table.store.moveTo && table.store.orderAttribute && !isTreeTable) ||
			(showDelete && table && table.store.deleteItem) ||
			(showEdit && table && table.edit))
			{
				this.separator = new dijit.ToolbarSeparator({});
				dojo.place(this.separator.domNode, this.domNode, "after");
			}
		}

		if(showMove && table && table.store.moveTo && table.store.orderAttribute && !isTreeTable){
			this.moveUpButton = new dijit.form.Button({
				id: this.tableId + "_xwtTableContextualToolbar_moveUpButton",
				label: this.moveUpLabel,
				"class": "xwtTableMoveUpButton",
				iconClass: "xwtContextualIcon xwtContextualMoveUp",
				showLabel: false,
				disabled: disabled,
				onClick: function(){
					table.moveUp();
				}
			});
			dojo.place(this.moveUpButton.domNode, this.domNode, "after");

			this.moveDownButton = new dijit.form.Button({
				id: this.tableId + "_xwtTableContextualToolbar_moveDownButton",
				label: this.moveDownLabel,
				"class": "xwtTableMoveDownButton",
				iconClass: "xwtContextualIcon xwtContextualMoveDown",
				showLabel: false,
				disabled: disabled,
				onClick: function(){
					table.moveDown();
				}
			});
			dojo.place(this.moveDownButton.domNode, this.domNode, "after");

			var popup = new xwt.widget.table._MoveToRowDropdown({
				table: table
			});

			this.moveToButton = new dijit.form.DropDownButton({
				id: this.tableId + "_xwtTableContextualToolbar_moveToButton",
				label: this.moveToLabel,
				iconClass: "xwtContextualIcon xwtContextualMoveTo",
				disabled: disabled,
				showLabel: true,
				dropDown: popup
			});

			this.moveToButton.toMenuItem = function(){
				return new dijit.PopupMenuItem({
					popup: new xwt.widget.table._MoveToRowDropdown({ table: table }),
					label: this.label,
					iconClass: "xwtContextualIcon xwtContextualMoveTo"
				});
			};
			dojo.place(this.moveToButton.domNode, this.domNode, "after");
			this.moveToButton.startup();
		}

		if(showDelete && table && table.store.deleteItem){
			//	Set up the alert dialog.
			this.deleteButton = new dijit.form.Button({
				id: this.tableId + "_xwtTableContextualToolbar_deleteButton",
				label: this.deleteLabel,
				iconClass: "xwtContextualIcon xwtContextualDelete",
				showLabel: true,
				disabled: disabled,
				onClick: dojo.hitch(this, function(){
					if(!this.deleteConfirm){
						this._createDeleteAlert(table);
					}
					if(this.deleteConfirm.dontShowAgain){
						table.deleting = true;
						if(table._selected.allSelected && table.store.deleteAllItems){
							table.store.deleteAllItems();
						} else {
							var s = table.selected();
							// CSCth63766
							// Can't delete locked items.
							dojo.forEach(s, function(item){
								if(!table.isLocked(item)){
									table.store.deleteItem(item);
								}
							});
						}
						// CSCth63766
						// Wait until the save completes to render.
						table.store.save({
							onComplete: function() {
								table.clearSelections();
								table.render(true);
								delete table.deleting;
							},
							onError: function(e){
								console.warn(e);
								table.clearSelections();
								table.render(true);
								delete table.deleting;
							}
						});
					} else {
						this.deleteConfirm.show();
					}
				})
			});
			dojo.place(this.deleteButton.domNode, this.domNode, "after");
		}

		if(showEdit && table && table.edit){
			this.editButton = new dijit.form.ToggleButton({
				id: this.tableId + "_xwtTableContextualToolbar_editButton",
				label: this.editLabel,
				iconClass: "xwtContextualIcon xwtContextualEdit",
				showLabel: true,
				disabled: disabled,
				onChange: function(state){
					if(state){
						var s = table.selected();
						if(!s.length){
							if(dojo.isFunction(table.editing)){
								if(!table.editing()){
									// Doesn't appear to be single-line editing, so just abort it
									// and flip state back.
									this.attr("checked", false);
								}else{
									// We seem to be single-line editing, force users
									// to explictly select save or cancel.
									this.attr("disabled", true);
								}
							}else{
								// Can't tell editor state, so untoggle.
								this.attr("checked", false);
							}
							return;
						}
						if(s.length == 1){
							//if expand panel is open, close that first.
							if (table.expandable() && table.expanded()) 
							{
								table.getExpander()._collapseRow();
							}
							if(table.store.isItem(s[0]) && !table.editing()){
								table.edit(s[0]);
								this.attr("disabled", true);
							}else{
								try{
									if(!table.store.isItem(s[0])){
										// May be a deleted/removed item, so deselect it.
										// odd case.
										table.deselect(s[0]);
									}
									if(!table.editing()){
										// We're not editing, so clear the check button.
										this.attr("checked", false);
									}
								}catch(e){
									// Ignore.
								}
							}
						}else{
							// Only allow editing of non-locked rows.
							var editables = [];
							var i;
							for(i = 0; i < s.length; i++){
								if(!table.isLocked(s[i]) && table.store.isItem(s[i])){
									// Only include valid items.
									editables.push(s[i]);
								}
							}
							if(!editables.length){
								this.attr("checked", false);	
							}
							if(editables.length){
								if(editables.length == 1){
									table.edit(editables[0]);
								}else{
									table.edit(editables);
								}
								this.attr("disabled", true);
							}
						}
					}
				}
			});
			this.editButton.connect(table, "edit",function(items){
				if(table.store.isItem(items)){
					this.attr("disabled", true);
				}else{
					this.attr("disabled", false);
				}
			});
			this.editButton.connect(table, "cancelEdit",function(){
				this.attr("checked", false);
				var sel = table.selected();
				if(sel && sel.length){
					var onlyLocked = true;
					if(sel && sel.length){
						var i;
						for(i = 0; i < sel.length; i++){
							if(!table.isLocked(sel[i])){
								onlyLocked = false;
								break;
							}
						}
					}
					if(!onlyLocked){	
						this.attr("disabled", false);
					}else{
						this.attr("disabled", true);
					}
				}else{
					this.attr("disabled", true);
				}
			});
			this.editButton.connect(table, "commit",function(){
				var sel = table.selected()
				if(sel && sel.length){
					var onlyLocked = true;
					if(sel && sel.length){
						var i;
						for(i = 0; i < sel.length; i++){
							if(!table.isLocked(sel[i])){
								onlyLocked = false;
								break;
							}
						}
					}
					if(!onlyLocked){	
						this.attr("disabled", false);
					}else{
						this.attr("disabled", true);
					}
				}else{
					this.attr("disabled", true);
				}
			});
			dojo.place(this.editButton.domNode, this.domNode, "after");
		}
		this.domNode.parentNode.removeChild(this.domNode);

		//	Set up our connections to the table.
		if("onSelect" in table){
			this.connect(table, "onSelect", dojo.hitch(this, function(){
				//if we are in edit, dont change button states on selection
				if (table && table.edit) {
					if (table.editing()) {
						return;
					}
				}
				
				// Throttle this to avoid spamming state changes of buttons.
				if(this.__onSelectTimer){
					clearTimeout(this.__onSelectTimer);
					delete this.__onSelectTimer;
				}
				this.__onSelectTimer = setTimeout(dojo.hitch(this, function(){
					var selected = table.selected();
					var onlyLocked = true;
					if(selected && selected.length){
						var i;
						for(i = 0; i < selected.length; i++){
							if(!table.isLocked(selected[i])){
								onlyLocked = false;
								break;
							}
						}
					}
					if(showEdit && table && table.edit && !onlyLocked){
						this.editButton.attr("disabled", false);
					}
					if(showDelete && table && table.store.deleteItem && !onlyLocked){
						this.deleteButton.attr("disabled", false);
					}
					if(showMove && table && table.store.moveTo && table.store.orderAttribute && !isTreeTable && !onlyLocked){
						var j;
						var hasLocked = false;
						var indexes = [];
						dojo.forEach(table.selected(), function(item){
							if(table.isLocked(item)){
								hasLocked = true;
							}
							// Collect up the indexes
							indexes.push(parseInt(table._idToIndex[table.store.getIdentity(item)]));
						});
						
						if(hasLocked){
							// Selection includes locked rows,
							// so disable move buttons.
							this.moveToButton.attr("disabled", true);
							this.moveUpButton.attr("disabled", true);
							this.moveDownButton.attr("disabled", true);
							return;
						}							
						
						// Okay, none of the selection is locked, so now we have to see if it is all
						// sequential.
						indexes.sort(function(a,b) { return a - b; });
						while(indexes.length > 1){
							var curIdx = indexes.shift();
							if(curIdx + 1 != indexes[0]){
								// Not sequential, so disable and return.
								this.moveToButton.attr("disabled", true);
								this.moveUpButton.attr("disabled", true);
								this.moveDownButton.attr("disabled", true);
								return;
							}
						}
						this.moveToButton.attr("disabled", false);
						this.moveUpButton.attr("disabled", false);
						this.moveDownButton.attr("disabled", false);

						//	Now check to make sure the first or last row is part of the selections.
						dojo.forEach(table.selected(), function(item){
							if(!table.isLocked(item)){
								var idx = table._idToIndex[table.store.getIdentity(item)];
								if(idx == 0){
									this.moveUpButton.attr("disabled", true);
								}
								if(idx == table._totalRows - 1){
									this.moveDownButton.attr("disabled", true);
								}
							}
						}, this);
					}
				}), 100);
			}));
			this.connect(table, "onSelectAll", dojo.hitch(this, function(){
				//if we are in edit, dont change button states on selection
				if (table && table.edit) {
					if (table.editing()) {
						return;
					}
				}
				if(showMove && table.store.moveTo && table.store.orderAttribute && !isTreeTable){
					this.moveToButton.attr("disabled", true);
					this.moveUpButton.attr("disabled", true);
					this.moveDownButton.attr("disabled", true);
				}
			}));
			this.connect(table, "onDeselect", dojo.hitch(this, function(){
				//if we are in edit, dont change button states on selection
				if (table && table.edit) {
					if (table.editing()) {
						return;
					}
				}
				// Throttle this to avoid spam-setting button states on the toolbar.
				if(this.__onDeselectTimer){
					clearTimeout(this.__onDeselectTimer);
					delete this.__onDeselectTimer;
				}
				this.__onDeselectTimer = setTimeout(dojo.hitch(this, function(){
	 				var selected = table.selected();
 					var onlyLocked = true;
					if(selected && selected.length){
						var i;
						for(i = 0; i < selected.length; i++){
							if(!table.isLocked(selected[i])){
								onlyLocked = false;
								break;
							}
						}
					}
					// Check the other button states.
					if(showDelete && table && table.store.deleteItem && !onlyLocked){
						this.deleteButton.attr("disabled", false);
					}else if(showDelete && table && table.store.deleteItem){
						this.deleteButton.attr("disabled", true);
					}

					if(showEdit && table && table.edit && !onlyLocked){
						this.editButton.attr("disabled", false);
					}else if(showEdit && table && table.edit){
						this.editButton.attr("disabled", true);
					}

					if(showMove && table && table.store.moveTo && table.store.orderAttribute && !isTreeTable && !onlyLocked){
						var j;
						var hasLocked = false;
						var indexes = [];
						dojo.forEach(table.selected(), function(item){
							if(table.isLocked(item)){
								hasLocked = true;
							}
							// Collect up the indexes
							indexes.push(parseInt(table._idToIndex[table.store.getIdentity(item)]));
						});
						
						if(hasLocked){
							// Selection includes locked rows,
							// so disable move buttons.
							this.moveToButton.attr("disabled", true);
							this.moveUpButton.attr("disabled", true);
							this.moveDownButton.attr("disabled", true);
							return;
						}							
						
						// Okay, none of the selection is locked, so now we have to see if it is all
						// sequential.
						indexes.sort(function(a,b) { return a - b; });
						while(indexes.length > 1){
							var curIdx = indexes.shift();
							if(curIdx + 1 != indexes[0]){
								// Not sequential, so disable and return.
								this.moveToButton.attr("disabled", true);
								this.moveUpButton.attr("disabled", true);
								this.moveDownButton.attr("disabled", true);
								return;
							}
						}
						this.moveUpButton.attr("disabled", false);
						this.moveDownButton.attr("disabled", false);
						this.moveToButton.attr("disabled", false);
						dojo.forEach(table.selected(), function(item){
							if(!table.isLocked(item)){
								var idx = table._idToIndex[table.store.getIdentity(item)];
								if(idx == 0){
									this.moveUpButton.attr("disabled", true);
								}
								if(idx == table._totalRows - 1){
									this.moveDownButton.attr("disabled", true);
								}
							}
						}, this);
					}else if(showMove && table && table.store.moveTo && table.store.orderAttribute && !isTreeTable){
						this.moveToButton.attr("disabled", true);
						this.moveUpButton.attr("disabled", true);
						this.moveDownButton.attr("disabled", true);
					}
				}), 100);
			}));
			this.connect(table, "onClearSelections", dojo.hitch(this, function(){
				//if we are in edit, dont change button states on selection
				if (table && table.edit) {
					if (table.editing()) {
						return;
					}
				}
				if(showEdit && table && table.edit){
					this.editButton.attr("disabled", true);
				}
				if(showDelete && table && table.store.deleteItem){
					this.deleteButton.attr("disabled", true);
				}
				if(showMove && table && table.store.moveTo && table.store.orderAttribute && !isTreeTable){
					this.moveToButton.attr("disabled", true);
					this.moveUpButton.attr("disabled", true);
					this.moveDownButton.attr("disabled", true);
				}
			}));
		}
		if(showMove && table.store.moveTo && table.store.orderAttribute && !isTreeTable){
			//	hook up the move up/move down enabling.
			this.connect(table, "onMove", dojo.hitch(this, function(){
				var atBeginning = false, atEnd = false;
				dojo.forEach(table.selected(), function(item){
					var idx = table._idToIndex[table.store.getIdentity(item)];
					if(idx == 0){
						atBeginning = true;
					}
					if(idx == table._totalRows - 1){
						atEnd = true;
					}
				}, this);
				this.moveUpButton.attr("disabled", atBeginning);
				this.moveDownButton.attr("disabled", atEnd);
			}));
		}
		
		//The edit toggle button is marked checked=false, the moment edit is clicked, 
		//and remains so as along as the editing is going on, to provide a visual 
		// indicator that editing is going on.
		//We need to reset it back when edit is completed or canceled, 
		//or the user has to click twice   - CSCti03814
		if("onEdit" in table){
			this.connect(table, "onEdit", dojo.hitch(this, function(){
				if (showEdit) {
					this.editButton.attr("checked", true);
				}
				//As per XMPGUI-187, we should disable other buttons
				//delete, add row, move up, down, to, filter

				//contextual toolbar
				if(showDelete && table && table.store.deleteItem ){
					this.deleteButton.attr("disabled", true);
				}
				if(showMove && table && table.store.moveTo && table.store.orderAttribute){
					this.moveToButton.attr("disabled", true);
					this.moveUpButton.attr("disabled", true);
					this.moveDownButton.attr("disabled", true);
				}
				if (showAdd && table && table.edit && !isTreeTable) {
					this.addRowButton.attr("disabled", true);
				}
				
				//preset filter
				if (this._toolbar.quickFilterSelect) {
					this._toolbar.quickFilterSelect.attr("disabled", true);
				}
				if (this._toolbar.newFilterButton) {
					this._toolbar.newFilterButton.attr("disabled", true);
				}
				
			}));
			this.connect(table, "onEditorClose", dojo.hitch(this, function(){
				var selected = table.selected();
				var onlyLocked = true;
				if(selected && selected.length){
					var i;
					for(i = 0; i < selected.length; i++){
						if(!table.isLocked(selected[i])){
							onlyLocked = false;
							break;
						}
					}
				}				
				if (showEdit) {
					this.editButton.attr("checked", false);
				}
				if (table.selected && table.selected().length && !onlyLocked) {
					if (table.store.deleteItem && showDelete) {
						this.deleteButton.attr("disabled", false);
					}
					if (showEdit && table && table.edit) {
						this.editButton.attr("disabled", false);
					}
					if (showMove && table && table.store.moveTo && table.store.orderAttribute && !isTreeTable) {
						this.moveToButton.attr("disabled", false);
						this.moveUpButton.attr("disabled", false);
						this.moveDownButton.attr("disabled", false);
						
						//	now check to make sure the first or last row is part of the selections.
						dojo.forEach(table.selected(), function(item){
							if (!table.isLocked(item)) {
								var idx = table._idToIndex[table.store.getIdentity(item)];
								if (idx == 0) {
									this.moveUpButton.attr("disabled", true);
								}
								if (idx == table._totalRows - 1) {
									this.moveDownButton.attr("disabled", true);
								}
							}
						}, this);
					}
				}
				else {
					if (showEdit) {
						this.editButton.attr("disabled", true);
					}
					}
				if (showAdd && table && table.edit && !isTreeTable) {
					this.addRowButton.attr("disabled", false);
				}
				
				//preset filter
				if (this._toolbar.quickFilterSelect) {
					this._toolbar.quickFilterSelect.attr("disabled", false);
				}
				if (this._toolbar.newFilterButton) {
					this._toolbar.newFilterButton.attr("disabled", false);
				}
			}));
		}
	},
	
	destroy: function(){
		if(!this.__destroyed){
			this.__destroyed = true;
			if(this.__onDeselectTimer){
				clearTimeout(this.__onDeselectTimer);
				delete this.__onDeselectTimer;
			}
			if(this.__onSelectTimer){
				clearTimeout(this.__onSelectTimer);
				delete this.__onSelectTimer;
			}
			if(this.deleteConfirm){
				// Cleanup our dialog.
				this.deleteConfirm.destroyRecursive();
				delete this.deleteConfirm;
			}
/*			
			if(this.filterToolbar && this.filterToolbar.domNode.parentNode){
				this.filterToolbar.destroyRecursive();
			}
*/			
			this.inherited(arguments);
		}

	}
});

dojo.declare("xwt.widget.table.ManageFilterDialog", xwt.widget.layout.Dialog, {
	//	TODO: i18ln
	button1Label: "Edit",
	button2Label: "Remove",
	button3Label: "Cancel",
	button1:null,
	button2:null,
	button3:null,
	title: "Manage Preset Filters",
	filterSelectLabel: "Select a filter  ",
	noFiltersLabel: "(No filters defined)",
	filterSelect: null,
	tableId: null,

	postCreate: function(){
		this.inherited(arguments);
		// Create our content.
		// Compute and size it to be a little less than the ComboBox.
		var bm = dojox.html.metrics.getTextBox(this.filterSelectLabel, {"whiteSpace": "nowrap"});
		var cbWidth = 230 - (bm.w + (dojo.isIE?20:0));
		this.filterSelect = new xwt.widget.form.DropDown({style: {"width": cbWidth + "px"}});
		
		var container = dojo.create("div", {
			className: "xwtManageFilterDialogContainer",
			style: "width: 240px; padding:5px; margin:5px"
		});
		
		var table = dojo.create("table", {style: {"borderCollapse":"separate"}});
		var tbody = dojo.create("tbody", null, table);
		var tr = dojo.create("tr", null, tbody);
		var td = dojo.create("td", {style: {"whiteSpace": "nowrap"}, innerHTML: this.filterSelectLabel}, tr);
		td = dojo.create("td", {style: {"paddingLeft": "5px"}}, tr);
		td.appendChild(this.filterSelect.domNode);
		
		//dojo.place(heading, container);
		//dojo.place(this.filterSelect.domNode, container);
		dojo.place(table, container);
		this.setDialogContent(container);
		this.filterSelect.startup();	
		this.connect(this, "show", "_populateFilters");
	},

	table: function(){
		if(this.tableId){
			return dijit.byId(this.tableId);
		}
		return null;
	},

	_createButtons: function(){
		var tg = this.buttonGroup;
		 this.button1 = new xwt.widget.form.TextButton({ label: this.button1Label, baseClass: this.button1BassClass });
		 this.button2 = new xwt.widget.form.TextButton({ label: this.button2Label });
		 this.button3 = new xwt.widget.form.TextButton({ label: this.button3Label });
		tg.addChild(this.button1);
		tg.addChild(this.button2);
		tg.addChild(this.button3);
		// Use this.connect to make sure connects are cleaned up on destroy.
		this.connect(this.button1, "onClick", "_editFilter");
		this.connect(this.button2, "onClick", "_removeFilter");
		this.connect(this.button3, "onClick", "hide");
	},
	_hookEvents: function(){
		//	we did this in the createButtons, so no worries.
		return;
	},

	_populateFilters: function(){
		var t = this.table(), fs = this.filterSelect;
		if(!t){ return; }
		//fs.options.length = 0;
		//While(fs.childNodes.length){ fs.removeChild(fs.childNodes[0]); fs.}
		while(this.filterSelect.options.length)
		{
			this.filterSelect.removeOption(0);
		}
		
		var newOptions = [];
		dojo.forEach(t.filters, function(f){ //t is the "table", don't use this CSCth60920
			if(f && f.editable){
				//fs.options[fs.options.length] = new Option(f.name, f.name);
				newOptions[newOptions.length] = {value:f.name, label: dojox.html.entities.encode(dojox.html.entities.decode(f.name, dojox.html.entities.html), dojox.html.entities.html)};
			}
		});
		
		if (newOptions.length >0)
		{
			this.filterSelect.addOption(newOptions);
		}
		
		var newFilters = this.filterSelect.getOptions(); 
		//if(!fs.options.length){
		if(newFilters.length <= 0){
			//	No filters to manage.
			//fs.options[fs.options.length] = new Option(this.noFiltersLabel, "");
			this.filterSelect.addOption({value:"!!!!!noVal!!!!", label:this.noFiltersLabel})
			
			//Disable edit/remove buttons.
			this.button1.attr("disabled", true);
			this.button2.attr("disabled", true);
		}
		else
		{
			//Disable edit/remove buttons.
			this.button1.attr("disabled", false);
			this.button2.attr("disabled", false);
			
		}
	},

	_getSelected: function(){
		var f = this.filterSelect.getValue(), 
			t = this.table(),
			filter = t._filterEngine.get(f);
		return filter;
	},

	_editFilter: function(){
		var filter = this._getSelected();
		this.onEdit(filter);
		this.hide();
	},
	_removeFilter: function(){
		var filter = this._getSelected(), t = this.table();
		if(!filter){ return; }
		this.onRemove(filter);
		t._filterEngine.remove(filter);
		t._filterEngine.save();
		this._populateFilters();
	},
	onEdit: function(filter){
		//	summary:
		//		Stub to be fired when a filter is edited.
	},
	onRemove: function(filter){
		//	summary:
		//		Stub to be fired when a filter is removed.
	}
});

dojo.declare("xwt.widget.table.SaveFilterDialog", xwt.widget.layout.Dialog, {
	button1Label: "Save",
	title: "Save a Preset Filter",
	filterInputLabel: "Filter Name  ",
	tableId: null,

	filterInput: null,

	postCreate: function(){
		this.inherited(arguments);

		//	Create our content.
		var input = this.filterInput = dojo.create("input", {
			className: "xwtSaveFilterDialogInput",
			type: "text",
			"class":"dialogInputElement",
			"style":"margin:5px"
		});
		this.connect(input, "onkeypress", function(evt){
			if(evt.charOrCode == dojo.keys.ENTER){
				dojo.stopEvent(evt);

				var val = dojo.trim(dojo.attr(this.filterInput, 'value'));
				if(val){
					this._saveFilter();
				}
			}
		});
		/*
		var label = dojo.create("label", {
			className: "xwtSaveFilterDialogLabel",
			innerHTML: this.filterInputLabel,
			"class":"dialogContentLabel"
		});*/
		var container = dojo.create("div", {
			className: "xwtManageFilterDialogContainer",
			innerHTML: this.filterInputLabel,
			style: {
				"width": "300px",
				"whiteSpace": "nowrap",
				"padding":"6px",
				"margin":"5px"
			}
		});

		//dojo.place(label, container);
		dojo.place(input, container);
		this.setDialogContent(container);

/* Why do we need this?? - Alka
		// Figure out how big to make the input.  Lots of calcs.  Ugh.
		var box = dojox.html.metrics.getTextBox(this.filterInputLabel, null, "xwtSaveFilterDialogLabel");
		var pl = dojo.style(this.containerNode.parentNode, "paddingLeft");
		var pr = dojo.style(this.containerNode.parentNode, "paddingRight");
		var lpl = dojo.style(label, "paddingLeft");
		var lpr = dojo.style(label, "paddingRight");
		var fieldWidth = 300 - (box.w + pl + pr + lpl + lpr);
		dojo.style(input, "width", fieldWidth + "px");
*/		
	},

	table: function(){
		if(this.tableId){
			return dijit.byId(this.tableId);
		}
		return null;
	},

	_createButtons: function(){
		var tg = this.buttonGroup;
		var button1 = new xwt.widget.form.TextButton({ label: this.button1Label, baseClass: this.button1BassClass });
		var button2 = new xwt.widget.form.TextButton({ label: this.button2Label });
		tg.addChild(button1);
		tg.addChild(button2);
		// Use this.connect to make sure connections are registered for cleanup.
		this.connect(button1, "onClick", "_saveFilter");
		this.connect(button2, "onClick", "hide");
	},
	_hookEvents: function(){
		return;
	},

	_saveFilter: function(){
		var name = dojo.trim(this.filterInput.value);
		if(!name){
			//	TODO: force them to type in a name!
			alert("Enter a valid filter name");
			return;
		}
		
		if(this.table()._filterEngine._filterMap[name]){	
			if(!this.table()._filterEngine._filterMap[name].editable)
			{				
				alert("Name belongs to pre-defined filter which cannot be edited. \nPls provide another name and save again.");
				return;
			}
		}

		this.onSave(name);

		//	Reset the widget.
		this.filterInput.value = "";
		this.hide();
	},
	onSave: function(filter){
		//	summary:
		//		Stub fired when a filter is saved.
//		var fs = this.filterSelect;
//		fs.options[fs.options.length] = new Option(filter.name, filter.name); 
	}
});

dojo.declare("xwt.widget.table.ContextualToolbar", [ xwt.widget.table.Toolbar, dijit._Container ], {
	//	summary:
	//		The widget representing any Contextual Toolbar (as per the Cisco TABLES specification).
	
	//	templatePath: String
	//		The path to the template that creates the widget.
	templateString:"<div class=\"dijitToolbar xwtContextualToolbar\" wairole=\"menubar\">\r\n\t<table class=\"xwtContextualToolbarRibbonContainer\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\r\n\t\t<tbody class=\"xwtContextualToolbarRibbonContainerTB\">\r\n\t\t\t<tr class=\"xwtContextualToolbarRibbonContainerTR\">\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<span class=\"xwtContextualPadding\"></span>\r\n\t\t\t\t</td>\r\n\t\t\t\t<td class=\"xwtContextualToolbarRibbonContainerTD\" cellpadding=\"0\" cellspacing=\"0\" vertical-align=\"top\">\r\n\t\t\t\t\t<div dojoType=\"xwt.widget.table.Ribbon\" id=\"${tableId}_xwtTableContextualToolbarRibbon\" dojoAttachPoint=\"ribbon\" class=\"xwtRibbon xwtContextualToolbarRibbon\">\r\n\t\t\t\t\t\t<div dojoAttachPoint=\"containerNode\"></div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</td>\r\n\t\t\t\t<td vertical-align=\"top\">\r\n\t\t\t\t\t<div dojoAttachPoint=\"quickFilterNode\" class=\"xwtQuickFilter\">\r\n\t\t\t\t\t\t<table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\r\n\t\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t\t<td class=\"xwtQuickFilterLabel\"><span>${quickFilterLabel}</span></td>\r\n\t\t\t\t\t\t\t\t<td width=\"120\">\r\n\t\t\t\t\t\t\t\t\t<select id=\"${tableId}_xwtTableContextualToolbar_quickFilterSelect\" dojoType=\"xwt.widget.form.DropDown\" class=\"xwtQuickFilterSelect\" sortByLabel=\"false\"\r\n\t\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"quickFilterSelect\" width=\"150\" dojoAttachEvent=\"onChange: _onQuickFilterChange\">\r\n\t\t\t\t\t\t\t\t\t</select>\r\n\t\t\t\t\t\t\t\t</td>\r\n\t\t\t\t\t\t\t\t<td width=\"10\"><span dojoType=\"dijit.ToolbarSeparator\"></span></td>\r\n\t\t\t\t\t\t\t\t<td width=\"30\">\r\n\t\t\t\t\t\t\t\t\t<span dojoType=\"dijit.form.ToggleButton\" iconClass=\"xwtContextualIcon xwtContextualFilterExpand\" class=\"xwtFilterStateButton\"\r\n\t\t\t\t\t\t\t\t\t\tshowLabel=\"false\" dojoAttachPoint=\"newFilterButton\" dojoAttachEvent=\"onClick: _onFilterButtonClick\">\r\n                        \t\t\t\tFilter\r\n                    \t\t\t\t</span>\r\n\t\t\t\t\t\t\t\t</td>\r\n\t\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t\t</table>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n",

	//	widgetsInTemplate: Boolean
	//		Indicates whether the dijit parser is to look for widgets defined in the template.
	widgetsInTemplate: true,

	//	tableId: String?
	//		A reference to the table widget this toolbar is attached to.
	tableId: "",

	//	_selectionState: Boolean
	//		Indicates whether the attached table has any selections.
	_selectionState: true,

	//	quickFilterLabel: String
	//		The label for the quick-filter selector.
	quickFilterLabel: "Show",
	
	//	quickFilter: Boolean
	//		Indicates whether to show the filter selector Use needFilter attribute. quickFilter retained for backward compatibility
	quickFilter: null,
	needFilter:true,

	//	manageFilterLabel: String
	//		The label to be inserted for quick-filter management.
	manageFilterLabel: "Manage Preset Filters",

	//	_allFilterLabel: String
	//		Label to be inserted for quick-filter management
	_allFilterLabel: "Show All",

	//	_quickFilterLabel: String
	//		Label to be inserted for quick-filter management
	_quickFilterLabel: "Quick Filter",

	//	_advanceFilterLabel: String
	//		Label to be inserted for quick-filter management
	_advanceFilterLabel: "Advanced Filter",

	//	filterManager: xwt.widget.table.ManageFilterDialog
	//		The dialog to do filter management.
	filterManager: null,

	//	disableManageFilters: Boolean
	//		Indicates whether to disable the Save button and preset filters Manage options.
	disableManageFilters: false,

	//	disableDefaultFilters: Boolean
	//		Indicates whether to disable the Quick Filter and Advacned Filter options.
	disableDefaultFilters: false,
	
	//	disableQuickFilter: Boolean
	//		Indicates whether to disable the Quick Filter option.
	disableQuickFilter: false,

	//	disableAdvancedFilter: Boolean
	//		Indicates whether to disable the Advacned Filter option.
	disableAdvancedFilter: false,

	//	_filterButton: xwt.widget.table.FilterButton
	//		The button representing the filtering functionality.
	_filterButton:null,

	//	filterToolbar: xwt.widget.table.FilteringToolbar
	//		The toolbar to be added after our parent toolbar for advanced filtering.
	filterToolbar: null,

	postCreate: function(){
		this.inherited(arguments);
		
		if(this.tableId){
			if(this.table()){
				//	See if our table has been created yet.
				this._onTableStartup();
			} else {
				this.subscribe(this.tableId + "-startup", "_onTableStartup");
			}
		}
		if (this.quickFilter!=null) {
			//doing this for backward compatibility
			this.needFilter = this.quickFilter;
		} 
		
		//Also of some reason if disableManageFilters = true, disableDefaultFilters=true and there are not preset filters, what the poioint of showing the filter dropdown.
		//set needFilter = false
		//practically, no one should be doing this, but we check anyway.
/*		
		if ( (this.table().filters==null) ||(this.table().filters.length <= 0) || 
			 (this.disableManageFilters == true) || (this.disableDefaultFilters == true))
			 {
			 	this.needFilter=false;
			 }
*/
		//if advanced filter is disabled, we disable the manage filter also, no matter what the user set
		//dont know why anyone would disable AdvancedFilter and want to manage filters, so we check anyway.
		if (this.disableAdvancedFilter === true || this.disableDefaultFilters === true)
		{
			this.disableManageFilters = true;
		}
		
		if(!this.needFilter ){
			dojo.style(this.quickFilterNode, "display", "none");
			dojo.style(this.ribbon.domNode, "margin-right", "0px");
		} else {
			this.filterManager = new xwt.widget.table.ManageFilterDialog({
				tableId: this.tableId
			});
			this.connect(this.filterManager, "onRemove", function(filter){
				//	Make sure the filter removed isn't the current one; if it is, clear our filters.
				if(filter == this.table()._currentFilter){
					this.table().clearFilter();
					var fValue = this.table().quickFilterDefault || "All";
					this.quickFilterSelect.attr("value", fValue);
				}

				//	Pull the filter out of the preset filter list.
				var s = this.quickFilterSelect;
				s.store.fetchItemByIdentity({
					identity: filter.name,
					onItem: function(item){
						s.store.deleteItem(item);
					}
				});
			});
			this.connect(this.filterManager, "onEdit", function(filter){
				//	Find our FilterButton in our children.
				var c = this.getChildren(), fb = this._filterButton;
/*				for(var i=0, l=c.length; i<l; i++){
					if(c[i].declaredClass == "xwt.widget.table.FilterButton"){
						fb = c[i];
						break;
					}
				}
*/
				if(fb){
					fb._showAdvancedToolbar(filter);
				} else {
					console.warn("A FilterButton was not found, we can't edit anything!");
				}
			});
		}
	},

	resize: function(){
		// summary:
		//		Rough resize function to trigger resize
		//		of the ribbon.
		if(this.ribbon){
			this.ribbon.resize();
		}
	},

	_onTableStartup: function(){
		var table = this.table();
		if(!table){ return; }

		if (this.needFilter  ) {
			this.filterToolbar = new (xwt.widget.table.FilteringToolbar)({
				tableId: this.tableId
			});

			this.filterToolbar.startup();
			dojo.place(this.filterToolbar.domNode, this.domNode, "after");
			
			this._filterButton = new xwt.widget.table.FilterButton({
				id: this.tableId + "_xwtTableContextualToolbar_filterButton",
				toolbarId: this.filterToolbar.id
			});
		}
		
		var i18n = dojo.i18n.getLocalization("xwt.widget.table", "Toolbar");
		if (this.needFilter) {
		
			//	set up our filtering select preset Filters.
			var s = this.quickFilterSelect;
			if (s.dropDown) {
				dojo.addClass(s.dropDown.domNode, "xwtTableQuickFilterMenu");
			}
			s.disableManageFilters = this.disableManageFilters;
			s.disableDefaultFilters = this.disableDefaultFilters;
			s.disableQuickFilter = this.disableQuickFilter;
			s.disableAdvancedFilter = this.disableAdvancedFilter;
			
			var filters = [];
			if (!this.disableDefaultFilters) {
				if (!this.disableQuickFilter) {
					filters.push({
						name: "Quick Filter",
						label: '<div>' + i18n.quickFilter + '</div>'
					})
				}
				if (!this.disableAdvancedFilter) {
					filters.push({
						name: "Advanced Filter",
						label: '<div>' + i18n.advancedFilter + '</div>'
					});
				}
				if (!this.disableQuickFilter && !this.disableAdvancedFilter) {
					filters.push({
						name: "Advanced Filter Separator",
						label: '<div></div>',
						separator: true
					});
				}
			}
			
			filters.push({
				name: "All",
				label: '<div>' + i18n.allFilter + '</div>'
			});
			
			if (!this.disableManageFilters) {
				filters.push({
					name: this.manageFilterLabel,
					label: "<div>" + this.manageFilterLabel + '</div>'
				});
			}
			
			filters.push({
				name: this.manageFilterLabel + " Separator",
				label: '<div></div>',
				separator: true
			});
			
			
			if ((table.filters != null) && (table.filters.length > 0)) {
				filters = filters.concat(dojo.map(table.filters, function(f, idx){
					return {
						name: f.name,
						label: '<div>' + dojox.html.entities.encode(dojox.html.entities.decode(f.name, dojox.html.entities.html), dojox.html.entities.html) + '</div>'
					}
				}));
			}
			
			var store = new dojo.data.ItemFileWriteStore({
				data: {
					identifier: 'name',
					label: 'label',
					items: filters
				}
			});
			var qfDefault = table.quickFilterDefault || "All";
			var useDefault = false;
			if (qfDefault != "All") {
				var i;
				for (i = 0; i < table.filters.length; i++) {
					if (qfDefault == table.filters[i].name) {
						useDefault = true;
						break;
					}
				}
			}
			if (!useDefault) {
				qfDefault = "All";
				table.quickFilterDefault = qfDefault;
			}
			
			/* Over-ride the menu generator function to let us insert separators. */
			if (!s.__oldGetMenuItemForOption) {
				s.__oldGetMenuItemForOption = s._getMenuItemForOption;
				s._getMenuItemForOption = function(option){
					var item = option.item;
					if (item) {
						var sep = s.store.getValue(item, "separator");
						if (sep) {
							return new dijit.MenuSeparator();
						}
						else {
							return s.__oldGetMenuItemForOption(option);
						}
					}
					else {
						return s.__oldGetMenuItemForOption(option);
					}
				};
			}
			s.setStore(store, qfDefault);
			
			if (!this.disableManageFilters) {
				this.connect(this.filterToolbar.saveFilterDialog, "onSave", dojo.hitch(this, function(name){
					console.log("changing advanced filter to the new name: " + name);
					//this.quickFilterSelect.attr("value" , name, false);
					this.quickFilterSelect._setValueAttr(name, false);
				}));
			}
			
			
			// Use this.connect to register for cleanup.  The scope of the call
			// doesn't matter here, since it operates on 'toolbar'
			this.connect(this._filterButton, "_showAdvancedToolbar", dojo.hitch(this, function(){
				if (this.quickFilterSelect.disableManageFilters) {
					dojo.style(this.filterToolbar.saveButton.domNode, "visibility", "hidden");
					this.filterToolbar.disableManageFilters = true;
				}
				else {
					dojo.style(this.filterToolbar.saveButton.domNode, "visibility", "");
					delete this.filterToolbar.disableManageFilters;
				}
			}));
		//when filter is applied or cleared, we need to update the filter button icon
		//hence these 2 connects
		this.connect(this.table(), "onFilter", dojo.hitch(this, function(){
			//change filter button state here 
			var val = this.quickFilterSelect.attr("value");
			if ((val == "Quick Filter") || (val == "Advanced Filter"))
			{
				this._setFilterButtonState(false, true);
			}
		}));

		this.connect(this.table(), "onClearFilter", dojo.hitch(this, function(){
			//change filter button state here
			var val = this.quickFilterSelect.attr("value");
			if ((val == "Quick Filter") || (val == "Advanced Filter"))
			{
				this._setFilterButtonState(false, false);
			}
		}));
		
		}

		if (dojo.isIE < 8) {
			var resizer = dojo.hitch(this, function(){
				var box = dojo.position(this.table().domNode);
				dojo.style(this.domNode, "width", box.w + "px");
				this.resize();
			});
			this.connect(this.table(), "resize", resizer);
			resizer();
		}
		
		/*
		this.connect(this.table(), "onSelect", dojo.hitch(this, function(){
			//	Enable the appropriate buttons.
			this._setSelectionState(true);
		}));
		this.connect(this.table(), "onClearSelections", dojo.hitch(this, function(){
			this._setSelectionState(false);
		}));
		this._setSelectionState(this.table().selected && this.table().selected().length > 0);
		*/
	},

	_onFilterButtonClick: function(value){
		if(!this.table()){ return; }
/*
//we dont need this here?
		//collapse any expanded rows - CSCtk53547
		_table = this.table();
		if(_table.expandable && _table.expandable() && _table.expanded && _table.expanded()){
			_table.getExpander()._collapseRow();
		}
*/

		//get reference to filterButton
		//since the filterbar is created via fitlerButton
		//TODO cleanup this some day
				//	Find our FilterButton in our children.
				var c = this.getChildren(), fb = this._filterButton;
/*				for(var i=0, l=c.length; i<l; i++){
					if(c[i].declaredClass == "xwt.widget.table.FilterButton"){
						fb = c[i];
						break;
					}
				}
*/
		var value = this.quickFilterSelect.attr("value");

		//this._lastQuickFilter = value;
		var closed = true, filtered=false;
		
		if(value == this.manageFilterLabel){
			//if "Manage Filters" was the selection, clicking this toggle button doesnt do anything"
			//should we disable it instead?? Ask UX
			return;
		}
		else if(value == "All" ){
			//if "All" clicking this button show quick filter
			//but if the quickfilter is not shown i.e.disableDefaultFilters=true we throw a message
			if (this.disableDefaultFilters || this.disableQuickFilter) 
			{
				var alert = new xwt.widget.notification.Alert({
					messageType:"information",
					buttons: [{label: "OK"}]
				});
				alert.setDialogContent("Select a filter from the filter list to see the details."); 
			}
			else
			{
				this.quickFilterSelect.attr("value", "Quick Filter");
				closed = false;
				filtered = false;
				this._lastQuickFilter = value;
			}
		} 
		else if(value == "Quick Filter" ){
			if (this.table()._currentFilter) {
				this.table().clearFilter();
				
				}
				if (fb.isShown) {
					fb._hideFilterBar();
					
				}
				filtered = false;
				closed = true;
				this.quickFilterSelect.attr("value", "All");
		} 
		else if(value == "Advanced Filter" ){
			if (this.table()._currentFilter){
				//this.table().clearFilter();
				filtered = true;
				if (fb.isShown) {
					fb._hideFilterBar();
					closed = true;
				}
				else {
					closed = false;
					fb._showAdvancedToolbar(this.table()._currentFilter);
				}

			}
			else {
				filtered = false;
				if (fb.isShown) {
					fb._hideFilterBar();
					closed = true;
				}
				else {
					closed = false;
					fb._showAdvancedToolbar();
				}
			}
		} 
		else {
			//	Get the filter and apply it.
			var f = this.table()._filterEngine.get(value);
			if(f){
				this.table().filter(f);
			}
			this._lastQuickFilter = value;
			filtered = true;
				//show the filter criteria
				//fb._showAdvancedToolbar(f);
				if (fb.isShown) {
					fb._hideFilterBar();
					closed = true;
				}
				else {
					closed = false;
					fb._showAdvancedToolbar(f);
					if (!f.editable) {
						this.filterToolbar._disable(true);
					}
				}
			}
		
		this._setFilterButtonState(closed, filtered);

	},

	_lastQuickFilter: 'All',
	_onQuickFilterChange: function(value){
		if(!this.table()){ return; }

		//collapse any expanded rows - CSCtk53547
		_table = this.table();
		if(_table.expandable && _table.expandable() && _table.expanded && _table.expanded()){
			_table.getExpander()._collapseRow();
		}
	
		//get reference to filterButton
		//since the filterbar is created via fitlerButton
				//	Find our FilterButton in our children.
				var c = this.getChildren(), fb = this._filterButton;
/*				
				for(var i=0, l=c.length; i<l; i++){
					if(c[i].declaredClass == "xwt.widget.table.FilterButton"){
						fb = c[i];
						break;
					}
				}
*/				

		var applied = false, closed=true;
		
		if(value == this.manageFilterLabel){
			this.filterManager.show();
			this.quickFilterSelect.attr("value", this._lastQuickFilter);
		}
		else if(value == "All" ){
			if (this.table()._currentFilter){
				this.table().clearFilter();
			}
			if (fb) {
				fb._hideFilterBar();
			}
			
			this._lastQuickFilter = value;
		} 
		else if(value == "Quick Filter" ){
			if (this.table()._currentFilter){
				this.table().clearFilter();
			}
			this._lastQuickFilter = value;
			if (fb) {
				fb._hideFilterBar();
				fb._showExamples();
			}
			applied=false;
			closed=false;
		} 
		else if(value == "Advanced Filter" ){
			if (this.table()._currentFilter){
				this.table().clearFilter();
			}
			this._lastQuickFilter = value;
			if (fb) {
				fb._hideFilterBar();
				fb._showAdvancedToolbar();
			}
			applied=false;
			closed=false;
			
		} 
		else {
			if (fb) {
				fb._hideFilterBar();
			}
			//	Get the filter and apply it.
			var f = this.table()._filterEngine.get(value);
			if(f){
				this.table().filter(f);
			}
			this._lastQuickFilter = value;
			applied=true;
			closed=true;
		}
		
		console.log("Selected filter Option: " + value);
		this._setFilterButtonState(closed, applied);
	},

	_setFilterButtonState: function(isClosed, isFiltered)
	{
		//console.log("Closed: " + isClosed + ", Applied: " + isFiltered);
		 if (isClosed && !isFiltered) {
		 	this.newFilterButton.attr("iconClass", "xwtContextualIcon xwtContextualFilterExpand");
		 }
		 if (!isClosed && !isFiltered) {
		 	this.newFilterButton.attr("iconClass", "xwtContextualIcon xwtContextualFilterCollapse");
		 }
		 if (isClosed && isFiltered) {
		 	this.newFilterButton.attr("iconClass", "xwtContextualIcon xwtContextualFilterExpandApplied");
		 }
		 if (!isClosed && isFiltered) {
		 	this.newFilterButton.attr("iconClass", "xwtContextualIcon xwtContextualFilterCollapseApplied");
		 }
	},
	
	_setSelectionState: function(/* Boolean */state){
		if(state != this._selectionState){
			this._selectionState = state;
			this._setButtonStates(!state);
		}
	},

	_setButtonStates: function(/* Boolean */state){
		//	summary:
		//		Enable or disable any buttons in our toolbar, as appropriate.
	//	this.editButton.attr("disabled", state);
	},

	table: function(){
		//	summary:
		//		Get the table reference for this toolbar.
		if(this.tableId){
			return dijit.byId(this.tableId);
		}
		return null;
	},
	
	destroy: function(){
		// Override to do cleanup.
		this.inherited(arguments);
		if(this.filterManager){
			this.filterManager.destroyRecursive();
			delete this.filterManager;
		}
		
		if(this.filterToolbar && this.filterToolbar.domNode.parentNode){
			this.filterToolbar.destroyRecursive();
			delete filterToolbar;
		}

		if(this._filterButton){
			this._filterButton.destroyRecursive();
			delete _filterButton;
		}
	}
});

//	FILTERING TOOLS
xwt.widget.table.FilteringWidgetMap = {
	'string': dijit.form.TextBox,
	'numeric': dijit.form.NumberTextBox,
	'alphanumeric': dijit.form.TextBox,
	'enumeration': xwt.widget.form.DropDown
};

dojo.declare("xwt.widget.table._FilterWidget", [dijit._Widget, dijit._Templated], {
	templateString: dojo.cache("xwt.widget.table", "templates/_FilterWidget.html", "<table class=\"xwtNotification xwtFilterWidget\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\">\r\n\t<tbody><tr>\r\n\t\t<td class=\"column-cell\">\r\n\t\t\t<select dojoType=\"xwt.widget.form.DropDown\" dojoAttachPoint=\"column\" searchAttr=\"name\"\r\n\t\t\t\tdojoAttachEvent=\"onChange: _onColumnChange\" style=\"width:175px;\"></select>\r\n\t\t</td>\r\n\t\t<td class=\"operator-cell\">\r\n\t\t\t<select dojoType=\"xwt.widget.form.DropDown\" dojoAttachPoint=\"operator\" searchAttr=\"name\" style=\"width:175px;\"></select>\r\n\t\t</td>\r\n\t\t<td dojoAttachPoint=\"criteriaCell\" class=\"criteria-cell\">\r\n\t\t\t<input type=\"text\" dojoType=\"dijit.form.TextBox\" dojoAttachPoint=\"criteria\" />\r\n\t\t</td>\r\n\t\t<td class=\"action-cell\">\r\n\t\t\t<button type=\"button\" dojoType=\"xwt.widget.form.TextButton\" dojoAttachPoint=\"removeButton\" dojoAttachEvent=\"onClick: onRemove\" iconClass=\"removeButton\" showLabel=\"false\"></button>\r\n\t\t\t<button type=\"button\" dojoType=\"xwt.widget.form.TextButton\" dojoAttachPoint=\"addButton\" dojoAttachEvent=\"onClick: onAdd\" iconClass=\"addButton\" showLabel=\"false\"></button>\r\n\t\t</td>\r\n\t\t<td>\r\n\t\t</td>\r\n\t</tr></tbody>\r\n</table>\r\n"),
	widgetsInTemplate: true,

	postCreate: function(){
		this.inherited(arguments);
		this.column.setStore(this.columnStore);
	},

	onAdd: function(){},
	onRemove: function(){
		this.destroy();
	},

	getFilterExpression: function(){
		if(this.column.attr("value")!=null)
		{
			var attr = this.column.attr("value");
			attr = attr.substr(0, attr.indexOf("-"));
			return {
				op: this.operator.attr('value'),
				attr: attr,
				value: this.criteria && this.criteria.attr('value')
			};
		}
	},

	_onColumnChange: function(value){
		var column = this.column,
			columnStore = this.columnStore,
			self = this;

		if(value){
			columnStore.fetchItemByIdentity({
				identity: value,
				onItem: function(item){
					self._setFilterType(item);
				}
			});
		}
	},

	_setSelectStore: function(select, store, onItem){
		select.store = store;
		select.attr('displayedValue', '');
	},

	_setFilterType: function(item){
		var id = this.columnStore.getIdentity(item);
		this.operator.sortByLabel = false;
		this.operator.setStore(this.opsStores[id]);
		var disabled = false;
		if(this.criteria){
			disabled = this.criteria.attr("disabled");
			this.criteria.destroyRecursive();
			this.criteria = null;
		}
		if(this.widgetTypeMap[id]){
			var criteria = this.criteria = new this.widgetTypeMap[id]({});
			// See if we're an enum type and if we need to build a store.			
			var type = this.columnStore.getValue(item, "filterType");
			var opts = this.columnStore.getValue(item, "filterOptions");
			if(type == "enumeration" && opts && opts.autoSuggestValues){
				var data = {identifier: "name", label: "name", items: []};
				var i;
				for(i = 0; i < opts.autoSuggestValues.length; i++){
					data.items.push({
						"name": opts.autoSuggestValues[i]
					});
				}
				criteria.searchAttr = "name";
				criteria.store = new dojo.data.ItemFileReadStore({data: data});

				// Test to see if sorting option is set
				// by default we are sorting so we mainly want 
				// to see if it was defined and its value was false.
				if("sortAutoSuggestValues" in opts){
					if(!opts.sortAutoSuggestValues){
						criteria.sortByLabel = false;
					}
				}
			}
			if (disabled) {
				criteria.attr("disabled", disabled);
			}
			criteria.placeAt(this.criteriaCell);
			//change for CSCti23856
			dojo.style(criteria.domNode, {	        	
	        	'width':160+'px'
	        });
			if(this._started){
				criteria.startup();
			}
			this.connect(this.operator, "onChange", function(value){
				if(criteria && criteria.domNode){
					if(value == "is-empty" || value == "is-not-empty"){
						dojo.style(criteria.domNode, "display", "none");
					}else if (dojo.style(criteria.domNode, "display") == "none"){
						dojo.style(criteria.domNode, "display", "");
					}
				}
			});
		}
	},
	
	destroy: function(){
		this.inherited(arguments);
		if(this.criteria){
			this.criteria.destroyRecursive();
		}
	}
});

dojo.declare("xwt.widget.table.FilteringToolbar", xwt.widget.table.ContextualToolbar, {
	templateString: dojo.cache("xwt.widget.table", "templates/FilteringToolbar.html", "<div class=\"dijitToolbar xwtContextualToolbar xwtFilteringToolbar\" wairole=\"menubar\" style=\"display: none;\">\r\n\t<div class=\"labels\">\r\n\t\t<span dojoAttachPoint=\"oneLabel\">${!l10n.matchOne}:</span>\r\n\t\t<span dojoAttachPoint=\"manyLabel\" style=\"display: none;\">\r\n\t\t\t${!l10n.matchManyStart}<select dojoType=\"xwt.widget.form.DropDown\" dojoAttachPoint=\"manySelect\">\r\n\t\t\t\t<option value=\"and\">${!l10n.all}</option>\r\n\t\t\t\t<option value=\"or\">${!l10n.any}</option>\r\n\t\t\t</select>${!l10n.matchManyEnd}:\r\n\t\t</span>\r\n\t\t<button type=\"button\" dojoType=\"dijit.form.ToggleButton\" dojoAttachPoint=\"filterOverflowButton\" iconClass=\"xwtFilteringToolbarOverflowButtonIcon\" showLabel=\"false\" class=\"xwtFilteringToolbarOverflowButton\">${!l10n.slideRight}</button>\r\n\t</div>\r\n\t<span class=\"filter-container\">\r\n\t\t<span class=\"label-cell\">${!l10n.filter}</span>\r\n\t\t<table cellpadding=\"0\" cellspacing=\"0\" border=\"0\" class=\"filter-table\">\r\n\t\t\t<tbody><tr>\r\n\t\t\t<td dojoAttachPoint=\"containerNode\" class=\"filter-cell\"></td>\r\n\t\t\t<td class=\"button-cell\">\r\n\t\t\t\t<button type=\"button\" dojoType=\"xwt.widget.form.TextButton\" dojoAttachPoint=\"goButton\" dojoAttachEvent=\"onClick: _onGo\" disabled>${!l10n.go}</button>\r\n\t\t\t\t<button type=\"button\" dojoType=\"xwt.widget.form.TextButton\" dojoAttachPoint=\"clearButton\" dojoAttachEvent=\"onClick: _onClear\" disabled>${!l10n.clearFilter}</button\r\n\t\t\t\t><button type=\"button\" dojoType=\"dijit.form.Button\" dojoAttachPoint=\"saveButton\" iconClass=\"saveButton\" showLabel=\"false\" dojoAttachEvent=\"onClick: _onSave\" disabled class=\"buttonNoBackground\">${!l10n.save}</button>\r\n\t\t\t</td>\r\n\t\t\t</tr></tbody>\r\n\t\t</table>\r\n\t</span>\r\n</div>\r\n"),
	hidden: true,

	//	saveFilterDialog: xwt.widget.table.SaveFilterDialog
	//		The save dialog.
	saveFilterDialog: null,

	//	currentFilter: xwt.widget.table.__Filter
	//		If we are editing a filter, this is a reference to the filter being edited.
	//		That way we can pre-populate the save dialog with the filter name.
	currentFilter: null,
	
	// filterOverflowButton: dijit.form.ToggleButton
	//		The toggle button to handle sliding the toolbar back and forth.
	filterOverflowButton: null,

	postMixInProperties: function(){
		this.inherited(arguments);

		var parts = this.l10n.matchMany.split('${0}');
		this.l10n.matchManyStart = parts[0];
		this.l10n.matchManyEnd = parts[1];
	},

	postCreate: function(){
		if(!xwt.widget.table.FilteringOperatorMap){
			// Define the singleton here, as the locale should be loaded.
			var emptyMap = {};
			var stringMap = {},
			numericMap = {},
			map = dojo.i18n.getLocalization("xwt.widget.table", "Filter");
			dojo.forEach(["contains", "not-contains", "starts-with", "ends-with",
				"is-empty", "is-not-empty", "equals", "not-equals"], function(key){
				stringMap[key] = map[key];
			});
			dojo.forEach(["equals", "not-equals", "greater-than", "less-than",
				"greater-equals", "less-equals"], function(key){
				numericMap[key] = map[key];
			});
        
			var booleanMap = {
				"is-true": map["is-true"],
				"is-false": map["is-false"]
			};
			var enumerationMap = {
				"equals": map["equals"],
				"not-equals": map["not-equals"]
			};
			xwt.widget.table.FilteringOperatorMap = {
				'empty': emptyMap,
				'string': stringMap,
				'numeric': numericMap,
				'alphanumeric': dojo.mixin({}, stringMap, numericMap),
				'boolean': booleanMap,
				'enumeration': enumerationMap
        		};
		}
		var opMap = xwt.widget.table.FilteringOperatorMap;

		function getOpsStore(type){
			var map = opMap[type],
				ops = [];
			for(var i in map){
				ops.push({
					id: i,
					name: map[i]
				});
			}
			return new dojo.data.ItemFileReadStore({
				data: {
					identifier: 'id',
					label: 'name',
					items: ops
				}
			});
		}

		this._emptyOpStore = getOpsStore('empty');
		this._stringOpStore = getOpsStore('string');
		this._numericOpStore = getOpsStore('numeric');
		this._alphanumericOpStore = getOpsStore('alphanumeric');
		this._booleanOpStore = getOpsStore('boolean');
		this._enumerationOpStore = getOpsStore('enumeration');

		this.inherited(arguments);

		//	Create our save dialog.
		this.saveFilterDialog = new xwt.widget.table.SaveFilterDialog({
			tableId: this.tableId
		});
		this.connect(this.saveFilterDialog, "onSave", dojo.hitch(this, "_save"))	
		// Only allow scroll when animations fire, avoids click causing it to move and making overflow unreachable.
		this.connect(this.domNode, "onscroll", function(e) { if(!this.__allowScroll) { this.domNode.scrollLeft = this.__scrollLeft; }});		
		this.connect(this.filterOverflowButton, "onChange", function(state){
			var self = this;
			if(state){
				var pos = dojo.position(this.domNode);
				var sWidth = this.domNode.scrollWidth;
				if(pos.w < sWidth){
					var sDistance = sWidth - pos.w;
					var buttonRight = {
						node: this.filterOverflowButton.domNode,
						properties: {
							right: { start: 0, end: -sDistance, units: "px" }
						},
						onBegin:function(){
							self.__allowScroll = true;
						},
						onAnimate: function(l){
							var move = l.right;
							move = move.substring(0, move.indexOf("px"));
							move = Math.abs(parseInt(move, 10));
							self.domNode.scrollLeft = move;
						},
						onEnd: function(){
							setTimeout(function() { 
								self.__scrollLeft = self.domNode.scrollLeft;	
								delete self.__allowScroll;
							}, 0);
						}
					}
					var bAnim = dojo.animateProperty(buttonRight);
					bAnim.play();
				}
			}else{
				if(this.domNode.scrollLeft != 0){
					var buttonLeft = {
						node: this.filterOverflowButton.domNode,
						properties: {
							right: { start: -this.domNode.scrollLeft, end: 0, units: "px" }
						},
						onBegin: function(){
							self.__allowScroll = true;	
						},
						onAnimate: function(l){
							var move = l.right;
							move = move.substring(0, move.indexOf("px"));
							move = Math.abs(parseInt(move, 10));
							self.domNode.scrollLeft = move;
						},
						onEnd: function(){
							dojo.style(self.filterOverflowButton.domNode, "dummy", "");
							dojo.style(self.filterOverflowButton.domNode, "right", "0px");
							setTimeout(function() {
								self.__scrollLeft = self.domNode.scrollLeft;
								delete self.__allowScroll;
							}, 0);
						}
					}
					var blAnim = dojo.animateProperty(buttonLeft);
					blAnim.play();
				}
			}
		});
	},
	
	resize: function(){
		// summary:
		//		Over-ride of the layout function to detect if the overflow 
		//		button should be shown or not.
		this.inherited(arguments);
		var pos = dojo.position(this.domNode);
		var sWidth = this.domNode.scrollWidth;
		this.filterOverflowButton.attr("checked", false, false);
		dojo.style(this.filterOverflowButton.domNode, "right", "0px");
		this.domNode.scrollLeft = 0;
		if(pos.w < sWidth){
			dojo.style(this.filterOverflowButton.domNode, "display", "");
		}else{
			dojo.style(this.filterOverflowButton.domNode, "display", "none");
		}
	},

	onStartup: function(){
		dojo.publish(this.id + "-startup", [ this ]);
	},

	_onGo: function(){
		if(!this.table()){ return; }
		var f = this.getFilter();
		if(dojo.isFunction(this.table().clearSelections)){
			// Filter changes should clear selections.  Came out
			// of discussions with IFM: CSCtj75300
			this.table().clearSelections();
		}
		this.table().filter(f);
		this.clearButton.attr('disabled', false);
		if (this.disableManageFilters === false)
		{
			this.saveButton.attr('disabled', false);
		}
		else
		{
			this.saveButton.attr('disabled', true);
		}
	},

	_onClear: function(){
		if(!this.table()){ return; }
		this._clearFilters();
		this.table().clearFilter();
		this._addFilterRule();
		this.goButton.attr("disabled", true);
		this.clearButton.attr('disabled', true);
	},
	
	_load: function(filter){
		var last = null;
		var filterCount = filter.expressions.length;
		dojo.forEach(filter.expressions, function(exp){
			last = this._addFilterRule(last, exp);
		}, this);
		
		if (filterCount > 1) {
			this.manySelect.attr('value', filter.conjunction);
		}
			
		this._currentFilter = filter;
		return (filter !== undefined);
	},

	_onSave: function(){
		//	Kick open the save dialog.
		if(this.disableManageFilters) { return; }
		if(this._currentFilter){
			this.saveFilterDialog.filterInput.value = this._currentFilter.name;
		}
		this.saveFilterDialog.show();
	},

	_save: function(name){
		//	summary:
		//		Save the complete filter expression using the given name.
		var f = this.getFilter();
		if(this.table()){
			f.name = name;
			this.table()._filterEngine.add(f);
			this.table()._filterEngine.save();

			//	Try adding the item.
			var context = dijit.byNode(this.domNode.previousSibling);
			if(context){
				var s = context.quickFilterSelect;
				//	Check to make sure the given item isn't already there.
				s.store.fetchItemByIdentity({
					identity: name,
					onItem: function(item){
						if(!s.store.isItem(item)){
							//	We don't care if it is an item, that just means it's already there.
							s.store.newItem({
								name: name,
								label: '<div>' + dojox.html.entities.encode(dojox.html.entities.decode(name, dojox.html.entities.html), dojox.html.entities.html) + '</div>'
							});
						}
					},
					onError: function(){
						console.warn("An error occurred when trying to find the saved filter in the Preset Filter list.");
					}
				});
			}
		}
	},

	show: function(filter){
		if(!this.hidden){ return; }
		dojo.style(this.domNode, 'display', '');
		this._clearFilters();
		if(filter && filter.expressions){
			this._load(filter);
		} else {
			this._addFilterRule();
		}
		this.hidden = false;
	},

	hide: function(){
		if(this.hidden){ return; }
		dojo.style(this.domNode, 'display', 'none');
		this._clearFilters();
		this.hidden = true;
	},

	getFilter: function(){
		return {
			conjunction: this.manySelect.attr('value'),
			expressions: dojo.map(this.getChildren(), function(child){ return child.getFilterExpression(); })
		};
	},

	_setupMappings: function(){
		var cols = this.columns,
			fWidgetMap = xwt.widget.table.FilteringWidgetMap,
			columns = [],
			widgetMap = {},
			opsMap = {},
			self = this;

		this._widgetTypeMap = widgetMap;
		this._opsStoreMap = opsMap;

		var columnFunc = function(column){
			var id = column.attr + '-' + column.label,
				filterType = column.filterType || 'alphanumeric';

			//we need to see if a title is provided. Use the title also, otherwise use the label
			//useful when column label is an icon - CSCti46809
			var displayStr;
			if (column.title)
			{
				displayStr = column.label + ' ' + column.title;
			}
			else{
				displayStr = column.label;
			}

			if(column.filterable){
				columns.push({
					id: id,
					name: displayStr,
					filterType: filterType,
					filterOptions: column.filterOptions
				});
			}

			widgetMap[id] = column.filterWidgetType || fWidgetMap[filterType];
			opsMap[id] = self['_' + filterType + 'OpStore'];
		};

		cols.forEach(function(col, i){
			if(col.columnType != xwt.widget.table.ColumnTypes.COLUMN){
				return;
			}
			if(col.children){
				col.children.forEach(columnFunc);
			}else{
				columnFunc(col);
			}
		});

		//need a default blank column - Alka
		var id = "!!!!!noVal!!!!";
		var filterType = 'empty';
		columns.push({
			id:id,
			name: "&nbsp",
			filterType: filterType,
			filterOptions: ""
		});

		widgetMap[id] =  fWidgetMap[filterType];
		opsMap[id] = self['_' + filterType + 'OpStore'];

		this._columnStore = new dojo.data.ItemFileReadStore({
			data: {
				identifier: 'id',
				label: 'name',	
				items: columns
			},
			hierarchical: false
		});
		
		//create custom sort order so that empty column remains on top
		this._columnStore.comparatorMap = {};
		this._columnStore.comparatorMap["name"] = function(a, b){
			var ret = 0;
			
			if (a == "&nbsp") {
				ret = -1;
			}
			else if (b == "&nbsp") { 
					ret = 1;
				}
				else //sort normally
				{
					if (a < b) 
						ret = -1;
					else 
						if (a > b) 
							ret = 1;
						else 
							ret = 0;
				}
			return ret;
		};
	},

	_onColumnsChange: function(){
		this._setupMappings();
	},

	_onTableStartup: function(table){
		table = table || this.table();
		var cols = this.columns = table._columns;

		this._setupMappings();

		this.connect(cols, 'onMove', '_onColumnsChange');
		this.connect(cols, 'onShow', '_onColumnsChange');
		this.connect(cols, 'onHide', '_onColumnsChange');

		this.connect(this, '_addFilterRule', function(){
			var p = table.getParent();
			if(p && p.isLayoutContainer){ table.resize(); }
		});
	},

	_clearFilters: function(){
		dojo.forEach(this.getChildren(), function(child){
			child.destroyRecursive();
		});
		this.saveButton.attr('disabled', true);
		if(dojo.isFunction(this.table.clearSelections)){
			// Filter changes should clear selections.  Came out
			// of discussions with IFM: CSCtj75300
			this.table.clearSelections();
		}
	},

	_addFilterRule: function(widget, expression){
		var scrollLeft = this.domNode.scrollLeft;
		var self = this;
		this.goButton.attr("disabled", true);
		this.saveButton.attr("disabled", true);
		var w = new xwt.widget.table._FilterWidget({
			opsStores: this._opsStoreMap,
			columnStore: this._columnStore,
			widgetTypeMap: this._widgetTypeMap,
			onAdd: function(){
				self._addFilterRule(w);				
			}
		});
		
		w.placeAt(widget? widget.domNode : this.containerNode, widget ? 'after' : 'first');
		this.connect(w.column, "onChange", dojo.hitch(this, function(value){
			if (value === "!!!!!noVal!!!!") {
				this.goButton.attr("disabled", true);
				this.saveButton.attr("disabled", true);
			}
			else {
				if (!w.column.attr("disabled")&&(this.getFilter()!=null)) {
					var filter = this.getFilter();
					var isfilterValid = true;
					dojo.forEach(filter.expressions, function(el){
							if((el==null) ||(el.attr==="") ||(el.op=""))
							{
								isfilterValid = false;
							}
						} 
					);					
					this.goButton.attr("disabled", !isfilterValid);
				}
			}
			
		}));
		this.connect(w, 'onRemove', '_checkRemoveButton');
		this.connect(w, 'onRemove', function(){
			var table = this.table();
			if(table){
				var p = table.getParent();
				if(p && p.isLayoutContainer){ table.resize(); }
			}
			if(dojo.isIE){
				// Poke IE7 to try and work around render issue.
				this.goButton.domNode.parentNode.className = this.goButton.domNode.parentNode.className;
				this.goButton.domNode.className = this.goButton.domNode.className;
				this.clearButton.domNode.className = this.clearButton.domNode.className;
				this.saveButton.domNode.className = this.saveButton.domNode.className;
				setTimeout(dojo.hitch(this, function(){
					this.goButton.domNode.parentNode.className = this.goButton.domNode.parentNode.className;
					this.goButton.domNode.className = this.goButton.domNode.className;
					this.clearButton.domNode.className = this.clearButton.domNode.className;
					this.saveButton.domNode.className = this.saveButton.domNode.className;
				}), 0);
			}
		});
		w.startup();

		if(dojo.isIE){	
			// Poke IE to try and work around render issue.
			this.goButton.domNode.parentNode.className = this.goButton.domNode.parentNode.className;
			this.goButton.domNode.className = this.goButton.domNode.className;
			this.clearButton.domNode.className = this.clearButton.domNode.className;
			this.saveButton.domNode.className = this.saveButton.domNode.className;
			setTimeout(dojo.hitch(this, function(){
				this.goButton.domNode.parentNode.className = this.goButton.domNode.parentNode.className;
				this.goButton.domNode.className = this.goButton.domNode.className;
				this.clearButton.domNode.className = this.clearButton.domNode.className;
				this.saveButton.domNode.className = this.saveButton.domNode.className;
			}), 0);
		}

		if(expression){
			//	Set the values on our new widget.
			var c = this.table() && this.table().getColumns().getByAttribute(expression.attr);
			if(c){
				var h = dojo.connect(w, "_setFilterType", function(item){
					dojo.disconnect(h);
					w.operator.attr("value", expression.op);
					if(w.criteria && expression.value !== undefined){
						w.criteria.attr("value", expression.value);
					}
				});
				w.column.attr("value", expression.attr + "-" + c.label);
			}
		}

		this.domNode.scrollLeft = scrollLeft;
		this._checkRemoveButton();
		return w;	//	xwt.widget.table._FilterWidget
	},

	_checkRemoveButton: function(){
		var children = this.getChildren(),
			len = children.length;
		if ((this.getFilter()!=null)) {
			var filter = this.getFilter();
			var isfilterValid = true;
			dojo.forEach(filter.expressions, function(el){
					if((el==null) ||(el.attr==="") ||(el.op=""))
					{
						isfilterValid = false;
					}
				} 
			);					
			this.goButton.attr("disabled", !isfilterValid);
		}
		if(len == 1){
			children[0].removeButton.attr('disabled', true);
		}else{
			for(var i=0, child; child=children[i]; i++){
				child.removeButton.attr('disabled', i==0 && len==1);
			}
		}
		dojo.style(this.oneLabel, 'display', len == 1 ? '' : 'none');
		dojo.style(this.manyLabel, 'display', len == 1 ? 'none' : '');
		if(len == 1){
			this.manySelect.attr('value', 'and');
		}
	},
	
	_disable:function(/*disable*/ disable){
		console.log("disabling filterbar");
		//disable all the filtering elements and buttons
		var filterToolbarDomNode = this.domNode;
		var q = dojo.query(".xwtFilterWidget", filterToolbarDomNode);
		
		dojo.query(".xwtFilterWidget", filterToolbarDomNode).forEach(function(node) {
			var x = dijit.findWidgets(node);
			for (i = 0; i < x.length; i++)
			{
				x[i].attr("disabled", true);
			}
		});
		
		this.goButton.attr("disabled", true);
		this.clearButton.attr("disabled", true);
		this.saveButton.attr("disabled", true);
	},
	
	destroy: function(){
		if(!this._nDestroyed){
			this._nDestroyed = true;
			this.inherited(arguments);
			if(this.saveFilterDialog){
				this.saveFilterDialog.destroyRecursive();
				delete this.saveFilterDialog;
			}
		}
	},
	
	destroyRecursive: function(){
		if(!this._rDestroyed){
			this._rDestroyed = true;
			this.inherited(arguments);
		}
	}	
});

dojo.declare("xwt.widget.table.FilterButton", [dijit.form.ToggleButton, dijit._Container, dijit._HasDropDown], {
	l10n: null,
	isShown:false,
/* Alka cleanup	
	templateString: dojo.cache("xwt.widget.table", "templates/FilterButton.html", "<table class='dijit dijitReset dijitInline dijitLeft'\r\n\tcellspacing='0' cellpadding='0' waiRole=\"presentation\"\r\n\t><tbody waiRole=\"presentation\"><tr waiRole=\"presentation\"\r\n\t\t><td class=\"dijitReset dijitStretch dijitButtonNode\"><button type=\"button\" id=\"${id}_button\" class=\"dijitReset dijitButtonContents\"\r\n\t\t\tdojoAttachEvent=\"onclick:_onButtonClick,onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse,onkeypress:_onButtonKeyPress\"  dojoAttachPoint=\"titleNode\"\r\n\t\t\twaiRole=\"button\" waiState=\"labelledby-${id}_label\"\r\n\t\t\t><div class=\"dijitReset dijitInline\" dojoAttachPoint=\"iconNode\" waiRole=\"presentation\"></div\r\n\t\t\t><div class=\"dijitReset dijitInline dijitButtonText\" id=\"${id}_label\" dojoAttachPoint=\"containerNode\" waiRole=\"presentation\"></div\r\n\t\t></button></td\r\n\t\t><td id=\"${id}_arrow\" class='dijitReset dijitRight dijitButtonNode dijitArrowButton'\r\n\t\t\tdojoAttachPoint=\"_popupStateNode,focusNode,_buttonNode\"\r\n\t\t\tdojoAttachEvent=\"onmouseenter:_onMouse,onmouseleave:_onMouse,onkeypress:_onArrowKeyPress\"\r\n\t\t\tstateModifier=\"DownArrow\"\r\n\t\t\ttitle=\"${optionsTitle}\" ${nameAttrSetting}\r\n\t\t\twaiRole=\"button\" waiState=\"haspopup-true\"\r\n\t\t\t><div class=\"dijitReset dijitArrowButtonInner\" waiRole=\"presentation\">&thinsp;</div\r\n\t\t\t><div class=\"dijitReset dijitArrowButtonChar\" waiRole=\"presentation\">&#9660;</div\r\n\t\t></td\r\n\t></tr></tbody\r\n></table>\r\n"),

	iconClass: "xwtContextualIcon xwtContextualFilter",
	showLabel: true,

	toolbarId: "",

	attributeMap: dojo.mixin(dojo.clone(dijit.form.Button.prototype.attributeMap), {
		id: "",
		tabIndex: ["focusNode", "titleNode"],
		title: "titleNode"
	}),

	// optionsTitle: String
	//		Text that describes the options menu (accessibility).
	optionsTitle: "",

	baseClass: "dijitToggleButton xwtTableFilterButton",

	_focusedNode: null,

	postMixInProperties: function(){
		var l10n = this.l10n = dojo.i18n.getLocalization("xwt.widget.table", "Filter");
		this.params.label = this.label = l10n.filter;

		this.inherited(arguments);
	},

	_onClick: function(e){
		dojo.stopEvent(e);

		return this.inherited(arguments);
	},
*/
	postCreate: function(){
		this.inherited(arguments);
			/*
		this._focalNodes = [this.titleNode, this._popupStateNode];
		var isIE = dojo.isIE;
		dojo.forEach(this._focalNodes, dojo.hitch(this, function(node){
			this.connect(node, isIE? "onactivate" : "onfocus", this._onNodeFocus);
			this.connect(node, isIE? "ondeactivate" : "onblur", this._onNodeBlur);
		}));
		if(isIE && (isIE < 8 || dojo.isQuirks)){ // fixed in IE8/strict
			with(this.titleNode){ // resize BUTTON tag so parent TD won't inherit extra padding
				style.width = scrollWidth + "px";
				this.connect(this.titleNode, "onresize", function(){
					setTimeout( function(){ style.width = scrollWidth + "px"; }, 0);
				});
			}
		}

		var l10n = this.l10n;

		var dropDown = this.dropDown = new dijit.Menu();
		var example = this.byExample = new dijit.MenuItem({
			label: '<span style="white-space: nowrap">' + l10n.byExample + '</span>'
		});
		var advanced = this.advanced = new dijit.MenuItem({
			label: '<span style="white-space: nowrap">' + l10n.advanced + '</span>'
		});

		dropDown.addChild(example);
		dropDown.addChild(advanced);

		//this.dropDownButton.dropDown = dropDown;
*/
		if(this.toolbarId){
			if(this.toolbar()){
				//	See if our table has been created yet.
				this._setupMenuItems();
			}else{
				this.subscribe(this.toolbarId + "-startup", "_setupMenuItems");
			}
		}
	},
/*
	_onNodeFocus: function(evt){
		this._focusedNode = evt.currentTarget;
		var fnc = this._focusedNode == this.focusNode ? "dijitDownArrowButtonFocused" : "dijitButtonContentsFocused";
		dojo.addClass(this._focusedNode, fnc);
	},

	_onNodeBlur: function(evt){
		var fnc = evt.currentTarget == this.focusNode ? "dijitDownArrowButtonFocused" : "dijitButtonContentsFocused";
		dojo.removeClass(evt.currentTarget, fnc);
	},

	_onBlur: function(){
		this.inherited(arguments);
		this._focusedNode = null;
	},
	
	_onButtonKeyPress: function( evt){
		// summary:
		//		Handler for the right-arrow key when the focus is on the left part of the button.
		if(evt.charOrCode == dojo.keys[this.isLeftToRight() ? "RIGHT_ARROW" : "LEFT_ARROW"]){
			dijit.focus(this._popupStateNode);
			dojo.stopEvent(evt);
		}
	},

	_onArrowKeyPress: function( evt){
		// summary:
		//		Handler for the left-arrow key when the focus is on the right part of the button.
		if(evt.charOrCode == dojo.keys[this.isLeftToRight() ? "LEFT_ARROW" : "RIGHT_ARROW"]){
			dijit.focus(this.titleNode);
			dojo.stopEvent(evt);
		}
	},
	
	focus: function( position){
		// summary:
		//		Focuses this widget according to position, if specified,
		//		otherwise on the arrow node.
		// position:
		//		"start" or "end"
		
		dijit.focus(position == "start" ? this.titleNode : this._popupStateNode);
	},
	_fillContent: function(){
		// Overrides Button._fillContent().
		//
		// My inner HTML contains both the button contents and a drop down widget, like
		// <DropDownButton>  <span>push me</span>  <Menu> ... </Menu> </DropDownButton>.
		// The first node is assumed to be the button content. The widget is the popup.

		if(this.srcNodeRef){ // programatically created buttons might not define srcNodeRef
			//FIXME: figure out how to filter out the widget and use all remaining nodes as button
			//	content, not just nodes[0]
			var nodes = dojo.query("*", this.srcNodeRef);
			dijit.form.DropDownButton.superclass._fillContent.call(this, nodes[0]);

			// Save pointer to srcNode so we can grab the dropdown widget after it's instantiated.
			this.dropDownContainer = this.srcNodeRef;
		}
	},

	startup: function(){
		if(this._started){ return; }

		// The child widget from srcNodeRef is the dropdown widget.  Insert it in the page DOM,
		// make it invisible, and store a reference to pass to the popup code.
		if(!this.dropDown){
			var dropDownNode = dojo.query("[widgetId]", this.dropDownContainer)[0];
			this.dropDown = dijit.byNode(dropDownNode);
			delete this.dropDownContainer;
		}

		this.inherited(arguments);
	},

	isLoaded: function(){
		// Returns whether or not we are loaded. If our dropdown has an href,
		// then we want to check that.
		var dropDown = this.dropDown;
		return (!dropDown.href || dropDown.isLoaded);
	},

	loadDropDown: function(){
		// Loads our dropdown
		var dropDown = this.dropDown;
		if(!dropDown){ return; }
		if(!this.isLoaded()){
			var handler = dojo.connect(dropDown, "onLoad", function(){
				dojo.disconnect(handler);
				this.openDropDown();
			});
			dropDown.refresh();
		}else{
			this.openDropDown();
		}
	},

	isFocusable: function(){
		// Overridden so that focus is handled by the _HasDropDown mixin, not by
		// the _FormWidget mixin.
		return this.inherited(arguments) && !this._mouseDown;
	},
*/
	toolbar: function(){
		//	summary:
		//		Get the table reference for this toolbar.
		if(this.toolbarId){
			return dijit.byId(this.toolbarId);
		}
		return null;
	},

	_onTableStartup: function(table){
		var example = this.example = new xwt.widget.table.FilterByExample({
			table: table
		});
		example.placeAt(table.tableHeadContainer);
		example.startup();

		// Destroy myself when the table is destroyed.
		var cl = dojo.connect(table, "destroy", function() { 
			dojo.disconnect(cl);
			example.destroy();
		});
	},

	_showAdvancedToolbar: function(filter){
		this._onChangeActive = false;
		var toolbar = this.toolbar();
		if(!this.attr('checked')){
			this.attr('checked', true);
		}
		if(!toolbar.table()){ return; }
		//CSCti44755
		if(toolbar.getFilter().expressions.length>0){ this._onChangeActive = true;return; }
		if (toolbar.getFilter() !== filter) {
//			toolbar.table().clearFilter();
			if (this.example) {
				this.example.hide();
			}
		}
		toolbar.show(filter);
		toolbar.resize();
		toolbar.table().resize();
		this._onChangeActive = true;
		this.isShown = true;
	},

	_showExamples: function(filter){
		this._onChangeActive = false;
		var toolbar = this.toolbar();
		if(!this.attr('checked')){
			this.attr('checked', true);
		}
		if(!toolbar.table()){ return; }
		//CSCti44755
		if((this.example) && (this.example.getFilter())){ this._onChangeActive = true;return; }
		if (toolbar.getFilter() !== filter) {
	//		toolbar.table().clearFilter();//
		//	toolbar.hide();
		}
		if(this.example){
			this.example.show(filter);
		}
		toolbar.table().resize();
		this._onChangeActive = true;
		this.isShown = true;
	},

	_hideFilterBar: function(){
		
		if(this.example){
				this.example.hide();
		}
		
		if (this.toolbar()) {
			this.toolbar().hide();
			this.toolbar().table().resize();
		}
		this.isShown = false;
	},
	_setupMenuItems: function(toolbar){
		toolbar = toolbar || this.toolbar();
		if(toolbar === undefined){ return; }
/*		
		this.connect(this.advanced, 'onClick', dojo.hitch(this, "_showAdvancedToolbar"));
		this.connect(this.byExample, 'onClick', dojo.hitch(this, "_showExamples"));
		this.connect(this, 'onChange', dojo.hitch(this, function(value){
			if(value){
				this.example.show();
			}else{
				if(this.example){
					this.example.hide();
				}
			}
			var toolbar = this.toolbar();
			if(!toolbar.table()){ return; }
			toolbar.table().clearFilter();
			toolbar.hide();
			toolbar.table().resize();
		}));
*/		
		if(toolbar.table() && toolbar.table()._started){
			this._onTableStartup(toolbar.table());
		}else{
			this.subscribe(toolbar.tableId + '-startup', '_onTableStartup');
		}
	}
/*
	toMenuItem: function(){
		var Ribbon = xwt.widget.table.Ribbon;
		return new dijit.PopupMenuItem({
			popup: Ribbon.prototype._cloneMenu.call(Ribbon.prototype, this.dropDown),
			label: this.l10n.filter,
			iconClass: this.iconClass
		});
	}
*/
});

dojo.declare("xwt.widget.table._ByExampleWidget", dijit.form.ComboBox, {
	templateString: dojo.cache("xwt.widget.table", "templates/_ByExampleWidget.html", "<div class=\"dijit dijitReset dijitInlineTable dijitLeft xwtByExampleWidget\"\r\n\tid=\"widget_${id}\"\r\n\tdojoAttachEvent=\"onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse\" dojoAttachPoint=\"comboNode\" waiRole=\"presentation\" tabIndex=\"-1\"\r\n\t><div style=\"overflow:hidden;\"\r\n\t\t><div class='dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton xwtByExampleDownArrowButton'\r\n\t\t\tdojoAttachPoint=\"downArrowNode\" waiRole=\"presentation\"\r\n\t\t\tdojoAttachEvent=\"onmousedown:_onArrowMouseDown,onmouseup:_onMouse,onmouseenter:_onMouse,onmouseleave:_onMouse\"\r\n\t\t\t><div class=\"dijitArrowButtonInner\">&thinsp;</div\r\n\t\t\t><div class=\"dijitArrowButtonChar\">&#9660;</div\r\n\t\t></div\r\n\t\t><div class=\"dijitReset dijitValidationIcon xwtByExampleWidgetButton\" dojoAttachEvent=\"onclick:_onButtonClick\"><br></div\r\n\t\t><div class=\"dijitReset dijitValidationIconText\">&Chi;</div\r\n\t\t><div class=\"dijitReset dijitInputField\"\r\n\t\t\t><input ${nameAttrSetting} type=\"text\" autocomplete=\"off\" class='dijitReset'\r\n\t\t\tdojoAttachEvent=\"onkeypress:_onKeyPress,compositionend\"\r\n\t\t\tdojoAttachPoint=\"textbox,focusNode\" waiRole=\"textbox\" waiState=\"haspopup-true,autocomplete-list\"\r\n\t\t/></div\r\n\t></div\r\n></div>\r\n"),

	hasDownArrow: false,

	// enableAutoSuggest: [public] boolean
	//		Boolean indicator to enable the auto-complete
	//		capablity of the toolbar.  False by default.
	enableAutoSuggest: false,

	// typePauseSearchDelay: [public] int
	//		How long to wait (in milliseconds) between keystrokes before initiating
	//		an autosuggest search (if enabled).    
	//		The default is 1000 milliseconds (1 second).
	typePauseSearchDelay: 1000,

	// _filtered: [private] boolean
	//		Flag indicating if the filter has been applied or not.
	//		The default is false.
	_filtered: false,

	// queryExpr: String
	//	Override of the default one (${0} - starts-width), to be a 'contains' one. For CSCti50363.
	queryExpr: "*${0}*",

	// highlightMatch: String
	//	Override of the default highlight match to show all indications of 'contains'.
	highlightMatch: "all",

	// autoComplete: boolean
	//	Override of autoComplete, as 'contains' can match anywhere, so we do not want it to pick the first 'hit'.
	autoComplete: false,

	// isEnum: boolean
	//	Flag to be set when instantiated as an enum viewer to just do a filter of type 'equals'.
	isEnum: false,

	_setFilteredAttr: function(filtered){
		// summary:
		//		Hook for using this.attr to set the filtered attribute
		// filtered: boolean
		//		Value indicating if the filter has been applied or not.
		// tags:
		//		protected
		this._filtered = filtered;
		dojo.toggleClass(this.domNode, 'filtered', filtered);
	},
	_getFilteredAttr: function(){
		// summary:
		//		Hook for using this.attr to get the setting of the
		//		filtered attribute.
		return this._filtered;
	},

	postCreate: function(){
		// summary:
		//		Override of basic postCreate function to establish connects
		//		to handle filter-as-you-go typing as well as Enter key execution.
		this.inherited(arguments);
		this.connect(this.focusNode, 'onkeydown', this._onExecute);
		this.connect(this, 'onChange', '_onChangeFiltering');
	},

	_onFocus: function(){
		// summary:
		//		Override of _onFocus to enable searching when tabbing into
		//		the field (if auto-suggest is enabled).
		this.inherited(arguments);
		if(this.enableAutoSuggest){
			this._startSearchAll();
		}
	},

	_onBlur: function(){
		// summary:
		//		Override of the default blur behavior.
		//		This is to trigger whether or not to filter.
		//		The combo will only filter if the entry is a non-empty
		//		string.

		// Clear off any keyboard timers since the blur
		// will trigger the filtering
		if(this._inputFilterTimer){
			clearTimeout(this._inputFilterTimer);
			delete this._inputFilterTimer;
		}

		// Invoke filtering or not based on if
		// there was a value to filter on.
		var val = this.attr("value");
		val = val ? val : "";
		if(val){
			// Only filter if the value doesn't match
			// the last filtered value. Avoids double
			// filtering by typing, letting it filter, 
			// then tabbing out.
			if(val !== this._lastFilteredValue){
				this._doFilter(true);
			}
		}else{
			if(this.attr("filtered") !== false){
				this._doFilter(false);
			}
		}
		this.inherited(arguments);
	},

	doHighlight: function(/*String*/label, /*String*/find){
		// summary:
		//		Highlights the string entered by the user in the menu.  By default this
		//		highlights the first occurrence found. Override this method
		//		to implement your custom highlighting.
		// tags:
		//		protected

		// Add greedy when this.highlightMatch == "all"
		var modifiers = "i"+(this.highlightMatch == "all"?"g":"");
		var escapedLabel = this._escapeHtml(label);
		find = dojo.regexp.escapeString(find); // Escape regexp special chars.
		var ret = escapedLabel.replace(new RegExp("(^|\\s)("+ find +")", modifiers),
				'$1<span class="xwtByExampleWidgetHighlightMatch">$2</span>');
		return ret;// Returns String, (almost) valid HTML (entities encoded).
	},

	_openResultList: function(/*Object*/ results, /*Object*/ dataObject){
		// summary:
		//		Override of the _openResultList of the parent ComboBox.
		//		This function filters out non-unique results from the dropdown.
		
		// Filter out non-unique results.
		var seen = [], self = this;
		results = dojo.filter(results, function(item, idx){
			var value = self.store.getValue(item, self.searchAttr);
			if(dojo.indexOf(seen, value) > -1){
				return false;
			}
			seen.push(value);
			return true;
		});
		
		if(this.isEnum){
			var userV = this.attr("value");
			if(userV){
				// See if we can move all the 'starts with ' matches to the top.
				var swResults = [];
				var rResults = [];
				this.autoComplete = false;
				
				// Reorganize the results list to have starts-with matches first
				// and enable auto-complete for them.
				dojo.forEach(results, function(item, idx){
					var value = self.store.getValue(item, self.searchAttr);
					if(value != null){
						value = value + "";
						value = value.toLowerCase();
						userV = userV.toLowerCase();
						if(value.indexOf(userV) == 0){
							swResults.push(item);
							self.autoComplete = true;
						}else{
							rResults.push(item);
						}
					}else{
						rResults.push(item);
					}
				});
				results = swResults.concat(rResults);
			}
		}
		this.inherited(arguments, [results, dataObject]);
	},

	onFilter: function(){
		// summary:
		//		Public event to listen to for filtering events.
		// filtered:
		//		Boolean denoting if a filter was applied (true)
		//		or removed (false).
		// tags:
		//		public
	},

	_doFilter: function(filtered){
		// summary:
		//		Internal function to apply filtering.
		// tags:
		//		private
		if(this.attr("disabled")) { return; }
		if(this.isEnum){
			var val = this.attr("value");
			var item = this.attr("item");
			var sValue;
			if(item){
				sValue = this.store.getValue(item, this.searchAttr);
				if(sValue != null){
					sValue += "";
				}
			}
			// even if it didnt pick a match, we still filter - CSCto45946;
			//will most likely get no results, unless the value was just added to the table and table is not refreshed yet.
			/*
			if(sValue != val){
				// It didn't pick a match, so clear the filter state.
				filtered = false;
			}
			*/
		}
		this.attr('filtered', filtered);
		this._lastFilteredValue = this.attr("value");
		this.onFilter(filtered);
		if(dojo.isIE){
			// IE doesn't always update render,
			// So ... poke it to render by just setting the
			// classname to itself.
			this.textbox.className = this.textbox.className;
		}
	},

	_onButtonClick: function(){
		// summary:
		//		Function that handles the behavior of the button
		//		to the right of the filter field.  In the current implementation,
		//		clicking the X (remove filter) clears the field so that
		//		it removes the filtering text.
		var f = this.attr("filtered");
		if(f){
			this.attr("value", "");
			this._doFilter(false);
			if(this._focused && this.enableAutoSuggest){
				this._startSearchAll();
			}
		}
	},

	_onExecute: function(e){
		// summary:
		//		Basic on-execute method that applies the filter if the Enter key is pressed.
		// e: Object
		//		The event object from the browser.
		if((e.keyCode == dojo.keys.ENTER ||
			e.keyCode == dojo.keys.RETURN) && !(e.ctrlKey || e.altKey || e.metaKey)){
			dojo.stopEvent(e);
			var filtered = this.attr('filtered');
			if(!filtered || this._lastFilteredValue !== this.attr('value')){
				this._doFilter(!!this.attr('value'));
			}
		}
	},

	getFilterExpression: function(){
		// summary:
		//		Obtains the filter expression based on the dropdown
		//		value.
		var expr = {
			op: 'contains',
			attr: this.searchAttr,
			value: this.attr('displayedValue')
		};
		if(this.isEnum){
			expr.op = "equals";
		}
		return expr;
	},

	_onChangeFiltering: function(value){
		// summary:
		//		Handles invocation of onChange filtering as the user types.
		//		This is linked up in post create to handle typing triggering filtering.
		// value:
		//		The current value in the ComboBox, only non-null/non-empty values
		//		will invoke filtering.
		// tags:
		//		private
		if(this._inputFilterTimer){
			clearTimeout(this._inputFilterTimer);
		}
		this._inputFilterTimer = setTimeout(dojo.hitch(this, function(){
			var filtered = this.attr("filtered");
			if(value){
				// Only trigger a filtering if filtering hasn't been applied
				// or if the filter value hasn't already been filtered.
				if(value !== this._lastFilteredValue || !filtered){
					this._doFilter(true);
				}
			}else{
				if(filtered !== false){
					this._doFilter(false);
				}
			}
			delete this._inputFilterTimer;
		}),this.typeSearchDelay);
	},

	_startSearch: function(){
		// summary:
		//		Overridden function to allow disabling of the auto-suggest
		//		as an option.  Effectively just disables the searching/auto-complete.
		// tags:
		//		protected
		if(this.enableAutoSuggest){
			return this.inherited(arguments);
		}
	},

	destroy: function(){
		// summary:
		//		Override of basic destroy to handle cleanup of any running timers
		//		and connects.
		// tags:
		//		public.
		this.inherited(arguments);
		if(this._inputFilterTimer){
			clearTimeout(this._inputFilterTimer);
			delete this._inputFilterTimer;
		}
	}
});

dojo.declare("xwt.widget.table.FilterByExample", [dijit._Widget, dijit._Templated, dijit._Container], {
	templateString: '<div style="overflow:hidden;display:none;" class="xwtFilterByExample"></div>',
	hidden: true,
	searchDelay: 800,

	postMixInProperties: function(){
		this.inherited(arguments);

		this.columns = this.table._columns;
	},

	postCreate: function(){
		this.inherited(arguments);

		this.__i18n = dojo.i18n.getLocalization("xwt.widget.table", "Filter");
		
		this.__children = [];
		var cols = this.columns;

		this._createTable();

		this._setupMappings();
		this._createWidgets();

		var conns = this._cols_conns = [];
		conns.push(dojo.connect(cols, 'onMove', this, '_onColumnsChange'));
		conns.push(dojo.connect(cols, 'onShow', this, '_onColumnsChange'));
		conns.push(dojo.connect(cols, 'onHide', this, '_onColumnsChange'));
		conns.push(dojo.connect(cols, 'onResize', this, '_resizeWidgets'));
	},

	startup: function(){
		if(this._started){ return; }
		this.inherited(arguments);

		dojo.forEach(this.getChildren(), function(w){ w.startup(); });
		//this.connect(this.table, "destroy", "_destroyWidgets");
		
		this._source = new xwt.widget.table._ColumnMover(this.domNode, { table: this.table, singular: true, additionalNodes: [this.domNode]});
		this._source.startup();		
	},

	_createTable: function(){
		if(!this.table){ return; }
		var cols = this.columns,
			table = this.table,
			cells = new dojox.string.Builder('<table cellpadding="0" cellspacing="0" border="0"><tbody><tr>');

		var selectorIndex = null;
		cols.forEach(function(column){
			if(selectorIndex == null && column.columnType == xwt.widget.table.ColumnTypes.SELECTOR){
				selectorIndex = column._index;
			}
			column._createCell(0, cells, table);
		});
		cells.append('</tr></tbody></table>');

		this.domNode.innerHTML = cells.toString();

		dojo.addClass(this.domNode.firstChild, table._css.head);
		this.tableHeadRow = this.containerNode = dojo.query("tr", this.domNode.firstChild)[0];

		if(selectorIndex != null){
			var selectorCellTable = dojo.query(".cell-container-" + selectorIndex, table.tableHeadInnerContainer)[0],
				scb = dojo.contentBox(selectorCellTable);
			selectorCell = dojo.query(".cell-container-" + selectorIndex, this.domNode)[0];
			if(scb.w >= 0){
				selectorCell.style.width = scb.w + 'px';
			}else{
				// We need to delay the sizing
				this._delayedSelectorWidth = true;
			}
		}
	},

	getChildren: function(){
		// summary:
		//		Returns array of children widgets.
		// description:
		//		Returns the widgets that are directly under this.containerNode.
		return this.__children;
		// This query fails on IE :-(  So, have to keep our own array.  Bummer.
		//return dojo.query("[widgetid]", this.containerNode).map(dijit.byNode); // Widget[]
	},

	getFilter: function(){
		var expressions = dojo.filter(this.getChildren(), function(child){ return child.attr('filtered'); });
		if(expressions.length){
			return {
				conjunction: 'and',
				expressions: dojo.map(
					expressions,
					function(child){
						return child.getFilterExpression();
					}
				)
			};
		}else{
			return null;
		}
	},

	onWidgetFilter: function(){
		if(!this.table){ return; }
		var f = this.getFilter();
		if(dojo.isFunction(this.table.clearSelections)){
			// Filter changes should clear selections.  Came out
			// of discussions with IFM: CSCtj75300
			this.table.clearSelections();
		}
		if(f){
			this.table.filter(f);
		}else{
			this.table.clearFilter();
 		}
	},

	_createWidgets: function(){
		var mappings = this.mappings,
			self = this,
			table = this.table,
			store = table.store,
			getPBW = table._getPadBorderWidth;
		var widget_conns = this._widget_conns = [];
		var searchDelay = this.searchDelay = table.filterDelay;
		var columnData = this.columns.columns;

		dojo.query(this.column_query, this.domNode).forEach(function(node, index){
			var mapping = mappings[index];
			var isEnum = false;		

			// Finding the column data is somewhat funky.
			var options = null;
			if(mapping.groupIndex > 0){
				var pColumn = columnData[mapping.groupIndex] || {};
				var children = pColumn.children || {};
				var cols = children._columns || {};
				options = cols[mapping.index] || {};
			}else{
				options = columnData[mapping.index];
			}

			//var options = columnData[index + offset] || {};
			var fopts = options.filterOptions || {};
			fopts = dojo.clone(fopts);
			var wStore = store;

			if(!fopts.autoSuggestValues && options.filterType == "boolean"){
				// If it is a boolean and they haven't specified values, then
				// we can enable it as an autosuggesting boolean field.
				fopts.autoSuggestValues = [true, false];
				if(!("enableAutoSuggest" in fopts)){
					fopts.enableAutoSuggest = true;
				}
				if(!("autoSuggestDelay" in fopts)){
					fopts.autoSuggestDelay = 300;
				}
			}

			if(fopts.autoSuggestValues){
				// Enumerated values were to show these as dropdown values instead
				// of searching the store feeding the Table.
				var eNum = fopts.autoSuggestValues;
				
				// Test to see if sorting option is set
				// by default we will sort, so we only want to
				// not sort if sortautoSuggest is explictly false
				// This should sync it to Advanced Filter Sorting.
				if("sortAutoSuggestValues" in fopts){
					if(fopts.sortAutoSuggestValues){
						eNum.sort();
					}
				}else{
					eNum.sort();
				}
				
				var data = {
					label: mapping.attr,
					items:[]
				};
				for(i = 0; i < eNum.length; i++){
					var item = {};
					item[mapping.attr] = eNum[i];
					data.items.push(item);
				}
				wStore = new dojo.data.ItemFileReadStore({data: data});

				if(!("enableAutoSuggest" in fopts)){
					// If we have enumerated values, then assume we probably
					// want autosuggest on.  This still allows users to disable it
					// if they so desire by being explicit in column config.
					fopts.enableAutoSuggest = true;
				}
				isEnum = true;
			}

			var w = new xwt.widget.table._ByExampleWidget({
				searchAttr: mapping.attr,
				searchDelay: fopts.autoSuggestDelay || searchDelay || 750,
				enableAutoSuggest: fopts.enableAutoSuggest ? true : false,
				intermediateChanges: true,
				typeSearchDelay: fopts.typePauseSearchDelay || 1000,
				store: wStore,
				isEnum: isEnum
			});
			
			if(!options.filterable){
				w.attr("disabled", true);
				w.attr("value", self.__i18n.notFilterable);
			}

			self.__children.push(w);
			w.placeAt(node);
			var width = (dojo.contentBox(node).w - getPBW(w.domNode));
			if(width > 0){
				// Don't set negative widths.  IE will blow up.
				w.domNode.style.width = width  + 'px';
			}
			widget_conns.push(dojo.connect(w, 'onFilter', self, 'onWidgetFilter'));
		});
	},

	_destroyWidgets: function(){
		dojo.forEach(this.getChildren(), function(w){
			w.destroyRecursive();
		});
		this.__children = [];
		if(this._widget_conns){
			dojo.forEach(this._widget_conns, dojo.disconnect);
		}
	},

	_setupMappings: function(){
		var columns = this.mappings = [],
			fWidgetMap = xwt.widget.table.FilteringWidgetMap,
			column_query = [];
		function colFunc(column, index){
			var colInfo = {
				index: column._index,
				groupIndex: column._groupIndex,
				attr: column.attr
			};

			if(column._groupIndex > -1){
				column_query.push('.cell-' + column._groupIndex +
					' .group-cell-' + column._index);
			}else{
				column_query.push('.cell-' + column._index);
			}

			columns.push(colInfo);
		}
		this.columns.forEach(function(col, i){
			if(col.columnType != xwt.widget.table.ColumnTypes.COLUMN){
				return;
			}
			if(col.children){
				col.children.forEach(colFunc);
			}else{
				colFunc(col);
			}
		});

		this.column_query = column_query.join(', ');
	},

	_onColumnsChange: function(){
		if(!this.table){ return; }
		this._destroyWidgets();

		var thead = this.tableHeadRow,
			table = this.table;

		dojo.query("*", this.domNode).orphan();

		this._createTable();

		this._setupMappings();
		this._createWidgets();
	},

	_resizeWidgets: function(){
		var getPBW = this.table._getPadBorderWidth;
		dojo.query(this.column_query, this.domNode).forEach(function(node, index){
			if(!node.firstChild){ return; }
			var fc = node.firstChild;
			var width = dojo.contentBox(node).w - getPBW(fc);
			if(width > 0){
				fc.style.width = width + "px";
			}
			fc = null;
		});
	},

	show: function(){
		if(!this.hidden){
			return;
		}
		if(!this.table){ return; }
		if(this._delayedSelectorWidth){
			// Had to delay sizing the selector, do it now,
			// Should be visible to compute
			var cols = this.columns;
			var selectorIndex = null;
			var table = this.table;
			cols.forEach(function(column){
				if(selectorIndex == null && column.columnType == xwt.widget.table.ColumnTypes.SELECTOR){
					selectorIndex = column._index;
				}
			});
			if(selectorIndex != null){
				var selectorCellTable = dojo.query(".cell-container-" + selectorIndex, table.tableHeadInnerContainer)[0];
				var scb = dojo.contentBox(selectorCellTable);
				var selectorCell = dojo.query(".cell-container-" + selectorIndex, this.domNode)[0];
				if(scb.w >= 0){
					selectorCell.style.width = scb.w + 'px';
					delete this._delayedSelectorWidth;
				}else{
					// We need to delay the sizing
					this._delayedSelectorWidth = true;
				}
                        }
		}
		dojo.style(this.domNode, 'display', '');
		this._resizeWidgets();
		dojo.addClass(this.table.tableHeadContainer, 'filter-by-example');
		this.hidden = false;
	},

	hide: function(){
		if(this.hidden){
			return;
		}
		if(!this.table){ return; }
		dojo.style(this.domNode, 'display', 'none');
		dojo.removeClass(this.table.tableHeadContainer, 'filter-by-example');

		dojo.forEach(this.getChildren(), function(child){
			child.attr('filtered', false);
			if(!child.attr("disabled")) { child.attr('value', ''); }
		});

		this.hidden = true;
	},

	destroy: function(){
		this.inherited(arguments);
		if(this._cols_conns && this._cols_conns){
			dojo.forEach(this._cols_conns, dojo.disconnect);
		}
		if(this._source){
			this._source.destroy();
		}
		this._destroyWidgets();
	}
});

}

if(!dojo._hasResource["xwt.widget._ConfigureTheme"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget._ConfigureTheme"] = true;
dojo.provide("xwt.widget._ConfigureTheme");



/*
 * This file is used to switch theme given a url parameter like http://host:port/context?theme=kubricklite. If url parameter theme is
 * not passed _ConfigureTheme will not do anything but let the application or RI page do whatever is in the HTML markup. If theme url parameter is passed
 * following logic is used.
 * 
 * Step1 : Regardless of what theme is remove any links that have kubricklite.css or reboot2.css as href to make sure opt build works fine in IE8.
 * Step2 : If theme requested is kubricklite , remove reboot2-base and reboot2-xwt links if present.
 * Step3 : If theme requested is reboot2 , remove kubricklite-base and kubricklite-xwt links if present.
 * Step4 : If theme requested is kubricklite add kubricklite-base.css and kubricklite-xwt.css as new link elements.
 * Step5 : If theme requested is reboot2 add reboot2-base.css and reboot2-xwt.css as new link elements.
 * 
 * Any style link that an RI or application may have added is not touched.
 * This is because :
 * 1. We do not know what these links are meant for.
 * 2. We do not know if application or RI specific links are affected by theme or are common for all the themes (we do not want to enforce anything on applications here.)
 * 
 * SUMMARY : Only xwt supported theme are touched any css or link otherwise is not touched. If one does not use theme as a url parameter the resulting markup
 * may not run in IE8 in otimized build.
 * 
*/

var themeInUse = "";

(function(){
	var d = dojo,
		theme = false,
		testMode = null,
		defTheme = "reboot2";

	var supportedThemes = ["kubricklite", "reboot2"];
	var kubrickliteCssFiles = ["kubricklite-base","kubricklite-xwt","kubricklite-explorer"];
	var reboot2CssFiles = ["reboot2-base","reboot2-xwt","reboot2-explorer"];

	if(window.location.href.indexOf("?") > -1){
		var str = window.location.href.substr(window.location.href.indexOf("?")+1).split(/#/);
		var ary  = str[0].split(/&/);
		for(var i=0; i<ary.length; i++){
			var split = ary[i].split(/=/),
				key = split[0],
				value = split[1].replace(/[^\w]/g, "");	// replace() to prevent XSS attack
			switch(key){
				case "locale":
					// locale string | null
					dojo.config.locale = locale = value;
					break;
				case "dir":
					// rtl | null
					document.getElementsByTagName("html")[0].dir = value;
					break;
				case "theme":
					// reboot2 | kubricklite | null
					theme = value;
					break;
				case "a11y":
					if(value){ testMode = "dijit_a11y"; }
			}
		}
	}
	//else {
	//	theme = defTheme;
	//}

	// always include the default theme files:
	if(theme || testMode){
		var themeToRemove = "";
		var linksInUse = dojo.query("head link", dojo.doc.documentElement);
		var linksToRemove = null;

		if(theme == "kubricklite"){
			linksToRemove = kubrickliteCssFiles;
		} else {
			linksToRemove = reboot2CssFiles;
		}
		
		// remove kubricklite.css and reboot2.css if some one is using.
		for(var m=0; m<linksInUse.length; m++){
			var l = linksInUse[m];
			if(l && l.rel=="stylesheet" && l.href){
				if(l.href.indexOf("kubricklite.css") > 0 || l.href.indexOf("reboot2.css") > 0){
					console.log("DESTROYED LINK::" + l.href);
					dojo.destroy(l);
				}
			}
		}

		// remove base and xwt css if some one is using.
		for(var k=0; k<linksInUse.length; k++){
			var link = linksInUse[k];
			if(link && link.rel=="stylesheet"){
				for(var l=0; l<linksToRemove.length; l++){
					if(link.href && link.href.indexOf(linksToRemove[l]+".css") > 0){
						console.log("DESTROYED LINK::" + link.href);
						dojo.destroy(link);
					}
				}
			}
		}

		var cssFiles;
		if(theme){
			if(theme == "kubricklite"){
				cssFiles = kubrickliteCssFiles;
			} else {
				cssFiles = reboot2CssFiles;
			}
			for(var i=0; i<cssFiles.length; i++){
				var themeCss = d.moduleUrl("xwt.themes",theme+"/"+cssFiles[i]+".css");
				document.write('<link rel="stylesheet" type="text/css" href="'+themeCss+'">');
				console.log("ADDED LINK::" + themeCss);
				//var themeCssRtl = d.moduleUrl("dijit.themes",theme+"/"+theme+"_rtl.css");
				//document.write('<link rel="stylesheet" type="text/css" href="'+themeCssRtl+'">');
			}
		}

		dojo.parser._xwtOldParse = dojo.parser.parse;
		dojo.parser.parse = function(/*DomNode?*/ rootNode, /* Object? */ args){
			var b = dojo.body();
			if(theme){
				if(!dojo.hasClass(b, theme)){
					dojo.removeClass(b, defTheme);
					if(!d.hasClass(b, theme)){ d.addClass(b, theme); } 
					var n = d.byId("themeStyles");
					if(n){ d.destroy(n); }
				}
				if(testMode){ d.addClass(b, testMode); }
			}
			return dojo.parser._xwtOldParse(rootNode, args);
		}

		d.addOnLoad(function(){
			themeInUse = theme;
			console.log("_conftheme-- themeInUse:: " + themeInUse);
		});
	}

})();

}

if(!dojo._hasResource["xwt.widget.TooltipDialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.TooltipDialog"] = true;
/*******************************************************************   
 *        Copyright (c) 2009-2011 Cisco Systems, Inc.   
 *        All rights reserved.   
 * 
 * @fileoverview 
 * The TooltipDialog is an extension of the dijit widget, dijit.TooltipDialog.
 *  
 * @author Dennis Park denpark@cisco.com
 * 
 ********************************************************************/
dojo.provide("xwt.widget.TooltipDialog");







dojo.declare("xwt.widget.TooltipDialog", [dojox.layout.ContentPane, dijit._Templated, dijit.form._FormMixin, dijit._DialogMixin],
{
	// summary:
	//		Pops up a dialog that appears like a Tooltip

	// title: String
	// 		Description of tooltip dialog (required for a11y)
	title: "",

	// doLayout: [protected] Boolean
	//		Don't change this parameter from the default value.
	//		This ContentPane parameter doesn't make sense for TooltipDialog, since TooltipDialog
	//		is never a child of a layout container, nor can you specify the size of
	//		TooltipDialog in order to control the size of an inner widget. 
	doLayout: false,

	// autofocus: Boolean
	// 		A Toggle to modify the default focus behavior of a Dialog, which
	// 		is to focus on the first dialog element after opening the dialog.
	//		False will disable autofocusing. Default: true
	autofocus: true,

	// baseClass: [protected] String
	//		The root className to use for the various states of this widget
	baseClass: "dijitTooltipDialog",

	// _firstFocusItem: [private] [readonly] DomNode
	//		The pointer to the first focusable node in the dialog.
	//		Set by `dijit._DialogMixin._getFocusItems`.
	_firstFocusItem: null,

	// _lastFocusItem: [private] [readonly] DomNode
	//		The pointer to which node has focus prior to our dialog.
	//		Set by `dijit._DialogMixin._getFocusItems`.
	_lastFocusItem: null,

	templateString: null,
	templateString:"<div waiRole=\"presentation\">\r\n\t<div class=\"dijitTooltipContainer\" waiRole=\"presentation\">\r\n\t\t<div class =\"dijitTooltipContents dijitTooltipFocusNode\" dojoAttachPoint=\"containerNode\" tabindex=\"-1\" waiRole=\"dialog\"></div>\r\n\t</div>\r\n\t<div class=\"dijitTooltipConnector\" waiRole=\"presentation\"></div>\r\n</div>\r\n",

	postCreate: function(){
		this.inherited(arguments);
		this.connect(this.containerNode, "onkeypress", "_onKey");
		this.containerNode.title = this.title;
	},

	orient: function(/*DomNode*/ node, /*String*/ aroundCorner, /*String*/ corner){
		// summary:
		//		Configure widget to be displayed in given position relative to the button.
		//		This is called from the dijit.popup code, and should not be called
		//		directly.
		// tags:
		//		protected
		var c = this._currentOrientClass;
		if(c){
			dojo.removeClass(this.domNode, c);
		}
		c = "dijitTooltipAB"+(corner.charAt(1)=='L'?"Left":"Right")+" dijitTooltip"+(corner.charAt(0)=='T' ? "Below" : "Above");
		dojo.addClass(this.domNode, c);
		this._currentOrientClass = c;
	},

	onOpen: function(/*Object*/ pos){
		// summary:
		//		Called when dialog is displayed.
		//		This is called from the dijit.popup code, and should not be called directly.
		// tags:
		//		protected
	
		this.orient(this.domNode,pos.aroundCorner, pos.corner);
		this._onShow(); // lazy load trigger
		
		if(this.autofocus){
			this._getFocusItems(this.containerNode);
			dijit.focus(this._firstFocusItem);
		}
	},
	
	_onKey: function(/*Event*/ evt){
		// summary:
		//		Handler for keyboard events
		// description:
		//		Keep keyboard focus in dialog; close dialog on escape key
		// tags:
		//		private

		var node = evt.target;
		var dk = dojo.keys;
		if (evt.charOrCode === dk.TAB){
			this._getFocusItems(this.containerNode);
		}
		var singleFocusItem = (this._firstFocusItem == this._lastFocusItem);
		if(evt.charOrCode == dk.ESCAPE){
			this.onCancel();
			dojo.stopEvent(evt);
		}else if(node == this._firstFocusItem && evt.shiftKey && evt.charOrCode === dk.TAB){
			if(!singleFocusItem){
				dijit.focus(this._lastFocusItem); // send focus to last item in dialog
			}
			dojo.stopEvent(evt);
		}else if(node == this._lastFocusItem && evt.charOrCode === dk.TAB && !evt.shiftKey){
			if(!singleFocusItem){
				dijit.focus(this._firstFocusItem); // send focus to first item in dialog
			}
			dojo.stopEvent(evt);
		}else if(evt.charOrCode === dk.TAB){
			// we want the browser's default tab handling to move focus
			// but we don't want the tab to propagate upwards
				evt.stopPropagation();
			}
		}
	}	
);

}

if(!dojo._hasResource["xwt.widget.layout.En_ScrollPane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.layout.En_ScrollPane"] = true;
/*******************************************************************
 *        Copyright (c) 2009-2011 Cisco Systems, Inc.
 *        All rights reserved.
 *
 * @fileoverview
 * The ScrollPane provides a custom scrollable pane for holding content.
 *
 * @author Harjeet Singh harjeesi@cisco.com & Jose Joice Jeganathan -X (jjeganat@cisco.com - HCL at Cisco)
 *
 ********************************************************************/
dojo.provide("xwt.widget.layout.En_ScrollPane");




dojo.declare("xwt.widget.layout.En_ScrollPane",  [dijit._Widget, dijit._Templated, dijit._Container, dijit._Contained], {
	// summary:
	//	The Scroll Pane provides a custom scrollable pane into which we can place content.
	//description:
	//	The Scroll Pane provides a custom scrollable pane into which we can place content.



	// template path
	templateString:"<div class=\"scrollPane\">\r\n\t<div class=\"parentContainer\" dojoAttachPoint=\"parentContainerAP\">\r\n\t\t<div class=\"containerNode\" dojoAttachPoint=\"containerNode\">\r\n\t\t</div>\r\n\t</div>\r\n\t<div class=\"vslider\" dojoAttachPoint=\"vsliderAP\">\r\n\t\t<div class=\"scrollUp\" dojoAttachPoint=\"scrollUpAP\"></div>\r\n\t\t<div class=\"vScrollBar\" dojoAttachPoint=\"vScrollBarAP\">\r\n\t\t\t<div class=\"vScroll\" dojoAttachPoint=\"vScrollAP\">\r\n\t\t\t\t<div class=\"vScrollTop\" dojoAttachPoint=\"vScrollTopAP\"></div>\r\n\t\t\t\t<div class=\"vScrollMid\" dojoAttachPoint=\"vScrollMidAP\"><span></span></div>\r\n\t\t\t\t<div class=\"vScrollBottom\" dojoAttachPoint=\"vScrollBottomAP\"></div>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t\t<div class=\"scrollDown\" dojoAttachPoint=\"scrollDownAP\"></div>\r\n\t</div>\r\n\t<div class=\"hslider\" dojoAttachPoint=\"hsliderAP\">\r\n\t\t<div class=\"scrollLeft\" dojoAttachPoint=\"scrollLeftAP\"></div>\r\n\t\t<div class=\"hScrollBar\" dojoAttachPoint=\"hScrollBarAP\">\r\n\t\t\t<div class=\"hScroll\" dojoAttachPoint=\"hScrollAP\">\r\n\t\t\t\t<div class=\"hScrollBottom\" dojoAttachPoint=\"hScrollLeftAP\"></div>\r\n\t\t\t\t<div class=\"hScrollMid\" dojoAttachPoint=\"hScrollMidAP\"></div>\r\n\t\t\t\t<div class=\"hScrollTop\" dojoAttachPoint=\"hScrollRightAP\"></div>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t\t<div class=\"scrollRight\" dojoAttachPoint=\"scrollRightAP\"></div>\r\n\t</div>\r\n</div>\r\n",


	// contentHeight: int
	// Height of the content.
	_contentHeight : 0,

	// visibleContentHeight : int
	// Height of the visible content.
	_visibleContentHeight : 0,

	// scrollActive :  boolean
	// Indicates if scroll is active.
	_scrollActive : false,

	//scrollHandleObj : Object
	// Reference to the vertical scroll handle.
	_scrollHandleObj : null,

	//scrollHandleHeight : int
	//Height of the vertical scrollbar button.
	_scrollHandleHeight : 0,

	//scrollbarTop : int
	//Top Position of the vertical ScrollBar button.
	_scrollbarTop : 0,

	//eventPos : int
	// Mouse Y position of the scrollbar while pressing the UP or DOWN arrows.
	_eventYPos : 0,

	//scrollbuttonActive : boolean
	//If true, indicates that the scroll pane up or down arrow is active; otherwise, false.
	_scrollbuttonActive : false,


	//scrollbuttonDirection : int
	//Direction of scrolling (up or down).
	_scrollbuttonDirection : 0,


    // scrollbuttonSpeed : int
    // How fast the content scrolls when you click the scroll buttons (up and down arrows).
	_scrollbuttonSpeed : 1,

	// scrollTimer : int
	// How fast the content scrolls. By decreasing this value, the content will move faster.
	_scrollTimer : 10,


	//scrollMoveToActive : boolean
	//While pressing the scroll bar this is true; otherwise, false.
	_scrollMoveToActive : false,


	//scrollMoveToYPosition : int
	// Mouse Y position of the scrollbar while pressing the Scroll bar.
	_scrollMoveToYPosition : false,


	// It contains events
	_tconnects: null,// jose
	// It contains events
	_connects: null,// jose
	// horizontal

	// visibleContentWidth : int
	// Width of the visible content.
	_visibleContentWidth : 0,

	// contentWidth: int
	// Width of the content.
	_contentWidth : 0,

	// hscrollHandleObj: Object
	// Reference to the horizontal scroll handle.
	_hscrollHandleObj :null,

	//scrollHandleWidth : int
	//Width of the horizontal scrollbar button.
	_scrollHandleWidth :0,

	//scrollbarLeft : int
	//Left Position of the horizontal ScrollBar button.
	_scrollbarLeft :0,

	//fontHeight : int
	//Height of the line.
	_fontHeight: 0,

	//fontSize : int
	//Width of the line.
	_fontSize: 0,


	_stopPos:0,
	//line height
	_lineHeight:0,

	//vs
	_rowHeight :23,
	_endRow:0,

	_verticalScrollHandleHeight : 16,

	_verticalScrollHandleMoving : 0,

	_waitTimer : 250,

	_isScrollPaneNeed:true,

        postCreate: function(){
            // initialize the arrays
            this._tconnects = [];
            this._connects = [];
        },

	startup: function(){

		// summary:
		//	Displays the scrollpane.
		// example:
		//		<div id="sp1" dojoType="xwt.widget.layout.En_Scrollpane"> ---place the content here--- </div>
		// example:
		//		In HTML:
		// <div id="sp1"> ---place the content here--- </div>
		//  In Javascript:
		// var divEle = document.getElementById("sp1");
		// var scrollpane = new xwt.widget.layout.En_Scrollpane({},divEle);


		if(this._started){
			return;
		}
		this._hideScrollpane();
		this._initScroll();

		this.inherited(arguments);

	},
	/*pCreate: function(){

	}, */
	setScrollContentTopPosition : function(topPos){
		//summary : Sets the parent container top position.
		this.parentContainerAP.scrollTop = topPos;
	},
	_startScroll: function(e){
		// summary: Starts the scroll when pressing the veritcal scroll bar.
		//Gets the top position of the scroll button.

		//if(document.all && !operaBrowser)e = event;
		this._scrollbarTop = this.vScrollAP.style.top.replace('px','');
		//Getting the Y position of the mouse
		this._eventYPos = e.clientY;
		this._scrollActive = true;
		// connect to the mouse move event
		if(this._scrollHandleHeight>0){
		this._tconnects.push(dojo.connect(this.vScrollBarAP,"onmousemove",this,"_scroll"));
		}
	},

	_stopScroll: function(e){
		// summary: Stops the scroll button press event.
		this._scrollActive = false;
		this._scrollbuttonActive = false;
		this._scrollMoveToActive = false;
		// disconnect the events of scroll button
		dojo.forEach(this._tconnects, dojo.disconnect);
	},

	_scroll: function(e){
		// summary: Executed when the user presses the vertical scroll bar.
			if(this._scrollHandleHeight<0){
			return;
		}
		if(!this._scrollActive) {
			return;
		}
		//if(document.all && !operaBrowser)e = event;
		if(e.button!=1 && document.all) {
			return;
		}
		dojo.addClass(this.vScrollBarAP,"xwtScroll");
		var topPos = this.vScrollAP.style.top.replace('px','');
		topPos = ((topPos/1)+((this._eventYPos-e.clientY)*-1));
		this._eventYPos=e.clientY;
		//var topPos = this._scrollbarTop + (e.clientY - this._eventYPos);
		// Check the negative value
		if(topPos<0) {
			topPos=0;
		}
		//Top position check with the scroll bar height.
		if( (topPos/1) > (this._visibleContentHeight-(this._verticalScrollHandleHeight+0)/1)) {
			topPos = this._visibleContentHeight-(this._verticalScrollHandleHeight+0);
		}
		this.vScrollAP.style.top = topPos + 'px';
		//this.parentContainerAP.scrollTop= Math.floor((this._contentHeight) * ((topPos) / (this._visibleContentHeight - this._verticalScrollHandleHeight))) ;
		this.setScrollContentTopPosition(Math.floor((this._contentHeight) * ((topPos) / (this._visibleContentHeight - this._verticalScrollHandleHeight))));
		//TODO harjeesi horizontal scroll

	},

	_scrollMoveToInit: function(e) {
		// summary: Click on the slider to move the content to this point.
		//if(document.all && !operaBrowser)e = event;
		if(this._scrollHandleHeight<=-1){
			return;
		}
		this._scrollMoveToActive = true;
		this._scrollMoveToYPosition = e.pageY ;//- this.vScrollBarAP.offsetTop;
	   // console.log(e.layerY+"  <<Y>>"+e.pageY +" <<Top >>"+this.vScrollAP.offsetTop+"<< b.Top>>"+this.vScrollBarAP.offsetTop+"<<p.top>>"+this.parentContainerAP.offsetTop);
		//var mbBar = dojo.marginBox(this.vScrollBarAP);
	    if(this.vScrollBarAP.offsetTop===10 || (this.vScrollBarAP.offsetTop - this.parentContainerAP.offsetTop) ===10 ){ //10==up arrow height
	    	this._scrollMoveToYPosition = e.layerY ;
	    }
		//var mbScroll = dojo.marginBox(this.vScrollAP);

		if( (this.vScrollAP.offsetTop / 1) > this._scrollMoveToYPosition) {
			this._scrollbuttonDirection = this._scrollbuttonSpeed*-1;
		} else {
			this._scrollbuttonDirection = this._scrollbuttonSpeed*1;
		}
		this._scrollbuttonDirection = this._scrollbuttonDirection * (this.vsliderAP.offsetHeight >0 ? this.vsliderAP.offsetHeight-this._rowHeight :1);
		// getting the y position , y - (screen Scrolltop - scroll top)
		this._scrollMoveToYPosition = this._scrollMoveToYPosition  -this.vScrollBarAP.offsetTop; //(this.vScrollAP.offsetTop-mbScroll.t)
		this._scrollMoveTo();

	},

	_scrollMoveTo: function () {
		// summary: Click on the slider to move the content to this point.

		if(!this._scrollMoveToActive || this._scrollActive) {
			return;
		}
		var topPos = this.vScrollAP.style.top.replace('px','');
		if(!this.parentContainerAP.scrollTop){
			this.parentContainerAP.scrollTop=0;
			//console.log("if this.containerNode.style.top "+this.containerNode.style.top);
		}

		if(this.parentContainerAP.scrollTop + this._scrollbuttonDirection >0){
			topPos=Math.floor((this.parentContainerAP.scrollTop + this._scrollbuttonDirection)/ this._verticalScrollHandleMoving);
		}

		var start = this.parentContainerAP.scrollTop;//((this.containerNode.style.top.replace('px','')/1)*-1);
	//	for(;   ((this.parentContainerAP.scrollTop/1) + start)*(-this._scrollbuttonDirection) <this._visibleContentHeight;){
			//console.log(this._scrollbuttonDirection +" :: this.containerNode.style.top "+this.containerNode.style.top+" , "+(((this.containerNode.style.top.replace('px','')/1) + start)*-this._scrollbuttonDirection)+" < "+pageLine);

	//	for(var n=0;n<this._fontHeight;n++){
		   if(!this._scrollMoveToActive){
				return;
		   }

			topPos = topPos/1 ;//+ this._scrollbuttonDirection;
			if(topPos < 0) {
				topPos=0;
				this._scrollMoveToActive=false;
			}
			if( (topPos/1) > (this._visibleContentHeight - ((this._verticalScrollHandleHeight + 0) / 1))){
				topPos = this._visibleContentHeight-(this._verticalScrollHandleHeight+0);
				this._scrollMoveToActive=false;
			}

			/*if(this._scrollbuttonDirection < 0 && topPos < (this._scrollMoveToYPosition- this._verticalScrollHandleHeight / 2)) {
				return;
			}
			if(this._scrollbuttonDirection>0 && topPos> this._scrollMoveToYPosition-this._verticalScrollHandleHeight/2) {
				return;
			}*/
			if(topPos >0 && ( start + this._scrollbuttonDirection) <= 0 ){
				topPos=0
			}
			this.vScrollAP.style.top = topPos + 'px';
			//this.parentContainerAP.scrollTop =start + this._scrollbuttonDirection; //Math.floor((this._contentHeight) * ((topPos)/(this._visibleContentHeight - this._scrollHandleHeight)));//+'px';

			this.setScrollContentTopPosition(start + this._scrollbuttonDirection);
			//console.log("this.parentContainerAP.scrollTop : "+this.parentContainerAP.scrollTop);
		//}
	    // }
		//setTimeout(dojo.hitch(this, '_scrollMoveTo'), 200);
	},

     _scrollButton: function (e){
		// summary: Identify the UP or DOWN arrow that is pressed.

		this._waitTimer = 260;
		if(this._scrollHandleHeight<=0){
			return;
		}
		this._stopPos=this.vScrollAP.style.top.replace('px','');
		this._stopPos=this._stopPos+this._fontHeight;
		this._scrollbuttonSpeed=1;//remove after test
		if(e.target == this.scrollUpAP){
			this._scrollbuttonDirection = this._scrollbuttonSpeed*-1;
		} else {
			this._scrollbuttonDirection = this._scrollbuttonSpeed;
		}
		this._scrollbuttonDirection=this._scrollbuttonDirection * this._rowHeight;

		this._scrollbuttonActive=true;
		// Move the contents
		 this._scrollButtonScroll();


	},
	_scrollButtonScroll: function(){
		// summary: Executed when the user presses the vertical scroll (up and down) buttons.

			this._waitTimer = this._waitTimer - 20;
		if(this._waitTimer <=0){
			this._waitTimer = 20;
		}
		//console.log("*******************"+this._waitTimer);
		// summary: Moves the contents while pressing the up or down arrow.
		if(!this._scrollbuttonActive) {
			return;
		}

		var topPos = this.vScrollAP.style.top.replace('px','');

		if(this.parentContainerAP.scrollTop + this._scrollbuttonDirection >0){
			topPos=Math.floor((this.parentContainerAP.scrollTop + this._scrollbuttonDirection)/ this._verticalScrollHandleMoving);
		}else if(this.parentContainerAP.scrollTop <=0){
			topPos = 0;
		}
		else{
			topPos = 0;
		}
		//for(var n=0;n<this._fontHeight;n++){
			if(!this._scrollbuttonActive) {
				return;
			}

			//if(this._stopPos<topPos)
				//return;
			topPos = topPos/1;// + (this._fontHeight >=1 ?  this._scrollbuttonDirection : (this._scrollbuttonDirection * this._fontHeight));
			if(topPos < 0){
				topPos = 0;
				this._scrollbuttonActive = false;
			}
			if( (topPos/1) > (this._visibleContentHeight - (this._scrollHandleHeight+0)/1)){
				topPos = this._visibleContentHeight - (this._scrollHandleHeight+0);
				this._scrollbuttonActive=false;
			}
			this.vScrollAP.style.top = (topPos) + 'px';
			//this.parentContainerAP.scrollTop = this.parentContainerAP.scrollTop + this._scrollbuttonDirection; //Math.floor((this._contentHeight) * ((topPos) / (this._visibleContentHeight - this._scrollHandleHeight)));
			this.setScrollContentTopPosition(this.parentContainerAP.scrollTop + this._scrollbuttonDirection);
			//this.containerNode.style.top = 0 - Math.floor((this._contentHeight) * ((topPos) / (this._visibleContentHeight - this._scrollHandleHeight)))+'px';
		//}
		setTimeout(dojo.hitch(this, '_scrollButtonScroll'), this._waitTimer);

	},
	_wheel:function(event){
		//summary: Moves the contents while scrolling.

		if (!event) {
			event = window.event;
		}
		var delta=0;
			    // normalize the delta
	    if (event.wheelDelta) {
	       // IE and Opera
	        delta = event.wheelDelta;
	    } else if (event.detail) {
	        // W3C
		        delta = event.detail ;
		}
		if(delta!==0){
			//return 0;


		//this._stopPos=this.vScrollAP.style.top.replace('px','');
		//this._stopPos=this._stopPos+this._fontHeight;
		this._scrollbuttonSpeed=1;//remove after test

		if(dojo.isIE){
			if(delta<0){
				this._scrollbuttonDirection = 1;
			} else {
				this._scrollbuttonDirection = -1;
			}
		}else{
			if(delta<0){
				this._scrollbuttonDirection = -1;
			} else {
				this._scrollbuttonDirection = 1;
			}
		}

		this._scrollbuttonDirection=this._scrollbuttonDirection * this._rowHeight;

		this._scrollbuttonActive=true;
		// Move the contents
	    this._scrollButtonScrollMouseWheel();
	    dojo.stopEvent(event);
		}

	},
	_scrollButtonScrollMouseWheel: function(){
		//summary: Moves the contents while scrolling.
		if(this._scrollHandleHeight<=0){
			return;
		}
		if(!this._scrollbuttonActive){
			return;
		}

		var topPos = this.vScrollAP.style.top.replace('px','');
		if(this.parentContainerAP.scrollTop + this._scrollbuttonDirection >0){
			topPos=Math.floor((this.parentContainerAP.scrollTop + this._scrollbuttonDirection)/ this._verticalScrollHandleMoving);
		}
		//for(var n=0;n<this._fontHeight;n++){
			if(!this._scrollbuttonActive) {
				return;
			}

			//if(this._stopPos<topPos)
				//return;
			topPos = topPos/1 ;//+ this._scrollbuttonDirection;
			if(topPos < 0){
				topPos = 0;
				this._scrollbuttonActive = false;
			}
			if( (topPos/1) > (this._visibleContentHeight - (this._scrollHandleHeight+0)/1)){
				topPos = this._visibleContentHeight - (this._scrollHandleHeight+0);
				this._scrollbuttonActive=false;
			}
			if(topPos >0 && (this.parentContainerAP.scrollTop + this._scrollbuttonDirection)<=0){
				topPos =0;
			}

			this.vScrollAP.style.top = (topPos) + 'px';
			//this.parentContainerAP.scrollTop= this.parentContainerAP.scrollTop + this._scrollbuttonDirection; //Math.floor((this._contentHeight) * ((topPos) / (this._visibleContentHeight - this._scrollHandleHeight)));
			this.setScrollContentTopPosition(this.parentContainerAP.scrollTop + this._scrollbuttonDirection);
		//}
		//setTimeout(dojo.hitch(this, '_scrollButtonScroll'), this._scrollTimer);

	},
	_scrollButtonStop :function () {
		// summary: Changes the up and down button status to inactive.
		this._scrollbuttonActive = false;
	},
	 _scrollHButton: function (e){
		// summary: Identifies the right or left arrow that is pressed.
		if(this._scrollHandleWidth<=0){
			return;
		}
		this._stopPos=this.hScrollAP.style.left.replace('px','');
		this._stopPos=this._stopPos+this._fontSize;
		//this._scrollbuttonSpeed=1;
		if(e.target == this.scrollLeftAP){
			this._scrollbuttonDirection = this._scrollbuttonSpeed*-1;
		} else {
			this._scrollbuttonDirection = this._scrollbuttonSpeed;
		}

      	this._scrollbuttonActive=true;
		// Move the contents
	    this._scrollHButtonScroll();

	},
	_scrollHButtonScroll: function(){
		// summary: Moves the contents while pressing the right or left arrow.
		//console.log("this._fontSize :"+this._fontSize);
		if(!this._scrollbuttonActive) {
			return;
		}
		var topPos = this.hScrollAP.style.left.replace('px','');
		//for(var n=0;n<this._fontSize;n++){
			if(!this._scrollbuttonActive) {
				return;
			}

			//if(this._stopPos<topPos)
				//return;

			topPos = topPos/1 + (this._scrollbuttonDirection * this._fontSize);
			if(topPos < 0){
				topPos = 0;
				this._scrollbuttonActive = false;
			}
			if( (topPos/1) > (this._visibleContentWidth - (this._scrollHandleWidth+0)/1)){
				topPos = this._visibleContentWidth - (this._scrollHandleWidth+0);
				this._scrollbuttonActive=false;
			}
			this.hScrollAP.style.left = (topPos) + 'px';
			this.parentContainerAP.scrollLeft=Math.floor((this._contentWidth) * ((topPos) / (this._visibleContentWidth - this._scrollHandleWidth))) ;
			//this.containerNode.style.left = (topPos == 0 ? 3+'px' : 0 - Math.floor((this._contentWidth) * ((topPos) / (this._visibleContentWidth - this._scrollHandleWidth)))+'px') ;
		//}
		setTimeout(dojo.hitch(this, '_scrollHButtonScroll'), this._scrollTimer);
	},

	_scrollHButtonStop :function () {
		// summary: Changes the up and down button status to inactive.
		this._scrollbuttonActive = false;
	},
	_scrollHButtonScrollMoveToResizePos: function(){
		// summary: Moves the contents while pressing the right or left arrow.
		//console.log("this._fontSize :"+this._fontSize);
		if(this._scrollHandleWidth<=0){
			return;
		}
		//if(!this._scrollbuttonActive) {
		//	return;
		//}
		var topPos = this.hScrollAP.style.left.replace('px','');


			topPos = topPos/1;// + this._scrollbuttonDirection;
			if(topPos < 0){
				topPos = 0;
				this._scrollbuttonActive = false;
			}
			if( (topPos/1) > (this._visibleContentWidth - (this._scrollHandleWidth+0)/1)){
				topPos = this._visibleContentWidth - (this._scrollHandleWidth+0);
				this._scrollbuttonActive=false;
			}
			this.hScrollAP.style.left = (topPos) + 'px';
			this.parentContainerAP.scrollLeft= Math.floor((this._contentWidth) * ((topPos) / (this._visibleContentWidth - this._scrollHandleWidth))) ;
		//}
		//setTimeout(dojo.hitch(this, '_scrollHButtonScroll'), this._scrollTimer);
	},
	_hscrollMoveToInit: function(e) {
		// summary: Click on the slider to move the content to this point.
		//if(document.all && !operaBrowser)e = event;
		if(this._scrollHandleWidth<=0){
			return;
		}
		this._scrollMoveToActive = true;
		//console.log(e.layerX+"<<x>>"+e.pageX+"<<left>>"+this.hScrollAP.offsetLeft+"<<b,left>>"+this.hScrollBarAP.offsetLeft+"<<p.left>"+this.parentContainerAP.offsetLeft );
		this._scrollMoveToYPosition = e.layerX - this.parentContainerAP.offsetLeft; //e.pageX ;//- this.vScrollBarAP.offsetTop;

		if(dojo.isIE && this.parentContainerAP.offsetLeft+10 == (e.pageX - e.layerX)){ //10 = left arrow
			this._scrollMoveToYPosition = e.pageX;
		}else if(!dojo.isIE && e.pageX==e.layerX){
			this._scrollMoveToYPosition = e.pageX;
		}



		if( (this.hScrollAP.offsetLeft / 1) > this._scrollMoveToYPosition) {
			this._scrollbuttonDirection = this._scrollbuttonSpeed*-1;
		} else {
			this._scrollbuttonDirection = this._scrollbuttonSpeed*1;
		}
		this._scrollMoveToYPosition =this._scrollMoveToYPosition - this.hScrollBarAP.offsetLeft;
		this._hscrollMoveTo();

	},

	_hscrollMoveTo: function () {
		// summary: Click on the horizontial slider to move the content to this point.

		if(!this._scrollMoveToActive || this._scrollActive) {
			return;
		}
		var topPos = this.hScrollAP.style.left.replace('px','');;// this.parentContainerAP.scrollLeft;

		var start = this.parentContainerAP.scrollLeft;
		//for(;(((this.parentContainerAP.scrollLeft/1) *(this._scrollbuttonDirection) ) + ( start *(-this._scrollbuttonDirection) ) )<this._visibleContentWidth;){


			//for(;((this.parentContainerAP.scrollLeft/1) + start)*(-this._scrollbuttonDirection) <this._visibleContentWidth;){
		var dir =this._scrollbuttonDirection;

		   var pageleft = (this.parentContainerAP.scrollLeft/1) + (this._scrollbuttonDirection * this._visibleContentWidth);
		   topPos = Math.floor((pageleft *(this._visibleContentWidth - this._scrollHandleWidth))/this._contentWidth )

			//topPos = topPos/1 + this._scrollbuttonDirection;
			if(!this._scrollMoveToActive) {
				return;
			}
			if(topPos < 0) {
				topPos=0;
				this._scrollMoveToActive=false;
			}
			if( (topPos/1) > (this._visibleContentWidth - ((this._scrollHandleWidth + 0) / 1))){
				topPos = this._visibleContentWidth-(this._scrollHandleWidth+0);
				this._scrollMoveToActive=false;
			}
		/*
			if(this._scrollbuttonDirection < 0 && topPos < (this._scrollMoveToYPosition- this._scrollHandleWidth / 2))
				return;

			if(this._scrollbuttonDirection>0 && topPos> this._scrollMoveToYPosition-this._scrollHandleWidth/2)
				return;
			*/
			this.hScrollAP.style.left = topPos + 'px';
			//console.log(topPos+"  === "+Math.floor((this._contentWidth) * ((topPos)/(this._visibleContentWidth - this._scrollHandleWidth))));
			this.parentContainerAP.scrollLeft = Math.floor((this._contentWidth) * ((topPos)/(this._visibleContentWidth - this._scrollHandleWidth)));
		//}
		//setTimeout(dojo.hitch(this, '_hscrollMoveTo'), this._scrollTimer);
	},
	_starthScroll: function(e){
		// summary: Starts the horizontal scroll press event.
		//Gets the top position of the scroll button.

		//if(document.all && !operaBrowser)e = event;
		if(this._scrollHandleWidth<=0){
			return;
		}
		this._scrollbarTop = this.vScrollAP.style.left.replace('px','');
		//Getting the Y position of the mouse
		this._eventYPos = e.clientX;
		this._scrollActive = true;
		// connect to the mouse move event
		this._tconnects.push(dojo.connect(dojo.doc,"onmousemove",this,"_hscroll"));
	},

	_stophScroll: function(e){
		// summary: Stops the scroll button press event.
		this._scrollActive = false;
		this._scrollbuttonActive = false;
		this._scrollMoveToActive = false;
		// disconnect the events of scroll button
		dojo.forEach(this._tconnects, dojo.disconnect);
	},

	_hscroll: function(e){
		// summary: Executed when dragging the scroll button.
		if(this._scrollHandleWidth<=0){
			return;
		}
		if(!this._scrollActive) {
			return;
		}
		//if(document.all && !operaBrowser)e = event;
		if(e.button!=1 && document.all) {
			return;
		}
		var topPos = this.hScrollAP.style.left.replace('px','');
		topPos = ((topPos/1)+((this._eventYPos-e.clientX)*-1));
		this._eventYPos=e.clientX;
		//var topPos = this._scrollbarTop + (e.clientY - this._eventYPos);
		// Check the negative value
		if(topPos<0) {
			topPos=0;
		}
		//Top position check with the scroll bar height..
		if( (topPos/1) > (this._visibleContentWidth-(this._scrollHandleWidth+0)/1)) {
			topPos = this._visibleContentWidth-(this._scrollHandleWidth+0);
		}
		this.hScrollAP.style.left = topPos + 'px';
		this.parentContainerAP.scrollLeft= Math.floor((this._contentWidth) * ((topPos) / (this._visibleContentWidth - this._scrollHandleWidth))) ;
		//TODO harjeesi horizontal scroll

	},
	_assignHorizontal:function(){
		//summary: Calculate the horizontal scroll bar width.

		// start -set width of the scroll pane
		//var width=dojo.style(this.domNode, "width");
		//this.parentContainerAP.style.width = width - 10+ 'px';// 16 + 'px';
		//this.hScrollBarAP.style.width = width - 20 + 'px';//width - 32
	    // End -set width of the scroll pane



		//Horizontal
		this._visibleContentWidth = this.hScrollBarAP.offsetWidth;
		//jefhu change here
		//compare  this.parentContainerAP.scrollWidth comes with a very large number.
		//so do re-calculation. Otherwise, it will introduce a unnecessary h-scrollbar
		/*var scrollWidth=this.parentContainerAP.scrollWidth-0;
		if (this.parentContainerAP.scrollWidth>dojo.marginBox(this.parentContainerAP).w){
			scrollWidth = dojo.marginBox(this.parentContainerAP).w;
		}
		this._contentWidth = (scrollWidth) - this._visibleContentWidth -10;*/
		this._contentWidth =(this.parentContainerAP.scrollWidth-10)  - this._visibleContentWidth ; //this.containerNode.offsetWidth - this._visibleContentWidth - 8;
		this._hscrollHandleObj = this.hScrollAP;
		this._scrollHandleWidth = this.hScrollAP.offsetWidth;
		this._scrollbarLeft = this.hScrollBarAP.offsetLeft;
		//Set Horizontal Scrollpane width.
		this._fontSize=dojo.style(this.containerNode,"fontSize").replace('px','');
		console.log("this._fontSize : "+this._fontSize);
		if(isNaN(this._fontSize)){
			this._fontSize=12;
		}
		var pageSize=Math.floor(((this.parentContainerAP.scrollWidth-0) /1)/(this._fontSize/1));
		var viewSize=Math.floor(this._visibleContentWidth/this._fontSize);
		var diffSize=(pageSize - viewSize);
		var scrollWidth=0;
		if(isNaN(diffSize)){
			diffSize=0;
		}
		if(diffSize <= 1){
			this._fontSize=this.hScrollBarAP.offsetWidth;//this._visibleContentHeight;
			scrollWidth=0;//this._fontSize;
		}
		else{
			this._fontSize=this.hScrollBarAP.offsetWidth/pageSize;
			scrollWidth=this._visibleContentWidth-(this._fontSize*diffSize);
		}
		//var scrollWidth=this._visibleContentWidth-(this._fontSize*diffSize);

		//this._fontSize=this._visibleContentHeight/diffSize;
		if(scrollWidth===0){
			this._scrollHandleWidth =0;
			dojo.style(this.hsliderAP,"visibility","hidden");

		}else{
			dojo.style(this.hsliderAP,"visibility","visible");
			this._fontSize = Math.floor(this._fontSize);
			dojo.style(this.hScrollMidAP,"width",(scrollWidth-6)+"px");
			dojo.style(this.hScrollAP,"width",scrollWidth+"px");
			this._scrollHandleWidth = this.hScrollAP.offsetWidth;
		}

	},
	_assignVetical:function(){
		//summary: Calculate the vertical scroll bar width.

		// start -set Height of the scroll pane
		var height = this.domNode.offsetHeight;//dojo.style(this.domNode, "height");
		//height = height > this.containerNode.offsetHeight ?  this.containerNode.offsetHeight : height;

		this.parentContainerAP.style.height = height-10 + 'px';//-18
		this.vsliderAP.style.height = height-10 + 'px';//-18
		this.vScrollBarAP.style.height =( height - (20+10) >0  ?  height - (20+10) : 0 ) + 'px';//32+18( up and down width + horizontal height)
	   // End -set height of the scroll pane

		//Vertical
		this._visibleContentHeight = this.vScrollBarAP.offsetHeight;
		this._contentHeight = (this.parentContainerAP.scrollHeight-20) - this._visibleContentHeight; //this.containerNode.offsetHeight - this._visibleContentHeight;
		this._scrollHandleObj = this.vScrollAP;
		this._scrollHandleHeight = this.vScrollAP.offsetHeight;
		this._scrollbarTop = this.vScrollBarAP.offsetTop;
		//set vertical scroll height
		this._lineHeight=this._rowHeight;//dojo.style(this.containerNode,"lineHeight");
		if(this._lineHeight===0){
			this._lineHeight=15;
		}
	    /*console.log("body wt : "+dojo.style(this.containerNode,"lineHeight"));
		console.log("this.containerNode.offsetHeight : "+this.containerNode.offsetHeight);
		console.log("this._visibleContentHeight :"+this._visibleContentHeight);*/
		var pageline=Math.floor(((this.parentContainerAP.scrollHeight-20)/1)/(this._lineHeight/1));
		var viewline=Math.floor(this._visibleContentHeight/this._lineHeight);
		var diff=(pageline - viewline);
		var scrollHt=0;
		if(isNaN(diff)){
			diff=0;
		}
		if(diff < 1){
			this._fontHeight=this.vScrollBarAP.offsetHeight;//this._visibleContentHeight;
			scrollHt=0;//this._fontHeight;

		}
		else{
			this._fontHeight=this.vScrollBarAP.offsetHeight/pageline;
			scrollHt=this._visibleContentHeight-(this._fontHeight*diff);
		}
		//this._fontHeight = Math.floor(this._fontHeight);
		if(scrollHt===0){
			dojo.style(this.vsliderAP,"visibility","hidden");
			this._scrollHandleHeight =0;
		}else{
			dojo.style(this.vsliderAP,"visibility","visible");
			dojo.style(this.vScrollMidAP,"height",(scrollHt-6)+"px");
			dojo.style(this.vScrollAP,"height",scrollHt+"px");
			this._scrollHandleHeight = this.vScrollAP.offsetHeight;
			this._verticalScrollHandleHeight = this.vScrollAP.offsetHeight > 16? this.vScrollAP.offsetHeight : 16;
			this._verticalScrollHandleMoving = this._contentHeight / (this.vScrollBarAP.offsetHeight - this._verticalScrollHandleHeight) ;

		}

	},
	assignValue : function(){
		// summary: Calculate the vertical and horizontal scroll pane width, height and speed.

		//console.log(this.domNode.offsetWidth+" <>this.containerNode.style.width  "+dojo.style(this.hsliderAP, "width")+" , <> "+this.hsliderAP.offsetWidth);
		// start -set width of the scroll pane
		var width=this.domNode.offsetWidth;//dojo.style(this.domNode, "width");
		var height = this.domNode.offsetHeight;//dojo.style(this.domNode, "height");
		//console.log("Width :: "+width+" , height :: "+height);
		//console.log("Height :: "+this.containerNode.height+" , offset :"+this.containerNode.offsetHeight);
		//height = height > this.containerNode.offsetHeight ?  this.containerNode.offsetHeight : height;
		//console.log("AF Width :: "+width+" , height :: "+height);
		/*console.log("offsetWidth :: "+this.domNode.offsetWidth+" , height :: "+this.domNode.offsetHeight);
		console.log("clientWidth :: "+this.domNode.clientWidth+" , height :: "+this.domNode.clientHeight);
		console.log("scrollWidth :: "+this.domNode.scrollWidth+" , height :: "+this.domNode.scrollHeight);*/
		if(width ===0 || height ===0){
			dojo.style(this.parentContainerAP, "height" ,"");
			dojo.style(this.parentContainerAP, "width" ,"");
			dojo.style(this.vsliderAP,"visibility","hidden");
			this._scrollHandleHeight =0;
			this._scrollHandleWidth =0;
			dojo.style(this.hsliderAP,"visibility","hidden");
			return;
		}
		this.parentContainerAP.style.width = ((width - (10 + 0)) > 0 ? (width - (10 + 0)) : 0  ) +'px';// 16 + 'px';
		this.hScrollBarAP.style.width =( width - 20 >0 ? width - 20  : 0 )+ 'px';//width - 30 (10+10+10) for L R and margin R
		// End -set width of the scroll pane

		// start -set Height of the scroll pane
		this.parentContainerAP.style.height = (height-10 > 0 ? height-10 : 0 ) + 'px';//-18
		this.vsliderAP.style.height = (height-10 > 0 ? height-10 : 0) + 'px';//-18
		this.vScrollBarAP.style.height = (height - (20+10) > 0  ? height - (20+10) : 0) + 'px';//32+18( up and down width + horizontal height)
		// End -set height of the scroll pane

	    //Vertical
		this._visibleContentHeight = this.vScrollBarAP.offsetHeight;
		this._contentHeight =(this.parentContainerAP.scrollHeight > 20 ?  this.parentContainerAP.scrollHeight-20 : 0 ) - this._visibleContentHeight;// this.containerNode.offsetHeight - this._visibleContentHeight;
		this._scrollHandleObj = this.vScrollAP;
		this._scrollHandleHeight = this.vScrollAP.offsetHeight;
		this._scrollbarTop = this.vScrollBarAP.offsetTop;
		//Horizontal
		this._visibleContentWidth = this.hScrollBarAP.offsetWidth;
		//jefhu change here
		//compare  this.parentContainerAP.scrollWidth comes with a very large number.
		//so do re-calculation. Otherwise, it will introduce a unnecessary h-scrollbar
		var scrollWidth=this.parentContainerAP.scrollWidth-0;
	/*	if (this.parentContainerAP.scrollWidth>dojo.marginBox(this.parentContainerAP).w){
			scrollWidth = dojo.marginBox(this.parentContainerAP).w;
		}
		this._contentWidth = (scrollWidth) - this._visibleContentWidth -10;*/

		this._contentWidth =(this.parentContainerAP.scrollWidth-10)  - this._visibleContentWidth ; //this.containerNode.offsetWidth - this._visibleContentWidth - 8;



		this._hscrollHandleObj = this.hScrollAP;
		this._scrollHandleWidth = this.hScrollAP.offsetWidth;
		this._scrollbarLeft = this.hScrollBarAP.offsetLeft;

		//set vertical scroll height
		this._lineHeight=this._rowHeight;//dojo.style(this.containerNode,"lineHeight");
	 	if(this._lineHeight===0){
			this._lineHeight=15;
	 	}
		var pageline=Math.floor(((this.parentContainerAP.scrollHeight-20)/1)/(this._lineHeight/1));
		var viewline=Math.floor(this._visibleContentHeight/this._lineHeight);
		var diff=(pageline - viewline);
		var scrollHt=0;
		if(isNaN(diff)){
			diff=0;
		}
		if(diff < 1){
			this._fontHeight=this.vScrollBarAP.offsetHeight;//this._visibleContentHeight;
			scrollHt=0;//this._fontHeight;

		}
		else{
			this._fontHeight=this.vScrollBarAP.offsetHeight/pageline;
			scrollHt=this._visibleContentHeight-(this._fontHeight*diff);
		}

		//var scrollHtH=((this._visibleContentHeight * this._visibleContentHeight ) /this._contentHeight );
		//console.log(scrollHt+" <><><><> "+scrollHtH);
		/*console.log("viewline :"+viewline);
		console.log("pageline :"+pageline);
		console.log("diff     :"+diff);
		console.log("fontht   :"+this._fontHeight);
		console.log("this.vScrollBarAP.offsetHeight    :"+this.vScrollBarAP.offsetHeight);
		console.log("scrollHt : "+scrollHt);*/
		//this._fontHeight = Math.floor(this._fontHeight);
		if(scrollHt===0){
			dojo.style(this.vsliderAP,"visibility","hidden");
			this._scrollHandleHeight =0;
			this._assignHorizontal();
		}else{
			dojo.style(this.vsliderAP,"visibility","visible");
			dojo.style(this.vScrollMidAP,"height",""+(scrollHt-6)+"px");
			dojo.style(this.vScrollAP,"height",scrollHt+"px");
			this._scrollHandleHeight = this.vScrollAP.offsetHeight;
			this._verticalScrollHandleHeight = this.vScrollAP.offsetHeight > 16? this.vScrollAP.offsetHeight : 16;
			this._verticalScrollHandleMoving = this._contentHeight / (this.vScrollBarAP.offsetHeight - this._verticalScrollHandleHeight) ;

		}


		//Set Horizontal Scrollpane width
		this._fontSize=dojo.style(this.containerNode,"fontSize").replace('px','');
		console.log("this._fontSize : "+this._fontSize);
		if(isNaN(this._fontSize)){
			this._fontSize=12;
	    }
		var pageSize=Math.floor(((this.parentContainerAP.scrollWidth-10)/1)/(this._fontSize/1));
		var viewSize=Math.floor(this._visibleContentWidth/this._fontSize);
		var diffSize=(pageSize - viewSize);

		//console.log("view size : "+view)
		if(isNaN(diffSize)){
			diffSize=0;
		}
		var scrollWidth=0;
		if(diffSize <= 1){
			this._fontSize=this.hScrollBarAP.offsetWidth;//this._visibleContentHeight;
			scrollWidth=0;//this._fontSize;
		}
		else{
			this._fontSize=this.hScrollBarAP.offsetWidth/pageSize;
			scrollWidth=this._visibleContentWidth-(this._fontSize*diffSize);
		}
		//var scrollWidth=this._visibleContentWidth-(this._fontSize*diffSize);

		//this._fontSize=this._visibleContentHeight/diffSize;
		if(scrollWidth===0){
			this._scrollHandleWidth =0;
			dojo.style(this.hsliderAP,"visibility","hidden");
			this._assignVetical();
		}else{
			dojo.style(this.hsliderAP,"visibility","visible");
			this._fontSize = Math.floor(this._fontSize);
			dojo.style(this.hScrollMidAP,"width",(scrollWidth-6)+"px");
			dojo.style(this.hScrollAP,"width",scrollWidth+"px");
			this._scrollHandleWidth = this.hScrollAP.offsetWidth;
		}
		/*console.log("this._fontSize : "+this._fontSize+" <> "+this.containerNode.offsetWidth);
		console.log("pageSize : "+pageSize);
		console.log("viewSize : "+viewSize);
		console.log("diffSize : "+diffSize);*/

	},
	_hideScrollpane : function(){
		dojo.style(this.hsliderAP,"visibility","hidden");
		dojo.style(this.vsliderAP,"visibility","hidden");

	},
	_initScroll: function () {
		// summary: Assign the scroll pane properties and connect the events.
		if(this._isScrollPaneNeed){


		this.assignValue();

		// Connects the events to the scroll button

		this._connects.push(dojo.connect(window, "onresize", dojo.hitch(this, "setScrollPosition")));
		this._connects.push(dojo.connect(this.containerNode, (!dojo.isMozilla ? "onmousewheel" : "DOMMouseScroll"), dojo.hitch(this, "_wheel")));
		this._connects.push(dojo.connect(this.vsliderAP, (!dojo.isMozilla ? "onmousewheel" : "DOMMouseScroll"), dojo.hitch(this, "_wheel")));



		this._connects.push(dojo.connect( this.vScrollAP, "onmousedown", dojo.hitch(this, "_startScroll")));

	   // dojo.connect( this.containerNode, "onmouseup", dojo.hitch(this, "_contentClicked"));

	    /*dojo.connect( dojo.body, "onmousemove", dojo.hitch(this, "_scroll"));
		dojo.connect( this.vScrollBarAP, "onselectstart", dojo.hitch(this, "_cancelEvent"));*/


		this._connects.push(dojo.connect( this.vScrollAP, "onmouseup", dojo.hitch(this, "_stopScroll")));

		if(document.all) {
			this._connects.push(dojo.connect( dojo.body(), "onmouseup", dojo.hitch(this, "_stopScroll")));
		} else {
			this._connects.push(dojo.connect( dojo.doc, "onmouseup", dojo.hitch(this, "_stopScroll")));
			//dojo.connect( document.documentElement, "onmouseup", dojo.hitch(this, "_stopScroll"));
		}
		// connents the events to UP and DOWN arrows
		//dojo.connect( this.scrollDownAP, "onmousedown", dojo.hitch(this, "_scrollButton"));

		this._connects.push(dojo.connect( this.scrollDownAP, "onmousedown", dojo.hitch(this, "_scrollButton")));

		this._connects.push(dojo.connect( this.scrollUpAP, "onmousedown", dojo.hitch(this, "_scrollButton")));

		this._connects.push(dojo.connect( this.scrollDownAP, "onmouseup", dojo.hitch(this, "_scrollButtonStop")));

		this._connects.push(dojo.connect( this.scrollUpAP, "onmouseup", dojo.hitch(this, "_scrollButtonStop")));

		/*dojo.connect( this.scrollDownAP, "onselectstart", dojo.hitch(this, "_cancelEvent"));

		dojo.connect( this.scrollUpAP, "onselectstart", dojo.hitch(this, "_cancelEvent"));*/

		// Connects the event to scroll bar
		this._connects.push(dojo.connect( this.vScrollBarAP, "onmousedown", dojo.hitch(this, "_scrollMoveToInit")));

		//Horizontal...
		this._connects.push(dojo.connect( this.hScrollAP, "onmousedown", dojo.hitch(this, "_starthScroll")));

		this._connects.push(dojo.connect( this.hScrollAP, "onmouseup", dojo.hitch(this, "_stophScroll")));

		this._connects.push(dojo.connect( this.scrollLeftAP, "onmousedown", dojo.hitch(this, "_scrollHButton")));

		this._connects.push(dojo.connect( this.scrollRightAP, "onmousedown", dojo.hitch(this, "_scrollHButton")));

		this._connects.push(dojo.connect( this.scrollLeftAP, "onmouseup", dojo.hitch(this, "_scrollHButtonStop")));

		this._connects.push(dojo.connect( this.scrollRightAP, "onmouseup", dojo.hitch(this, "_scrollHButtonStop")));

		this._connects.push(dojo.connect( this.hScrollBarAP, "onmousedown", dojo.hitch(this, "_hscrollMoveToInit")));
	}
		/*
		dojo.subscribe("widgetBlur", function(data,d){
		    console.log(d+" widgetBlur "+data);
		 });


			 dojo.subscribe("deviceTree1", function(data){
				    console.log(d+" : deviceTree1 : "+data);
				 });
			 dojo.subscribe("execute", function(item,node){
				    console.log(" : execute : ");
				 });
			*/

	},
	_destroyAction: function () {
		// summary: Inactive the events.

		dojo.forEach(this._connects, dojo.disconnect);


	},
	_contentClicked: function(e){
		// summary: content click event.
		   setTimeout(dojo.hitch(this, '_contentOnClicked'), 500);
	      // console.log(this.parentContainerAP.scrollHeight+" :scrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr : "+this.parentContainerAP.scrollWidth);
	},
	_contentOnClicked: function(){
		// summary: The content click event.
			this.resizeScroll();
	},
	connectClickEvent : function(){
		// summary: Connect to the content click event.

		dojo.connect( this.containerNode, "onmouseup", dojo.hitch(this, "_contentClicked"));
	},
	setScrollPosition: function(e){
		// summary: resize the scrollpane.
         this.resizeScroll();
	},
	resizeScroll: function(){
		// summary :
		// After we resize the content inside a widget, this API
		// needs to be called to obtain the resize functionality for the scroll pane.
		if(this._isScrollPaneNeed){
		 this.assignValue();
		 this._scrollHButtonScrollMoveToResizePos();
	  }
	},


	resize: function(changeSize, resultSize) {

		// summary: Resize the scroll panel.

		if (changeSize) {
			dojo.marginBox(this.domNode, changeSize);
        } else if(resultSize){
        	// nothing to be done just reset the scrolls
		} else {
			// in case we want to do custom resize if changeSize and resultSize are not available
		}
        this.resizeScroll();

	},

	disableScrollPane: function(){
		// summary: Disable the scroll pane actions.
		this._isScrollPaneNeed=false;
		this._destroyAction();
	},
	enablecrollPane: function(){
		// summary: Enable the scroll pane actions.
		this._isScrollPaneNeed=true;
		this._initScroll();
	},

	/*init:function(rowHeight,fetchRowCount){
		this._rowHeight = rowHeight;
		//this._endRow= this._endRow + fetchRowCount;
		this.resizeScroll();
	},
	getScrollTop:function(){
		return this.parentContainerAP.scrollTop;
	},
	getTopRowNumber:function(){
		topPos= this.parentContainerAP.scrollTop;
		var numRow = topPos / this._rowHeight;
		var rest = topPos % this._rowHeight;
		if (rest > 0) {
			numRow = parseInt(numRow+1);
		}
		//console.debug("ScrollTop; numRow: " + numRow);
		return numRow;
	},
	getEndRowNumber:function(ht){
		topPos= this.parentContainerAP.scrollTop + ht ;
		var numRow = topPos / this._rowHeight;
		var rest = topPos % this._rowHeight;
		if (rest > 0) {
			numRow = parseInt(numRow+1);
		}
		//console.debug("ScrollEnd; numRow: " + numRow);
		return numRow;
	},
	needRows : function(topRow , pageHeight, availableRowCount){
		if( (topRow *  this._rowHeight )+pageHeight  > availableRowCount *  this._rowHeight){
			return true;
		}
		else{
			return false;
		}
	},
	positionRow: function(inRowIndex, inRowNode){
		// Calculate the row position.
		//console.log("index "+inRowIndex);
		var rowPos = inRowIndex * this._rowHeight;

		// set the new top
		inRowNode.style.top = rowPos + "px";
		inRowNode.style.position = "absolute";
	},*/
	setRowHeight : function(rowHeight){
		this._rowHeight = rowHeight;
	},
	getRowHeight : function(){
		return this._rowHeight;
	},
	setColor : function (rgbColor) {

	},
	setContentWidth : function(width/*int*/){
		// summary: Set the width of the Content.
		this.containerNode.style.width = width+ 'px';

	},
	getContentWidth : function(){
		// summary: Gets the width of the content area.
	    // returns:
        //   An integer that contains the width of the content area.
		return this.containerNode.style.width ;
	},
	setWidth : function(width /* int */){
		// summary: Set the width of the scroll pane.



		this.domNode.style.width = width + 'px';
		this.parentContainerAP.style.width = (width - (10+2))+ 'px';// 16 + 'px';
		this.hScrollBarAP.style.width = width - 20 + 'px';//width - 32
		dojo.style(this.domNode, "width","");

	},
	getWidth : function(){
		// summary: Gets the width of the scroll pane.
		// returns :
		// An integer that contains the width of the scroll pane.
		console.log(this.domNode.style.width+" :: width :: "+dojo.style(this.domNode, "width"));
	   if(this.domNode.style.width){
		   return 	this.domNode.style.width;
	   }else{
		   return 	dojo.style(this.domNode, "width")+"px";
	   }


	},
	setHeight: function (height /* int */ )	{
		// summary: Set the height of the scroll pane.

	   // console.log(height+" height "+dojo.style(this.domNode, "height"));
	   // height = dojo.style(this.domNode, "height");
		this.domNode.style.height = height + 'px';
		this.parentContainerAP.style.height = height-10 + 'px';//-18
		this.vsliderAP.style.height = height-10 + 'px';//-18
		this.vScrollBarAP.style.height = height - (20+10) + 'px';//32+18( up and down width + horizontal height)
		dojo.style(this.domNode, "height","");
	},
	getHeight: function (){
		// summary: Gets the height of the scroll pane.
		// returns:
        //   An integer that contains the height of the scroll pane.
		 if(this.domNode.style.height){
			   return 	this.domNode.style.height;
		   }else{
			   return 	dojo.style(this.domNode, "height")+"px";
		   }
		//return 	this.domNode.style.height;
	},

	setSliderBgColor: function(color /* Color */){
		// summary: Set the background color.
		this.vScrollBarAP.style.backgroundColor 	= color;
		this.scrollUpAP.style.backgroundColor 		= color;
		this.scrollDownAP.style.backgroundColor 	= color;
		this.hScrollBarAP.style.backgroundColor 	= color;
		this.scrollLeftAP.style.backgroundColor 	= color;
		this.scrollRightAP.style.backgroundColor 	= color;
	},

	setContentBgColor: function (rgbColor /* Color */)	{
		// summary: Set the container background color.
		this.parentContainerAP.style.backgroundColor = rgbColor;
	},

	setScrollButtonSpeed: function(newScrollButtonSpeed /* int */){
		// summary: Set how many pixels the scroll button will move.
		this._scrollbuttonSpeed = newScrollButtonSpeed;
	},

	setScrollTimer: function(newInterval /* int */){
		// summary: Set the content movement speed. Decreasing this value makes the content move faster.
		this._scrollTimer = newInterval;
	}



});

}

if(!dojo._hasResource["xwt.widget.anchoredoverlay._Overlay"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.anchoredoverlay._Overlay"] = true;
/* ************************************************** */
/* Copyright (c) 2009-2011 Cisco Systems, Inc.      */
/* All rights reserved.                               */
/* ************************************************** */ 
/****************************************************************************/
/* @fileoverview 															*/
/* The TokenField is an extension of the dijit widget, dijit.TooltipDialog.	*/
/* 																			*/ 
/* @author Dennis Park denpark@cisco.com									*/
/* 																			*/ 
/****************************************************************************/ 
dojo.provide("xwt.widget.anchoredoverlay._Overlay");





dojo.declare("xwt.widget.anchoredoverlay._Overlay", [xwt.widget.TooltipDialog, xwt.widget._ZIndexMixin], {
//	templateString: null,	
	templateString:"<div waiRole=\"presentation\">\r\n\t\r\n\t\r\n\t<!--   Commented out to REMOVE overflow: hidden\r\n\t\r\n\t\t<div class=\"dijitTooltipContainer tokenFieldContentPanel\" dojoAttachPoint=\"tokenContentPanel\" waiRole=\"presentation\" style=\"overflow:hidden\">\r\n\t\r\n\t-->\t\t\r\n\t\t\t\r\n\t\t<div class=\"dijitTooltipContainer tokenFieldContentPanel\" dojoAttachPoint=\"tokenContentPanel\" waiRole=\"presentation\">\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t<!--<div dojoAttachPoint=\"scrollNode\" dojoType='xwt.widget.layout.En_ScrollPane'>\r\n\t\t\t\t<div class =\"dijitTooltipContents dijitTooltipFocusNode\" dojoAttachPoint=\"containerNode\" tabindex=\"-1\" waiRole=\"dialog\"></div>\r\n\t\t\t</div> -->\r\n\t\t\t<div class =\"dijitTooltipContents dijitTooltipFocusNode\" dojoAttachPoint=\"containerNode\" tabindex=\"-1\" waiRole=\"dialog\"></div>\r\n\t\t</div>\r\n\t\t<!--\r\n\t\t<div class=\"_dijitTooltipConnector_\" dojoAttachPoint=\"connector\" waiRole=\"presentation\">\r\n\t\t\t<div class=\"d1\" dojoAttachPoint=\"left\"></div>\r\n\t\t\t<div class=\"d2\" dojoAttachPoint=\"right\"></div>\t\t\r\n\t\t</div>\r\n\t\t\r\n\t\t-->\r\n</div>\r\n",
	baseClass: "xwtOverlay dijitTooltipDialog",
	widgetsInTemplate: true,
	parentId: null,
	
	startup: function(){
		this.inherited(arguments);
		
//		this.scrollNode.startup();
		
//		setTimeout(dojo.hitch(this.scrollNode,'resizeScroll'), 100);		
		this._setIndex();
	},                 
	
	postCreate: function(){	
		//	tags:
		//		protected extension
		//	description:
		//		Set up connections to events for the dialog.
	
		this.inherited(arguments);
		//this.hookZIndex();
	},

	_isLeft:function(){
		//console.debug('current orient class:  '+this._currentOrientClass);
		if(this._currentOrientClass.search("\dijitTooltipABLeft") != -1){
			//console.debug('isLeft');
			return true;
		}
		//console.debug('isRight');
		return false;
	},

	_isBelow:function(){
		//console.debug('current orient class:  '+this._currentOrientClass);
		//debugger;
		
		if(this._currentOrientClass.search("\dijitTooltipBelow") != -1){
			//console.debug('isBelow');
			//console.debug(this._currentOrientClass);
			return true;
		}
		//console.debug('isAbove');
		//console.debug(this._currentOrientClass);
		return false;
	},
	
	orient: function(/*DomNode*/ node, /*String*/ aroundCorner, /*String*/ corner){
		// summary:
		//		Configures the widget to be displayed in a given position relative to the button.
		//		This is called from the dijit.popup code, and should not be called
		//		directly.
		// tags:
		//		protected
		var c = this._currentOrientClass;
		if(c){
			dojo.removeClass(this.domNode, c);
		}
		c = "dijitTooltipAB"+(corner.charAt(1)=='L'?"Left":"Right")+" dijitTooltip"+(corner.charAt(0)=='T' ? "Below_" : "Above_");
		dojo.addClass(this.domNode, c);
		this._currentOrientClass = c;
	},
	
	getLabel : function(){
		//	summary:
		//		Implements custom behavior to return a label for the tokenfield.
		//	tags:
		//		protected extension			
		// return a String
	},
	
	getParentId: function(){
		return this.parentId;
	}
});

}

if(!dojo._hasResource["xwt.widget.anchoredoverlay.AnchoredOverlay"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.anchoredoverlay.AnchoredOverlay"] = true;
/* ************************************************** */
/* Copyright (c) 2009-2011 Cisco Systems, Inc.      */
/* All rights reserved.                               */
/* ************************************************** */ 
/****************************************************************************/
/* @fileoverview 															*/
/* The Anchored Overlay is an extension of the xwt widget, DropDownButton.	*/
/* 																			*/ 
/* @author Dennis Park denpark@cisco.com									*/
/* 																			*/ 
/****************************************************************************/
dojo.provide("xwt.widget.anchoredoverlay.AnchoredOverlay");










dojo.declare("xwt.widget.anchoredoverlay.AnchoredOverlay", dijit.form.DropDownButton, {
	
	// Summary:
	//		An Anchored Overlay is a composite component that consists of an embedded 
	//		token field (label and icon) with a dropdown overlay that is opened and closed 
	//		by clicking the token field icon. The overlay portion allows the progressive 
	//		disclosure of information and the in-context completion of tasks.
	
	// description:
	//		An Anchored Overlay is a composite component that consists of an embedded 
	//		token field (label and icon) with a dropdown overlay that is opened and closed 
	//		by clicking the token field icon. The overlay portion allows the progressive 
	//		disclosure of information and the in-context completion of tasks.
	//		For details, see the Anchored Overlay specification: http://sjc5-netapp03a-web/projects/nmtg-ue-svn/nmtg-ux/Published/nmtg_ux_standards/v1_5/anchored_overlay.html.
	
	//	example:
		//	To create an Anchored Overlay using HTML markup:
		//	|	<div dojoType='xwt.widget.AnchoredOverlay'				   
		//	|	label='A very long token field label A very long token field label A very long token field label'
		//	|	content='<label for="name">Name:</label> <input dojoType="dijit.form.TextBox" name="name"><br><label for="hobby">Hobby:</label> <input dojoType="dijit.form.TextBox" name="hobby"><br> <button dojoType="xwt.widget.AnchoredOverlay" label="Nested Middle Token" content=""></button>'>
		//	|	</div>
		//  Or, if the content is a URL, rather than HTML markup:
		//	|	<div dojoType='xwt.widget.AnchoredOverlay'				   
		//	|	label='A Token Field on Bottom Right' contentUrl='data/anchoredoverlay/demoRepeater.jsp' />	
	//
	//	example:
		//	To create an Anchored Overlay programmatically:
		//	|	var _myOverlay = new xwt.widget.AnchoredOverlay({content:"any html markup" label:"tokenfield label"});
		//	|	_myOverlay.startup();
	
	templateString: null,	
	templateString:"<span class=\"dijit dijitReset dijitLeft dijitInline \"\r\n\t\r\n\t><span class='dijitReset dijitRight dijitInline'\r\n\t\t><span dojoAttachEvent=\"onmouseenter:onMouseEnter,onmouseleave:onMouseLeave\" class='dijitReset dijitInline dijitButtonNode tokenField' dojoAttachPoint=\"tokenFieldNode\"\r\n\t\t\t><button class=\"dijitReset dijitStretch dijitButtonContents tokenFieldDropDown\" \r\n\t\t\t\t${nameAttrSetting} type=\"${type}\" value=\"${value}\"\r\n\t\t\t\tdojoAttachPoint=\"focusNode,titleNode\" \r\n\t\t\t\twaiRole=\"button\" waiState=\"haspopup-true,labelledby-${id}_label\"\r\n\t\t\t\t><span class=\"dijitReset dijitInline\" \r\n\t\t\t\t\tdojoAttachPoint=\"iconNode\"\r\n\t\t\t\t></span\r\n\t\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"  \r\n\t\t\t\t\tdojoAttachPoint=\"containerNode,popupStateNode\" \r\n\t\t\t\t\tid=${id}\"_label\"\r\n\t\t\t\t></span\r\n\t\t\t\t></button>\r\n\t\t<span id=\"${id}_hoverIcon\" class=\"tokenfieldHovering\" dojoAttachPoint=\"hoverIcon\" dojoAttachEvent=\"onmouseenter:_hoverOnQVArrow, onmouseleave:_hoverOffQVArrow, onclick: _onClickQV\">&thinsp;</span>\t\t\t\t\r\n\t\t<span class=\"dijitReset dijitInline dijitArrowButtonInner tokenFieldExpand\" dojoAttachEvent=\"onmouseenter: _discloseHover,onkeydown:_onKeyPress,onkeypress:_onKey\" dojoAttachPoint=\"tokenIcon\">&thinsp;</span>\r\n\t\t<span class=\"dijitReset dijitInline dijitArrowButtonChar\" dojoAttachEvent=\"onmouseenter: _discloseHover,onkeydown:_onKeyPress,onkeypress:_onKey\" dojoAttachPoint=\"a11ytokenIcon\">&#9660;</span>\t\t\t\t\r\n\t\t</span\r\n\t></span\r\n></span>\r\n",
	
	content: '',
	// animationDuration: Integer
	//		Number of milliseconds to display the expand-overlay animation sequence.
	animationDuration: 250,
	contentUrl: '',
	
	// labelValue: String
	//		The actual value of the token field (not shortened with ellipses).
	labelValue: '',
	
	// quickviewPanel: Object
	//		The reference of the QuickView.
	quickviewPanel: null,
	
	// autoWidth: boolean
	//		Flag to indicate that the width of the QuickView should be set automatically.
	autoWidth: false,
	
	// timer: Object
	//		The reference to the QuickView's open delay.  A timer object.
	timer: '',
	
	//	fixedWidth: Integer
	//		The value of the token field's width, in pixels.  If this value is anything but null, then
	//		it indicates that the token field has a fixed width.
	fixedWidth: null,
	
	//	contentPanelMinHeight:  integer
	//		The overlay's (content panel's) minimum height in pixels.  If this value is anything but null, then
	//		it indicates that the overlay has a fixed minimum height.
	contentPanelMinHeight: null,
	
	initDropDownMinWidth: 0,
	
	// qvOpened: boolean
	//		Flag indicating whether or not the QuickView has been opened.
	qvOpened: false,
	
	baseClass: 'xwtAnchoredOverlay dijitButton',
	
	startup: function(){
		if(!this._started){	
			if(!this.dropDown){
				this.dropDown = this._createDropDown();
			}
			if(this.labelValue === ''){
				this.labelValue = this.attr('label');	
				var _labelDisplayValue = this._trimLabel(this.labelValue);		
				this.attr('label', _labelDisplayValue);	
			}	
//			this.focus();
			this.inherited(arguments);
		}
		
		if(dojo.isIE < 8){
		    this.ie7Hack_buttonLabelInterval = setInterval(dojo.hitch(this, function(){
				if(this.domNode){
					this.domNode.className = this.domNode.className;
				}
			}),100);
		}
	},
	postCreate: function(){
		this.inherited(arguments);
		if(this.fixedWidth){
			if(this.fixedWidth < 64){
				this.fixedWidth = 100;
			}
			else if(this.fixedWidth > 464){				
				this.fixedWidth = 500;
			}
		}
		
		this._hookEventHandlers();
		this._connectToShowTooltip();
	
		// Create the border 'tape' to hide the border between the button
		// and the data pane.	
		this.tapeNode = dojo.create('div', {
			style: {
				"position":"absolute", 
				"zIndex": "-1000",
				"top": "-1000px"
			}
		});
		var currentBody = dojo.body();
		currentBody.appendChild(this.tapeNode);
		
		//CSCtn63842
		this._subscribeHandle = dojo.subscribe(this.ANCHOREDOVERLAY_TOPIC, this , "handleAnotherAOopen");
		
	},
	
	//------------------------------CSCtn63842----------------------------------------------------------------------
	//	ANCHOREDOVERLAY_TOPIC: String Constant.  
	//		topic name (don't change)
	ANCHOREDOVERLAY_TOPIC: "xwt/widget/anchoredoverlay/dropdownopen",
	
	//	forecCloseDropdown: boolean
	//		forecCloseDropdown default to false 
	forecCloseDropdown:false,
	
	handleAnotherAOopen:function(/*AnchoredOverlay*/ ao){
	// summary:
	// Once another AnchoredOverlay is able to open dropdown, this function will be triggered (due to topic subscription)
	// This method checks if the about-to-open ao is nested in this dropdown.  Also it considers the 'checkWhetherToCloseDropdown'
	// which gives the application the opportunity to add in it's own conditions of whether or not to close this dropdown
			
		if (ao && ao.id!=this.id && this._opened){
			if (this.checkWhetherToCloseDropdown(ao) && (!this.isAnchoredOverlayNested(ao))){
				this.forecCloseDropdown =true;
				this.closeDropDown(true);
				this.forecCloseDropdown =false;
			}			
		}
		return;
	},
	
	checkWhetherToCloseDropdown: function(/* about to open dropdown AnchoredOverlay*/ ao){
	// summary:
	// Overwrite-able api for application to apply customized logic to determine whether to close current anchoredoverlay dropdown	
		return true;
	},
	
	isAnchoredOverlayNested:function( /* about to open dropdown AnchoredOverlay*/ ao){
	// summary:
	// Check if input anchoredOverlay is nested in this.dropdown object
	
	   var isNested = false;
	   if (!this.dropDown) return false;
	   if (!this.dropDown.domNode) return false;
	   var currentNode = ao.domNode;
	   while ((!isNested) && (currentNode != dojo.body())){
		   isNested =(currentNode==this.dropDown.domNode)? true:false;
		   currentNode = currentNode.parentNode;			  
		}
	   return isNested;
	},
	
	//-------------------------------------------------------------------------------------------------------------------------------
	
	destroy: function(){
		//----------//CSCtn63842
		if (this._subscribeHandle){
			dojo.unsubscribe(this._subscribeHandle);
		}
		//----------CSCtn63842//
		if(this.onMouseOverShowTokenFieldTooltipConnect){
			dojo.disconnect(this.onMouseOverShowTokenFieldTooltipConnect);
		}
		
		if(this.expandCollapseConnection){
			dojo.disconnect(this.expandCollapseConnection);
		}
		
		if(this.onBlurEventConnection){
			dojo.disconnect(this.onBlurEventConnection);
		}
		
		if(this.expandCollapseConnection2){
			dojo.disconnect(this.expandCollapseConnection2);
		}
		
		if(this.onBlurEventConnection2){
			dojo.disconnect(this.onBlurEventConnection2);
		}
		
		var _content = this.getContent();
		
		if(dojo.isArray(_content)){
			dojo.forEach(_content, function(widget){
			if(widget.destroy){
				widget.destroy();
			}
		});
		}
		else if(dojo.isFunction(_content.destroy)){
			console.log("AnchoredOverlay destroy content ", _content);
			_content.destroy();
		}
		
		if(this.dropDown){
			// teardown so that constraints will be rebuilt next time (redundant reference: #6002)
			this.dropDown.destroy();
			delete this.dropDown;
		}
		if(this._rsHandler){
			dojo.disconnect(this._rsHandler);
			delete this._rsHandler;
		}
		
		dojo.destroy(this.tapeNode);
		this._closeQuickView();
		
		
		if(this.ie7Hack_buttonLabelInterval ){
			clearInterval(this.buttonLabelInterval);
		}
		
		if(this._qvClose_HideAnchor){
			dojo.disconnect(this._qvClose_HideAnchor);
		}
		if(this._qvHide_HideAnchor){
			dojo.disconnect(this._qvHide_HideAnchor);
		}
		
		
		
		this.inherited(arguments);
		
	},
	
	_connectToShowTooltip: function(){
		
		this.onMouseOverShowTokenFieldTooltipConnect = dojo.connect(this.titleNode,"onmouseover",this,"_showTokenFieldTooltip");		
	},
	_showTokenFieldTooltip: function(){
		if(this._isEllipsesOccured){			
			this.titleNode.title = this.labelValue;
			dojo.style(this.titleNode, {'cursor' : 'pointer'});
		}
	},
	
	closeDropDown: function(/*Boolean*/ focus){
		// summary:  
		//	Method to close the overlay (content panel).
		if(xwtPopups.popupsSuspended(this.dropDown.domNode.parentNode.style.zIndex) && (!this.forecCloseDropdown)) {
            return;
		}
		
		if(this._opened){
			//console.debug('closeDropdown', this);
			this.preClose();				
			this.inherited(arguments);
			
			this._changeStyle();		
			this.setLabel(this.dropDown.getLabel());
			this.postClose();
			if(this._rsHandler){
				dojo.disconnect(this._rsHandler);
				delete this._rsHandler;
			}
		}
	},
	
	_createDropDown: function(){
		var _dialog = new xwt.widget.anchoredoverlay._Overlay({
			content: this.content,
			parentId: this.id
		});

		if(this.content.length < 1){
			if(this.contentUrl.length > 0){
				_dialog.attr('href',this.contentUrl);
			}
		}
		
		_dialog.content.executeScripts=true;
		_dialog.content.parseOnLoad=true;
		if (this.content!==null){
			this.content.anchoredoverlay = this;
		}
		
		if(this.contentPanelMinHeight){
			dojo.style(_dialog.tokenContentPanel, "minHeight", this.contentPanelMinHeight+"px");
		}
		
		return _dialog;
	},
	
	setContentPanelMinHeight: function(_minHeight){
		this.contentPanelMinHeight = _minHeight;
	},
	
	_closeQuickView: function(){
		if(this.quickviewPanel){
			if(this.quickviewPanel._targetNode){
				dojo.style(this.quickviewPanel._targetNode, "visibility", "hidden");
			}
		this.qvOpened = false;
		}
	},
	
	_styleForClosedDropDown:function(){
		// ---------------token field styles--------------------------
		
		//	removing the  '-' icon
		dojo.removeClass(this.tokenIcon, 'tokenFieldCollapse');
		
		//	adding the  '+' icon
		dojo.addClass(this.tokenIcon, 'tokenFieldExpand');
		
		//  removing the missing bottom border
		dojo.removeClass(this.tokenFieldNode, 'openBelow');
		
		//  removing the missing top border
		dojo.removeClass(this.tokenFieldNode, 'openAbove');
		
		// -----------------content panel styles--------------------------

		dojo.removeClass(this.dropDown.tokenContentPanel, 'vertical');
		
		// reset the drop-down height style rule so it does not retain prev.
		//	fixed height.
		dojo.style(this.dropDown.tokenContentPanel, {
			'height':'auto',
			'width':'auto',
			'max-height':'auto'
		});
		dojo.style(this.tapeNode, {'display' : 'none'});
		
	},
	
	_changeStyle: function(){
		if(this._opened !== true){			
			this._styleForClosedDropDown();
		}else{
			var _w = dojo.position(this.dropDown.domNode).w;
			
			var _tokenWidthContentBox = dojo.contentBox(this.tokenFieldNode);
		
			var scrollers = this._getScrollerSize();	
			if(_w < _tokenWidthContentBox.w){
				//console.debug('_w was changed from:  ' + _w  +'  to:  ' + _tokenWidth);
				_w = _tokenWidthContentBox.w + scrollers.v;
			}
			
			if(!this.dropDownWidth){
				this.dropDownWidth = _w;
				dojo.style(this.dropDown.tokenContentPanel, {'minWidth': _w+'px'});
			}
			
			if(this.dropDownWidth < _tokenWidthContentBox.w){
				this.dropDownWidth = _tokenWidthContentBox.w;
				dojo.style(this.dropDown.tokenContentPanel, {'minWidth': this.dropDownWidth+'px'});
			}
			
			// If the initial min-width set by the user is greater than the auto-calculated min-width
			if (dojo.style(this.dropDown.tokenContentPanel,"minWidth") < this.initDropDownMinWidth){
				// Because the calculated one is smaller then what user wants, so we use user-defined min-width
				dojo.style(this.dropDown.tokenContentPanel, {'minWidth': this.initDropDownMinWidth+'px'});
			}
			
			// Calc width of overlay 'tape'
			// TODO:  Move calcs to top later.	
			var bPos = dojo.position(this.tokenFieldNode,true);
			var bBorders = dojo._getBorderExtents(this.tokenFieldNode);
			var _tapeWidth = bPos.w - bBorders.w;
			dojo.style(this.tapeNode, {'width' : _tapeWidth+'px'});
			

			//--------Adjust height to prevent window scroll bars------determine and set dropdown panel height---------
			
			var _vp = dijit.getViewport();
			var _tfcpHeight = this.dropDown.tokenContentPanel.clientHeight;
			// get position of content panel.
		
			var _newHeight;
			// prevent overflow related rendering
			if(!this.dropDown._isBelow()){
				
				dojo.addClass(this.dropDown.tokenContentPanel, 'vertical');
				
				// check to see if there is an overflow on the y axis that will result in 
				//	the parent getting covered.
				//console.debug('isAbove -- adjust');
				
				var _buttonCoords = dojo.coords(this.domNode);
				//console.dir(_buttonCoords);
				
				var _panelLowerLeftYCoord = (_buttonCoords.y - _buttonCoords.h) + 2;   // +7 is from 5 + (borders) 2 (from somewhere?)
				
				// subtract height from content panel position, should be > 0
				if((_panelLowerLeftYCoord - _tfcpHeight) < 1 ){
					//console.debug('adjusting');
					// if negative, set the panel height to the 
					//	position, let vertical scrolling take care of rest.
					
					//console.debug('oldHeight:  '+_tfcpHeight +'   -   new Height:  '+_panelLowerLeftYCoord);
					_newHeight =  _panelLowerLeftYCoord;
					dojo.style(this.dropDown.tokenContentPanel, {
//						"height":  _newHeight+ "px",
						"height":  ((_newHeight>=0)? _newHeight:0)+ "px",
						"max-height": _newHeight+ "px"
					});
				}
				var height = dojo.style(this.dropDown.tokenContentPanel,"height");
				dojo.style(this.dropDown.tokenContentPanel,
						{
					"maxHeight": height+ "px",
					"minHeight": height+ "px"
					}				
				);
			}else{
				// check to see if there is an overflow that will result in 
				//	a scrollbar on the window which will shift everything over
				//	16 - 17 px.			
				var _top = dojo.position(this.domNode, true);
				if((_top.y + _tfcpHeight) > _vp.h){
					// if so, set the panel height to be the 
					//	(viewport height - content panel position)
					//	position, let vertical scrolling take care of rest.
					_newHeight = _vp.h - _top.y;
					//console.debug('oldHeight:  '+_tfcpHeight +'   -   new Height:  '+_newHeight);
					_newHeight = _newHeight - 50;    // not sure where 46px came from.
//					_newHeight = _newHeight - 20;    // not sure where 46px came from.
					
					
					dojo.style(this.dropDown.tokenContentPanel, {
						"height":  ((_newHeight>=0)? _newHeight:0)+ "px",
//						"height":  _newHeight+ "px",
						"max-height": _newHeight+ "px"
					});
				}else{
					 _tfcpHeight =  _tfcpHeight - 10;
					dojo.style(this.dropDown.tokenContentPanel, {
						"height":  ((_tfcpHeight>=0)? _tfcpHeight:0)+ "px",
//						"height":  _tfcpHeight+ "px",
						"max-height": _tfcpHeight+ "px"
					});
				}
			}
			
			// ---------Decide which styling rules to use based on orientation--
			// Apply classes first, then calc sizes in case classes change sizes
			dojo.removeClass(this.tokenIcon, 'tokenFieldExpand');
			dojo.addClass(this.tokenIcon, 'tokenFieldCollapse');			

			// Gather up some positional data.  We need it to do adjustments
			// to the tape and popup locations.
			var _tfPos = dojo.position(this.tokenFieldNode, true);

			// Internal function to dojo, but been around forever and not likely to go
			// so we can call it fairly safely.  Gives border data.
			var borders = dojo._getBorderExtents(this.tokenFieldNode);
			var bHeight = borders.t;

			// Try to set the zIndex by inspecting what it has to overlay.
			
//			var zIn = dojo.style(this.dropDown.domNode.parentNode, "zIndex");
			
			// CSCtn71589 - previous way of extracting the zIndex is returning
			//		a value in scientific (E) notation.  Precision is lost in
			//		in this method of conversion.
			
			var zIn = this.dropDown.domNode.parentNode.style.zIndex;
			
			if(zIn){
				zIn = parseFloat(zIn);
			}else{
				zIn = 9999;
			}
			
			if(!this.dropDown._isBelow()){
				dojo.addClass(this.tokenFieldNode, 'openAbove');
				
				// Check and adapt the button and tape alignment as needed
				this._alignDropDown(true);
			}else{
				dojo.addClass(this.tokenFieldNode, 'openBelow');

				// Check and adapt the button and tape alignment as needed
				this._alignDropDown(false);
			}
			
			this.tapeNode.parentNode.removeChild(this.tapeNode);
			dojo.body().appendChild(this.tapeNode);
			
			if(dojo.isWebKit){
				if(!this.dropDown._isBelow()){
					bHeight = bHeight + 1;
				}
			}
			
			dojo.style(this.tapeNode, {
				'display' : 'inline',
				'zIndex' : zIn, // zIndex it to be one level higher than the panel it overlays.
				'backgroundColor' : dojo.style(this.tokenFieldNode, "backgroundColor"),
				'height' : bHeight + 'px',
				'position' : 'absolute',
				'border' : 'none',
				'left' :  _tfPos.x + borders.l +'px' // left is button pos + border width.
			});
			
		}
	},
	
	//	------------------------------------------------------------------------
	
	preOpen: function(){
		//	summary:
		//		Implement custom behavior before the content panel opens.
		//	tags:
		//		protected extension	
		//console.debug('pre open');
	},
	
	postOpen: function(){
		//	summary:
		//		Implement custom behavior after the content panel opens.
		//	tags:
		//		protected extension			
		//console.debug('post open');
	},
		
	
	preClose: function(){
		//	summary:
		//		Implement custom behavior before the content panel closes.
		//	tags:
		//		protected extension			
		//console.debug('about to close the content panel');
	},
	
	postClose: function(){
		//	summary:
		//		Implement custom behavior after the content panel closes.
		//	tags:
		//		protected extension			
		//console.debug('closed the content panel');
	},
	
	getContent: function(){
		// summary:
		//		Returns the DOM content.
		var _ret;
		if(this.attr('content')!= null){
			_ret = this.attr('content');
		}
		else{
			_ret = this.dropDown.attr('content'); 
		}
		return _ret;
	},
	
	
	setContent: function(_content){
		// summary:
		//		Sets the DOM content.
		this.dropDown.attr('content', _content);
		this.attr('content', _content);
		_content.anchoredOverlay = this;
	},
	
	setLabel:function(_newLabel){
	//	summary:
	//		Sets the label and the label display value of the token field.
		if(_newLabel){
			if(_newLabel.length > 0){
				if(_newLabel != this.attr('label')){
					this.labelValue = _newLabel;
					var _labelDisplayValue = this._trimLabel(_newLabel);
					this.attr('label', _labelDisplayValue);
					//console.debug('label changed and set', this);
				}
			}
		}
	},
	
	
	//add setValue to make it like formWidget (Data aware, repeater needs it)
	setValue:function(_newLabel){
		//summary:
		//	Sets the value (internally, it just calls setLabel).
		this.setLabel(_newLabel);
		this.value = _newLabel; //jefhu added this line so that ao.getValue() is equvilant to ao.value;
		// If onChange was not extended by the anyone, then the following code will not execute
		if(dojo.isFunction(this.onChange)){
			this.onChange(_newLabel);
		}
	},

	//add getValue to make it like formWidget (Data aware, repeater needs it)
	getValue:function(){
		// summary:
		//	Gets the value (internally, it just calls setLabel).
		return this.getLabelValue();
	},
	
	setFixedWidth: function(fixedWidthParam){
	//	summary:
	//		Sets the token field's width; forces a fixed width on the token field. 
		if(fixedWidthParam>0){
			if(fixedWidthParam > 500){
				//console.log("FW:"+fixedWidthParam);
				this.fixedWidth = 500; // maximum width set if exceeds 500 via public APIs
			}
			else{
				if(fixedWidthParam >= 100 && fixedWidthParam <=500){
					this.fixedWidth = fixedWidthParam; // actual width set via public APIs
				}
				else{
					this.fixedWidth = 100;//minimum width if nothing set via public APIs
				}
			}
		}
		else{
			this.fixedWidth = 100;//minimum width if nothing set via public api
		}
	},
	
	
	getFixedWidth: function(){
	// summary:  
	//		Gets the fixed width of the token field.
		return this.fixedWidth;
	},
	
	_trimLabel:function(_labelToTrim){
		// summary:
		//	Handles trimming of a label string down to a manageable size.
		// _labelToTrim: String
		//	The string label to trim down to the right size.
		// tags:
		//	private
		var visualLength = function(str){
			var box = dojox.html.metrics.getTextBox(str, {"whiteSpace": "nowrap"});
			return box.w;
		};
		var _trimmed = _labelToTrim;
		var len = visualLength(_labelToTrim);
		
		var labelWidth = null;

		if(this.getFixedWidth()){
			/*// 43 =  10 (left/right padding) + 2 (left/right border width)  + 13 (+/- icon) + 8 (qv arrow) + 10 (padding for both icons)
			labelWidth = this.getFixedWidth() - 43;*/
			
			// 36 =  4 (left/right padding) + 4 (left/right border width)  + 18 (+/- icon width (13px) + right margin (5px)) + 10 (qv arrow width(2px)+right padding (4px) + right margin (4px))
			// 36 + 20 (extra pixels added)
			labelWidth = this.getFixedWidth() - 56;
		}else{
			//257 is the magic number
			labelWidth = 257;			
		}
				
		if(len==0 ||len > labelWidth){
			//console.debug('length: ' + len + '  <-- is Greater than 300px, so trimming');
			var trimToPx = function(str, length){
				var tmp = str;
				var trimmed = str;
				if (visualLength(str) > length){
					trimmed += "...";
					while(visualLength(trimmed) > length){
						tmp = tmp.substring(0, tmp.length-1);
						trimmed = tmp + "...";
					}
				}			       
				return trimmed;
			};
			_trimmed = trimToPx(_labelToTrim, labelWidth);
			this._isEllipsesOccured = true;
			dojo.style(this.containerNode, {'paddingRight': '0px'});	
		}else{
			if(this.getFixedWidth()){
				var padding = labelWidth - len;
				dojo.style(this.containerNode, {'paddingRight': padding+'px'});	
			}			
		}
		return _trimmed;   // returns String.		
	},
	
	getDisplayValue: function(){
		// summary:
		//	Returns the label display value. It can be different than the 
		//	value that is returned from the getLabelValue method when
		//	the length of the string exceeds the maximum number of
		//	characters allowed for an anchored overlay field.
		//	
		// tags:
		//	getter	
		
		return this.attr('label');  // return a String
	},
	
	getLabelValue: function(){
		// summary:
		//	Returns the actual label value.
		// tags:
		//	getter
		return this.labelValue;  // return a String
	},
	
	getContentDom: function(){
		// summary:
		//	Returns the DOM content (only when contentUrl has been set).
		if(this.dropDown && this.dropDown.domNode &&
			this.dropDown.domNode.childNodes.length > 0){
			return this.dropDown.domNode.childNodes[0].childNodes[0];
		}
		return this.domNode;
	},

	preOpenQuickView: function(){
		// summary:
		//	Implements custom behavior before the QuickView opens.
	},

	_openQVDelay: function(){		
		if(this.quickviewPanel){
			this.preOpenQuickView();
			this._closeQuickView();
			this.quickviewPanel.openAtNode(this.hoverIcon);
			this.qvOpened = true;
			this._qvClose_HideAnchor = dojo.connect(this.quickviewPanel, "close",this,"_quickViewPanelClosed");
			this._qvHide_HideAnchor = dojo.connect(this.quickviewPanel, "hide",this,"_quickViewPanelClosed"); 
		}
	},	
	
	_quickViewPanelClosed:function(){
		this.qvOpened = false;
		dojo.style(this.hoverIcon, "visibility", "hidden");
		
		if(this._qvClose_HideAnchor){
			dojo.disconnect(this._qvClose_HideAnchor);
		}
		if(this._qvHide_HideAnchor){
			dojo.disconnect(this._qvHide_HideAnchor);
		}
	},
	
	_hoverOnQVArrow: function(){
		this.timer = setTimeout(dojo.hitch(this, "_openQVDelay"),750);
	},
	
	_hoverOffQVArrow: function(){
		if(this.timer !== ''){
			clearTimeout(this.timer);
			delete this.timer;
		}
		//dojo.disconnect(this._popUpDelay2);
	},
	
	_onClickQV: function(){
		// summary:
		//		Event connected to the template that triggers
		//		the QuickView immediately if the icon is clicked.
		if(this.timer){
			clearTimeout(this.timer);
			delete this.timer;
		}
		this._openQVDelay();
	},
	
	onMouseLeave: function() {
		if(this.quickviewPanel){		
			if(this.qvOpened == false || (this.hoverIcon.id && this.quickviewPanel._targetNode && this.hoverIcon.id != this.quickviewPanel._targetNode.id)){
				dojo.style(this.hoverIcon, "visibility", "hidden");
			}
		}
	},
	
	onMouseEnter: function() {
		if(this.quickviewPanel){
			if(this._opened !== true){
				dojo.style(this.hoverIcon, "visibility", "visible");
			}
		}		
	},
	
	_onBlur: function(){
		this.inherited(arguments);
	},
	
	openDropDown: function(){
	//	summary:
	//		Opens the overlay (content panel).
		if(!this._opened){
			//----------//CSCtn63842
			dojo.publish(this.ANCHOREDOVERLAY_TOPIC, [this]);
			//----------CSCtn63842//
			if(this.timer !== ''){
				clearTimeout(this.timer);
			}
			//	----- Handle quick view -----
			dojo.style(this.hoverIcon, {
			    visibility: 'hidden'
			});
			
			this.dropDown.startup();
			this.preOpen();
			
			dojo.style(this.dropDown.domNode, {'opacity' : '0'});
			this.inherited('openDropDown', arguments); 
			
	
			this._closeQuickView();
			
			this._changeStyle();
			this._fadeIn();
	
			this.postOpen();		
			
			if(!this.dropDown._isBelow()){
				if(dojo.isIE){
					if(dojo.hasClass(dojo.body(), "reboot2")){
						//var _top = dojo.style(this.dropDown.tokenContentPanel, "top");
						var _pos = dojo.position(this.dropDown.tokenContentPanel);
						var _top = _top - 5;
						if (_top<0)
							_top=0;
						dojo.style(this.dropDown.tokenContentPanel, "top", _top + "px");
					}
				}
			}			

			// Establish a listener to resize so that the dropdowns are updated in some fashion
			// on window resize.
			this._rsHandler = dojo.connect(dojo.global, "onresize", this, "_resizeListener");
			dijit.scrollIntoView(this.dropDown.domNode);
		}
	},
	
	_fadeIn: function(){		
        var fadeArgs = {
            node: this.dropDown.domNode,
            duration: this.animationDuration
        };
        dojo.fadeIn(fadeArgs).play();
	},
	
	_setupDropdown: function(){
		// summary:
		//		Sets up nodes and connects mouse and keypress events.
		this._buttonNode = this._buttonNode || this.focusNode || this.domNode;
		this._popupStateNode = this._popupStateNode || this.focusNode || this._buttonNode;
		this._aroundNode = this._aroundNode || this.domNode;
		this.enableExpandCollapse();
		//this.connect(this._buttonNode, "onclick", "_onDropDownMouse");
		this.connect(this._buttonNode, "onkeydown", "_onDropDownKeydown");
		//this.connect(this._buttonNode, "onblur", "_onDropDownBlur");
		this.connect(this._buttonNode, "onkeypress", "_onKey");

		// If we have a _setStateClass function (which happens when
		// we are a form widget), then we need to connect our open/close
		// functions to it
		if(this._setStateClass){
			this.connect(this, "openDropDown", "_setStateClass");
			this.connect(this, "closeDropDown", "_setStateClass");
		}

		// Add a class to the "dijitDownArrowButton" type class to _buttonNode so theme can set direction of arrow
		// based on where drop down will normally appear
		var defaultPos = {
				"after" : this.isLeftToRight() ? "Right" : "Left",
				"before" : this.isLeftToRight() ? "Left" : "Right",
				"above" : "Up",
				"below" : "Down",
				"left" : "Left",
				"right" : "Right"
		}[this.dropDownPosition[0]] || this.dropDownPosition[0] || "Down";
		dojo.addClass(this._arrowWrapperNode || this._buttonNode, "dijit" + defaultPos + "ArrowButton");
	},
	
	_discloseHover: function(){
	},
	
	_checkPermission: function(){
		
	},
	
	hideExpandCollapse: function(){
		dojo.style(this.tokenIcon, {visibility: 'hidden'});
	},
	showExpandCollapse: function(){
		dojo.style(this.tokenIcon, {visibility: 'visible'});
	},
	
	disableExpandCollapse:function(){
		dojo.disconnect(this.expandCollapseConnection);
		dojo.disconnect(this.expandCollapseConnection2);	
		this.hideExpandCollapse();
	},
	enableExpandCollapse: function(){
		this.expandCollapseConnection = dojo.connect(this.tokenIcon, "onmousedown", this,"_onDropDownMouse");
		this.expandCollapseConnection2 = dojo.connect(this.a11ytokenIcon, "onmousedown", this,"_onDropDownMouse");
		this.showExpandCollapse();
	},
	
	enableOnBlur: function(){
		this.onBlurEventConnection = dojo.connect(this.tokenIcon,"onblur",this,"_onDropDownBlur");
		this.onBlurEventConnection2 = dojo.connect(this.a11ytokenIcon,"onblur",this,"_onDropDownBlur");
	},
	
	disableOnBlur: function(){
		if(this.onBlurEventConnection){
			dojo.disconnect(this.onBlurEventConnection);
			dojo.disconnect(this.onBlurEventConnection2);
		}
	},
	
	_hookEventHandlers: function(){
		this.enableOnBlur();
	},

	setDisabled:function(){		
		this.attr("disabled",true);
	},
	
	setEnabled:function(){		
		this.attr("disabled",false);		
	},

	_getScrollerSize: function(){
		// summary:
		//		Calculates vertical and horizontal scrollbar sizes.
		// returns:
		//		{v: #, h: #} where v is the vertical scrollbar width
		//		and h is the horizontal scrollbar width.
		// tags:
		//		private
		var d = dojo.create("div");
		dojo.style(d, {
			position: "absolute",
			opacity: 0,
			overflow: "hidden",
			width: "100px",
			height: "100px",
			zIndex: "-10000",
			top: "-1000px",
			padding: "0px",
			margin: "0px"
		});
		var content = dojo.create("div");
		dojo.style(content, {
			width: "500px",
			height: "500px"
		});
		d.appendChild(content);
		// Attach it to size.
		dojo.body().appendChild(d);

		// Compute scrollbars based on content size before
		// and after scroll enablement 
		var b = dojo.contentBox(d);
		dojo.style(d, "overflow", "scroll");
		var a = dojo.contentBox(d);
		dojo.destroy(d);
		return { v: b.w - a.w, h: b.h - a.h };
	},

	_resizeListener: function(){
		// summary:
		//	Handles the dropdowns on resize.  If they are
		//	not manipulated, the alignment will go wrong.  The simple solution
		//	is to close it.  A not-so-simple solution is to move the 
		//	dropdown and its tape.
//		if(this._opened){
			// Uncomment this if you want it to move on resize of page.
			// It is throttled a fair amount to handle IE spamming resize events.
			/*
			if(this._moveTimer){
				clearTimeout(this._moveTimer);
				delete this._moveTimer;
			}
			this._moveTimer = setTimeout(dojo.hitch(this, function(){
				delete this._moveTimer;
				this._alignDropDown(!this.dropDown._isBelow());
			}), 50);
			*/

			// Enable this if you just want it to close on move.
//			this.closeDropDown();
//		}
	},

	_alignDropDown: function(above){
		// summary
		//	Handles aligning the dropdown with the button at the right or left edge, .
		//	and positioning the tape in the right location.
		// above:
		//	Boolean to indicate if the dropdown opened up or down.
		// tags:
		//	private
		var buttonPos = dojo.position(this.tokenFieldNode, true);
		var popupPos = dojo.position(this.dropDown.domNode.parentNode, true);
		var borders = dojo._getBorderExtents(this.tokenFieldNode);
		var tapeWidth = buttonPos.w - borders.w;
		var margins = {
			t: 0,
			l: 0,
			w: 0,
			h: 0
		};
		if(dojo.hasClass(dojo.body(), "reboot2")){
			// For some reason the margins seem to matter in reboot2 (they do not in kubricklite), so
			// we have to calc them off (or on), depending on what we are aligning.
			margins = dojo._getMarginExtents(this.domNode);
		}	
//		if(dojo.isIE && margins.h){
			// IE, is, of course, strange and we have to fudge it - if shadows are there.
//			margins.h = (2 * margins.h) + borders.h;
//		}
		dojo.style(this.tapeNode,{
			"width": tapeWidth + "px",
			"height": borders.t + "px"
		});

		// Check the alignment for left/right and adjust if necessary.
		if(dojo.hasClass(this.dropDown.domNode, "dijitTooltipABRight")){
			var tfRight = Math.round(buttonPos.x + buttonPos.w);
			var popupRight = Math.round(popupPos.x + popupPos.w);
			var newLeft = popupPos.x;
			if(tfRight !== popupRight){
				// Okay, we need to adjust it a little.
				newLeft = popupPos.x - (popupRight - tfRight);
				dojo.style(this.dropDown.domNode.parentNode, "left", newLeft + "px");
			}
			dojo.style(this.tapeNode, "left", ((newLeft + popupPos.w) - (tapeWidth + borders.l)) + "px");
			
		}else if(dojo.hasClass(this.dropDown.domNode, "dijitTooltipABLeft")){
			dojo.style(this.dropDown.domNode.parentNode, "left", buttonPos.x + "px");
			dojo.style(this.tapeNode, "left", (buttonPos.x + borders.l) + "px");
		}

		// Check the edge alignment and adjust if necessary.  Also adjust tape as needed.
		if(above){
			// Okay, now we need to adjust the popup div so that it bottom-aligns
			// with the top of the button, this is the current button y, minus
			// the height of the pop container, plus a shift down of the border.
			var pTop = (buttonPos.y - popupPos.h) + borders.l - Math.ceil(margins.h);
			dojo.style(this.dropDown.domNode.parentNode, "top", pTop + "px");

			// Reset positional data for tape position
			popupPos = dojo.position(this.dropDown.domNode.parentNode, true);

			// Overlay position is the y position of the bottom border edge 
			// of the popup/along the top of the button.
			
			var _tapePos = (popupPos.y + popupPos.h - borders.t) + Math.ceil(margins.h);
			
			if(dojo.isIE){
				_tapePos = _tapePos + 1;
			}
			
			dojo.style(this.tapeNode, 'top', _tapePos + 'px');
			
//			console.debug(this.tapeNode);
		}else{
			// Lets try to do some adjustments on the popup container.
			// Needs to move up one px so it sits on the button bottom edge.
			dojo.style(this.dropDown.domNode.parentNode,
				"top",  
				(Math.floor(buttonPos.y + buttonPos.h) - borders.t) + "px");
				
			// Also determine if we need to shift the edge left or right.
			popupPos = dojo.position(this.dropDown.domNode.parentNode, true);

			// y position of 'tape' should just be the drop down position, 
			dojo.style(this.tapeNode, 'top', Math.floor(popupPos.y) + "px");
		}
	}
//	,_onBlur:function(){}
});

}

if(!dojo._hasResource["xwt.widget.notification.ErrorMessage"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["xwt.widget.notification.ErrorMessage"] = true;
/* ************************************************** */
/* Copyright (c) 2009-2011 Cisco Systems, Inc.       */
/* All rights reserved.                               */
/* ************************************************** */ 

dojo.provide("xwt.widget.notification.ErrorMessage");





dojo.declare("xwt.widget.notification.ErrorMessage", [dijit._Widget, dijit._Templated], {
	//	summary:
	//		A very simple widget for displaying error messages.
	//
	//	example:
	//		To create a new error message, create an instance with an assigned node:
	//	|	new xwt.widget.notification.ErrorMessage({
	//	|		message: "There was an error. <a href='help.html>Here is a link to more information</a>.",
	//	|		code: 33,
	//	|		details: "Here is a a stack trace"
	//	|	}, parentNode);

	postMixInProperties: function(){
	// summary
	// life circle API
		this.inherited(arguments);
		var messages = dojo.i18n.getLocalization("xwt", "notification");
		this.showErrorDetailsMessage = messages.showErrorDetails;
		this.errorCodeMessage = messages.errorCode;
	},

	// templateString
	templateString: '<div class="xwtErrorMessage"><div class="xwtErrorMessageWrapper"><div class="xwtErrorMessageText">${message}</div>' + 
					'<div class="xwtErrorCode" dojoAttachPoint="errorCodeNode">${errorCodeMessage} ${code}.</div>' +
					'<a class="xwtErrorDetailsLink" href="#" dojoAttachPoint="detailsNode" dojoAttachEvent="onclick: onDetails">${showErrorDetailsMessage}<span>&gt;&gt;</span></a></div></div>', 
	// message: Boolean
	//		The error message to display.  
	message: "",

	// code: Number
	//		An error code if there is one associated with the error.
	code: "",

	// details: String
	//		More detailed error information.  
	details: "",
	
	_dialog: null,
	
	// dialogTitle string
	dialogTitle:"",
	onDetails: function(){
		// summary:
		//		An event that is fired when the details are expanded  
		//this.detailsNode.innerHTML = this.details;
		/*this.detailsNode.className = "xwtErrorDetails";*/
        if(this._dialog === null || this._dialog === undefined){
        	this._dialog = new xwt.widget.layout.Dialog({title:this.dialogTitle,
        		fixGradient: function(){
	                var _pos_tdMiddleContentArea = dojo.marginBox(this.middleContentArea);
	                var tdHeight  = _pos_tdMiddleContentArea.h;                
	                if(tdHeight > 85) {
	                      var _height = tdHeight - 85;	
	                      dojo.style(this.middleLeft, {
	                          "height": _height + "px"
	                      });	                      
	                      dojo.style(this.middleRight, {
	                          "height": _height + "px"
	                      });
	                }           
        		}	
        	});      
        	dojo.connect(this._dialog.buttonGroup.getItemAt(0), "onClick", this._dialog, "hide");
        	this._dialog.buttonGroup.removeChild(this._dialog.buttonGroup.getItemAt(1));        	
        }
		
		var div = dojo.create("div", {innerHTML:this.details});
	    this._removeChildrenFromNode(this._dialog.containerNode);
		
		this._dialog.startup();
		this._dialog.setDialogContent(div);
		
		this._dialog.fixGradient();	
		this._dialog.show();
		
	},
        postCreate: function(){
	    // summary:
        //widget life-cycle method. 
                this.inherited(arguments);
                if (!this.code) {
                    this.errorCodeNode.innerHTML = "";
                }
                if (!this.details) {
                    this.detailsNode.innerHTML = "";
                }

        },
	
	    destroy:function(){
        //	summary:
        //widget life-cycle method. clean up objects.
        
        	if (this._dialog){
        		delete this._dialog;
        	}
        		
        	this.inherited(arguments);
        },
        
	    _removeChildrenFromNode:function(node)  {
        	
           var len = node.childNodes.length;

        	while (node.hasChildNodes())
        	{
        	  node.removeChild(node.firstChild);
        	}
        }

});

}

if(!dojo._hasResource["bssLayer.bssLayer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["bssLayer.bssLayer"] = true;
// this file is located at:
//
//   <server_root>/js/src/bss/bssLayer.js

 // This is a layer file. It's like any other Dojo module, except that we
 // don't put any code other than require/provide statements in it. When we
 // make a build, this will be replaced by a single minified copy of all
 // the modules listed below, as well as their dependencies, all in the
 // right order:

 dojo.provide("bssLayer.bssLayer");

 // some basics and sophisticated components combined //together.
//These comments will vanish in the compressed file.
 









//dojo.require("dijit.dijit-all");






























}


dojo.i18n._preloadLocalizations("bssLayer.nls.bssLayer", ["ROOT","en","en-us","xx"]);
